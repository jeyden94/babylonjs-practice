{
  "version": 3,
  "sources": ["../../../dev/core/src/Engines/WebGPU/webgpuTextureHelper.ts", "../../../dev/core/src/Engines/thinWebGPUEngine.ts", "../../../dev/core/src/Engines/WebGPU/webgpuConstants.ts", "../../../dev/core/src/Engines/WebGPU/webgpuShaderProcessor.ts", "../../../dev/core/src/Engines/WebGPU/webgpuPipelineContext.ts", "../../../dev/core/src/Engines/WebGPU/webgpuShaderProcessingContext.ts", "../../../dev/core/src/Misc/codeStringParsingTools.ts", "../../../dev/core/src/Engines/WebGPU/webgpuShaderProcessorsGLSL.ts", "../../../dev/core/src/Engines/WebGPU/webgpuShaderProcessorsWGSL.ts", "../../../dev/core/src/Engines/WebGPU/webgpuHardwareTexture.ts", "../../../dev/core/src/Engines/WebGPU/webgpuTextureManager.ts", "../../../dev/core/src/Meshes/WebGPU/webgpuDataBuffer.ts", "../../../dev/core/src/Engines/WebGPU/webgpuBufferManager.ts", "../../../dev/core/src/Engines/WebGPU/webgpuCacheSampler.ts", "../../../dev/core/src/Buffers/buffer.nonFloatVertexBuffers.ts", "../../../dev/core/src/Engines/WebGPU/webgpuCacheRenderPipeline.ts", "../../../dev/core/src/Engines/WebGPU/webgpuCacheRenderPipelineTree.ts", "../../../dev/core/src/Engines/WebGPU/webgpuStencilStateComposer.ts", "../../../dev/core/src/Engines/WebGPU/webgpuDepthCullingState.ts", "../../../dev/core/src/Materials/Textures/externalTexture.ts", "../../../dev/core/src/Engines/WebGPU/webgpuMaterialContext.ts", "../../../dev/core/src/Engines/WebGPU/webgpuDrawContext.ts", "../../../dev/core/src/Engines/WebGPU/webgpuCacheBindGroups.ts", "../../../dev/core/src/ShadersWGSL/clearQuad.vertex.ts", "../../../dev/core/src/ShadersWGSL/clearQuad.fragment.ts", "../../../dev/core/src/Engines/WebGPU/webgpuClearQuad.ts", "../../../dev/core/src/Engines/WebGPU/webgpuBundleList.ts", "../../../dev/core/src/Engines/WebGPU/webgpuQuerySet.ts", "../../../dev/core/src/Engines/WebGPU/webgpuTimestampQuery.ts", "../../../dev/core/src/Engines/WebGPU/webgpuOcclusionQuery.ts", "../../../dev/core/src/Engines/Processors/shaderCodeInliner.ts", "../../../dev/core/src/Engines/WebGPU/webgpuTintWASM.ts", "../../../dev/core/src/Engines/WebGPU/webgpuSnapshotRendering.ts", "../../../dev/core/src/Buffers/buffer.align.ts", "../../../dev/core/src/AudioV2/abstractAudio/audioEngineV2.ts", "../../../dev/core/src/AudioV2/abstractAudio/subProperties/abstractSpatialAudioListener.ts", "../../../dev/core/src/AudioV2/abstractAudio/subProperties/spatialAudioListener.ts", "../../../dev/core/src/AudioV2/webAudio/subProperties/spatialWebAudioListener.ts", "../../../dev/core/src/AudioV2/abstractAudio/mainAudioOut.ts", "../../../dev/core/src/AudioV2/webAudio/webAudioMainOut.ts", "../../../dev/core/src/AudioV2/webAudio/webAudioUnmuteUI.ts", "../../../dev/core/src/AudioV2/webAudio/webAudioEngine.ts", "../../../dev/core/src/Audio/audioEngine.ts", "../../../dev/core/src/Engines/WebGPU/webgpuExternalTexture.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.alpha.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.rawTexture.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.readTexture.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.cubeTexture.ts", "../../../dev/core/src/Engines/WebGPU/webgpuRenderTargetWrapper.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.renderTarget.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.renderTargetTexture.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.renderTargetCube.ts", "../../../dev/core/src/Misc/coroutine.ts", "../../../dev/core/src/Meshes/mesh.vertexData.ts", "../../../dev/core/src/Meshes/transformNode.ts", "../../../dev/core/src/Collisions/meshCollisionData.ts", "../../../dev/core/src/Meshes/abstractMesh.ts", "../../../dev/core/src/Engines/AbstractEngine/abstractEngine.query.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.query.ts", "../../../dev/core/src/Engines/webgpuEngine.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.multiRender.ts"],
  "sourcesContent": ["/* eslint-disable babylonjs/available */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { ILog2 } from \"../../Maths/math.scalar.functions\";\r\nimport { Constants } from \"../constants\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { IHardwareTextureWrapper } from \"../../Materials/Textures/hardwareTextureWrapper\";\r\n\r\n/** @internal */\r\nexport class WebGPUTextureHelper {\r\n    public static ComputeNumMipmapLevels(width: number, height: number) {\r\n        return ILog2(Math.max(width, height)) + 1;\r\n    }\r\n\r\n    public static GetTextureTypeFromFormat(format: GPUTextureFormat): number {\r\n        switch (format) {\r\n            // One Component = 8 bits unsigned\r\n            case WebGPUConstants.TextureFormat.R8Unorm:\r\n            case WebGPUConstants.TextureFormat.R8Uint:\r\n            case WebGPUConstants.TextureFormat.RG8Unorm:\r\n            case WebGPUConstants.TextureFormat.RG8Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA8Uint:\r\n            case WebGPUConstants.TextureFormat.BGRA8Unorm:\r\n            case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGB10A2UINT: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.RGB10A2Unorm: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.RGB9E5UFloat: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.RG11B10UFloat: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n                return Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n\r\n            // One Component = 8 bits signed\r\n            case WebGPUConstants.TextureFormat.R8Snorm:\r\n            case WebGPUConstants.TextureFormat.R8Sint:\r\n            case WebGPUConstants.TextureFormat.RG8Snorm:\r\n            case WebGPUConstants.TextureFormat.RG8Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8Sint:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n                return Constants.TEXTURETYPE_BYTE;\r\n\r\n            // One component = 16 bits unsigned\r\n            case WebGPUConstants.TextureFormat.R16Uint:\r\n            case WebGPUConstants.TextureFormat.R16Unorm:\r\n            case WebGPUConstants.TextureFormat.RG16Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA16Unorm:\r\n            case WebGPUConstants.TextureFormat.RG16Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Uint:\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n                return Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n\r\n            // One component = 16 bits signed\r\n            case WebGPUConstants.TextureFormat.R16Sint:\r\n            case WebGPUConstants.TextureFormat.R16Snorm:\r\n            case WebGPUConstants.TextureFormat.RG16Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA16Snorm:\r\n            case WebGPUConstants.TextureFormat.RG16Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Sint:\r\n                return Constants.TEXTURETYPE_SHORT;\r\n\r\n            case WebGPUConstants.TextureFormat.R16Float:\r\n            case WebGPUConstants.TextureFormat.RG16Float:\r\n            case WebGPUConstants.TextureFormat.RGBA16Float:\r\n                return Constants.TEXTURETYPE_HALF_FLOAT;\r\n\r\n            // One component = 32 bits unsigned\r\n            case WebGPUConstants.TextureFormat.R32Uint:\r\n            case WebGPUConstants.TextureFormat.RG32Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Uint:\r\n                return Constants.TEXTURETYPE_UNSIGNED_INTEGER;\r\n\r\n            // One component = 32 bits signed\r\n            case WebGPUConstants.TextureFormat.R32Sint:\r\n            case WebGPUConstants.TextureFormat.RG32Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Sint:\r\n                return Constants.TEXTURETYPE_UNSIGNED_INTEGER;\r\n\r\n            case WebGPUConstants.TextureFormat.R32Float:\r\n            case WebGPUConstants.TextureFormat.RG32Float:\r\n            case WebGPUConstants.TextureFormat.RGBA32Float:\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                return Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        return Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    public static GetBlockInformationFromFormat(format: GPUTextureFormat): { width: number; height: number; length: number } {\r\n        switch (format) {\r\n            // 8 bits formats\r\n            case WebGPUConstants.TextureFormat.R8Unorm:\r\n            case WebGPUConstants.TextureFormat.R8Snorm:\r\n            case WebGPUConstants.TextureFormat.R8Uint:\r\n            case WebGPUConstants.TextureFormat.R8Sint:\r\n                return { width: 1, height: 1, length: 1 };\r\n\r\n            // 16 bits formats\r\n            case WebGPUConstants.TextureFormat.R16Uint:\r\n            case WebGPUConstants.TextureFormat.R16Sint:\r\n            case WebGPUConstants.TextureFormat.R16Unorm:\r\n            case WebGPUConstants.TextureFormat.R16Snorm:\r\n            case WebGPUConstants.TextureFormat.R16Float:\r\n            case WebGPUConstants.TextureFormat.RG8Unorm:\r\n            case WebGPUConstants.TextureFormat.RG8Snorm:\r\n            case WebGPUConstants.TextureFormat.RG8Uint:\r\n            case WebGPUConstants.TextureFormat.RG8Sint:\r\n                return { width: 1, height: 1, length: 2 };\r\n\r\n            // 32 bits formats\r\n            case WebGPUConstants.TextureFormat.R32Uint:\r\n            case WebGPUConstants.TextureFormat.R32Sint:\r\n            case WebGPUConstants.TextureFormat.R32Float:\r\n            case WebGPUConstants.TextureFormat.RG16Uint:\r\n            case WebGPUConstants.TextureFormat.RG16Sint:\r\n            case WebGPUConstants.TextureFormat.RG16Float:\r\n            case WebGPUConstants.TextureFormat.RG16Unorm:\r\n            case WebGPUConstants.TextureFormat.RG16Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA8Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Sint:\r\n            case WebGPUConstants.TextureFormat.BGRA8Unorm:\r\n            case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGB9E5UFloat:\r\n            case WebGPUConstants.TextureFormat.RGB10A2UINT:\r\n            case WebGPUConstants.TextureFormat.RGB10A2Unorm:\r\n            case WebGPUConstants.TextureFormat.RG11B10UFloat:\r\n                return { width: 1, height: 1, length: 4 };\r\n\r\n            // 64 bits formats\r\n            case WebGPUConstants.TextureFormat.RG32Uint:\r\n            case WebGPUConstants.TextureFormat.RG32Sint:\r\n            case WebGPUConstants.TextureFormat.RG32Float:\r\n            case WebGPUConstants.TextureFormat.RGBA16Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Float:\r\n            case WebGPUConstants.TextureFormat.RGBA16Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA16Snorm:\r\n                return { width: 1, height: 1, length: 8 };\r\n\r\n            // 128 bits formats\r\n            case WebGPUConstants.TextureFormat.RGBA32Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Float:\r\n                return { width: 1, height: 1, length: 16 };\r\n\r\n            // Depth and stencil formats\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"No fixed size for Stencil8 format!\";\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n                return { width: 1, height: 1, length: 2 };\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"No fixed size for Depth24Plus format!\";\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"No fixed size for Depth24PlusStencil8 format!\";\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n                return { width: 1, height: 1, length: 4 };\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n                return { width: 1, height: 1, length: 5 };\r\n\r\n            // BC compressed formats usable if \"texture-compression-bc\" is both\r\n            // supported by the device/user agent and enabled in requestDevice.\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n                return { width: 4, height: 4, length: 16 };\r\n\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n                return { width: 4, height: 4, length: 8 };\r\n\r\n            // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n            // supported by the device/user agent and enabled in requestDevice.\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n                return { width: 4, height: 4, length: 8 };\r\n\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n                return { width: 4, height: 4, length: 16 };\r\n\r\n            // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n            // supported by the device/user agent and enabled in requestDevice.\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n                return { width: 4, height: 4, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n                return { width: 5, height: 4, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n                return { width: 5, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n                return { width: 6, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n                return { width: 6, height: 6, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n                return { width: 8, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n                return { width: 8, height: 6, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n                return { width: 8, height: 8, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n                return { width: 10, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n                return { width: 10, height: 6, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n                return { width: 10, height: 8, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n                return { width: 10, height: 10, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n                return { width: 12, height: 10, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n                return { width: 12, height: 12, length: 16 };\r\n        }\r\n\r\n        return { width: 1, height: 1, length: 4 };\r\n    }\r\n\r\n    public static IsHardwareTexture(texture: IHardwareTextureWrapper | GPUTexture): texture is IHardwareTextureWrapper {\r\n        return !!(texture as IHardwareTextureWrapper).release;\r\n    }\r\n\r\n    public static IsInternalTexture(texture: InternalTexture | GPUTexture): texture is InternalTexture {\r\n        return !!(texture as InternalTexture).dispose;\r\n    }\r\n\r\n    public static IsImageBitmap(imageBitmap: ImageBitmap | { width: number; height: number }): imageBitmap is ImageBitmap {\r\n        return (imageBitmap as ImageBitmap).close !== undefined;\r\n    }\r\n\r\n    public static IsImageBitmapArray(imageBitmap: ImageBitmap[] | { width: number; height: number }): imageBitmap is ImageBitmap[] {\r\n        return Array.isArray(imageBitmap as ImageBitmap[]) && (imageBitmap as ImageBitmap[])[0].close !== undefined;\r\n    }\r\n\r\n    public static IsCompressedFormat(format: GPUTextureFormat): boolean {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static GetWebGPUTextureFormat(type: number, format: number, useSRGBBuffer = false): GPUTextureFormat {\r\n        switch (format) {\r\n            case Constants.TEXTUREFORMAT_DEPTH16:\r\n                return WebGPUConstants.TextureFormat.Depth16Unorm;\r\n            case Constants.TEXTUREFORMAT_DEPTH24:\r\n                return WebGPUConstants.TextureFormat.Depth24Plus;\r\n            case Constants.TEXTUREFORMAT_DEPTH24_STENCIL8:\r\n                return WebGPUConstants.TextureFormat.Depth24PlusStencil8;\r\n            case Constants.TEXTUREFORMAT_DEPTH32_FLOAT:\r\n                return WebGPUConstants.TextureFormat.Depth32Float;\r\n            case Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8:\r\n                return WebGPUConstants.TextureFormat.Depth32FloatStencil8;\r\n            case Constants.TEXTUREFORMAT_STENCIL8:\r\n                return WebGPUConstants.TextureFormat.Stencil8;\r\n\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC7RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:\r\n                return WebGPUConstants.TextureFormat.BC6HRGBUFloat;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:\r\n                return WebGPUConstants.TextureFormat.BC6HRGBFloat;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC3RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC2RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC1RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB : WebGPUConstants.TextureFormat.ASTC4x4Unorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB : WebGPUConstants.TextureFormat.ETC2RGB8Unorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB : WebGPUConstants.TextureFormat.ETC2RGBA8Unorm;\r\n        }\r\n\r\n        switch (type) {\r\n            case Constants.TEXTURETYPE_BYTE:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R8Snorm;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG8Snorm;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R8Sint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG8Sint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Sint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Snorm;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R8Unorm;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG8Unorm;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return useSRGBBuffer ? WebGPUConstants.TextureFormat.RGBA8UnormSRGB : WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n                    case Constants.TEXTUREFORMAT_BGRA:\r\n                        return useSRGBBuffer ? WebGPUConstants.TextureFormat.BGRA8UnormSRGB : WebGPUConstants.TextureFormat.BGRA8Unorm;\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R8Uint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG8Uint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Uint;\r\n                    case Constants.TEXTUREFORMAT_ALPHA:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_ALPHA format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_LUMINANCE:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_LUMINANCE format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_LUMINANCE_ALPHA:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_LUMINANCE_ALPHA format not supported in WebGPU\";\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n                }\r\n            case Constants.TEXTURETYPE_SHORT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R16Sint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG16Sint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Sint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Sint;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R16Uint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG16Uint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Uint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Uint;\r\n                }\r\n            case Constants.TEXTURETYPE_INT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R32Sint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG32Sint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Sint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Sint;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_INTEGER: // Refers to UNSIGNED_INT\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R32Uint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG32Uint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Uint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Uint;\r\n                }\r\n            case Constants.TEXTURETYPE_FLOAT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R32Float; // By default. Other possibility is R16Float.\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG32Float; // By default. Other possibility is RG16Float.\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Float; // By default. Other possibility is RGBA16Float.\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Float;\r\n                }\r\n            case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R16Float;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG16Float;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Float;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Float;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"TEXTURETYPE_UNSIGNED_SHORT_5_6_5 format not supported in WebGPU\";\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RG11B10UFloat;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV\";\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RG11B10UFloat;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGB9E5UFloat;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV\";\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGB9E5UFloat;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 format not supported in WebGPU\";\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 format not supported in WebGPU\";\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGB10A2Unorm;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGB10A2UINT;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGB10A2Unorm;\r\n                }\r\n        }\r\n\r\n        return useSRGBBuffer ? WebGPUConstants.TextureFormat.RGBA8UnormSRGB : WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n    }\r\n\r\n    public static GetNumChannelsFromWebGPUTextureFormat(format: GPUTextureFormat): number {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.R8Unorm:\r\n            case WebGPUConstants.TextureFormat.R8Snorm:\r\n            case WebGPUConstants.TextureFormat.R8Uint:\r\n            case WebGPUConstants.TextureFormat.R8Sint:\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.R16Uint:\r\n            case WebGPUConstants.TextureFormat.R16Sint:\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n            case WebGPUConstants.TextureFormat.R16Float:\r\n            case WebGPUConstants.TextureFormat.R16Unorm:\r\n            case WebGPUConstants.TextureFormat.R16Snorm:\r\n            case WebGPUConstants.TextureFormat.R32Uint:\r\n            case WebGPUConstants.TextureFormat.R32Sint:\r\n            case WebGPUConstants.TextureFormat.R32Float:\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n                return 1;\r\n\r\n            case WebGPUConstants.TextureFormat.RG8Unorm:\r\n            case WebGPUConstants.TextureFormat.RG8Snorm:\r\n            case WebGPUConstants.TextureFormat.RG8Uint:\r\n            case WebGPUConstants.TextureFormat.RG8Sint:\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.RG16Uint:\r\n            case WebGPUConstants.TextureFormat.RG16Sint:\r\n            case WebGPUConstants.TextureFormat.RG16Float:\r\n            case WebGPUConstants.TextureFormat.RG16Unorm:\r\n            case WebGPUConstants.TextureFormat.RG16Snorm:\r\n            case WebGPUConstants.TextureFormat.RG32Uint:\r\n            case WebGPUConstants.TextureFormat.RG32Sint:\r\n            case WebGPUConstants.TextureFormat.RG32Float:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n                return 2;\r\n\r\n            case WebGPUConstants.TextureFormat.RGB9E5UFloat:\r\n            case WebGPUConstants.TextureFormat.RG11B10UFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n                return 3;\r\n\r\n            case WebGPUConstants.TextureFormat.RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA8Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Sint:\r\n            case WebGPUConstants.TextureFormat.BGRA8Unorm:\r\n            case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA16Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA16Snorm:\r\n            case WebGPUConstants.TextureFormat.RGB10A2UINT:\r\n            case WebGPUConstants.TextureFormat.RGB10A2Unorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA16Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Float:\r\n            case WebGPUConstants.TextureFormat.RGBA32Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Float:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n                return 4;\r\n        }\r\n\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw `Unknown format ${format}!`;\r\n    }\r\n\r\n    public static HasStencilAspect(format: GPUTextureFormat): boolean {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static HasDepthAspect(format: GPUTextureFormat): boolean {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static HasDepthAndStencilAspects(format: GPUTextureFormat): boolean {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static GetDepthFormatOnly(format: GPUTextureFormat): GPUTextureFormat {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n                return WebGPUConstants.TextureFormat.Depth16Unorm;\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n                return WebGPUConstants.TextureFormat.Depth24Plus;\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                return WebGPUConstants.TextureFormat.Depth24Plus;\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n                return WebGPUConstants.TextureFormat.Depth32Float;\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n                return WebGPUConstants.TextureFormat.Depth32Float;\r\n        }\r\n\r\n        return format;\r\n    }\r\n\r\n    public static GetSample(sampleCount: number) {\r\n        // WebGPU only supports 1 or 4\r\n        return sampleCount > 1 ? 4 : 1;\r\n    }\r\n}\r\n", "import type { InternalTexture } from \"core/Materials/Textures/internalTexture\";\r\nimport { AbstractEngine } from \"./abstractEngine\";\r\nimport type { WebGPUCacheRenderPipeline } from \"./WebGPU/webgpuCacheRenderPipeline\";\r\nimport type { WebGPUTextureManager } from \"./WebGPU/webgpuTextureManager\";\r\nimport type { WebGPUHardwareTexture } from \"./WebGPU/webgpuHardwareTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { WebGPUTextureHelper } from \"./WebGPU/webgpuTextureHelper\";\r\nimport type { WebGPURenderTargetWrapper } from \"./WebGPU/webgpuRenderTargetWrapper\";\r\nimport { WebGPUPerfCounter } from \"./WebGPU/webgpuPerfCounter\";\r\nimport type { WebGPUSnapshotRendering } from \"./WebGPU/webgpuSnapshotRendering\";\r\nimport { Constants } from \"./constants\";\r\nimport type { WebGPUBundleList } from \"./WebGPU/webgpuBundleList\";\r\nimport type { WebGPUTimestampQuery } from \"./WebGPU/webgpuTimestampQuery\";\r\nimport type { WebGPUOcclusionQuery } from \"./WebGPU/webgpuOcclusionQuery\";\r\n\r\n/**\r\n * The base engine class for WebGPU\r\n */\r\nexport abstract class ThinWebGPUEngine extends AbstractEngine {\r\n    // TODO WEBGPU remove those variables when code stabilized\r\n    /** @internal */\r\n    public dbgShowShaderCode = false;\r\n    /** @internal */\r\n    public dbgSanityChecks = true;\r\n    /** @internal */\r\n    public dbgVerboseLogsNumFrames = 10;\r\n    /** @internal */\r\n    public dbgLogIfNotDrawWrapper = true;\r\n    /** @internal */\r\n    public dbgShowEmptyEnableEffectCalls = true;\r\n    /** @internal */\r\n    public dbgVerboseLogsForFirstFrames = false;\r\n\r\n    /** @internal */\r\n    public _textureHelper: WebGPUTextureManager;\r\n    /** @internal */\r\n    public _cacheRenderPipeline: WebGPUCacheRenderPipeline;\r\n    /** @internal */\r\n    public _occlusionQuery: WebGPUOcclusionQuery;\r\n\r\n    // Frame Life Cycle (recreated each frame)\r\n    /** @internal */\r\n    public _renderEncoder: GPUCommandEncoder;\r\n    /** @internal */\r\n    public _uploadEncoder: GPUCommandEncoder;\r\n\r\n    /** @internal */\r\n    public _currentRenderPass: Nullable<GPURenderPassEncoder> = null;\r\n\r\n    protected _snapshotRendering: WebGPUSnapshotRendering;\r\n    protected _snapshotRenderingMode = Constants.SNAPSHOTRENDERING_STANDARD;\r\n\r\n    /** @internal */\r\n    public _timestampQuery: WebGPUTimestampQuery;\r\n    /** @internal */\r\n    public _timestampIndex = 0;\r\n\r\n    /** @internal */\r\n    public _debugStackRenderPass: string[] = [];\r\n\r\n    /**\r\n     * Gets the GPU time spent in the main render pass for the last frame rendered (in nanoseconds).\r\n     * You have to enable the \"timestamp-query\" extension in the engine constructor options and set engine.enableGPUTimingMeasurements = true.\r\n     * It will only return time spent in the main pass, not additional render target / compute passes (if any)!\r\n     */\r\n    public readonly gpuTimeInFrameForMainPass?: WebGPUPerfCounter;\r\n\r\n    /**\r\n     * Used for both the compatibilityMode=false and the snapshot rendering modes (as both can't be enabled at the same time)\r\n     * @internal\r\n     */\r\n    public _bundleList: WebGPUBundleList;\r\n\r\n    /**\r\n     * Enables or disables GPU timing measurements.\r\n     * Note that this is only supported if the \"timestamp-query\" extension is enabled in the options.\r\n     */\r\n    public get enableGPUTimingMeasurements(): boolean {\r\n        return this._timestampQuery.enable;\r\n    }\r\n\r\n    public set enableGPUTimingMeasurements(enable: boolean) {\r\n        if (this._timestampQuery.enable === enable) {\r\n            return;\r\n        }\r\n        (this.gpuTimeInFrameForMainPass as any) = enable ? new WebGPUPerfCounter() : undefined;\r\n        this._timestampQuery.enable = enable;\r\n    }\r\n\r\n    protected _currentPassIsMainPass() {\r\n        return this._currentRenderTarget === null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _endCurrentRenderPass(): number {\r\n        if (!this._currentRenderPass) {\r\n            return 0;\r\n        }\r\n\r\n        if (this._debugStackRenderPass.length !== 0) {\r\n            for (let i = 0; i < this._debugStackRenderPass.length; ++i) {\r\n                this._currentRenderPass.popDebugGroup();\r\n            }\r\n        }\r\n\r\n        const currentPassIndex = this._currentPassIsMainPass() ? 2 : 1;\r\n\r\n        if (!this._snapshotRendering.endRenderPass(this._currentRenderPass) && !this.compatibilityMode) {\r\n            this._bundleList.run(this._currentRenderPass);\r\n            this._bundleList.reset();\r\n        }\r\n        this._currentRenderPass.end();\r\n\r\n        this._timestampQuery.endPass(\r\n            this._timestampIndex,\r\n            (this._currentRenderTarget && (this._currentRenderTarget as WebGPURenderTargetWrapper).gpuTimeInFrame\r\n                ? (this._currentRenderTarget as WebGPURenderTargetWrapper).gpuTimeInFrame\r\n                : this.gpuTimeInFrameForMainPass) as WebGPUPerfCounter\r\n        );\r\n        this._timestampIndex += 2;\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log(\r\n                    \"frame #\" +\r\n                        (this as any)._count +\r\n                        \" - \" +\r\n                        (currentPassIndex === 2 ? \"main\" : \"render target\") +\r\n                        \" end pass\" +\r\n                        (currentPassIndex === 1 ? \" - internalTexture.uniqueId=\" + this._currentRenderTarget?.texture?.uniqueId : \"\")\r\n                );\r\n            }\r\n        }\r\n        this._debugPopGroup?.(0);\r\n        this._currentRenderPass = null;\r\n\r\n        return currentPassIndex;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateMipmaps(texture: InternalTexture, commandEncoder?: GPUCommandEncoder) {\r\n        commandEncoder = commandEncoder ?? this._renderEncoder;\r\n\r\n        const gpuHardwareTexture = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (!gpuHardwareTexture) {\r\n            return;\r\n        }\r\n\r\n        if (commandEncoder === this._renderEncoder) {\r\n            // We must close the current pass (if any) because we are going to use the render encoder to generate the mipmaps (so, we are going to create a new render pass)\r\n            this._endCurrentRenderPass();\r\n        }\r\n\r\n        const format = (texture._hardwareTexture as WebGPUHardwareTexture).format;\r\n        const mipmapCount = WebGPUTextureHelper.ComputeNumMipmapLevels(texture.width, texture.height);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log(\r\n                    \"frame #\" +\r\n                        (this as any)._count +\r\n                        \" - generate mipmaps - width=\" +\r\n                        texture.width +\r\n                        \", height=\" +\r\n                        texture.height +\r\n                        \", isCube=\" +\r\n                        texture.isCube +\r\n                        \", command encoder=\" +\r\n                        (commandEncoder === this._renderEncoder ? \"render\" : \"copy\")\r\n                );\r\n            }\r\n        }\r\n\r\n        if (texture.isCube) {\r\n            this._textureHelper.generateCubeMipmaps(gpuHardwareTexture, format, mipmapCount, commandEncoder);\r\n        } else {\r\n            this._textureHelper.generateMipmaps(gpuHardwareTexture, format, mipmapCount, 0, texture.is3D, commandEncoder);\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/** @internal */\r\n// eslint-disable-next-line import/export\r\nexport const enum PowerPreference {\r\n    LowPower = \"low-power\",\r\n    HighPerformance = \"high-performance\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum FeatureName {\r\n    CoreFeaturesAndLimits = \"core-features-and-limits\",\r\n    DepthClipControl = \"depth-clip-control\",\r\n    Depth32FloatStencil8 = \"depth32float-stencil8\",\r\n    TextureCompressionBC = \"texture-compression-bc\",\r\n    TextureCompressionBCSliced3D = \"texture-compression-bc-sliced-3d\",\r\n    TextureCompressionETC2 = \"texture-compression-etc2\",\r\n    TextureCompressionASTC = \"texture-compression-astc\",\r\n    TextureCompressionASTCSliced3D = \"texture-compression-astc-sliced-3d\",\r\n    TimestampQuery = \"timestamp-query\",\r\n    IndirectFirstInstance = \"indirect-first-instance\",\r\n    ShaderF16 = \"shader-f16\",\r\n    RG11B10UFloatRenderable = \"rg11b10ufloat-renderable\",\r\n    BGRA8UnormStorage = \"bgra8unorm-storage\",\r\n    Float32Filterable = \"float32-filterable\",\r\n    Float32Blendable = \"float32-blendable\",\r\n    ClipDistances = \"clip-distances\",\r\n    DualSourceBlending = \"dual-source-blending\",\r\n    Subgroups = \"subgroups\",\r\n    TextureFormatsTier1 = \"texture-formats-tier1\",\r\n    TextureFormatsTier2 = \"texture-formats-tier2\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum BufferMapState {\r\n    Unmapped = \"unmapped\",\r\n    Pending = \"pending\",\r\n    Mapped = \"mapped\",\r\n}\r\n\r\n/** @internal */\r\nexport enum BufferUsage {\r\n    MapRead = 1,\r\n    MapWrite = 2,\r\n    CopySrc = 4,\r\n    CopyDst = 8,\r\n    Index = 16,\r\n    Vertex = 32,\r\n    Uniform = 64,\r\n    Storage = 128,\r\n    Indirect = 256,\r\n    QueryResolve = 512,\r\n}\r\n\r\n/** @internal */\r\nexport const enum MapMode {\r\n    Read = 1,\r\n    Write = 2,\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureDimension {\r\n    E1d = \"1d\",\r\n    E2d = \"2d\",\r\n    E3d = \"3d\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureUsage {\r\n    CopySrc = 1,\r\n    CopyDst = 2,\r\n    TextureBinding = 4,\r\n    StorageBinding = 8,\r\n    RenderAttachment = 16,\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureViewDimension {\r\n    E1d = \"1d\",\r\n    E2d = \"2d\",\r\n    E2dArray = \"2d-array\",\r\n    Cube = \"cube\",\r\n    CubeArray = \"cube-array\",\r\n    E3d = \"3d\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureAspect {\r\n    All = \"all\",\r\n    StencilOnly = \"stencil-only\",\r\n    DepthOnly = \"depth-only\",\r\n}\r\n\r\n/**\r\n * Comments taken from https://github.com/gfx-rs/wgpu/blob/master/wgpu-types/src/lib.rs\r\n * @internal\r\n */\r\nexport const enum TextureFormat {\r\n    // 8-bit formats\r\n    R8Unorm = \"r8unorm\", // Red channel only. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.\r\n    R8Snorm = \"r8snorm\", // Red channel only. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.\r\n    R8Uint = \"r8uint\", // Red channel only. 8 bit integer per channel. Unsigned in shader.\r\n    R8Sint = \"r8sint\", // Red channel only. 8 bit integer per channel. Signed in shader.\r\n\r\n    // 16-bit formats\r\n    R16Uint = \"r16uint\", // Red channel only. 16 bit integer per channel. Unsigned in shader.\r\n    R16Sint = \"r16sint\", // Red channel only. 16 bit integer per channel. Signed in shader.\r\n    R16Float = \"r16float\", // Red channel only. 16 bit float per channel. Float in shader.\r\n    RG8Unorm = \"rg8unorm\", // Red and green channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.\r\n    RG8Snorm = \"rg8snorm\", // Red and green channels. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.\r\n    RG8Uint = \"rg8uint\", // Red and green channels. 8 bit integer per channel. Unsigned in shader.\r\n    RG8Sint = \"rg8sint\", // Red and green channels. 8 bit integer per channel. Signed in shader.\r\n    R16Unorm = \"r16unorm\", // Red channel only. 16 bit integer per channel. [0, 65535] converted to float [0, 1] in shader.\r\n    R16Snorm = \"r16snorm\", // Red channel only. 16 bit integer per channel. [-32768, 32767] converted to float [-1, 1] in shader.\r\n\r\n    // 32-bit formats\r\n    R32Uint = \"r32uint\", // Red channel only. 32 bit integer per channel. Unsigned in shader.\r\n    R32Sint = \"r32sint\", // Red channel only. 32 bit integer per channel. Signed in shader.\r\n    R32Float = \"r32float\", // Red channel only. 32 bit float per channel. Float in shader.\r\n    RG16Uint = \"rg16uint\", // Red and green channels. 16 bit integer per channel. Unsigned in shader.\r\n    RG16Sint = \"rg16sint\", // Red and green channels. 16 bit integer per channel. Signed in shader.\r\n    RG16Float = \"rg16float\", // Red and green channels. 16 bit float per channel. Float in shader.\r\n    RGBA8Unorm = \"rgba8unorm\", // Red, green, blue, and alpha channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.\r\n    RGBA8UnormSRGB = \"rgba8unorm-srgb\", // Red, green, blue, and alpha channels. 8 bit integer per channel. Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.\r\n    RGBA8Snorm = \"rgba8snorm\", // Red, green, blue, and alpha channels. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.\r\n    RGBA8Uint = \"rgba8uint\", // Red, green, blue, and alpha channels. 8 bit integer per channel. Unsigned in shader.\r\n    RGBA8Sint = \"rgba8sint\", // Red, green, blue, and alpha channels. 8 bit integer per channel. Signed in shader.\r\n    BGRA8Unorm = \"bgra8unorm\", // Blue, green, red, and alpha channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.\r\n    BGRA8UnormSRGB = \"bgra8unorm-srgb\", // Blue, green, red, and alpha channels. 8 bit integer per channel. Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.\r\n    RG16Unorm = \"rg16unorm\", // Red and green channels. 16 bit integer per channel. [0, 65535] converted to float [0, 1] in shader.\r\n    RG16Snorm = \"rg16snorm\", // Red and green channels. 16 bit integer per channel. [-32768, 32767] converted to float [-1, 1] in shader.\r\n    // Packed 32-bit formats\r\n    RGB9E5UFloat = \"rgb9e5ufloat\", // Packed unsigned float with 9 bits mantisa for each RGB component, then a common 5 bits exponent\r\n    RGB10A2UINT = \"rgb10a2uint\", // Red, green, blue, and alpha channels. 10 bit integer for RGB channels, 2 bit integer for alpha channel. [0, 1023] ([0, 3] for alpha).\r\n    RGB10A2Unorm = \"rgb10a2unorm\", // Red, green, blue, and alpha channels. 10 bit integer for RGB channels, 2 bit integer for alpha channel. [0, 1023] ([0, 3] for alpha) converted to/from float [0, 1] in shader.\r\n    RG11B10UFloat = \"rg11b10ufloat\", // Red, green, and blue channels. 11 bit float with no sign bit for RG channels. 10 bit float with no sign bit for blue channel. Float in shader.\r\n\r\n    // 64-bit formats\r\n    RG32Uint = \"rg32uint\", // Red and green channels. 32 bit integer per channel. Unsigned in shader.\r\n    RG32Sint = \"rg32sint\", // Red and green channels. 32 bit integer per channel. Signed in shader.\r\n    RG32Float = \"rg32float\", // Red and green channels. 32 bit float per channel. Float in shader.\r\n    RGBA16Uint = \"rgba16uint\", // Red, green, blue, and alpha channels. 16 bit integer per channel. Unsigned in shader.\r\n    RGBA16Sint = \"rgba16sint\", // Red, green, blue, and alpha channels. 16 bit integer per channel. Signed in shader.\r\n    RGBA16Float = \"rgba16float\", // Red, green, blue, and alpha channels. 16 bit float per channel. Float in shader.\r\n    RGBA16Unorm = \"rgba16unorm\", // Red, green, blue, and alpha channels. 16 bit integer per channel. [0, 65535] converted to float [0, 1] in shader.\r\n    RGBA16Snorm = \"rgba16snorm\", // Red, green, blue, and alpha channels. 16 bit integer per channel. [-32768, 32767] converted to float [-1, 1] in shader.\r\n\r\n    // 128-bit formats\r\n    RGBA32Uint = \"rgba32uint\", // Red, green, blue, and alpha channels. 32 bit integer per channel. Unsigned in shader.\r\n    RGBA32Sint = \"rgba32sint\", // Red, green, blue, and alpha channels. 32 bit integer per channel. Signed in shader.\r\n    RGBA32Float = \"rgba32float\", // Red, green, blue, and alpha channels. 32 bit float per channel. Float in shader.\r\n\r\n    // Depth and stencil formats\r\n    Stencil8 = \"stencil8\",\r\n    Depth16Unorm = \"depth16unorm\",\r\n    Depth24Plus = \"depth24plus\", // Special depth format with at least 24 bit integer depth.\r\n    Depth24PlusStencil8 = \"depth24plus-stencil8\", // Special depth/stencil format with at least 24 bit integer depth and 8 bits integer stencil.\r\n    Depth32Float = \"depth32float\", // Special depth format with 32 bit floating point depth.\r\n\r\n    // BC compressed formats usable if \"texture-compression-bc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    BC1RGBAUnorm = \"bc1-rgba-unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). 4 color + alpha pallet. 5 bit R + 6 bit G + 5 bit B + 1 bit alpha. Also known as DXT1.\r\n    BC1RGBAUnormSRGB = \"bc1-rgba-unorm-srgb\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). 4 color + alpha pallet. 5 bit R + 6 bit G + 5 bit B + 1 bit alpha. Also known as DXT1.\r\n    BC2RGBAUnorm = \"bc2-rgba-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet. 5 bit R + 6 bit G + 5 bit B + 4 bit alpha. Also known as DXT3.\r\n    BC2RGBAUnormSRGB = \"bc2-rgba-unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet. 5 bit R + 6 bit G + 5 bit B + 4 bit alpha. Also known as DXT3.\r\n    BC3RGBAUnorm = \"bc3-rgba-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet + 8 alpha pallet. 5 bit R + 6 bit G + 5 bit B + 8 bit alpha. Also known as DXT5.\r\n    BC3RGBAUnormSRGB = \"bc3-rgba-unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet + 8 alpha pallet. 5 bit R + 6 bit G + 5 bit B + 8 bit alpha. Also known as DXT5.\r\n    BC4RUnorm = \"bc4-r-unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). 8 color pallet. 8 bit R. Also known as RGTC1.\r\n    BC4RSnorm = \"bc4-r-snorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). 8 color pallet. 8 bit R. Also known as RGTC1.\r\n    BC5RGUnorm = \"bc5-rg-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 8 color red pallet + 8 color green pallet. 8 bit RG. Also known as RGTC2.\r\n    BC5RGSnorm = \"bc5-rg-snorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 8 color red pallet + 8 color green pallet. 8 bit RG. Also known as RGTC2.\r\n    BC6HRGBUFloat = \"bc6h-rgb-ufloat\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 16 bit unsigned float RGB. Float in shader. Also known as BPTC (float).\r\n    BC6HRGBFloat = \"bc6h-rgb-float\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 16 bit signed float RGB. Float in shader. Also known as BPTC (float).\r\n    BC7RGBAUnorm = \"bc7-rgba-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 8 bit integer RGBA. Also known as BPTC (unorm).\r\n    BC7RGBAUnormSRGB = \"bc7-rgba-unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 8 bit integer RGBA. Also known as BPTC (unorm).\r\n\r\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    ETC2RGB8Unorm = \"etc2-rgb8unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB.\r\n    ETC2RGB8UnormSRGB = \"etc2-rgb8unorm-srgb\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB.\r\n    ETC2RGB8A1Unorm = \"etc2-rgb8a1unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB + 1 bit alpha.\r\n    ETC2RGB8A1UnormSRGB = \"etc2-rgb8a1unorm-srgb\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB + 1 bit alpha.\r\n    ETC2RGBA8Unorm = \"etc2-rgba8unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGB + 8 bit alpha.\r\n    ETC2RGBA8UnormSRGB = \"etc2-rgba8unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGB + 8 bit alpha.\r\n    EACR11Unorm = \"eac-r11unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 11 bit integer R.\r\n    EACR11Snorm = \"eac-r11snorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 11 bit integer R.\r\n    EACRG11Unorm = \"eac-rg11unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 11 bit integer R + 11 bit integer G.\r\n    EACRG11Snorm = \"eac-rg11snorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 11 bit integer R + 11 bit integer G.\r\n\r\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    ASTC4x4Unorm = \"astc-4x4-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC4x4UnormSRGB = \"astc-4x4-unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC5x4Unorm = \"astc-5x4-unorm\", // 5x4 block compressed texture. 16 bytes per block (6.4 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC5x4UnormSRGB = \"astc-5x4-unorm-srgb\", // 5x4 block compressed texture. 16 bytes per block (6.4 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC5x5Unorm = \"astc-5x5-unorm\", // 5x5 block compressed texture. 16 bytes per block (5.12 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC5x5UnormSRGB = \"astc-5x5-unorm-srgb\", // 5x5 block compressed texture. 16 bytes per block (5.12 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC6x5Unorm = \"astc-6x5-unorm\", // 6x5 block compressed texture. 16 bytes per block (4.27 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC6x5UnormSRGB = \"astc-6x5-unorm-srgb\", // 6x5 block compressed texture. 16 bytes per block (4.27 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC6x6Unorm = \"astc-6x6-unorm\", // 6x6 block compressed texture. 16 bytes per block (3.56 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC6x6UnormSRGB = \"astc-6x6-unorm-srgb\", // 6x6 block compressed texture. 16 bytes per block (3.56 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x5Unorm = \"astc-8x5-unorm\", // 8x5 block compressed texture. 16 bytes per block (3.2 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x5UnormSRGB = \"astc-8x5-unorm-srgb\", // 8x5 block compressed texture. 16 bytes per block (3.2 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x6Unorm = \"astc-8x6-unorm\", // 8x6 block compressed texture. 16 bytes per block (2.67 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x6UnormSRGB = \"astc-8x6-unorm-srgb\", // 8x6 block compressed texture. 16 bytes per block (2.67 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x8Unorm = \"astc-8x8-unorm\", // 8x8 block compressed texture. 16 bytes per block (2 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x8UnormSRGB = \"astc-8x8-unorm-srgb\", // 8x8 block compressed texture. 16 bytes per block (2 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x5Unorm = \"astc-10x5-unorm\", // 10x5 block compressed texture. 16 bytes per block (2.56 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x5UnormSRGB = \"astc-10x5-unorm-srgb\", // 10x5 block compressed texture. 16 bytes per block (2.56 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x6Unorm = \"astc-10x6-unorm\", // 10x6 block compressed texture. 16 bytes per block (2.13 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x6UnormSRGB = \"astc-10x6-unorm-srgb\", // 10x6 block compressed texture. 16 bytes per block (2.13 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x8Unorm = \"astc-10x8-unorm\", // 10x8 block compressed texture. 16 bytes per block (1.6 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x8UnormSRGB = \"astc-10x8-unorm-srgb\", // 10x8 block compressed texture. 16 bytes per block (1.6 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x10Unorm = \"astc-10x10-unorm\", // 10x10 block compressed texture. 16 bytes per block (1.28 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x10UnormSRGB = \"astc-10x10-unorm-srgb\", // 10x10 block compressed texture. 16 bytes per block (1.28 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC12x10Unorm = \"astc-12x10-unorm\", // 12x10 block compressed texture. 16 bytes per block (1.07 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC12x10UnormSRGB = \"astc-12x10-unorm-srgb\", // 12x10 block compressed texture. 16 bytes per block (1.07 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC12x12Unorm = \"astc-12x12-unorm\", // 12x12 block compressed texture. 16 bytes per block (0.89 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC12x12UnormSRGB = \"astc-12x12-unorm-srgb\", // 12x12 block compressed texture. 16 bytes per block (0.89 bit/px). Complex pallet. 8 bit integer RGBA.\r\n\r\n    // \"depth32float-stencil8\" feature\r\n    Depth32FloatStencil8 = \"depth32float-stencil8\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum AddressMode {\r\n    ClampToEdge = \"clamp-to-edge\",\r\n    Repeat = \"repeat\",\r\n    MirrorRepeat = \"mirror-repeat\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum FilterMode {\r\n    Nearest = \"nearest\",\r\n    Linear = \"linear\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum MipmapFilterMode {\r\n    Nearest = \"nearest\",\r\n    Linear = \"linear\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum CompareFunction {\r\n    Never = \"never\",\r\n    Less = \"less\",\r\n    Equal = \"equal\",\r\n    LessEqual = \"less-equal\",\r\n    Greater = \"greater\",\r\n    NotEqual = \"not-equal\",\r\n    GreaterEqual = \"greater-equal\",\r\n    Always = \"always\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum ShaderStage {\r\n    Vertex = 1,\r\n    Fragment = 2,\r\n    Compute = 4,\r\n}\r\n\r\n/** @internal */\r\nexport const enum BufferBindingType {\r\n    Uniform = \"uniform\",\r\n    Storage = \"storage\",\r\n    ReadOnlyStorage = \"read-only-storage\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum SamplerBindingType {\r\n    Filtering = \"filtering\",\r\n    NonFiltering = \"non-filtering\",\r\n    Comparison = \"comparison\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureSampleType {\r\n    Float = \"float\",\r\n    UnfilterableFloat = \"unfilterable-float\",\r\n    Depth = \"depth\",\r\n    Sint = \"sint\",\r\n    Uint = \"uint\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum StorageTextureAccess {\r\n    WriteOnly = \"write-only\",\r\n    ReadOnly = \"read-only\",\r\n    ReadWrite = \"read-write\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum CompilationMessageType {\r\n    Error = \"error\",\r\n    Warning = \"warning\",\r\n    Info = \"info\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum PipelineErrorReason {\r\n    Validation = \"validation\",\r\n    Internal = \"internal\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum AutoLayoutMode {\r\n    Auto = \"auto\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum PrimitiveTopology {\r\n    PointList = \"point-list\",\r\n    LineList = \"line-list\",\r\n    LineStrip = \"line-strip\",\r\n    TriangleList = \"triangle-list\",\r\n    TriangleStrip = \"triangle-strip\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum FrontFace {\r\n    CCW = \"ccw\",\r\n    CW = \"cw\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum CullMode {\r\n    None = \"none\",\r\n    Front = \"front\",\r\n    Back = \"back\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum ColorWrite {\r\n    Red = 1,\r\n    Green = 2,\r\n    Blue = 4,\r\n    Alpha = 8,\r\n    All = 15,\r\n}\r\n\r\n/** @internal */\r\nexport const enum BlendFactor {\r\n    Zero = \"zero\",\r\n    One = \"one\",\r\n    Src = \"src\",\r\n    OneMinusSrc = \"one-minus-src\",\r\n    SrcAlpha = \"src-alpha\",\r\n    OneMinusSrcAlpha = \"one-minus-src-alpha\",\r\n    Dst = \"dst\",\r\n    OneMinusDst = \"one-minus-dst\",\r\n    DstAlpha = \"dst-alpha\",\r\n    OneMinusDstAlpha = \"one-minus-dst-alpha\",\r\n    SrcAlphaSaturated = \"src-alpha-saturated\",\r\n    Constant = \"constant\",\r\n    OneMinusConstant = \"one-minus-constant\",\r\n    Src1 = \"src1\",\r\n    OneMinusSrc1 = \"one-minus-src1\",\r\n    Src1Alpha = \"src1-alpha\",\r\n    OneMinusSrc1Alpha = \"one-minus-src1-alpha\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum BlendOperation {\r\n    Add = \"add\",\r\n    Subtract = \"subtract\",\r\n    ReverseSubtract = \"reverse-subtract\",\r\n    Min = \"min\",\r\n    Max = \"max\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum StencilOperation {\r\n    Keep = \"keep\",\r\n    Zero = \"zero\",\r\n    Replace = \"replace\",\r\n    Invert = \"invert\",\r\n    IncrementClamp = \"increment-clamp\",\r\n    DecrementClamp = \"decrement-clamp\",\r\n    IncrementWrap = \"increment-wrap\",\r\n    DecrementWrap = \"decrement-wrap\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum IndexFormat {\r\n    Uint16 = \"uint16\",\r\n    Uint32 = \"uint32\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum VertexFormat {\r\n    Uint8 = \"uint8\",\r\n    Uint8x2 = \"uint8x2\",\r\n    Uint8x4 = \"uint8x4\",\r\n    Sint8 = \"sint8\",\r\n    Sint8x2 = \"sint8x2\",\r\n    Sint8x4 = \"sint8x4\",\r\n    Unorm8 = \"unorm8\",\r\n    Unorm8x2 = \"unorm8x2\",\r\n    Unorm8x4 = \"unorm8x4\",\r\n    Snorm8 = \"snorm8\",\r\n    Snorm8x2 = \"snorm8x2\",\r\n    Snorm8x4 = \"snorm8x4\",\r\n    Uint16 = \"uint16\",\r\n    Uint16x2 = \"uint16x2\",\r\n    Uint16x4 = \"uint16x4\",\r\n    Sint16 = \"sint16\",\r\n    Sint16x2 = \"sint16x2\",\r\n    Sint16x4 = \"sint16x4\",\r\n    Unorm16 = \"unorm16\",\r\n    Unorm16x2 = \"unorm16x2\",\r\n    Unorm16x4 = \"unorm16x4\",\r\n    Snorm16 = \"snorm16\",\r\n    Snorm16x2 = \"snorm16x2\",\r\n    Snorm16x4 = \"snorm16x4\",\r\n    Float16 = \"float16\",\r\n    Float16x2 = \"float16x2\",\r\n    Float16x4 = \"float16x4\",\r\n    Float32 = \"float32\",\r\n    Float32x2 = \"float32x2\",\r\n    Float32x3 = \"float32x3\",\r\n    Float32x4 = \"float32x4\",\r\n    Uint32 = \"uint32\",\r\n    Uint32x2 = \"uint32x2\",\r\n    Uint32x3 = \"uint32x3\",\r\n    Uint32x4 = \"uint32x4\",\r\n    Sint32 = \"sint32\",\r\n    Sint32x2 = \"sint32x2\",\r\n    Sint32x3 = \"sint32x3\",\r\n    Sint32x4 = \"sint32x4\",\r\n    UNORM10x10x10x2 = \"unorm10-10-10-2\",\r\n    UNORM8x4BGRA = \"unorm8x4-bgra\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum VertexStepMode {\r\n    Vertex = \"vertex\",\r\n    Instance = \"instance\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum ComputePassTimestampLocation {\r\n    Beginning = \"beginning\",\r\n    End = \"end\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum RenderPassTimestampLocation {\r\n    Beginning = \"beginning\",\r\n    End = \"end\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum LoadOp {\r\n    Load = \"load\",\r\n    Clear = \"clear\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum StoreOp {\r\n    Store = \"store\",\r\n    Discard = \"discard\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum QueryType {\r\n    Occlusion = \"occlusion\",\r\n    Timestamp = \"timestamp\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum CanvasAlphaMode {\r\n    Opaque = \"opaque\",\r\n    Premultiplied = \"premultiplied\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum CanvasToneMappingMode {\r\n    Standard = \"standard\",\r\n    Extended = \"extended\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum DeviceLostReason {\r\n    Unknown = \"unknown\",\r\n    Destroyed = \"destroyed\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum ErrorFilter {\r\n    Validation = \"validation\",\r\n    OutOfMemory = \"out-of-memory\",\r\n    Internal = \"internal\",\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IShaderProcessor } from \"../Processors/iShaderProcessor\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { WebGPUSamplerDescription, WebGPUShaderProcessingContext, WebGPUTextureDescription, WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\n\r\n/** @internal */\r\nexport abstract class WebGPUShaderProcessor implements IShaderProcessor {\r\n    public static readonly LeftOvertUBOName = \"LeftOver\";\r\n    public static readonly InternalsUBOName = \"Internals\";\r\n\r\n    public static UniformSizes: { [type: string]: number } = {\r\n        // GLSL types\r\n        bool: 1,\r\n        int: 1,\r\n        float: 1,\r\n        vec2: 2,\r\n        ivec2: 2,\r\n        uvec2: 2,\r\n        vec3: 3,\r\n        ivec3: 3,\r\n        uvec3: 3,\r\n        vec4: 4,\r\n        ivec4: 4,\r\n        uvec4: 4,\r\n        mat2: 4,\r\n        mat3: 12,\r\n        mat4: 16,\r\n\r\n        // WGSL types\r\n        i32: 1,\r\n        u32: 1,\r\n        f32: 1,\r\n        mat2x2: 4,\r\n        mat3x3: 12,\r\n        mat4x4: 16,\r\n        mat2x2f: 4,\r\n        mat3x3f: 12,\r\n        mat4x4f: 16,\r\n        vec2i: 2,\r\n        vec3i: 3,\r\n        vec4i: 4,\r\n        vec2u: 2,\r\n        vec3u: 3,\r\n        vec4u: 4,\r\n        vec2f: 2,\r\n        vec3f: 3,\r\n        vec4f: 4,\r\n        vec2h: 1,\r\n        vec3h: 2,\r\n        vec4h: 2,\r\n    };\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _SamplerFunctionByWebGLSamplerType: { [key: string]: string } = {\r\n        sampler2D: \"sampler2D\",\r\n        sampler2DArray: \"sampler2DArray\",\r\n        sampler2DShadow: \"sampler2DShadow\",\r\n        sampler2DArrayShadow: \"sampler2DArrayShadow\",\r\n        samplerCube: \"samplerCube\",\r\n        sampler3D: \"sampler3D\",\r\n    };\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _TextureTypeByWebGLSamplerType: { [key: string]: string } = {\r\n        sampler2D: \"texture2D\",\r\n        sampler2DArray: \"texture2DArray\",\r\n        sampler2DShadow: \"texture2D\",\r\n        sampler2DArrayShadow: \"texture2DArray\",\r\n        samplerCube: \"textureCube\",\r\n        samplerCubeArray: \"textureCubeArray\",\r\n        sampler3D: \"texture3D\",\r\n    };\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _GpuTextureViewDimensionByWebGPUTextureType: { [key: string]: GPUTextureViewDimension } = {\r\n        textureCube: WebGPUConstants.TextureViewDimension.Cube,\r\n        textureCubeArray: WebGPUConstants.TextureViewDimension.CubeArray,\r\n        texture2D: WebGPUConstants.TextureViewDimension.E2d,\r\n        texture2DArray: WebGPUConstants.TextureViewDimension.E2dArray,\r\n        texture3D: WebGPUConstants.TextureViewDimension.E3d,\r\n    };\r\n\r\n    // if the webgl sampler type is not listed in this array, \"sampler\" is taken by default\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _SamplerTypeByWebGLSamplerType: { [key: string]: string } = {\r\n        sampler2DShadow: \"samplerShadow\",\r\n        sampler2DArrayShadow: \"samplerShadow\",\r\n    };\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _IsComparisonSamplerByWebGPUSamplerType: { [key: string]: boolean } = {\r\n        samplerShadow: true,\r\n        samplerArrayShadow: true,\r\n        sampler: false,\r\n    };\r\n\r\n    public shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    protected _webgpuProcessingContext: WebGPUShaderProcessingContext;\r\n\r\n    protected abstract _getArraySize(name: string, type: string, preProcessors: { [key: string]: string }): [string, string, number];\r\n    protected abstract _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string;\r\n\r\n    protected _addUniformToLeftOverUBO(name: string, uniformType: string, preProcessors: { [key: string]: string }): void {\r\n        let length = 0;\r\n\r\n        [name, uniformType, length] = this._getArraySize(name, uniformType, preProcessors);\r\n\r\n        for (let i = 0; i < this._webgpuProcessingContext.leftOverUniforms.length; i++) {\r\n            if (this._webgpuProcessingContext.leftOverUniforms[i].name === name) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        this._webgpuProcessingContext.leftOverUniforms.push({\r\n            name,\r\n            type: uniformType,\r\n            length,\r\n        });\r\n    }\r\n\r\n    protected _buildLeftOverUBO(): string {\r\n        if (!this._webgpuProcessingContext.leftOverUniforms.length) {\r\n            return \"\";\r\n        }\r\n        const name = WebGPUShaderProcessor.LeftOvertUBOName;\r\n        let availableUBO = this._webgpuProcessingContext.availableBuffers[name];\r\n        if (!availableUBO) {\r\n            availableUBO = {\r\n                binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n            };\r\n            this._webgpuProcessingContext.availableBuffers[name] = availableUBO;\r\n            this._addBufferBindingDescription(name, availableUBO, WebGPUConstants.BufferBindingType.Uniform, true);\r\n            this._addBufferBindingDescription(name, availableUBO, WebGPUConstants.BufferBindingType.Uniform, false);\r\n        }\r\n\r\n        return this._generateLeftOverUBOCode(name, availableUBO);\r\n    }\r\n\r\n    protected _collectBindingNames(): void {\r\n        // collect all the binding names for faster processing in WebGPUCacheBindGroup\r\n        for (let i = 0; i < this._webgpuProcessingContext.bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = this._webgpuProcessingContext.bindGroupLayoutEntries[i];\r\n            if (setDefinition === undefined) {\r\n                this._webgpuProcessingContext.bindGroupLayoutEntries[i] = [];\r\n                continue;\r\n            }\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = this._webgpuProcessingContext.bindGroupLayoutEntries[i][j];\r\n                const name = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].name;\r\n                const nameInArrayOfTexture = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].nameInArrayOfTexture;\r\n                if (entry) {\r\n                    if (entry.texture || entry.externalTexture || entry.storageTexture) {\r\n                        this._webgpuProcessingContext.textureNames.push(nameInArrayOfTexture!);\r\n                    } else if (entry.sampler) {\r\n                        this._webgpuProcessingContext.samplerNames.push(name);\r\n                    } else if (entry.buffer) {\r\n                        this._webgpuProcessingContext.bufferNames.push(name);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _preCreateBindGroupEntries(): void {\r\n        const bindGroupEntries = this._webgpuProcessingContext.bindGroupEntries;\r\n\r\n        for (let i = 0; i < this._webgpuProcessingContext.bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = this._webgpuProcessingContext.bindGroupLayoutEntries[i];\r\n\r\n            const entries: GPUBindGroupEntry[] = [];\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = this._webgpuProcessingContext.bindGroupLayoutEntries[i][j];\r\n\r\n                if (entry.sampler || entry.texture || entry.storageTexture || entry.externalTexture) {\r\n                    entries.push({\r\n                        binding: entry.binding,\r\n                        resource: undefined as any,\r\n                    });\r\n                } else if (entry.buffer) {\r\n                    entries.push({\r\n                        binding: entry.binding,\r\n                        resource: {\r\n                            buffer: undefined as any,\r\n                            offset: 0,\r\n                            size: 0,\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n\r\n            bindGroupEntries[i] = entries;\r\n        }\r\n    }\r\n\r\n    protected _addTextureBindingDescription(\r\n        name: string,\r\n        textureInfo: WebGPUTextureDescription,\r\n        textureIndex: number,\r\n        dimension: Nullable<GPUTextureViewDimension>,\r\n        format: Nullable<GPUTextureFormat>,\r\n        isVertex: boolean\r\n    ): void {\r\n        // eslint-disable-next-line prefer-const\r\n        let { groupIndex, bindingIndex } = textureInfo.textures[textureIndex];\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];\r\n        }\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {\r\n            let len;\r\n            if (dimension === null) {\r\n                len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                    binding: bindingIndex,\r\n                    visibility: 0,\r\n                    externalTexture: {},\r\n                });\r\n            } else if (format) {\r\n                len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                    binding: bindingIndex,\r\n                    visibility: 0,\r\n                    storageTexture: {\r\n                        access: WebGPUConstants.StorageTextureAccess.WriteOnly,\r\n                        format,\r\n                        viewDimension: dimension,\r\n                    },\r\n                });\r\n            } else {\r\n                len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                    binding: bindingIndex,\r\n                    visibility: 0,\r\n                    texture: {\r\n                        sampleType: textureInfo.sampleType,\r\n                        viewDimension: dimension,\r\n                        multisampled: false,\r\n                    },\r\n                });\r\n            }\r\n            const textureName = textureInfo.isTextureArray ? name + textureIndex : name;\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name, index: len - 1, nameInArrayOfTexture: textureName };\r\n        }\r\n\r\n        bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;\r\n        if (isVertex) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Vertex;\r\n        } else {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Fragment;\r\n        }\r\n    }\r\n\r\n    protected _addSamplerBindingDescription(name: string, samplerInfo: WebGPUSamplerDescription, isVertex: boolean): void {\r\n        // eslint-disable-next-line prefer-const\r\n        let { groupIndex, bindingIndex } = samplerInfo.binding;\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];\r\n        }\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {\r\n            const len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                binding: bindingIndex,\r\n                visibility: 0,\r\n                sampler: {\r\n                    type: samplerInfo.type,\r\n                },\r\n            });\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name, index: len - 1 };\r\n        }\r\n\r\n        bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;\r\n        if (isVertex) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Vertex;\r\n        } else {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Fragment;\r\n        }\r\n    }\r\n\r\n    protected _addBufferBindingDescription(name: string, uniformBufferInfo: WebGPUBufferDescription, bufferType: GPUBufferBindingType, isVertex: boolean): void {\r\n        // eslint-disable-next-line prefer-const\r\n        let { groupIndex, bindingIndex } = uniformBufferInfo.binding;\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];\r\n        }\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {\r\n            const len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                binding: bindingIndex,\r\n                visibility: 0,\r\n                buffer: {\r\n                    type: bufferType,\r\n                },\r\n            });\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name, index: len - 1 };\r\n        }\r\n\r\n        bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;\r\n        if (isVertex) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Vertex;\r\n        } else {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Fragment;\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { IPipelineContext } from \"../IPipelineContext\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { Effect } from \"../../Materials/effect\";\r\nimport type { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport type { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like, IQuaternionLike } from \"../../Maths/math.like\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport type { AbstractEngine } from \"../abstractEngine\";\r\n\r\n/** @internal */\r\nexport interface IWebGPURenderPipelineStageDescriptor {\r\n    vertexStage: GPUProgrammableStage;\r\n    fragmentStage?: GPUProgrammableStage;\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUPipelineContext implements IPipelineContext {\r\n    public engine: WebGPUEngine;\r\n\r\n    public shaderProcessingContext: WebGPUShaderProcessingContext;\r\n\r\n    protected _leftOverUniformsByName: { [name: string]: string };\r\n\r\n    // Property used to handle vertex buffers with int values when the shader code expect float values.\r\n    public vertexBufferKindToType: { [kind: string]: number };\r\n\r\n    public sources: {\r\n        vertex: string;\r\n        fragment: string;\r\n        rawVertex: string;\r\n        rawFragment: string;\r\n    };\r\n\r\n    public stages: Nullable<IWebGPURenderPipelineStageDescriptor>;\r\n\r\n    // The field is indexed by textureState. See @WebGPUMaterialContext.textureState for more information.\r\n    public bindGroupLayouts: { [textureState: number]: GPUBindGroupLayout[] } = {};\r\n\r\n    /**\r\n     * Stores the left-over uniform buffer\r\n     */\r\n    public uniformBuffer: Nullable<UniformBuffer>;\r\n\r\n    // Default implementation.\r\n    public onCompiled?: () => void;\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public get isAsync() {\r\n        return false;\r\n    }\r\n\r\n    public get isReady(): boolean {\r\n        if (this.stages) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _name: string;\r\n\r\n    constructor(shaderProcessingContext: WebGPUShaderProcessingContext, engine: WebGPUEngine) {\r\n        this._name = \"unnamed\";\r\n        this.shaderProcessingContext = shaderProcessingContext;\r\n        this._leftOverUniformsByName = {};\r\n        this.engine = engine;\r\n        this.vertexBufferKindToType = {};\r\n    }\r\n\r\n    public _handlesSpectorRebuildCallback(): void {\r\n        // Nothing to do yet for spector.\r\n    }\r\n\r\n    public _fillEffectInformation(\r\n        effect: Effect,\r\n        uniformBuffersNames: { [key: string]: number },\r\n        uniformsNames: string[],\r\n        uniforms: { [key: string]: Nullable<WebGLUniformLocation> },\r\n        samplerList: string[],\r\n        samplers: { [key: string]: number },\r\n        attributesNames: string[],\r\n        attributes: number[]\r\n    ) {\r\n        const engine = this.engine;\r\n\r\n        if (engine._doNotHandleContextLost) {\r\n            effect._fragmentSourceCode = \"\";\r\n            effect._vertexSourceCode = \"\";\r\n        }\r\n\r\n        const foundSamplers = this.shaderProcessingContext.availableTextures;\r\n        let index: number;\r\n        for (index = 0; index < samplerList.length; index++) {\r\n            const name = samplerList[index];\r\n            const sampler = foundSamplers[samplerList[index]];\r\n\r\n            if (sampler == null || sampler == undefined) {\r\n                samplerList.splice(index, 1);\r\n                index--;\r\n            } else {\r\n                samplers[name] = index;\r\n            }\r\n        }\r\n\r\n        for (const attr of engine.getAttributes(this, attributesNames)) {\r\n            attributes.push(attr);\r\n        }\r\n\r\n        // Build the uniform layout for the left over uniforms.\r\n        this.buildUniformLayout();\r\n\r\n        const attributeNamesFromEffect: string[] = [];\r\n        const attributeLocationsFromEffect: number[] = [];\r\n        for (index = 0; index < attributesNames.length; index++) {\r\n            const location = attributes[index];\r\n            if (location >= 0) {\r\n                attributeNamesFromEffect.push(attributesNames[index]);\r\n                attributeLocationsFromEffect.push(location);\r\n            }\r\n        }\r\n        this.shaderProcessingContext.attributeNamesFromEffect = attributeNamesFromEffect;\r\n        this.shaderProcessingContext.attributeLocationsFromEffect = attributeLocationsFromEffect;\r\n    }\r\n\r\n    /** @internal */\r\n    /**\r\n     * Build the uniform buffer used in the material.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        if (!this.shaderProcessingContext.leftOverUniforms.length) {\r\n            return;\r\n        }\r\n\r\n        this.uniformBuffer?.dispose();\r\n        this.uniformBuffer = new UniformBuffer(this.engine, undefined, undefined, \"leftOver-\" + this._name);\r\n\r\n        for (const leftOverUniform of this.shaderProcessingContext.leftOverUniforms) {\r\n            const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, \"$1\");\r\n            const size = WebGPUShaderProcessor.UniformSizes[type];\r\n            this.uniformBuffer.addUniform(leftOverUniform.name, size, leftOverUniform.length);\r\n            this._leftOverUniformsByName[leftOverUniform.name] = leftOverUniform.type;\r\n        }\r\n\r\n        this.uniformBuffer.create();\r\n    }\r\n\r\n    public setEngine(engine: AbstractEngine): void {\r\n        this.engine = engine as WebGPUEngine;\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        if (this.uniformBuffer) {\r\n            this.uniformBuffer.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setInt(uniformName: string, value: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateInt(uniformName, value);\r\n    }\r\n\r\n    /**\r\n     * Sets an int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int2.\r\n     * @param y Second int in int2.\r\n     */\r\n    public setInt2(uniformName: string, x: number, y: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateInt2(uniformName, x, y);\r\n    }\r\n\r\n    /**\r\n     * Sets an int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int3.\r\n     * @param y Second int in int3.\r\n     * @param z Third int in int3.\r\n     */\r\n    public setInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateInt3(uniformName, x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Sets an int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int4.\r\n     * @param y Second int in int4.\r\n     * @param z Third int in int4.\r\n     * @param w Fourth int in int4.\r\n     */\r\n    public setInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateInt4(uniformName, x, y, z, w);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): void {\r\n        this.setIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): void {\r\n        this.setIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): void {\r\n        this.setIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setUInt(uniformName: string, value: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUInt(uniformName, value);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint2.\r\n     * @param y Second unsigned int in uint2.\r\n     */\r\n    public setUInt2(uniformName: string, x: number, y: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUInt2(uniformName, x, y);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint3.\r\n     * @param y Second unsigned int in uint3.\r\n     * @param z Third unsigned int in uint3.\r\n     */\r\n    public setUInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUInt3(uniformName, x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint4.\r\n     * @param y Second unsigned int in uint4.\r\n     * @param z Third unsigned int in uint4.\r\n     * @param w Fourth unsigned int in uint4.\r\n     */\r\n    public setUInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUInt4(uniformName, x, y, z, w);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray(uniformName: string, array: Uint32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray2(uniformName: string, array: Uint32Array): void {\r\n        this.setUIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray3(uniformName: string, array: Uint32Array): void {\r\n        this.setUIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray4(uniformName: string, array: Uint32Array): void {\r\n        this.setUIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): void {\r\n        this.setArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): void {\r\n        this.setArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): void {\r\n        this.setArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateMatrices(uniformName, matrices);\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateMatrix(uniformName, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateMatrix3x3(uniformName, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateMatrix2x2(uniformName, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     */\r\n    public setFloat(uniformName: string, value: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateFloat(uniformName, value);\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): void {\r\n        this.setFloat2(uniformName, vector2.x, vector2.y);\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateFloat2(uniformName, x, y);\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): void {\r\n        this.setFloat3(uniformName, vector3.x, vector3.y, vector3.z);\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateFloat3(uniformName, x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): void {\r\n        this.setFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w);\r\n    }\r\n\r\n    /**\r\n     * Sets a Quaternion on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param quaternion Value to be set.\r\n     */\r\n    public setQuaternion(uniformName: string, quaternion: IQuaternionLike): void {\r\n        this.setFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w);\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateFloat4(uniformName, x, y, z, w);\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): void {\r\n        this.setFloat3(uniformName, color3.r, color3.g, color3.b);\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): void {\r\n        this.setFloat4(uniformName, color3.r, color3.g, color3.b, alpha);\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): void {\r\n        this.setFloat4(uniformName, color4.r, color4.g, color4.b, color4.a);\r\n    }\r\n\r\n    public _getVertexShaderCode(): string | null {\r\n        return this.sources?.vertex;\r\n    }\r\n\r\n    public _getFragmentShaderCode(): string | null {\r\n        return this.sources?.fragment;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\nimport type { _IShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\n\r\nconst MaxGroups = 4;\r\nconst MaxBindingsPerGroup = 1 << 16;\r\n\r\n// all types not listed are assumed to consume 1 location\r\nconst TypeToLocationSize: { [key: string]: number } = {\r\n    // GLSL types\r\n    mat2: 2,\r\n    mat3: 3,\r\n    mat4: 4,\r\n\r\n    // WGSL types\r\n    mat2x2: 2,\r\n    mat3x3: 3,\r\n    mat4x4: 4,\r\n};\r\n\r\n/** @internal */\r\nexport interface WebGPUBindingInfo {\r\n    groupIndex: number;\r\n    bindingIndex: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface WebGPUTextureDescription {\r\n    autoBindSampler?: boolean;\r\n    isTextureArray: boolean;\r\n    isStorageTexture: boolean;\r\n    textures: Array<WebGPUBindingInfo>;\r\n    sampleType?: GPUTextureSampleType; // not used if the texture is a storage texture\r\n}\r\n\r\n/** @internal */\r\nexport interface WebGPUSamplerDescription {\r\n    binding: WebGPUBindingInfo;\r\n    type: GPUSamplerBindingType;\r\n}\r\n\r\n/** @internal */\r\nexport interface WebGPUBufferDescription {\r\n    binding: WebGPUBindingInfo;\r\n}\r\n\r\n/** @internal */\r\nexport interface WebGPUBindGroupLayoutEntryInfo {\r\n    name: string;\r\n    index: number; // index of the entry (GPUBindGroupLayoutEntry) in the bindGroupLayoutEntries[group] array\r\n    nameInArrayOfTexture?: string; // something like texture0, texture1, ... if texture is an array, else same thing as \"name\"\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class WebGPUShaderProcessingContext implements _IShaderProcessingContext {\r\n    /** @internal */\r\n    public static _SimplifiedKnownBindings = true; // if true, use only group=0,binding=0 as a known group/binding for the Scene ubo and use group=1,binding=X for all other bindings\r\n    // if false, see _KnownUBOs for the known groups/bindings used\r\n\r\n    protected static _SimplifiedKnownUBOs: { [key: string]: WebGPUBufferDescription } = {\r\n        Scene: { binding: { groupIndex: 0, bindingIndex: 0 } },\r\n        Light0: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light1: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light2: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light3: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light4: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light5: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light6: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light7: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light8: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light9: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light10: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light11: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light12: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light13: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light14: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light15: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light16: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light17: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light18: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light19: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light20: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light21: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light22: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light23: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light24: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light25: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light26: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light27: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light28: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light29: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light30: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light31: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Material: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Mesh: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Internals: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n    };\r\n\r\n    protected static _KnownUBOs: { [key: string]: WebGPUBufferDescription } = {\r\n        Scene: { binding: { groupIndex: 0, bindingIndex: 0 } },\r\n\r\n        Light0: { binding: { groupIndex: 1, bindingIndex: 0 } },\r\n        Light1: { binding: { groupIndex: 1, bindingIndex: 1 } },\r\n        Light2: { binding: { groupIndex: 1, bindingIndex: 2 } },\r\n        Light3: { binding: { groupIndex: 1, bindingIndex: 3 } },\r\n        Light4: { binding: { groupIndex: 1, bindingIndex: 4 } },\r\n        Light5: { binding: { groupIndex: 1, bindingIndex: 5 } },\r\n        Light6: { binding: { groupIndex: 1, bindingIndex: 6 } },\r\n        Light7: { binding: { groupIndex: 1, bindingIndex: 7 } },\r\n        Light8: { binding: { groupIndex: 1, bindingIndex: 8 } },\r\n        Light9: { binding: { groupIndex: 1, bindingIndex: 9 } },\r\n        Light10: { binding: { groupIndex: 1, bindingIndex: 10 } },\r\n        Light11: { binding: { groupIndex: 1, bindingIndex: 11 } },\r\n        Light12: { binding: { groupIndex: 1, bindingIndex: 12 } },\r\n        Light13: { binding: { groupIndex: 1, bindingIndex: 13 } },\r\n        Light14: { binding: { groupIndex: 1, bindingIndex: 14 } },\r\n        Light15: { binding: { groupIndex: 1, bindingIndex: 15 } },\r\n        Light16: { binding: { groupIndex: 1, bindingIndex: 16 } },\r\n        Light17: { binding: { groupIndex: 1, bindingIndex: 17 } },\r\n        Light18: { binding: { groupIndex: 1, bindingIndex: 18 } },\r\n        Light19: { binding: { groupIndex: 1, bindingIndex: 19 } },\r\n        Light20: { binding: { groupIndex: 1, bindingIndex: 20 } },\r\n        Light21: { binding: { groupIndex: 1, bindingIndex: 21 } },\r\n        Light22: { binding: { groupIndex: 1, bindingIndex: 22 } },\r\n        Light23: { binding: { groupIndex: 1, bindingIndex: 23 } },\r\n        Light24: { binding: { groupIndex: 1, bindingIndex: 24 } },\r\n        Light25: { binding: { groupIndex: 1, bindingIndex: 25 } },\r\n        Light26: { binding: { groupIndex: 1, bindingIndex: 26 } },\r\n        Light27: { binding: { groupIndex: 1, bindingIndex: 27 } },\r\n        Light28: { binding: { groupIndex: 1, bindingIndex: 28 } },\r\n        Light29: { binding: { groupIndex: 1, bindingIndex: 29 } },\r\n        Light30: { binding: { groupIndex: 1, bindingIndex: 30 } },\r\n        Light31: { binding: { groupIndex: 1, bindingIndex: 31 } },\r\n\r\n        Material: { binding: { groupIndex: 2, bindingIndex: 0 } },\r\n        Mesh: { binding: { groupIndex: 2, bindingIndex: 1 } },\r\n        Internals: { binding: { groupIndex: 2, bindingIndex: 2 } },\r\n    };\r\n\r\n    public static get KnownUBOs() {\r\n        return WebGPUShaderProcessingContext._SimplifiedKnownBindings ? WebGPUShaderProcessingContext._SimplifiedKnownUBOs : WebGPUShaderProcessingContext._KnownUBOs;\r\n    }\r\n\r\n    public shaderLanguage: ShaderLanguage;\r\n\r\n    public uboNextBindingIndex: number;\r\n    public freeGroupIndex: number;\r\n    public freeBindingIndex: number;\r\n\r\n    public availableVaryings: { [key: string]: number };\r\n    public availableAttributes: { [key: string]: number };\r\n    public availableBuffers: { [key: string]: WebGPUBufferDescription };\r\n    public availableTextures: { [key: string]: WebGPUTextureDescription };\r\n    public availableSamplers: { [key: string]: WebGPUSamplerDescription };\r\n\r\n    public leftOverUniforms: { name: string; type: string; length: number }[];\r\n\r\n    public orderedAttributes: string[];\r\n    public bindGroupLayoutEntries: GPUBindGroupLayoutEntry[][];\r\n    public bindGroupLayoutEntryInfo: WebGPUBindGroupLayoutEntryInfo[][];\r\n    public bindGroupEntries: GPUBindGroupEntry[][];\r\n    public bufferNames: string[]; // list of all uniform/storage buffer names used in the shader\r\n    public textureNames: string[]; // list of all texture names used in the shader\r\n    public samplerNames: string[]; // list of all sampler names used in the shader\r\n    public attributeNamesFromEffect: string[];\r\n    public attributeLocationsFromEffect: number[];\r\n\r\n    public vertexBufferKindToNumberOfComponents: { [kind: string]: number } = {};\r\n\r\n    private _attributeNextLocation: number;\r\n    private _varyingNextLocation: number;\r\n\r\n    constructor(shaderLanguage: ShaderLanguage, pureMode = false) {\r\n        this.shaderLanguage = shaderLanguage;\r\n\r\n        this._attributeNextLocation = 0;\r\n        this._varyingNextLocation = 0;\r\n        this.freeGroupIndex = 0;\r\n        this.freeBindingIndex = 0;\r\n\r\n        this.availableVaryings = {};\r\n        this.availableAttributes = {};\r\n        this.availableBuffers = {};\r\n        this.availableTextures = {};\r\n        this.availableSamplers = {};\r\n\r\n        this.orderedAttributes = [];\r\n        this.bindGroupLayoutEntries = [];\r\n        this.bindGroupLayoutEntryInfo = [];\r\n        this.bindGroupEntries = [];\r\n        this.bufferNames = [];\r\n        this.textureNames = [];\r\n        this.samplerNames = [];\r\n\r\n        this.leftOverUniforms = [];\r\n\r\n        if (!pureMode) {\r\n            this._findStartingGroupBinding();\r\n        }\r\n    }\r\n\r\n    private _findStartingGroupBinding(): void {\r\n        const knownUBOs = WebGPUShaderProcessingContext.KnownUBOs;\r\n\r\n        const groups: number[] = [];\r\n        for (const name in knownUBOs) {\r\n            const binding = knownUBOs[name].binding;\r\n            if (binding.groupIndex === -1) {\r\n                continue;\r\n            }\r\n            if (groups[binding.groupIndex] === undefined) {\r\n                groups[binding.groupIndex] = binding.bindingIndex;\r\n            } else {\r\n                groups[binding.groupIndex] = Math.max(groups[binding.groupIndex], binding.bindingIndex);\r\n            }\r\n        }\r\n\r\n        this.freeGroupIndex = groups.length - 1;\r\n        if (this.freeGroupIndex === 0) {\r\n            this.freeGroupIndex++;\r\n            this.freeBindingIndex = 0;\r\n        } else {\r\n            this.freeBindingIndex = groups[groups.length - 1] + 1;\r\n        }\r\n    }\r\n\r\n    public getAttributeNextLocation(dataType: string, arrayLength: number = 0): number {\r\n        const index = this._attributeNextLocation;\r\n\r\n        this._attributeNextLocation += (TypeToLocationSize[dataType] ?? 1) * (arrayLength || 1);\r\n\r\n        return index;\r\n    }\r\n\r\n    public getVaryingNextLocation(dataType: string, arrayLength: number = 0): number {\r\n        const index = this._varyingNextLocation;\r\n\r\n        this._varyingNextLocation += (TypeToLocationSize[dataType] ?? 1) * (arrayLength || 1);\r\n\r\n        return index;\r\n    }\r\n\r\n    public getNextFreeUBOBinding() {\r\n        return this._getNextFreeBinding(1);\r\n    }\r\n\r\n    private _getNextFreeBinding(bindingCount: number) {\r\n        if (this.freeBindingIndex > MaxBindingsPerGroup - bindingCount) {\r\n            this.freeGroupIndex++;\r\n            this.freeBindingIndex = 0;\r\n        }\r\n\r\n        if (this.freeGroupIndex === MaxGroups) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"Too many textures or UBOs have been declared and it is not supported in WebGPU.\";\r\n        }\r\n\r\n        const returnValue = {\r\n            groupIndex: this.freeGroupIndex,\r\n            bindingIndex: this.freeBindingIndex,\r\n        };\r\n\r\n        this.freeBindingIndex += bindingCount;\r\n\r\n        return returnValue;\r\n    }\r\n}\r\n", "/**\r\n * Extracts the characters between two markers (for eg, between \"(\" and \")\"). The function handles nested markers as well as markers inside strings (delimited by \", ' or `) and comments\r\n * @param markerOpen opening marker\r\n * @param markerClose closing marker\r\n * @param block code block to parse\r\n * @param startIndex starting index in block where the extraction must start. The character at block[startIndex] should be the markerOpen character!\r\n * @returns index of the last character for the extraction (or -1 if the string is invalid - no matching closing marker found). The string to extract (without the markers) is the string between startIndex + 1 and the returned value (exclusive)\r\n */\r\nexport function ExtractBetweenMarkers(markerOpen: string, markerClose: string, block: string, startIndex: number): number {\r\n    let currPos = startIndex,\r\n        openMarkers = 0,\r\n        waitForChar = \"\";\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case markerOpen:\r\n                    openMarkers++;\r\n                    break;\r\n                case markerClose:\r\n                    openMarkers--;\r\n                    break;\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                } else {\r\n                    waitForChar = \"\";\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    currPos++;\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n        if (openMarkers === 0) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return openMarkers === 0 ? currPos - 1 : -1;\r\n}\r\n\r\n/**\r\n * Parses a string and skip whitespaces\r\n * @param s string to parse\r\n * @param index index where to start parsing\r\n * @returns the index after all whitespaces have been skipped\r\n */\r\nexport function SkipWhitespaces(s: string, index: number): number {\r\n    while (index < s.length) {\r\n        const c = s[index];\r\n        if (c !== \" \" && c !== \"\\n\" && c !== \"\\r\" && c !== \"\\t\" && c !== \"\\u000a\" && c !== \"\\u00a0\") {\r\n            break;\r\n        }\r\n        index++;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Checks if a character is an identifier character (meaning, if it is 0-9, A-Z, a-z or _)\r\n * @param c character to check\r\n * @returns true if the character is an identifier character\r\n */\r\nexport function IsIdentifierChar(c: string): boolean {\r\n    const v = c.charCodeAt(0);\r\n    return (\r\n        (v >= 48 && v <= 57) || // 0-9\r\n        (v >= 65 && v <= 90) || // A-Z\r\n        (v >= 97 && v <= 122) || // a-z\r\n        v == 95\r\n    ); // _\r\n}\r\n\r\n/**\r\n * Removes the comments of a code block\r\n * @param block code block to parse\r\n * @returns block with the comments removed\r\n */\r\nexport function RemoveComments(block: string): string {\r\n    let currPos = 0,\r\n        waitForChar = \"\",\r\n        inComments = false;\r\n    const s = [];\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                            inComments = true;\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                            inComments = true;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n            if (!inComments) {\r\n                s.push(currChar);\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                    s.push(currChar);\r\n                } else {\r\n                    waitForChar = \"\";\r\n                    inComments = false;\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    inComments = false;\r\n                    currPos++;\r\n                }\r\n            } else {\r\n                if (!inComments) {\r\n                    s.push(currChar);\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n    }\r\n\r\n    return s.join(\"\");\r\n}\r\n\r\n/**\r\n * Finds the first occurrence of a character in a string going backward\r\n * @param s the string to parse\r\n * @param index starting index in the string\r\n * @param c the character to find\r\n * @param c2 an optional second character to find\r\n * @returns the index of the character if found, else -1\r\n */\r\nexport function FindBackward(s: string, index: number, c: string, c2?: string): number {\r\n    while (index >= 0 && s.charAt(index) !== c && (!c2 || s.charAt(index) !== c2)) {\r\n        index--;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Escapes a string so that it is usable as a regular expression\r\n * @param s string to escape\r\n * @returns escaped string\r\n */\r\nexport function EscapeRegExp(s: string): string {\r\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\n\r\n/**\r\n * Injects code at the beginning and/or end of a function.\r\n * The function is identified by \"mainFuncDecl\". The starting code is injected just after the first \"\\{\" found after the mainFuncDecl.\r\n * The ending code is injected just before the last \"\\}\" of the whole block of code (so, it is assumed that the function is the last of the block of code).\r\n * @param code code to inject into\r\n * @param mainFuncDecl Function declaration to find in the code (for eg: \"void main\")\r\n * @param startingCode The code to inject at the beginning of the function\r\n * @param endingCode The code to inject at the end of the function\r\n * @returns The code with the injected code\r\n */\r\nexport function InjectStartingAndEndingCode(code: string, mainFuncDecl: string, startingCode?: string, endingCode?: string): string {\r\n    let idx = code.indexOf(mainFuncDecl);\r\n    if (idx < 0) {\r\n        return code;\r\n    }\r\n    if (startingCode) {\r\n        // eslint-disable-next-line no-empty\r\n        while (idx++ < code.length && code.charAt(idx) != \"{\") {}\r\n        if (idx < code.length) {\r\n            const part1 = code.substring(0, idx + 1);\r\n            const part2 = code.substring(idx + 1);\r\n            code = part1 + startingCode + part2;\r\n        }\r\n    }\r\n\r\n    if (endingCode) {\r\n        const lastClosingCurly = code.lastIndexOf(\"}\");\r\n        code = code.substring(0, lastClosingCurly);\r\n        code += endingCode + \"\\n}\";\r\n    }\r\n\r\n    return code;\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { _IShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\nimport type { WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\nimport { InjectStartingAndEndingCode } from \"../../Misc/codeStringParsingTools\";\r\nimport { Constants } from \"../constants\";\r\n\r\n/** @internal */\r\nexport class WebGPUShaderProcessorGLSL extends WebGPUShaderProcessor {\r\n    protected _missingVaryings: Array<string> = [];\r\n    protected _textureArrayProcessing: Array<string> = [];\r\n    protected _preProcessors: { [key: string]: string };\r\n    protected _vertexIsGLES3: boolean = false;\r\n    protected _fragmentIsGLES3: boolean = false;\r\n\r\n    public override shaderLanguage = ShaderLanguage.GLSL;\r\n    public parseGLES3 = true;\r\n    public attributeKeywordName: string | undefined;\r\n    public varyingVertexKeywordName: string | undefined;\r\n    public varyingFragmentKeywordName: string | undefined;\r\n\r\n    protected _getArraySize(name: string, type: string, preProcessors: { [key: string]: string }): [string, string, number] {\r\n        let length = 0;\r\n        const startArray = name.indexOf(\"[\");\r\n        const endArray = name.indexOf(\"]\");\r\n        if (startArray > 0 && endArray > 0) {\r\n            const lengthInString = name.substring(startArray + 1, endArray);\r\n            length = +lengthInString;\r\n            if (isNaN(length)) {\r\n                length = +preProcessors[lengthInString.trim()];\r\n            }\r\n            name = name.substring(0, startArray);\r\n        }\r\n        return [name, type, length];\r\n    }\r\n\r\n    public initializeShaders(processingContext: Nullable<_IShaderProcessingContext>): void {\r\n        this._webgpuProcessingContext = processingContext as WebGPUShaderProcessingContext;\r\n\r\n        this._missingVaryings.length = 0;\r\n        this._textureArrayProcessing.length = 0;\r\n        this.attributeKeywordName = undefined;\r\n        this.varyingVertexKeywordName = undefined;\r\n        this.varyingFragmentKeywordName = undefined;\r\n    }\r\n\r\n    public preProcessShaderCode(code: string, isFragment: boolean): string {\r\n        const ubDeclaration = `// Internals UBO\\nuniform ${WebGPUShaderProcessor.InternalsUBOName} {\\nfloat yFactor_;\\nfloat textureOutputHeight_;\\n};\\n`;\r\n        const alreadyInjected = code.indexOf(\"// Internals UBO\") !== -1;\r\n\r\n        if (isFragment) {\r\n            this._fragmentIsGLES3 = code.indexOf(\"#version 3\") !== -1;\r\n            if (this._fragmentIsGLES3) {\r\n                this.varyingFragmentKeywordName = \"in\";\r\n            }\r\n            return alreadyInjected ? code : ubDeclaration + \"##INJECTCODE##\\n\" + code;\r\n        }\r\n\r\n        this._vertexIsGLES3 = code.indexOf(\"#version 3\") !== -1;\r\n        if (this._vertexIsGLES3) {\r\n            this.attributeKeywordName = \"in\";\r\n            this.varyingVertexKeywordName = \"out\";\r\n        }\r\n        return alreadyInjected ? code : ubDeclaration + code;\r\n    }\r\n\r\n    public varyingCheck(varying: string, isFragment: boolean) {\r\n        const outRegex = /(flat\\s)?\\s*\\bout\\b/;\r\n        const inRegex = /(flat\\s)?\\s*\\bin\\b/;\r\n        const varyingRegex = /(flat\\s)?\\s*\\bvarying\\b/;\r\n\r\n        const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;\r\n\r\n        return regex.test(varying);\r\n    }\r\n\r\n    public varyingProcessor(varying: string, isFragment: boolean, preProcessors: { [key: string]: string }) {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const outRegex = /\\s*(flat)?\\s*out\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const inRegex = /\\s*(flat)?\\s*in\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const varyingRegex = /\\s*(flat)?\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;\r\n        const match = regex.exec(varying);\r\n        if (match !== null) {\r\n            const interpolationQualifier = match[1] ?? \"\";\r\n            const varyingType = match[2];\r\n            const name = match[3];\r\n            let location: number;\r\n            if (isFragment) {\r\n                location = this._webgpuProcessingContext.availableVaryings[name];\r\n                this._missingVaryings[location] = \"\";\r\n                if (location === undefined) {\r\n                    Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\r\n                }\r\n            } else {\r\n                location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\r\n                this._webgpuProcessingContext.availableVaryings[name] = location;\r\n                this._missingVaryings[location] = `layout(location = ${location}) ${interpolationQualifier} in ${varyingType} ${name};`;\r\n            }\r\n\r\n            varying = varying.replace(\r\n                match[0],\r\n                location === undefined ? \"\" : `layout(location = ${location}) ${interpolationQualifier} ${isFragment ? \"in\" : \"out\"} ${varyingType} ${name};`\r\n            );\r\n        }\r\n        return varying;\r\n    }\r\n\r\n    public attributeProcessor(attribute: string, preProcessors: { [key: string]: string }) {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const inRegex = /\\s*in\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const attribRegex = /\\s*attribute\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const regex = this._vertexIsGLES3 ? inRegex : attribRegex;\r\n        const match = regex.exec(attribute);\r\n        if (match !== null) {\r\n            const attributeType = match[1];\r\n            const name = match[2];\r\n            const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\r\n\r\n            this._webgpuProcessingContext.availableAttributes[name] = location;\r\n            this._webgpuProcessingContext.orderedAttributes[location] = name;\r\n\r\n            const numComponents = this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents[name];\r\n            if (numComponents !== undefined) {\r\n                // Special case for an int/ivecX vertex buffer that is used as a float/vecX attribute in the shader.\r\n                const newType = numComponents < 0 ? (numComponents === -1 ? \"int\" : \"ivec\" + -numComponents) : numComponents === 1 ? \"uint\" : \"uvec\" + numComponents;\r\n                const newName = `_int_${name}_`;\r\n\r\n                attribute = attribute.replace(match[0], `layout(location = ${location}) in ${newType} ${newName}; ${attributeType} ${name} = ${attributeType}(${newName});`);\r\n            } else {\r\n                attribute = attribute.replace(match[0], `layout(location = ${location}) in ${attributeType} ${name};`);\r\n            }\r\n        }\r\n        return attribute;\r\n    }\r\n\r\n    public uniformProcessor(uniform: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const uniformRegex = /\\s*uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const match = uniformRegex.exec(uniform);\r\n        if (match !== null) {\r\n            let uniformType = match[1];\r\n            let name = match[2];\r\n\r\n            if (uniformType.indexOf(\"sampler\") === 0 || uniformType.indexOf(\"sampler\") === 1) {\r\n                let arraySize = 0; // 0 means the texture is not declared as an array\r\n\r\n                [name, uniformType, arraySize] = this._getArraySize(name, uniformType, preProcessors);\r\n\r\n                let textureInfo = this._webgpuProcessingContext.availableTextures[name];\r\n                if (!textureInfo) {\r\n                    textureInfo = {\r\n                        autoBindSampler: true,\r\n                        isTextureArray: arraySize > 0,\r\n                        isStorageTexture: false,\r\n                        textures: [],\r\n                        sampleType: WebGPUConstants.TextureSampleType.Float,\r\n                    };\r\n                    for (let i = 0; i < (arraySize || 1); ++i) {\r\n                        textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\r\n                    }\r\n                }\r\n\r\n                const samplerType = WebGPUShaderProcessor._SamplerTypeByWebGLSamplerType[uniformType] ?? \"sampler\";\r\n                const isComparisonSampler = !!WebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType[samplerType];\r\n                const samplerBindingType = isComparisonSampler ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\r\n                const samplerName = name + Constants.AUTOSAMPLERSUFFIX;\r\n\r\n                let samplerInfo = this._webgpuProcessingContext.availableSamplers[samplerName];\r\n                if (!samplerInfo) {\r\n                    samplerInfo = {\r\n                        binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n                        type: samplerBindingType,\r\n                    };\r\n                }\r\n\r\n                const componentType = uniformType.charAt(0) === \"u\" ? \"u\" : uniformType.charAt(0) === \"i\" ? \"i\" : \"\";\r\n\r\n                if (componentType) {\r\n                    uniformType = uniformType.substring(1);\r\n                }\r\n\r\n                const sampleType = isComparisonSampler\r\n                    ? WebGPUConstants.TextureSampleType.Depth\r\n                    : componentType === \"u\"\r\n                      ? WebGPUConstants.TextureSampleType.Uint\r\n                      : componentType === \"i\"\r\n                        ? WebGPUConstants.TextureSampleType.Sint\r\n                        : WebGPUConstants.TextureSampleType.Float;\r\n\r\n                textureInfo.sampleType = sampleType;\r\n\r\n                const isTextureArray = arraySize > 0;\r\n                const samplerGroupIndex = samplerInfo.binding.groupIndex;\r\n                const samplerBindingIndex = samplerInfo.binding.bindingIndex;\r\n                const samplerFunction = WebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType[uniformType];\r\n                const textureType = WebGPUShaderProcessor._TextureTypeByWebGLSamplerType[uniformType];\r\n                const textureDimension = WebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType[textureType];\r\n\r\n                // Manage textures and samplers.\r\n                if (!isTextureArray) {\r\n                    arraySize = 1;\r\n                    uniform = `layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${samplerType} ${samplerName};\r\n                        layout(set = ${textureInfo.textures[0].groupIndex}, binding = ${textureInfo.textures[0].bindingIndex}) uniform ${componentType}${textureType} ${name}Texture;\r\n                        #define ${name} ${componentType}${samplerFunction}(${name}Texture, ${samplerName})`;\r\n                } else {\r\n                    const layouts = [];\r\n                    layouts.push(`layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};`);\r\n                    uniform = `\\n`;\r\n                    for (let i = 0; i < arraySize; ++i) {\r\n                        const textureSetIndex = textureInfo.textures[i].groupIndex;\r\n                        const textureBindingIndex = textureInfo.textures[i].bindingIndex;\r\n\r\n                        layouts.push(`layout(set = ${textureSetIndex}, binding = ${textureBindingIndex}) uniform ${textureType} ${name}Texture${i};`);\r\n\r\n                        uniform += `${i > 0 ? \"\\n\" : \"\"}#define ${name}${i} ${componentType}${samplerFunction}(${name}Texture${i}, ${samplerName})`;\r\n                    }\r\n                    uniform = layouts.join(\"\\n\") + uniform;\r\n                    this._textureArrayProcessing.push(name);\r\n                }\r\n\r\n                this._webgpuProcessingContext.availableTextures[name] = textureInfo;\r\n                this._webgpuProcessingContext.availableSamplers[samplerName] = samplerInfo;\r\n\r\n                this._addSamplerBindingDescription(samplerName, samplerInfo, !isFragment);\r\n\r\n                for (let i = 0; i < arraySize; ++i) {\r\n                    this._addTextureBindingDescription(name, textureInfo, i, textureDimension, null, !isFragment);\r\n                }\r\n            } else {\r\n                this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\r\n                uniform = \"\";\r\n            }\r\n        }\r\n        return uniform;\r\n    }\r\n\r\n    public uniformBufferProcessor(uniformBuffer: string, isFragment: boolean): string {\r\n        const uboRegex = /uniform\\s+(\\w+)/gm;\r\n\r\n        const match = uboRegex.exec(uniformBuffer);\r\n        if (match !== null) {\r\n            const name = match[1];\r\n\r\n            let uniformBufferInfo = this._webgpuProcessingContext.availableBuffers[name];\r\n            if (!uniformBufferInfo) {\r\n                const knownUBO = WebGPUShaderProcessingContext.KnownUBOs[name];\r\n\r\n                let binding;\r\n                if (knownUBO && knownUBO.binding.groupIndex !== -1) {\r\n                    binding = knownUBO.binding;\r\n                } else {\r\n                    binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                }\r\n\r\n                uniformBufferInfo = { binding };\r\n                this._webgpuProcessingContext.availableBuffers[name] = uniformBufferInfo;\r\n            }\r\n\r\n            this._addBufferBindingDescription(name, uniformBufferInfo, WebGPUConstants.BufferBindingType.Uniform, !isFragment);\r\n\r\n            uniformBuffer = uniformBuffer.replace(\"uniform\", `layout(set = ${uniformBufferInfo.binding.groupIndex}, binding = ${uniformBufferInfo.binding.bindingIndex}) uniform`);\r\n        }\r\n        return uniformBuffer;\r\n    }\r\n\r\n    public postProcessor(\r\n        code: string,\r\n        defines: string[],\r\n        isFragment: boolean,\r\n        _processingContext: Nullable<_IShaderProcessingContext>,\r\n        _parameters: { [key: string]: number | string | boolean | undefined },\r\n        preProcessors: { [key: string]: string }\r\n    ): string {\r\n        const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;\r\n\r\n        // Remove extensions\r\n        const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;\r\n        code = code.replace(regex, \"\");\r\n\r\n        // Replace instructions\r\n        code = code.replace(/texture2D\\s*\\(/g, \"texture(\");\r\n        if (isFragment) {\r\n            const hasFragCoord = code.indexOf(\"gl_FragCoord\") >= 0;\r\n            const fragCoordCode = `\r\n                glFragCoord_ = gl_FragCoord;\r\n                if (yFactor_ == 1.) {\r\n                    glFragCoord_.y = textureOutputHeight_ - glFragCoord_.y;\r\n                }\r\n            `;\r\n\r\n            const injectCode = hasFragCoord ? \"vec4 glFragCoord_;\\n\" : \"\";\r\n            const hasOutput = code.search(/layout *\\(location *= *0\\) *out/g) !== -1;\r\n\r\n            code = code.replace(/texture2DLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCubeLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCube\\s*\\(/g, \"texture(\");\r\n            code = code.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\r\n            code = code.replace(/gl_FragColor/g, \"glFragColor\");\r\n            code = code.replace(/gl_FragData/g, \"glFragData\");\r\n            code = code.replace(/gl_FragCoord/g, \"glFragCoord_\");\r\n            if (!this._fragmentIsGLES3) {\r\n                code = code.replace(/void\\s+?main\\s*\\(/g, (hasDrawBuffersExtension || hasOutput ? \"\" : \"layout(location = 0) out vec4 glFragColor;\\n\") + \"void main(\");\r\n            } else {\r\n                const match = /^\\s*out\\s+\\S+\\s+\\S+\\s*;/gm.exec(code);\r\n                if (match !== null) {\r\n                    code = code.substring(0, match.index) + \"layout(location = 0) \" + code.substring(match.index);\r\n                }\r\n            }\r\n            code = code.replace(/dFdy/g, \"(-yFactor_)*dFdy\"); // will also handle dFdyCoarse and dFdyFine\r\n            code = code.replace(\"##INJECTCODE##\", injectCode);\r\n\r\n            if (hasFragCoord) {\r\n                code = InjectStartingAndEndingCode(code, \"void main\", fragCoordCode);\r\n            }\r\n        } else {\r\n            if (\"VERTEXOUTPUT_INVARIANT\" in preProcessors) {\r\n                code = \"invariant gl_Position;\\n\" + code;\r\n            }\r\n            code = code.replace(/gl_InstanceID/g, \"gl_InstanceIndex\");\r\n            code = code.replace(/gl_VertexID/g, \"gl_VertexIndex\");\r\n            const hasMultiviewExtension = defines.indexOf(\"#define MULTIVIEW\") !== -1;\r\n            if (hasMultiviewExtension) {\r\n                return \"#extension GL_OVR_multiview2 : require\\nlayout (num_views = 2) in;\\n\" + code;\r\n            }\r\n        }\r\n\r\n        // Flip Y + convert z range from [-1,1] to [0,1]\r\n        if (!isFragment) {\r\n            const lastClosingCurly = code.lastIndexOf(\"}\");\r\n            code = code.substring(0, lastClosingCurly);\r\n            code += \"gl_Position.y *= yFactor_;\\n\";\r\n            // isNDCHalfZRange is always true in WebGPU\r\n            code += \"}\";\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _applyTextureArrayProcessing(code: string, name: string): string {\r\n        // Replaces the occurrences of name[XX] by nameXX\r\n        const regex = new RegExp(name + \"\\\\s*\\\\[(.+)?\\\\]\", \"gm\");\r\n        let match = regex.exec(code);\r\n\r\n        while (match !== null) {\r\n            const index = match[1];\r\n            let iindex = +index;\r\n            if (this._preProcessors && isNaN(iindex)) {\r\n                iindex = +this._preProcessors[index.trim()];\r\n            }\r\n            code = code.replace(match[0], name + iindex);\r\n            match = regex.exec(code);\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string {\r\n        let ubo = `layout(set = ${uniformBufferDescription.binding.groupIndex}, binding = ${uniformBufferDescription.binding.bindingIndex}) uniform ${name} {\\n    `;\r\n        for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\r\n            if (leftOverUniform.length > 0) {\r\n                ubo += `    ${leftOverUniform.type} ${leftOverUniform.name}[${leftOverUniform.length}];\\n`;\r\n            } else {\r\n                ubo += `    ${leftOverUniform.type} ${leftOverUniform.name};\\n`;\r\n            }\r\n        }\r\n        ubo += \"};\\n\\n\";\r\n\r\n        return ubo;\r\n    }\r\n\r\n    public finalizeShaders(vertexCode: string, fragmentCode: string): { vertexCode: string; fragmentCode: string } {\r\n        // make replacements for texture names in the texture array case\r\n        for (let i = 0; i < this._textureArrayProcessing.length; ++i) {\r\n            const name = this._textureArrayProcessing[i];\r\n            vertexCode = this._applyTextureArrayProcessing(vertexCode, name);\r\n            fragmentCode = this._applyTextureArrayProcessing(fragmentCode, name);\r\n        }\r\n\r\n        // inject the missing varying in the fragment shader\r\n        for (let i = 0; i < this._missingVaryings.length; ++i) {\r\n            const decl = this._missingVaryings[i];\r\n            if (decl && decl.length > 0) {\r\n                fragmentCode = decl + \"\\n\" + fragmentCode;\r\n            }\r\n        }\r\n\r\n        // Builds the leftover UBOs.\r\n        const leftOverUBO = this._buildLeftOverUBO();\r\n\r\n        vertexCode = leftOverUBO + vertexCode;\r\n        fragmentCode = leftOverUBO + fragmentCode;\r\n\r\n        this._collectBindingNames();\r\n        this._preCreateBindGroupEntries();\r\n\r\n        this._preProcessors = null as any;\r\n        this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents = {};\r\n\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { _IShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\nimport type { WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport { RemoveComments, InjectStartingAndEndingCode } from \"../../Misc/codeStringParsingTools\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\nimport { Constants } from \"../constants\";\r\n\r\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimation\";\r\nimport \"../../ShadersWGSL/ShadersInclude/instancesDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/instancesVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/helperFunctions\";\r\nimport \"../../ShadersWGSL/ShadersInclude/fresnelFunction\";\r\nimport \"../../ShadersWGSL/ShadersInclude/meshUboDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/sceneUboDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/decalFragment\";\r\n\r\nconst builtInName_frag_depth = \"fragmentOutputs.fragDepth\";\r\n\r\nconst leftOverVarName = \"uniforms\";\r\nconst internalsVarName = \"internals\";\r\n\r\nconst gpuTextureViewDimensionByWebGPUTextureFunction: { [key: string]: Nullable<GPUTextureViewDimension> } = {\r\n    texture_1d: WebGPUConstants.TextureViewDimension.E1d,\r\n    texture_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_3d: WebGPUConstants.TextureViewDimension.E3d,\r\n    texture_cube: WebGPUConstants.TextureViewDimension.Cube,\r\n    texture_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\r\n    texture_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_depth_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_depth_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_depth_cube: WebGPUConstants.TextureViewDimension.Cube,\r\n    texture_depth_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\r\n    texture_depth_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_storage_1d: WebGPUConstants.TextureViewDimension.E1d,\r\n    texture_storage_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_storage_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_storage_3d: WebGPUConstants.TextureViewDimension.E3d,\r\n    texture_external: null,\r\n};\r\n\r\n/** @internal */\r\nexport class WebGPUShaderProcessorWGSL extends WebGPUShaderProcessor {\r\n    protected _attributesInputWGSL: string[];\r\n    protected _attributesWGSL: string[];\r\n    protected _attributesConversionCodeWGSL: string[];\r\n    protected _hasNonFloatAttribute: boolean;\r\n    protected _varyingsWGSL: string[];\r\n    protected _varyingNamesWGSL: string[];\r\n    protected _stridedUniformArrays: string[];\r\n\r\n    public override shaderLanguage = ShaderLanguage.WGSL;\r\n    public uniformRegexp = /uniform\\s+(\\w+)\\s*:\\s*(.+)\\s*;/;\r\n    public textureRegexp = /var\\s+(\\w+)\\s*:\\s*((array<\\s*)?(texture_\\w+)\\s*(<\\s*(.+)\\s*>)?\\s*(,\\s*\\w+\\s*>\\s*)?);/;\r\n    public noPrecision = true;\r\n    public pureMode = false;\r\n\r\n    protected _getArraySize(name: string, uniformType: string, preProcessors: { [key: string]: string }): [string, string, number] {\r\n        let length = 0;\r\n\r\n        const endArray = uniformType.lastIndexOf(\">\");\r\n        if (uniformType.indexOf(\"array\") >= 0 && endArray > 0) {\r\n            let startArray = endArray;\r\n            while (startArray > 0 && uniformType.charAt(startArray) !== \" \" && uniformType.charAt(startArray) !== \",\") {\r\n                startArray--;\r\n            }\r\n            const lengthInString = uniformType.substring(startArray + 1, endArray);\r\n            length = +lengthInString;\r\n            if (isNaN(length)) {\r\n                length = +preProcessors[lengthInString.trim()];\r\n            }\r\n            while (startArray > 0 && (uniformType.charAt(startArray) === \" \" || uniformType.charAt(startArray) === \",\")) {\r\n                startArray--;\r\n            }\r\n            uniformType = uniformType.substring(uniformType.indexOf(\"<\") + 1, startArray + 1);\r\n        }\r\n\r\n        return [name, uniformType, length];\r\n    }\r\n\r\n    public initializeShaders(processingContext: Nullable<_IShaderProcessingContext>): void {\r\n        this._webgpuProcessingContext = processingContext as WebGPUShaderProcessingContext;\r\n\r\n        this._attributesInputWGSL = [];\r\n        this._attributesWGSL = [];\r\n        this._attributesConversionCodeWGSL = [];\r\n        this._hasNonFloatAttribute = false;\r\n        this._varyingsWGSL = [];\r\n        this._varyingNamesWGSL = [];\r\n        this._stridedUniformArrays = [];\r\n    }\r\n\r\n    public preProcessShaderCode(code: string): string {\r\n        // Same check as in webgpuShaderProcessorsGLSL to avoid same ubDelcaration to be injected twice.\r\n        const ubDeclaration = this.pureMode\r\n            ? \"\"\r\n            : `struct ${WebGPUShaderProcessor.InternalsUBOName} {\\n  yFactor_: f32,\\n  textureOutputHeight_: f32,\\n};\\nvar<uniform> ${internalsVarName} : ${WebGPUShaderProcessor.InternalsUBOName};\\n`;\r\n        const alreadyInjected = code.indexOf(ubDeclaration) !== -1;\r\n        return alreadyInjected ? code : ubDeclaration + RemoveComments(code);\r\n    }\r\n\r\n    public varyingCheck(varying: string): boolean {\r\n        const regex = /(flat|linear|perspective)?\\s*(center|centroid|sample)?\\s*\\bvarying\\b/;\r\n\r\n        return regex.test(varying);\r\n    }\r\n\r\n    public varyingProcessor(varying: string, isFragment: boolean, preProcessors: { [key: string]: string }) {\r\n        const varyingRegex = /\\s*(flat|linear|perspective)?\\s*(center|centroid|sample)?\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s*:\\s*(.+)\\s*;/gm;\r\n        const match = varyingRegex.exec(varying);\r\n        if (match !== null) {\r\n            const interpolationType = match[1] ?? \"perspective\";\r\n            const interpolationSampling = match[2] ?? \"center\";\r\n            const varyingType = match[4];\r\n            const name = match[3];\r\n            const interpolation = interpolationType === \"flat\" ? `@interpolate(${interpolationType})` : `@interpolate(${interpolationType}, ${interpolationSampling})`;\r\n            let location: number;\r\n            if (isFragment) {\r\n                location = this._webgpuProcessingContext.availableVaryings[name];\r\n                if (location === undefined) {\r\n                    Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\r\n                }\r\n            } else {\r\n                location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\r\n                this._webgpuProcessingContext.availableVaryings[name] = location;\r\n                this._varyingsWGSL.push(`  @location(${location}) ${interpolation} ${name} : ${varyingType},`);\r\n                this._varyingNamesWGSL.push(name);\r\n            }\r\n\r\n            varying = \"\";\r\n        }\r\n        return varying;\r\n    }\r\n\r\n    public attributeProcessor(attribute: string, preProcessors: { [key: string]: string }) {\r\n        const attribRegex = /\\s*attribute\\s+(\\S+)\\s*:\\s*(.+)\\s*;/gm;\r\n        const match = attribRegex.exec(attribute);\r\n        if (match !== null) {\r\n            const attributeType = match[2];\r\n            const name = match[1];\r\n            const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\r\n\r\n            this._webgpuProcessingContext.availableAttributes[name] = location;\r\n            this._webgpuProcessingContext.orderedAttributes[location] = name;\r\n\r\n            const numComponents = this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents[name];\r\n            if (numComponents !== undefined) {\r\n                // Special case for an int/ivecX vertex buffer that is used as a float/vecX attribute in the shader.\r\n                const newType =\r\n                    numComponents < 0 ? (numComponents === -1 ? \"i32\" : \"vec\" + -numComponents + \"<i32>\") : numComponents === 1 ? \"u32\" : \"vec\" + numComponents + \"<u32>\";\r\n                const newName = `_int_${name}_`;\r\n\r\n                this._attributesInputWGSL.push(`@location(${location}) ${newName} : ${newType},`);\r\n                this._attributesWGSL.push(`${name} : ${attributeType},`);\r\n                this._attributesConversionCodeWGSL.push(`vertexInputs.${name} = ${attributeType}(vertexInputs_.${newName});`);\r\n                this._hasNonFloatAttribute = true;\r\n            } else {\r\n                this._attributesInputWGSL.push(`@location(${location}) ${name} : ${attributeType},`);\r\n                this._attributesWGSL.push(`${name} : ${attributeType},`);\r\n                this._attributesConversionCodeWGSL.push(`vertexInputs.${name} = vertexInputs_.${name};`);\r\n            }\r\n            attribute = \"\";\r\n        }\r\n        return attribute;\r\n    }\r\n\r\n    public uniformProcessor(uniform: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        const match = this.uniformRegexp.exec(uniform);\r\n        if (match !== null) {\r\n            const uniformType = match[2];\r\n            const name = match[1];\r\n\r\n            this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\r\n\r\n            uniform = \"\";\r\n        }\r\n        return uniform;\r\n    }\r\n\r\n    public textureProcessor(texture: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        const match = this.textureRegexp.exec(texture);\r\n        if (match !== null) {\r\n            const name = match[1]; // name of the variable\r\n            const type = match[2]; // texture_2d<f32> or array<texture_2d_array<f32>, 5> for eg\r\n            const isArrayOfTexture = !!match[3];\r\n            const textureFunc = match[4]; // texture_2d, texture_depth_2d, etc\r\n            const isStorageTexture = textureFunc.indexOf(\"storage\") > 0;\r\n            const componentType = match[6]; // f32 or i32 or u32 or undefined\r\n            const storageTextureFormat = isStorageTexture ? (componentType.substring(0, componentType.indexOf(\",\")).trim() as GPUTextureFormat) : null;\r\n\r\n            let arraySize = isArrayOfTexture ? this._getArraySize(name, type, preProcessors)[2] : 0;\r\n            let textureInfo = this._webgpuProcessingContext.availableTextures[name];\r\n            if (!textureInfo) {\r\n                textureInfo = {\r\n                    isTextureArray: arraySize > 0,\r\n                    isStorageTexture,\r\n                    textures: [],\r\n                    sampleType: WebGPUConstants.TextureSampleType.Float,\r\n                };\r\n                arraySize = arraySize || 1;\r\n                for (let i = 0; i < arraySize; ++i) {\r\n                    textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\r\n                }\r\n            } else {\r\n                arraySize = textureInfo.textures.length;\r\n            }\r\n\r\n            this._webgpuProcessingContext.availableTextures[name] = textureInfo;\r\n\r\n            const isDepthTexture = textureFunc.indexOf(\"depth\") > 0;\r\n            const textureDimension = gpuTextureViewDimensionByWebGPUTextureFunction[textureFunc];\r\n            const sampleType = isDepthTexture\r\n                ? WebGPUConstants.TextureSampleType.Depth\r\n                : componentType === \"u32\"\r\n                  ? WebGPUConstants.TextureSampleType.Uint\r\n                  : componentType === \"i32\"\r\n                    ? WebGPUConstants.TextureSampleType.Sint\r\n                    : WebGPUConstants.TextureSampleType.Float;\r\n\r\n            textureInfo.sampleType = sampleType;\r\n\r\n            if (textureDimension === undefined) {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw `Can't get the texture dimension corresponding to the texture function \"${textureFunc}\"!`;\r\n            }\r\n\r\n            for (let i = 0; i < arraySize; ++i) {\r\n                const { groupIndex, bindingIndex } = textureInfo.textures[i];\r\n\r\n                if (i === 0) {\r\n                    texture = `@group(${groupIndex}) @binding(${bindingIndex}) ${texture}`;\r\n                }\r\n\r\n                this._addTextureBindingDescription(name, textureInfo, i, textureDimension, storageTextureFormat, !isFragment);\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    private _convertDefinesToConst(preProcessors: { [key: string]: string }) {\r\n        let code = \"\";\r\n        for (const key in preProcessors) {\r\n            const value = preProcessors[key];\r\n            if (key.startsWith(\"__\")) {\r\n                continue;\r\n            }\r\n            if (!isNaN(parseInt(value)) || !isNaN(parseFloat(value))) {\r\n                code += `const ${key} = ${value};\\n`;\r\n            } else if (key && value === \"\") {\r\n                code += `const ${key} = true;\\n`;\r\n            }\r\n        }\r\n        return code;\r\n    }\r\n\r\n    public postProcessor(\r\n        code: string,\r\n        _defines: string[],\r\n        _isFragment: boolean,\r\n        _processingContext: Nullable<_IShaderProcessingContext>,\r\n        _parameters: {\r\n            [key: string]: number | string | boolean | undefined;\r\n        },\r\n        preProcessors: { [key: string]: string },\r\n        preProcessorsFromCode: { [key: string]: string }\r\n    ) {\r\n        // Collect the preprocessor names (coming from a \"#define NAME VALUE\" declaration) directly defined in the shader code (preProcessorsFromCode) and not defined at the material level (preProcessors).\r\n        // This is because we will have to perform a replace on the code to replace the defines with their values.\r\n        //\r\n        // We don't have to do it for preprocessor names defined at the material level because replacing them by \"const NAME = VALUE;\" will take care of it (see _convertDefinesToConst()) and is faster than doing a search/replace for each of them.\r\n        //\r\n        // The reason why doing \"const NAME = VALUE;\" doesn't work for preprocessor names defined in the code is that VALUE can be any string and not only numbers or booleans.\r\n        // So, if we have this code:\r\n        //\r\n        //      #define vDiffuseUV vMainUV\r\n        //      textureSample(..., fragmentInputs.vDiffuseUV)\r\n        ///\r\n        // only a search/replace will work, 'const vDiffuseUV = \"vMainUV\";' will not work\r\n        //\r\n        // Note that the search/replace text processing will also apply to the \"#define NAME VALUE\" definition itself, so it will become \"#define VALUE VALUE\"\r\n        // It's not a problem, though, because all #define XXX will be commented out in the final code.\r\n        const defineList: string[] = [];\r\n\r\n        for (const key in preProcessorsFromCode) {\r\n            const value = preProcessorsFromCode[key];\r\n\r\n            // Excludes the defines that are booleans (note that there aren't \"false\" booleans: we simply don't add them in the preProcessorsFromCode object).\r\n            // That's because we need (at least some of) them to stay untouched, like #define DISABLE_UNIFORMTY_ANALYSIS or #define CUSTOM_VERTEX_BEGIN (else, they would be replaced with \"#define true\" after the search/replace processing)\r\n            if (value !== \"true\") {\r\n                defineList.push(key);\r\n            }\r\n        }\r\n\r\n        // We must sort the define names by length to avoid replacing a define with a longer name (ex: #define A 1 and #define AB 2, if we replace A with 1, we will have #define 1B 2)\r\n        // So, we start by longest names and we finish with the shortest ones.\r\n        defineList.sort((a, b) => (a.length - b.length > 0 ? -1 : a.length === b.length ? 0 : 1));\r\n\r\n        for (const name of defineList) {\r\n            // Let's retrieve the value of the define from the code\r\n            // Note that we can't use the value from preProcessorsFromCode[name] because this value could have been changed from a previous replace\r\n            // For example:\r\n            //      #define IOR 1.333\r\n            //      #define ETA 1.0/IOR\r\n            //\r\n            // After IOR replacement is performed, we will have:\r\n            //      #define 1.333 1.333\r\n            //      #define ETA 1.0/1.333\r\n            //\r\n            // but preProcessorsFromCode[\"ETA\"] is still \"1.0/IOR\" and not \"1.0/1.333\", so we must retrieve the value for ETA from the current code\r\n            const i0 = code.indexOf(\"#define \" + name);\r\n\r\n            let i1 = code.indexOf(\"\\n\", i0);\r\n            if (i1 === -1) {\r\n                i1 = code.length;\r\n            }\r\n\r\n            const value = code.substring(i0 + 8 + name.length + 1, i1);\r\n\r\n            code = code.replace(new RegExp(name, \"g\"), value);\r\n        }\r\n\r\n        code = this._convertDefinesToConst(preProcessors) + code;\r\n\r\n        if (\"VERTEXOUTPUT_INVARIANT\" in preProcessors) {\r\n            code = \"#define VERTEXOUTPUT_INVARIANT\\n\" + code;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    public finalizeShaders(vertexCode: string, fragmentCode: string): { vertexCode: string; fragmentCode: string } {\r\n        const enabledExtensions: string[] = [];\r\n\r\n        const fragCoordCode =\r\n            fragmentCode.indexOf(\"fragmentInputs.position\") >= 0 && !this.pureMode\r\n                ? `\r\n            if (internals.yFactor_ == 1.) {\r\n                fragmentInputs.position.y = internals.textureOutputHeight_ - fragmentInputs.position.y;\r\n            }\r\n        `\r\n                : \"\";\r\n\r\n        // Add the group/binding info to the sampler declaration (var xxx: sampler|sampler_comparison)\r\n        vertexCode = this._processSamplers(vertexCode, true);\r\n        fragmentCode = this._processSamplers(fragmentCode, false);\r\n\r\n        // Add the group/binding info to the uniform/storage buffer declarations (var<uniform> XXX:YYY or var<storage(,read_write|read)> XXX:YYY)\r\n        vertexCode = this._processCustomBuffers(vertexCode, true);\r\n        fragmentCode = this._processCustomBuffers(fragmentCode, false);\r\n\r\n        // Builds the leftover UBOs.\r\n        const leftOverUBO = this._buildLeftOverUBO();\r\n\r\n        vertexCode = leftOverUBO + vertexCode;\r\n        fragmentCode = leftOverUBO + fragmentCode;\r\n\r\n        // Vertex code\r\n        vertexCode = vertexCode.replace(/#define /g, \"//#define \");\r\n        vertexCode = this._processStridedUniformArrays(vertexCode);\r\n\r\n        let vertexInputs = \"struct VertexInputs {\\n  @builtin(vertex_index) vertexIndex : u32,\\n  @builtin(instance_index) instanceIndex : u32,\\n\";\r\n        if (this._attributesInputWGSL.length > 0) {\r\n            vertexInputs += this._attributesInputWGSL.join(\"\\n\");\r\n        }\r\n        vertexInputs += \"\\n};\\nvar<private> vertexInputs\" + (this._hasNonFloatAttribute ? \"_\" : \"\") + \" : VertexInputs;\\n\";\r\n        if (this._hasNonFloatAttribute) {\r\n            vertexInputs += \"struct VertexInputs_ {\\n  vertexIndex : u32, instanceIndex : u32,\\n\";\r\n            vertexInputs += this._attributesWGSL.join(\"\\n\");\r\n            vertexInputs += \"\\n};\\nvar<private> vertexInputs : VertexInputs_;\\n\";\r\n        }\r\n\r\n        let vertexOutputs =\r\n            \"struct FragmentInputs {\\n  @builtin(position)\" + (vertexCode.indexOf(\"#define VERTEXOUTPUT_INVARIANT\") >= 0 ? \" @invariant\" : \"\") + \" position : vec4<f32>,\\n\";\r\n        if (this._varyingsWGSL.length > 0) {\r\n            vertexOutputs += this._varyingsWGSL.join(\"\\n\");\r\n        }\r\n        vertexOutputs += \"\\n};\\nvar<private> vertexOutputs : FragmentInputs;\\n\";\r\n\r\n        vertexCode = vertexInputs + vertexOutputs + vertexCode;\r\n\r\n        let vertexMainStartingCode = `\\n  vertexInputs${this._hasNonFloatAttribute ? \"_\" : \"\"} = input;\\n`;\r\n        if (this._hasNonFloatAttribute) {\r\n            vertexMainStartingCode += \"vertexInputs.vertexIndex = vertexInputs_.vertexIndex;\\nvertexInputs.instanceIndex = vertexInputs_.instanceIndex;\\n\";\r\n            vertexMainStartingCode += this._attributesConversionCodeWGSL.join(\"\\n\");\r\n            vertexMainStartingCode += \"\\n\";\r\n        }\r\n        const vertexMainEndingCode = this.pureMode\r\n            ? `  return vertexOutputs;`\r\n            : `  vertexOutputs.position.y = vertexOutputs.position.y * internals.yFactor_;\\n  return vertexOutputs;`;\r\n        let needDiagnosticOff = vertexCode.indexOf(Constants.DISABLEUA) !== -1;\r\n\r\n        vertexCode =\r\n            (needDiagnosticOff ? \"diagnostic(off, derivative_uniformity);\\n\" : \"\") +\r\n            \"diagnostic(off, chromium.unreachable_code);\\n\" +\r\n            InjectStartingAndEndingCode(vertexCode, \"fn main\", vertexMainStartingCode, vertexMainEndingCode);\r\n\r\n        // fragment code\r\n        fragmentCode = fragmentCode.replace(/#define /g, \"//#define \");\r\n        fragmentCode = this._processStridedUniformArrays(fragmentCode);\r\n        if (!this.pureMode) {\r\n            fragmentCode = fragmentCode.replace(/dpdy/g, \"(-internals.yFactor_)*dpdy\"); // will also handle dpdyCoarse and dpdyFine\r\n        }\r\n\r\n        let fragmentInputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n  @builtin(front_facing) frontFacing : bool,\\n\";\r\n        if (this._varyingsWGSL.length > 0) {\r\n            fragmentInputs += this._varyingsWGSL.join(\"\\n\");\r\n        }\r\n        fragmentInputs += \"\\n};\\nvar<private> fragmentInputs : FragmentInputs;\\n\";\r\n\r\n        let fragmentOutputs = \"struct FragmentOutputs {\\n\";\r\n\r\n        // Adding fragData output locations\r\n        const regexRoot = \"fragmentOutputs\\\\.fragData\";\r\n        let match = fragmentCode.match(new RegExp(regexRoot + \"0\", \"g\"));\r\n        let indexLocation = 0;\r\n\r\n        if (match) {\r\n            fragmentOutputs += ` @location(${indexLocation}) fragData0 : vec4<f32>,\\n`;\r\n            indexLocation++;\r\n            for (let index = 1; index < 8; index++) {\r\n                match = fragmentCode.match(new RegExp(regexRoot + index, \"g\"));\r\n                if (match) {\r\n                    fragmentOutputs += ` @location(${indexLocation}) fragData${indexLocation} : vec4<f32>,\\n`;\r\n                    indexLocation++;\r\n                }\r\n            }\r\n            if (fragmentCode.indexOf(\"MRT_AND_COLOR\") !== -1) {\r\n                fragmentOutputs += `  @location(${indexLocation}) color : vec4<f32>,\\n`;\r\n                indexLocation++;\r\n            }\r\n        }\r\n\r\n        // Adding fragData output locations\r\n        const regex = /oitDepthSampler/;\r\n        match = fragmentCode.match(regex);\r\n\r\n        if (match) {\r\n            fragmentOutputs += ` @location(${indexLocation++}) depth : vec2<f32>,\\n`;\r\n            fragmentOutputs += ` @location(${indexLocation++}) frontColor : vec4<f32>,\\n`;\r\n            fragmentOutputs += ` @location(${indexLocation++}) backColor : vec4<f32>,\\n`;\r\n        }\r\n\r\n        if (indexLocation === 0) {\r\n            const useDualSourceBlending = fragmentCode.indexOf(\"DUAL_SOURCE_BLENDING\") !== -1;\r\n\r\n            if (useDualSourceBlending) {\r\n                enabledExtensions.push(\"dual_source_blending\");\r\n\r\n                fragmentOutputs += \"  @location(0) @blend_src(0) color : vec4<f32>,\\n\";\r\n                fragmentOutputs += \"  @location(0) @blend_src(1) color2 : vec4<f32>,\\n\";\r\n            } else {\r\n                fragmentOutputs += \"  @location(0) color : vec4<f32>,\\n\";\r\n            }\r\n            indexLocation++;\r\n        }\r\n\r\n        // FragDepth\r\n        let hasFragDepth = false;\r\n        let idx = 0;\r\n        while (!hasFragDepth) {\r\n            idx = fragmentCode.indexOf(builtInName_frag_depth, idx);\r\n            if (idx < 0) {\r\n                break;\r\n            }\r\n            const saveIndex = idx;\r\n            hasFragDepth = true;\r\n            while (idx > 1 && fragmentCode.charAt(idx) !== \"\\n\") {\r\n                if (fragmentCode.charAt(idx) === \"/\" && fragmentCode.charAt(idx - 1) === \"/\") {\r\n                    hasFragDepth = false;\r\n                    break;\r\n                }\r\n                idx--;\r\n            }\r\n            idx = saveIndex + builtInName_frag_depth.length;\r\n        }\r\n\r\n        if (hasFragDepth) {\r\n            fragmentOutputs += \"  @builtin(frag_depth) fragDepth: f32,\\n\";\r\n        }\r\n\r\n        fragmentOutputs += \"};\\nvar<private> fragmentOutputs : FragmentOutputs;\\n\";\r\n\r\n        fragmentCode = fragmentInputs + fragmentOutputs + fragmentCode;\r\n\r\n        const fragmentStartingCode = \"  fragmentInputs = input;\\n  \" + fragCoordCode;\r\n        const fragmentEndingCode = \"  return fragmentOutputs;\";\r\n        needDiagnosticOff = fragmentCode.indexOf(Constants.DISABLEUA) !== -1;\r\n\r\n        if (enabledExtensions.length > 0) {\r\n            fragmentCode = \"enable \" + enabledExtensions.join(\";\\nenable \") + \";\\n\" + fragmentCode;\r\n        }\r\n\r\n        fragmentCode =\r\n            (needDiagnosticOff ? \"diagnostic(off, derivative_uniformity);\\n\" : \"\") +\r\n            \"diagnostic(off, chromium.unreachable_code);\\n\" +\r\n            InjectStartingAndEndingCode(fragmentCode, \"fn main\", fragmentStartingCode, fragmentEndingCode);\r\n\r\n        this._collectBindingNames();\r\n        this._preCreateBindGroupEntries();\r\n\r\n        this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents = {};\r\n\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n\r\n    protected _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string {\r\n        let stridedArrays = \"\";\r\n        let ubo = `struct ${name} {\\n`;\r\n        for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\r\n            const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, \"$1\");\r\n            const size = WebGPUShaderProcessor.UniformSizes[type];\r\n\r\n            if (leftOverUniform.length > 0) {\r\n                if (size <= 2) {\r\n                    const stridedArrayType = `${name}_${this._stridedUniformArrays.length}_strided_arr`;\r\n                    stridedArrays += `struct ${stridedArrayType} {\r\n                        @size(16)\r\n                        el: ${type},\r\n                    }`;\r\n                    this._stridedUniformArrays.push(leftOverUniform.name);\r\n\r\n                    ubo += ` @align(16) ${leftOverUniform.name} : array<${stridedArrayType}, ${leftOverUniform.length}>,\\n`;\r\n                } else {\r\n                    ubo += ` ${leftOverUniform.name} : array<${leftOverUniform.type}, ${leftOverUniform.length}>,\\n`;\r\n                }\r\n            } else {\r\n                ubo += `  ${leftOverUniform.name} : ${leftOverUniform.type},\\n`;\r\n            }\r\n        }\r\n        ubo += \"};\\n\";\r\n        ubo = `${stridedArrays}\\n${ubo}`;\r\n        ubo += `@group(${uniformBufferDescription.binding.groupIndex}) @binding(${uniformBufferDescription.binding.bindingIndex}) var<uniform> ${leftOverVarName} : ${name};\\n`;\r\n\r\n        return ubo;\r\n    }\r\n\r\n    private _processSamplers(code: string, isVertex: boolean): string {\r\n        const samplerRegexp = /var\\s+(\\w+Sampler)\\s*:\\s*(sampler|sampler_comparison)\\s*;/gm;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const match = samplerRegexp.exec(code);\r\n            if (match === null) {\r\n                break;\r\n            }\r\n\r\n            const name = match[1]; // name of the variable\r\n            const samplerType = match[2]; // sampler or sampler_comparison\r\n            const suffixLessLength = name.length - Constants.AUTOSAMPLERSUFFIX.length;\r\n            const textureName = name.lastIndexOf(Constants.AUTOSAMPLERSUFFIX) === suffixLessLength ? name.substring(0, suffixLessLength) : null;\r\n            const samplerBindingType = samplerType === \"sampler_comparison\" ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\r\n\r\n            if (textureName) {\r\n                const textureInfo = this._webgpuProcessingContext.availableTextures[textureName];\r\n                if (textureInfo) {\r\n                    textureInfo.autoBindSampler = true;\r\n                }\r\n            }\r\n\r\n            let samplerInfo = this._webgpuProcessingContext.availableSamplers[name];\r\n            if (!samplerInfo) {\r\n                samplerInfo = {\r\n                    binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n                    type: samplerBindingType,\r\n                };\r\n                this._webgpuProcessingContext.availableSamplers[name] = samplerInfo;\r\n            }\r\n\r\n            this._addSamplerBindingDescription(name, samplerInfo, isVertex);\r\n\r\n            const part1 = code.substring(0, match.index);\r\n            const insertPart = `@group(${samplerInfo.binding.groupIndex}) @binding(${samplerInfo.binding.bindingIndex}) `;\r\n            const part2 = code.substring(match.index);\r\n\r\n            code = part1 + insertPart + part2;\r\n\r\n            samplerRegexp.lastIndex += insertPart.length;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _processCustomBuffers(code: string, isVertex: boolean): string {\r\n        const instantiateBufferRegexp = /var<\\s*(uniform|storage)\\s*(,\\s*(read|read_write)\\s*)?>\\s+(\\S+)\\s*:\\s*(\\S+)\\s*;/gm;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const match = instantiateBufferRegexp.exec(code);\r\n            if (match === null) {\r\n                break;\r\n            }\r\n\r\n            const type = match[1];\r\n            const decoration = match[3];\r\n            let name = match[4];\r\n            const structName = match[5];\r\n\r\n            let bufferInfo = this._webgpuProcessingContext.availableBuffers[name];\r\n            if (!bufferInfo) {\r\n                const knownUBO = type === \"uniform\" ? WebGPUShaderProcessingContext.KnownUBOs[structName] : null;\r\n\r\n                let binding;\r\n                if (knownUBO) {\r\n                    name = structName;\r\n                    binding = knownUBO.binding;\r\n                    if (binding.groupIndex === -1) {\r\n                        binding = this._webgpuProcessingContext.availableBuffers[name]?.binding;\r\n                        if (!binding) {\r\n                            binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                        }\r\n                    }\r\n                } else {\r\n                    binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                }\r\n\r\n                bufferInfo = { binding };\r\n                this._webgpuProcessingContext.availableBuffers[name] = bufferInfo;\r\n            }\r\n\r\n            this._addBufferBindingDescription(\r\n                name,\r\n                this._webgpuProcessingContext.availableBuffers[name],\r\n                decoration === \"read_write\"\r\n                    ? WebGPUConstants.BufferBindingType.Storage\r\n                    : type === \"storage\"\r\n                      ? WebGPUConstants.BufferBindingType.ReadOnlyStorage\r\n                      : WebGPUConstants.BufferBindingType.Uniform,\r\n                isVertex\r\n            );\r\n\r\n            const groupIndex = bufferInfo.binding.groupIndex;\r\n            const bindingIndex = bufferInfo.binding.bindingIndex;\r\n\r\n            const part1 = code.substring(0, match.index);\r\n            const insertPart = `@group(${groupIndex}) @binding(${bindingIndex}) `;\r\n            const part2 = code.substring(match.index);\r\n\r\n            code = part1 + insertPart + part2;\r\n\r\n            instantiateBufferRegexp.lastIndex += insertPart.length;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _processStridedUniformArrays(code: string): string {\r\n        for (const uniformArrayName of this._stridedUniformArrays) {\r\n            code = code.replace(new RegExp(`${uniformArrayName}\\\\s*\\\\[(.*?)\\\\]`, \"g\"), `${uniformArrayName}[$1].el`);\r\n        }\r\n        return code;\r\n    }\r\n}\r\n", "/* eslint-disable jsdoc/require-jsdoc */\r\n/* eslint-disable babylonjs/available */\r\nimport type { IHardwareTextureWrapper } from \"../../Materials/Textures/hardwareTextureWrapper\";\r\nimport { ILog2 } from \"../../Maths/math.scalar.functions\";\r\nimport type { Nullable } from \"../../types\";\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\n\r\n/** @internal */\r\nexport class WebGPUHardwareTexture implements IHardwareTextureWrapper {\r\n    /**\r\n     * Cache of RenderPassDescriptor and BindGroup used when generating mipmaps (see WebGPUTextureHelper.generateMipmaps)\r\n     * @internal\r\n     */\r\n    public _mipmapGenRenderPassDescr: GPURenderPassDescriptor[][];\r\n    /** @internal */\r\n    public _mipmapGenBindGroup: GPUBindGroup[][];\r\n\r\n    /**\r\n     * Cache for the invertYPreMultiplyAlpha function (see WebGPUTextureHelper)\r\n     * @internal\r\n     */\r\n    public _copyInvertYTempTexture?: GPUTexture;\r\n    /** @internal */\r\n    public _copyInvertYRenderPassDescr: GPURenderPassDescriptor;\r\n    /** @internal */\r\n    public _copyInvertYBindGroup: GPUBindGroup;\r\n    /** @internal */\r\n    public _copyInvertYBindGroupWithOfst: GPUBindGroup;\r\n\r\n    /** @internal */\r\n    public _originalFormatIsRGB = false;\r\n\r\n    private _webgpuTexture: Nullable<GPUTexture>;\r\n    // There can be multiple MSAA textures for a single WebGPU texture because different layers of a 2DArrayTexture / 3DTexture\r\n    // or different faces of a cube texture can be bound to different render targets at the same time (in a multi RenderTargetWrapper)\r\n    private _webgpuMSAATexture: Nullable<GPUTexture[]>;\r\n\r\n    public get underlyingResource(): Nullable<GPUTexture> {\r\n        return this._webgpuTexture;\r\n    }\r\n\r\n    public getMSAATexture(index: number): Nullable<GPUTexture> {\r\n        return this._webgpuMSAATexture?.[index] ?? null;\r\n    }\r\n\r\n    public setMSAATexture(texture: GPUTexture, index: number) {\r\n        if (!this._webgpuMSAATexture) {\r\n            this._webgpuMSAATexture = [];\r\n        }\r\n\r\n        this._webgpuMSAATexture[index] = texture;\r\n    }\r\n\r\n    public releaseMSAATexture(index?: number): void {\r\n        if (this._webgpuMSAATexture) {\r\n            if (index !== undefined) {\r\n                this._engine._textureHelper.releaseTexture(this._webgpuMSAATexture[index]);\r\n                delete this._webgpuMSAATexture[index];\r\n            } else {\r\n                for (const texture of this._webgpuMSAATexture) {\r\n                    this._engine._textureHelper.releaseTexture(texture);\r\n                }\r\n                this._webgpuMSAATexture = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public view: Nullable<GPUTextureView>;\r\n    public viewForWriting: Nullable<GPUTextureView>;\r\n    public format: GPUTextureFormat = WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n    public textureUsages = 0;\r\n    public textureAdditionalUsages = 0;\r\n\r\n    constructor(\r\n        private _engine: WebGPUEngine,\r\n        existingTexture: Nullable<GPUTexture> = null\r\n    ) {\r\n        this._webgpuTexture = existingTexture;\r\n        this._webgpuMSAATexture = null;\r\n        this.view = null;\r\n        this.viewForWriting = null;\r\n    }\r\n\r\n    public set(hardwareTexture: GPUTexture): void {\r\n        this._webgpuTexture = hardwareTexture;\r\n    }\r\n\r\n    public setUsage(_textureSource: number, generateMipMaps: boolean, is2DArray: boolean, isCube: boolean, is3D: boolean, width: number, height: number, depth: number): void {\r\n        let viewDimension: GPUTextureViewDimension = WebGPUConstants.TextureViewDimension.E2d;\r\n        let arrayLayerCount = 1;\r\n        if (isCube) {\r\n            viewDimension = is2DArray ? WebGPUConstants.TextureViewDimension.CubeArray : WebGPUConstants.TextureViewDimension.Cube;\r\n            arrayLayerCount = 6 * (depth || 1);\r\n        } else if (is3D) {\r\n            viewDimension = WebGPUConstants.TextureViewDimension.E3d;\r\n            arrayLayerCount = 1;\r\n        } else if (is2DArray) {\r\n            viewDimension = WebGPUConstants.TextureViewDimension.E2dArray;\r\n            arrayLayerCount = depth;\r\n        }\r\n\r\n        const format = WebGPUTextureHelper.GetDepthFormatOnly(this.format);\r\n        const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(this.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All;\r\n\r\n        this.createView({\r\n            label: `TextureView${is3D ? \"3D\" : isCube ? \"Cube\" : \"2D\"}${is2DArray ? \"_Array\" + arrayLayerCount : \"\"}_${width}x${height}_${generateMipMaps ? \"wmips\" : \"womips\"}_${\r\n                this.format\r\n            }_${viewDimension}`,\r\n            format,\r\n            dimension: viewDimension,\r\n            mipLevelCount: generateMipMaps ? ILog2(Math.max(width, height)) + 1 : 1,\r\n            baseArrayLayer: 0,\r\n            baseMipLevel: 0,\r\n            arrayLayerCount,\r\n            aspect,\r\n        });\r\n    }\r\n\r\n    public createView(descriptor?: GPUTextureViewDescriptor, createViewForWriting = false): void {\r\n        this.view = this._webgpuTexture!.createView(descriptor);\r\n        if (createViewForWriting && descriptor) {\r\n            const saveNumMipMaps = descriptor.mipLevelCount;\r\n            descriptor.mipLevelCount = 1;\r\n            this.viewForWriting = this._webgpuTexture!.createView(descriptor);\r\n            descriptor.mipLevelCount = saveNumMipMaps;\r\n        }\r\n    }\r\n\r\n    public reset(): void {\r\n        this._webgpuTexture = null;\r\n        this._webgpuMSAATexture = null;\r\n        this.view = null;\r\n        this.viewForWriting = null;\r\n    }\r\n\r\n    public release(): void {\r\n        this._webgpuTexture?.destroy();\r\n        this.releaseMSAATexture();\r\n        this._copyInvertYTempTexture?.destroy();\r\n        this.reset();\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\n// License for the mipmap generation code:\r\n//\r\n// Copyright 2020 Brandon Jones\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport { Constants } from \"../constants\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { IHardwareTextureWrapper } from \"../../Materials/Textures/hardwareTextureWrapper\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\nimport type { _IProcessingOptions } from \"../Processors/shaderProcessingOptions\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { Finalize, Initialize, Process } from \"../Processors/shaderProcessor\";\r\nimport type { WebGPUShaderProcessorWGSL } from \"./webgpuShaderProcessorsWGSL\";\r\n\r\n// TODO WEBGPU improve mipmap generation by using compute shaders\r\n\r\nconst mipmapVertexSource = `\r\n    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));\r\n    const tex = array<vec2<f32>, 4>( vec2f(0.0f, 0.0f),  vec2f(1.0f, 0.0f),  vec2f(0.0f, 1.0f),  vec2f(1.0f, 1.0f));\r\n\r\n    varying vTex: vec2f;\r\n\r\n    @vertex\r\n    fn main(input : VertexInputs) -> FragmentInputs {\r\n        vertexOutputs.vTex = tex[input.vertexIndex];\r\n        vertexOutputs.position = vec4f(pos[input.vertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst mipmapFragmentSource = `\r\n    var imgSampler: sampler;\r\n    var img: texture_2d<f32>;\r\n\r\n    varying vTex: vec2f;\r\n\r\n    @fragment\r\n    fn main(input: FragmentInputs) -> FragmentOutputs {\r\n        fragmentOutputs.color = textureSample(img, imgSampler, input.vTex);\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaVertexSource = `\r\n    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));\r\n    const tex = array<vec2<f32>, 4>( vec2f(0.0f, 0.0f),  vec2f(1.0f, 0.0f),  vec2f(0.0f, 1.0f),  vec2f(1.0f, 1.0f));\r\n\r\n    var img: texture_2d<f32>;\r\n\r\n    #ifdef INVERTY\r\n        varying vTextureSize: vec2f;\r\n    #endif\r\n\r\n    @vertex\r\n    fn main(input : VertexInputs) -> FragmentInputs {\r\n        #ifdef INVERTY\r\n            vertexOutputs.vTextureSize = vec2f(textureDimensions(img, 0));\r\n        #endif\r\n        vertexOutputs.position =  vec4f(pos[input.vertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaFragmentSource = `\r\n    var img: texture_2d<f32>;\r\n\r\n    #ifdef INVERTY\r\n        varying vTextureSize: vec2f;\r\n    #endif\r\n\r\n    @fragment\r\n    fn main(input: FragmentInputs) -> FragmentOutputs {\r\n    #ifdef INVERTY\r\n        var color: vec4f = textureLoad(img, vec2i(i32(input.position.x), i32(input.vTextureSize.y - input.position.y)), 0);\r\n    #else\r\n        var color: vec4f = textureLoad(img, vec2i(input.position.xy), 0);\r\n    #endif\r\n    #ifdef PREMULTIPLYALPHA\r\n        color = vec4f(color.rgb * color.a, color.a);\r\n    #endif\r\n        fragmentOutputs.color = color;\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaWithOfstVertexSource = invertYPreMultiplyAlphaVertexSource;\r\n\r\nconst invertYPreMultiplyAlphaWithOfstFragmentSource = `\r\n    var img: texture_2d<f32>;\r\n    uniform ofstX: f32;\r\n    uniform ofstY: f32;\r\n    uniform width: f32;\r\n    uniform height: f32;\r\n\r\n    #ifdef INVERTY\r\n        varying vTextureSize: vec2f;\r\n    #endif\r\n\r\n    @fragment\r\n    fn main(input: FragmentInputs) -> FragmentOutputs {\r\n        if (input.position.x < uniforms.ofstX || input.position.x >= uniforms.ofstX + uniforms.width) {\r\n            discard;\r\n        }\r\n        if (input.position.y < uniforms.ofstY || input.position.y >= uniforms.ofstY + uniforms.height) {\r\n            discard;\r\n        }\r\n    #ifdef INVERTY\r\n        var color: vec4f = textureLoad(img, vec2i(i32(input.position.x), i32(uniforms.ofstY + uniforms.height - (input.position.y - uniforms.ofstY))), 0);\r\n    #else\r\n        var color: vec4f = textureLoad(img, vec2i(input.position.xy), 0);\r\n    #endif\r\n    #ifdef PREMULTIPLYALPHA\r\n        color = vec4f(color.rgb * color.a, color.a);\r\n    #endif\r\n        fragmentOutputs.color = color;\r\n    }\r\n    `;\r\n\r\nconst clearVertexSource = `\r\n    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));\r\n\r\n    @vertex\r\n    fn main(input : VertexInputs) -> FragmentInputs {\r\n        vertexOutputs.position =  vec4f(pos[input.vertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst clearFragmentSource = `\r\n    uniform color: vec4f;\r\n\r\n    @fragment\r\n    fn main(input: FragmentInputs) -> FragmentOutputs {\r\n        fragmentOutputs.color = uniforms.color;\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureVertexSource = `\r\n    struct VertexOutput {\r\n        @builtin(position) Position : vec4<f32>,\r\n        @location(0) fragUV : vec2<f32>\r\n    }\r\n\r\n    @vertex\r\n    fn main(\r\n        @builtin(vertex_index) VertexIndex : u32\r\n    ) -> VertexOutput {\r\n        var pos = array<vec2<f32>, 4>(\r\n            vec2(-1.0,  1.0),\r\n            vec2( 1.0,  1.0),\r\n            vec2(-1.0, -1.0),\r\n            vec2( 1.0, -1.0)\r\n        );\r\n        var tex = array<vec2<f32>, 4>(\r\n            vec2(0.0, 0.0),\r\n            vec2(1.0, 0.0),\r\n            vec2(0.0, 1.0),\r\n            vec2(1.0, 1.0)\r\n        );\r\n\r\n        var output: VertexOutput;\r\n\r\n        output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\r\n        output.fragUV = tex[VertexIndex];\r\n\r\n        return output;\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureFragmentSource = `\r\n    @group(0) @binding(0) var videoSampler: sampler;\r\n    @group(0) @binding(1) var videoTexture: texture_external;\r\n\r\n    @fragment\r\n    fn main(\r\n        @location(0) fragUV: vec2<f32>\r\n    ) -> @location(0) vec4<f32> {\r\n        return textureSampleBaseClampToEdge(videoTexture, videoSampler, fragUV);\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureInvertYFragmentSource = `\r\n    @group(0) @binding(0) var videoSampler: sampler;\r\n    @group(0) @binding(1) var videoTexture: texture_external;\r\n\r\n    @fragment\r\n    fn main(\r\n        @location(0) fragUV: vec2<f32>\r\n    ) -> @location(0) vec4<f32> {\r\n        return textureSampleBaseClampToEdge(videoTexture, videoSampler, vec2<f32>(fragUV.x, 1.0 - fragUV.y));\r\n    }\r\n    `;\r\n\r\nconst resolveDepthVertexSource = `\r\n    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));\r\n\r\n    @vertex\r\n    fn main(input : VertexInputs) -> FragmentInputs {\r\n        vertexOutputs.position = vec4f(pos[input.vertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst resolveDepthFragmentSource = `\r\n    var msaaDepthTexture: texture_depth_multisampled_2d;\r\n\r\n    @fragment\r\n    fn main(input: FragmentInputs) -> FragmentOutputs {\r\n    #ifdef USE_MIN\r\n        let numSamples = textureNumSamples(msaaDepthTexture);\r\n        var depth = 1.0;\r\n\r\n        for (var i = 0u; i < numSamples; i = i + 1u) {\r\n            depth = min(depth, textureLoad(msaaDepthTexture, vec2u(input.position.xy), i));\r\n        }\r\n        \r\n        fragmentOutputs.color = vec4f(depth);\r\n    #else\r\n        fragmentOutputs.color = vec4f(textureLoad(msaaDepthTexture, vec2u(input.position.xy), 0)); // do like WebGL, take the first sample\r\n    #endif\r\n    }\r\n    `;\r\n\r\nenum PipelineType {\r\n    MipMap = 0,\r\n    InvertYPremultiplyAlpha = 1,\r\n    Clear = 2,\r\n    InvertYPremultiplyAlphaWithOfst = 3,\r\n    ResolveDepth = 4,\r\n}\r\n\r\nenum VideoPipelineType {\r\n    DontInvertY = 0,\r\n    InvertY = 1,\r\n}\r\n\r\ninterface IPipelineParameters {\r\n    invertY?: boolean;\r\n    premultiplyAlpha?: boolean;\r\n}\r\n\r\nconst shadersForPipelineType = [\r\n    { vertex: mipmapVertexSource, fragment: mipmapFragmentSource },\r\n    { vertex: invertYPreMultiplyAlphaVertexSource, fragment: invertYPreMultiplyAlphaFragmentSource },\r\n    { vertex: clearVertexSource, fragment: clearFragmentSource },\r\n    { vertex: invertYPreMultiplyAlphaWithOfstVertexSource, fragment: invertYPreMultiplyAlphaWithOfstFragmentSource },\r\n    { vertex: resolveDepthVertexSource, fragment: resolveDepthFragmentSource },\r\n];\r\n\r\n/**\r\n * Map a (renderable) texture format (GPUTextureFormat) to an index for fast lookup (in caches for eg)\r\n * The number of entries should not go over 64! Else, the code in WebGPUCacheRenderPipeline.setMRT should be updated\r\n */\r\nexport const renderableTextureFormatToIndex: { [name: string]: number } = {\r\n    \"\": 0,\r\n    r8unorm: 1,\r\n    r8uint: 2,\r\n    r8sint: 3,\r\n\r\n    r16uint: 4,\r\n    r16sint: 5,\r\n    r16float: 6,\r\n    rg8unorm: 7,\r\n    rg8uint: 8,\r\n    rg8sint: 9,\r\n\r\n    r32uint: 10,\r\n    r32sint: 11,\r\n    r32float: 12,\r\n    rg16uint: 13,\r\n    rg16sint: 14,\r\n    rg16float: 15,\r\n    rgba8unorm: 16,\r\n    \"rgba8unorm-srgb\": 17,\r\n    rgba8uint: 18,\r\n    rgba8sint: 19,\r\n    bgra8unorm: 20,\r\n    \"bgra8unorm-srgb\": 21,\r\n\r\n    rgb10a2uint: 22,\r\n    rgb10a2unorm: 23,\r\n    /* rg11b10ufloat: this entry is dynamically added if the \"RG11B10UFloatRenderable\" extension is supported */\r\n\r\n    rg32uint: 24,\r\n    rg32sint: 25,\r\n    rg32float: 26,\r\n    rgba16uint: 27,\r\n    rgba16sint: 28,\r\n    rgba16float: 29,\r\n\r\n    rgba32uint: 30,\r\n    rgba32sint: 31,\r\n    rgba32float: 32,\r\n\r\n    stencil8: 33,\r\n    depth16unorm: 34,\r\n    depth24plus: 35,\r\n    \"depth24plus-stencil8\": 36,\r\n    depth32float: 37,\r\n\r\n    \"depth32float-stencil8\": 38,\r\n\r\n    r16unorm: 39,\r\n    rg16unorm: 40,\r\n    rgba16unorm: 41,\r\n    r16snorm: 42,\r\n    rg16snorm: 43,\r\n    rgba16snorm: 44,\r\n};\r\n\r\n/** @internal */\r\nexport class WebGPUTextureManager {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _bufferManager: WebGPUBufferManager;\r\n    private _mipmapSampler: GPUSampler;\r\n    private _videoSampler: GPUSampler;\r\n    private _ubCopyWithOfst: GPUBuffer;\r\n    private _pipelines: { [format: string]: Array<[GPURenderPipeline, GPUBindGroupLayout]> } = {};\r\n    private _compiledShaders: GPUShaderModule[][] = [];\r\n    private _videoPipelines: { [format: string]: Array<[GPURenderPipeline, GPUBindGroupLayout]> } = {};\r\n    private _videoCompiledShaders: GPUShaderModule[][] = [];\r\n    private _deferredReleaseTextures: Array<[Nullable<IHardwareTextureWrapper | GPUTexture>, Nullable<BaseTexture>]> = [];\r\n    private _commandEncoderForCreation: GPUCommandEncoder;\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                         Initialization / Helpers\r\n    //------------------------------------------------------------------------------\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice, bufferManager: WebGPUBufferManager, enabledExtensions: GPUFeatureName[]) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n        this._bufferManager = bufferManager;\r\n\r\n        if (enabledExtensions.indexOf(WebGPUConstants.FeatureName.RG11B10UFloatRenderable) !== -1) {\r\n            const keys = Object.keys(renderableTextureFormatToIndex);\r\n            renderableTextureFormatToIndex[WebGPUConstants.TextureFormat.RG11B10UFloat] = renderableTextureFormatToIndex[keys[keys.length - 1]] + 1;\r\n        }\r\n\r\n        this._mipmapSampler = device.createSampler({ minFilter: WebGPUConstants.FilterMode.Linear });\r\n        this._videoSampler = device.createSampler({ minFilter: WebGPUConstants.FilterMode.Linear });\r\n        this._ubCopyWithOfst = this._bufferManager.createBuffer(\r\n            4 * 4,\r\n            WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst,\r\n            \"UBCopyWithOffset\"\r\n        ).underlyingResource;\r\n\r\n        this._getPipeline(WebGPUConstants.TextureFormat.RGBA8Unorm);\r\n        this._getVideoPipeline(WebGPUConstants.TextureFormat.RGBA8Unorm);\r\n    }\r\n\r\n    private _getPipeline(format: GPUTextureFormat, type: PipelineType = PipelineType.MipMap, params?: IPipelineParameters): [GPURenderPipeline, GPUBindGroupLayout] {\r\n        const index =\r\n            type === PipelineType.MipMap\r\n                ? 1 << 0\r\n                : type === PipelineType.InvertYPremultiplyAlpha\r\n                  ? ((params!.invertY ? 1 : 0) << 1) + ((params!.premultiplyAlpha ? 1 : 0) << 2)\r\n                  : type === PipelineType.Clear\r\n                    ? 1 << 3\r\n                    : type === PipelineType.InvertYPremultiplyAlphaWithOfst\r\n                      ? ((params!.invertY ? 1 : 0) << 4) + ((params!.premultiplyAlpha ? 1 : 0) << 5)\r\n                      : type === PipelineType.ResolveDepth\r\n                        ? 1 << 6\r\n                        : 0;\r\n\r\n        if (!this._pipelines[format]) {\r\n            this._pipelines[format] = [];\r\n        }\r\n\r\n        let pipelineAndBGL = this._pipelines[format][index];\r\n        if (!pipelineAndBGL) {\r\n            let defines = \"\";\r\n            if (type === PipelineType.InvertYPremultiplyAlpha || type === PipelineType.InvertYPremultiplyAlphaWithOfst) {\r\n                if (params!.invertY) {\r\n                    defines += \"#define INVERTY\\n\";\r\n                }\r\n                if (params!.premultiplyAlpha) {\r\n                    defines += \"#define PREMULTIPLYALPHA\\n\";\r\n                }\r\n            }\r\n\r\n            let modules = this._compiledShaders[index];\r\n            if (!modules) {\r\n                let vertexCode = shadersForPipelineType[type].vertex;\r\n                let fragmentCode = shadersForPipelineType[type].fragment;\r\n\r\n                const processorOptions: _IProcessingOptions = {\r\n                    defines: defines.split(\"\\n\"),\r\n                    indexParameters: null,\r\n                    isFragment: false,\r\n                    shouldUseHighPrecisionShader: true,\r\n                    processor: this._engine._getShaderProcessor(ShaderLanguage.WGSL),\r\n                    supportsUniformBuffers: true,\r\n                    shadersRepository: \"\",\r\n                    includesShadersStore: {},\r\n                    version: (this._engine.version * 100).toString(),\r\n                    platformName: this._engine.shaderPlatformName,\r\n                    processingContext: this._engine._getShaderProcessingContext(ShaderLanguage.WGSL, true),\r\n                    isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n                    useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n                };\r\n\r\n                Initialize(processorOptions);\r\n\r\n                // Disable special additions not needed here\r\n                (processorOptions.processor as WebGPUShaderProcessorWGSL).pureMode = true;\r\n\r\n                Process(\r\n                    vertexCode,\r\n                    processorOptions,\r\n                    (migratedVertexCode) => {\r\n                        vertexCode = migratedVertexCode;\r\n                    },\r\n                    this._engine\r\n                );\r\n\r\n                processorOptions.isFragment = true;\r\n\r\n                Process(\r\n                    fragmentCode,\r\n                    processorOptions,\r\n                    (migratedFragmentCode) => {\r\n                        fragmentCode = migratedFragmentCode;\r\n                    },\r\n                    this._engine\r\n                );\r\n\r\n                const final = Finalize(vertexCode, fragmentCode, processorOptions);\r\n\r\n                // Restore\r\n                (processorOptions.processor as WebGPUShaderProcessorWGSL).pureMode = false;\r\n\r\n                const vertexModule = this._device.createShaderModule({\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_InternalVertexShader_${index}`,\r\n                    code: final.vertexCode,\r\n                });\r\n                const fragmentModule = this._device.createShaderModule({\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_InternalFragmentShader_${index}`,\r\n                    code: final.fragmentCode,\r\n                });\r\n                modules = this._compiledShaders[index] = [vertexModule, fragmentModule];\r\n            }\r\n\r\n            const pipeline = this._device.createRenderPipeline({\r\n                label: `BabylonWebGPUDevice${this._engine.uniqueId}_InternalPipeline_${format}_${index}`,\r\n                layout: WebGPUConstants.AutoLayoutMode.Auto,\r\n                vertex: {\r\n                    module: modules[0],\r\n                    entryPoint: \"main\",\r\n                },\r\n                fragment: {\r\n                    module: modules[1],\r\n                    entryPoint: \"main\",\r\n                    targets: [\r\n                        {\r\n                            format,\r\n                        },\r\n                    ],\r\n                },\r\n                primitive: {\r\n                    topology: WebGPUConstants.PrimitiveTopology.TriangleStrip,\r\n                    stripIndexFormat: WebGPUConstants.IndexFormat.Uint16,\r\n                },\r\n            });\r\n\r\n            pipelineAndBGL = this._pipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];\r\n        }\r\n\r\n        return pipelineAndBGL;\r\n    }\r\n\r\n    private _getVideoPipeline(format: GPUTextureFormat, type: VideoPipelineType = VideoPipelineType.DontInvertY): [GPURenderPipeline, GPUBindGroupLayout] {\r\n        const index = type === VideoPipelineType.InvertY ? 1 << 0 : 0;\r\n\r\n        if (!this._videoPipelines[format]) {\r\n            this._videoPipelines[format] = [];\r\n        }\r\n\r\n        let pipelineAndBGL = this._videoPipelines[format][index];\r\n        if (!pipelineAndBGL) {\r\n            let modules = this._videoCompiledShaders[index];\r\n            if (!modules) {\r\n                const vertexModule = this._device.createShaderModule({\r\n                    code: copyVideoToTextureVertexSource,\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_CopyVideoToTexture_VertexShader`,\r\n                });\r\n                const fragmentModule = this._device.createShaderModule({\r\n                    code: index === 0 ? copyVideoToTextureFragmentSource : copyVideoToTextureInvertYFragmentSource,\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_CopyVideoToTexture_FragmentShader_${index === 0 ? \"DontInvertY\" : \"InvertY\"}`,\r\n                });\r\n                modules = this._videoCompiledShaders[index] = [vertexModule, fragmentModule];\r\n            }\r\n\r\n            const pipeline = this._device.createRenderPipeline({\r\n                label: `BabylonWebGPUDevice${this._engine.uniqueId}_InternalVideoPipeline_${format}_${index === 0 ? \"DontInvertY\" : \"InvertY\"}`,\r\n                layout: WebGPUConstants.AutoLayoutMode.Auto,\r\n                vertex: {\r\n                    module: modules[0],\r\n                    entryPoint: \"main\",\r\n                },\r\n                fragment: {\r\n                    module: modules[1],\r\n                    entryPoint: \"main\",\r\n                    targets: [\r\n                        {\r\n                            format,\r\n                        },\r\n                    ],\r\n                },\r\n                primitive: {\r\n                    topology: WebGPUConstants.PrimitiveTopology.TriangleStrip,\r\n                    stripIndexFormat: WebGPUConstants.IndexFormat.Uint16,\r\n                },\r\n            });\r\n\r\n            pipelineAndBGL = this._videoPipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];\r\n        }\r\n\r\n        return pipelineAndBGL;\r\n    }\r\n\r\n    public setCommandEncoder(encoder: GPUCommandEncoder): void {\r\n        this._commandEncoderForCreation = encoder;\r\n    }\r\n\r\n    public copyVideoToTexture(video: ExternalTexture, texture: InternalTexture, format: GPUTextureFormat, invertY = false, commandEncoder?: GPUCommandEncoder): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getVideoPipeline(format, invertY ? VideoPipelineType.InvertY : VideoPipelineType.DontInvertY);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`copy video to texture - invertY=${invertY}`);\r\n\r\n        const webgpuHardwareTexture = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        const renderPassDescriptor: GPURenderPassDescriptor = {\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_copyVideoToTexture_${format}_${invertY ? \"InvertY\" : \"DontInvertY\"}${texture.label ? \"_\" + texture.label : \"\"}`,\r\n            colorAttachments: [\r\n                {\r\n                    view: webgpuHardwareTexture.underlyingResource!.createView({\r\n                        format,\r\n                        dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                        mipLevelCount: 1,\r\n                        baseArrayLayer: 0,\r\n                        baseMipLevel: 0,\r\n                        arrayLayerCount: 1,\r\n                        aspect: WebGPUConstants.TextureAspect.All,\r\n                    }),\r\n                    loadOp: WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ],\r\n        };\r\n        const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n        const descriptor: GPUBindGroupDescriptor = {\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: this._videoSampler,\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: this._device.importExternalTexture({\r\n                        source: video.underlyingResource,\r\n                    }),\r\n                },\r\n            ],\r\n        };\r\n\r\n        const bindGroup = this._device.createBindGroup(descriptor);\r\n\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.draw(4, 1, 0, 0);\r\n        passEncoder.end();\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public invertYPreMultiplyAlpha(\r\n        gpuOrHdwTexture: GPUTexture | WebGPUHardwareTexture,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        faceIndex = 0,\r\n        mipLevel = 0,\r\n        layers = 1,\r\n        ofstX = 0,\r\n        ofstY = 0,\r\n        rectWidth = 0,\r\n        rectHeight = 0,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        allowGPUOptimization?: boolean\r\n    ): void {\r\n        const useRect = rectWidth !== 0;\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getPipeline(format, useRect ? PipelineType.InvertYPremultiplyAlphaWithOfst : PipelineType.InvertYPremultiplyAlpha, {\r\n            invertY,\r\n            premultiplyAlpha,\r\n        });\r\n\r\n        faceIndex = Math.max(faceIndex, 0);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`internal process texture - invertY=${invertY} premultiplyAlpha=${premultiplyAlpha}`);\r\n\r\n        let gpuTexture: Nullable<GPUTexture>;\r\n        if (WebGPUTextureHelper.IsHardwareTexture(gpuOrHdwTexture)) {\r\n            gpuTexture = gpuOrHdwTexture.underlyingResource;\r\n            if (!(invertY && !premultiplyAlpha && layers === 1 && faceIndex === 0)) {\r\n                // we optimize only for the most likely case (invertY=true, premultiplyAlpha=false, layers=1, faceIndex=0) to avoid dealing with big caches\r\n                gpuOrHdwTexture = undefined as any;\r\n            }\r\n        } else {\r\n            gpuTexture = gpuOrHdwTexture;\r\n            gpuOrHdwTexture = undefined as any;\r\n        }\r\n        if (!gpuTexture) {\r\n            return;\r\n        }\r\n\r\n        if (useRect) {\r\n            this._bufferManager.setRawData(this._ubCopyWithOfst, 0, new Float32Array([ofstX, ofstY, rectWidth, rectHeight]), 0, 4 * 4);\r\n        }\r\n\r\n        const webgpuHardwareTexture = gpuOrHdwTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        const outputTexture =\r\n            webgpuHardwareTexture?._copyInvertYTempTexture ??\r\n            this.createTexture(\r\n                { width, height, layers: 1 },\r\n                false,\r\n                false,\r\n                false,\r\n                false,\r\n                false,\r\n                format,\r\n                1,\r\n                commandEncoder,\r\n                WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.TextureBinding,\r\n                undefined,\r\n                \"TempTextureForCopyWithInvertY\"\r\n            );\r\n\r\n        const renderPassDescriptor = webgpuHardwareTexture?._copyInvertYRenderPassDescr ?? {\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_invertYPreMultiplyAlpha_${format}_${invertY ? \"InvertY\" : \"DontInvertY\"}_${\r\n                premultiplyAlpha ? \"PremultiplyAlpha\" : \"DontPremultiplyAlpha\"\r\n            }`,\r\n            colorAttachments: [\r\n                {\r\n                    view: outputTexture.createView({\r\n                        format,\r\n                        dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                        baseMipLevel: 0,\r\n                        mipLevelCount: 1,\r\n                        arrayLayerCount: 1,\r\n                        baseArrayLayer: 0,\r\n                    }),\r\n                    loadOp: WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ],\r\n        };\r\n        const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n        let bindGroup = useRect ? webgpuHardwareTexture?._copyInvertYBindGroupWithOfst : webgpuHardwareTexture?._copyInvertYBindGroup;\r\n        if (!bindGroup) {\r\n            const descriptor: GPUBindGroupDescriptor = {\r\n                layout: bindGroupLayout,\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        resource: gpuTexture.createView({\r\n                            format,\r\n                            dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                            baseMipLevel: mipLevel,\r\n                            mipLevelCount: 1,\r\n                            arrayLayerCount: layers,\r\n                            baseArrayLayer: faceIndex,\r\n                        }),\r\n                    },\r\n                ],\r\n            };\r\n            if (useRect) {\r\n                descriptor.entries.push({\r\n                    binding: 1,\r\n                    resource: {\r\n                        buffer: this._ubCopyWithOfst,\r\n                    },\r\n                });\r\n            }\r\n            bindGroup = this._device.createBindGroup(descriptor);\r\n        }\r\n\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.draw(4, 1, 0, 0);\r\n        passEncoder.end();\r\n\r\n        commandEncoder!.copyTextureToTexture(\r\n            {\r\n                texture: outputTexture,\r\n            },\r\n            {\r\n                texture: gpuTexture,\r\n                mipLevel,\r\n                origin: {\r\n                    x: 0,\r\n                    y: 0,\r\n                    z: faceIndex,\r\n                },\r\n            },\r\n            {\r\n                width: rectWidth || width,\r\n                height: rectHeight || height,\r\n                depthOrArrayLayers: 1,\r\n            }\r\n        );\r\n\r\n        if (webgpuHardwareTexture) {\r\n            webgpuHardwareTexture._copyInvertYTempTexture = outputTexture;\r\n            webgpuHardwareTexture._copyInvertYRenderPassDescr = renderPassDescriptor;\r\n            if (useRect) {\r\n                webgpuHardwareTexture._copyInvertYBindGroupWithOfst = bindGroup;\r\n            } else {\r\n                webgpuHardwareTexture._copyInvertYBindGroup = bindGroup;\r\n            }\r\n        } else {\r\n            this._deferredReleaseTextures.push([outputTexture, null]);\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                               Creation\r\n    //------------------------------------------------------------------------------\r\n\r\n    public createTexture(\r\n        imageBitmap: ImageBitmap | { width: number; height: number; layers: number },\r\n        hasMipmaps = false,\r\n        generateMipmaps = false,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        is3D = false,\r\n        format: GPUTextureFormat = WebGPUConstants.TextureFormat.RGBA8Unorm,\r\n        sampleCount = 1,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        usage = -1,\r\n        additionalUsages = 0,\r\n        label?: string\r\n    ): GPUTexture {\r\n        sampleCount = WebGPUTextureHelper.GetSample(sampleCount);\r\n\r\n        const layerCount = (imageBitmap as any).layers || 1;\r\n        const textureSize = {\r\n            width: imageBitmap.width,\r\n            height: imageBitmap.height,\r\n            depthOrArrayLayers: layerCount,\r\n        };\r\n\r\n        const renderAttachmentFlag = renderableTextureFormatToIndex[format] ? WebGPUConstants.TextureUsage.RenderAttachment : 0;\r\n        const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);\r\n        const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(imageBitmap.width, imageBitmap.height) : 1;\r\n        const usages = usage >= 0 ? usage : WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.CopyDst | WebGPUConstants.TextureUsage.TextureBinding;\r\n\r\n        additionalUsages |= hasMipmaps && !isCompressedFormat ? WebGPUConstants.TextureUsage.CopySrc | renderAttachmentFlag : 0;\r\n\r\n        if (!isCompressedFormat && !is3D) {\r\n            // we don't know in advance if the texture will be updated with copyExternalImageToTexture (which requires to have those flags), so we need to force the flags all the times\r\n            additionalUsages |= renderAttachmentFlag | WebGPUConstants.TextureUsage.CopyDst;\r\n        }\r\n\r\n        const gpuTexture = this._device.createTexture({\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_Texture${is3D ? \"3D\" : \"2D\"}_${label ? label + \"_\" : \"\"}${textureSize.width}x${textureSize.height}x${\r\n                textureSize.depthOrArrayLayers\r\n            }_${hasMipmaps ? \"wmips\" : \"womips\"}_${format}_samples${sampleCount}`,\r\n            size: textureSize,\r\n            dimension: is3D ? WebGPUConstants.TextureDimension.E3d : WebGPUConstants.TextureDimension.E2d,\r\n            format,\r\n            usage: usages | additionalUsages,\r\n            sampleCount,\r\n            mipLevelCount,\r\n        });\r\n\r\n        if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\r\n            this.updateTexture(imageBitmap, gpuTexture, imageBitmap.width, imageBitmap.height, layerCount, format, 0, 0, invertY, premultiplyAlpha, 0, 0);\r\n\r\n            if (hasMipmaps && generateMipmaps) {\r\n                this.generateMipmaps(gpuTexture, format, mipLevelCount, 0, is3D, commandEncoder);\r\n            }\r\n        }\r\n\r\n        return gpuTexture;\r\n    }\r\n\r\n    public createCubeTexture(\r\n        imageBitmaps: ImageBitmap[] | { width: number; height: number },\r\n        hasMipmaps = false,\r\n        generateMipmaps = false,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        format: GPUTextureFormat = WebGPUConstants.TextureFormat.RGBA8Unorm,\r\n        sampleCount = 1,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        usage = -1,\r\n        additionalUsages = 0,\r\n        label?: string\r\n    ): GPUTexture {\r\n        sampleCount = WebGPUTextureHelper.GetSample(sampleCount);\r\n\r\n        const width = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].width : imageBitmaps.width;\r\n        const height = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].height : imageBitmaps.height;\r\n\r\n        const renderAttachmentFlag = renderableTextureFormatToIndex[format] ? WebGPUConstants.TextureUsage.RenderAttachment : 0;\r\n        const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);\r\n        const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;\r\n        const usages = usage >= 0 ? usage : WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.CopyDst | WebGPUConstants.TextureUsage.TextureBinding;\r\n\r\n        additionalUsages |= hasMipmaps && !isCompressedFormat ? WebGPUConstants.TextureUsage.CopySrc | renderAttachmentFlag : 0;\r\n\r\n        if (!isCompressedFormat) {\r\n            // we don't know in advance if the texture will be updated with copyExternalImageToTexture (which requires to have those flags), so we need to force the flags all the times\r\n            additionalUsages |= renderAttachmentFlag | WebGPUConstants.TextureUsage.CopyDst;\r\n        }\r\n\r\n        const gpuTexture = this._device.createTexture({\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureCube_${label ? label + \"_\" : \"\"}${width}x${height}x6_${\r\n                hasMipmaps ? \"wmips\" : \"womips\"\r\n            }_${format}_samples${sampleCount}`,\r\n            size: {\r\n                width,\r\n                height,\r\n                depthOrArrayLayers: 6,\r\n            },\r\n            dimension: WebGPUConstants.TextureDimension.E2d,\r\n            format,\r\n            usage: usages | additionalUsages,\r\n            sampleCount,\r\n            mipLevelCount,\r\n        });\r\n\r\n        if (WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps)) {\r\n            this.updateCubeTextures(imageBitmaps, gpuTexture, width, height, format, invertY, premultiplyAlpha, 0, 0);\r\n\r\n            if (hasMipmaps && generateMipmaps) {\r\n                this.generateCubeMipmaps(gpuTexture, format, mipLevelCount, commandEncoder);\r\n            }\r\n        }\r\n\r\n        return gpuTexture;\r\n    }\r\n\r\n    public generateCubeMipmaps(gpuTexture: GPUTexture | WebGPUHardwareTexture, format: GPUTextureFormat, mipLevelCount: number, commandEncoder?: GPUCommandEncoder): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`create cube mipmaps - ${mipLevelCount} levels`);\r\n\r\n        for (let f = 0; f < 6; ++f) {\r\n            this.generateMipmaps(gpuTexture, format, mipLevelCount, f, false, commandEncoder);\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public generateMipmaps(\r\n        gpuOrHdwTexture: GPUTexture | WebGPUHardwareTexture,\r\n        format: GPUTextureFormat,\r\n        mipLevelCount: number,\r\n        faceIndex = 0,\r\n        is3D = false,\r\n        commandEncoder?: GPUCommandEncoder\r\n    ): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getPipeline(format);\r\n\r\n        faceIndex = Math.max(faceIndex, 0);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`create mipmaps for face #${faceIndex} - ${mipLevelCount} levels`);\r\n\r\n        let gpuTexture: Nullable<GPUTexture>;\r\n        if (WebGPUTextureHelper.IsHardwareTexture(gpuOrHdwTexture)) {\r\n            gpuTexture = gpuOrHdwTexture.underlyingResource;\r\n            gpuOrHdwTexture._mipmapGenRenderPassDescr = gpuOrHdwTexture._mipmapGenRenderPassDescr || [];\r\n            gpuOrHdwTexture._mipmapGenBindGroup = gpuOrHdwTexture._mipmapGenBindGroup || [];\r\n        } else {\r\n            gpuTexture = gpuOrHdwTexture;\r\n            gpuOrHdwTexture = undefined as any;\r\n        }\r\n        if (!gpuTexture) {\r\n            return;\r\n        }\r\n\r\n        const webgpuHardwareTexture = gpuOrHdwTexture as Nullable<WebGPUHardwareTexture>;\r\n        for (let i = 1; i < mipLevelCount; ++i) {\r\n            const renderPassDescriptor = webgpuHardwareTexture?._mipmapGenRenderPassDescr[faceIndex]?.[i - 1] ?? {\r\n                label: `BabylonWebGPUDevice${this._engine.uniqueId}_generateMipmaps_${format}_faceIndex${faceIndex}_level${i}`,\r\n                colorAttachments: [\r\n                    {\r\n                        view: gpuTexture.createView({\r\n                            format,\r\n                            dimension: is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n                            baseMipLevel: i,\r\n                            mipLevelCount: 1,\r\n                            arrayLayerCount: 1,\r\n                            baseArrayLayer: faceIndex,\r\n                        }),\r\n                        loadOp: WebGPUConstants.LoadOp.Load,\r\n                        storeOp: WebGPUConstants.StoreOp.Store,\r\n                    },\r\n                ],\r\n            };\r\n            if (webgpuHardwareTexture) {\r\n                webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] = webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] || [];\r\n                webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex][i - 1] = renderPassDescriptor;\r\n            }\r\n            const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n            const bindGroup =\r\n                webgpuHardwareTexture?._mipmapGenBindGroup[faceIndex]?.[i - 1] ??\r\n                this._device.createBindGroup({\r\n                    layout: bindGroupLayout,\r\n                    entries: [\r\n                        {\r\n                            binding: 0,\r\n                            resource: gpuTexture.createView({\r\n                                format,\r\n                                dimension: is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n                                baseMipLevel: i - 1,\r\n                                mipLevelCount: 1,\r\n                                arrayLayerCount: 1,\r\n                                baseArrayLayer: faceIndex,\r\n                            }),\r\n                        },\r\n                        {\r\n                            binding: 1,\r\n                            resource: this._mipmapSampler,\r\n                        },\r\n                    ],\r\n                });\r\n            if (webgpuHardwareTexture) {\r\n                webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] = webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] || [];\r\n                webgpuHardwareTexture._mipmapGenBindGroup[faceIndex][i - 1] = bindGroup;\r\n            }\r\n\r\n            passEncoder.setPipeline(pipeline);\r\n            passEncoder.setBindGroup(0, bindGroup);\r\n            passEncoder.draw(4, 1, 0, 0);\r\n            passEncoder.end();\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public createGPUTextureForInternalTexture(\r\n        texture: InternalTexture,\r\n        width?: number,\r\n        height?: number,\r\n        depth?: number,\r\n        creationFlags?: number,\r\n        dontCreateMSAATexture?: boolean\r\n    ): WebGPUHardwareTexture {\r\n        if (!texture._hardwareTexture) {\r\n            texture._hardwareTexture = new WebGPUHardwareTexture(this._engine);\r\n        }\r\n\r\n        if (width === undefined) {\r\n            width = texture.width;\r\n        }\r\n        if (height === undefined) {\r\n            height = texture.height;\r\n        }\r\n        if (depth === undefined) {\r\n            depth = texture.depth;\r\n        }\r\n\r\n        texture.width = texture.baseWidth = width;\r\n        texture.height = texture.baseHeight = height;\r\n        texture.depth = texture.baseDepth = depth;\r\n\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const isStorageTexture = ((creationFlags ?? 0) & Constants.TEXTURE_CREATIONFLAG_STORAGE) !== 0;\r\n\r\n        gpuTextureWrapper.format = WebGPUTextureHelper.GetWebGPUTextureFormat(texture.type, texture.format, texture._useSRGBBuffer);\r\n\r\n        if (!dontCreateMSAATexture) {\r\n            this.createMSAATexture(texture, texture.samples);\r\n        }\r\n\r\n        if (texture.samples > 1) {\r\n            // In case of a MSAA texture, the current texture will be the \"resolve\" texture, which cannot have a depth format\r\n            switch (gpuTextureWrapper.format) {\r\n                case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n                    gpuTextureWrapper.format = WebGPUConstants.TextureFormat.R16Unorm;\r\n                    break;\r\n                case WebGPUConstants.TextureFormat.Depth24Plus:\r\n                case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                case WebGPUConstants.TextureFormat.Depth32Float:\r\n                case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n                    gpuTextureWrapper.format = WebGPUConstants.TextureFormat.R32Float;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        gpuTextureWrapper.textureUsages =\r\n            texture._source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget\r\n                ? WebGPUConstants.TextureUsage.TextureBinding | WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment\r\n                : texture._source === InternalTextureSource.DepthStencil\r\n                  ? WebGPUConstants.TextureUsage.TextureBinding | WebGPUConstants.TextureUsage.RenderAttachment\r\n                  : -1;\r\n\r\n        gpuTextureWrapper.textureAdditionalUsages = isStorageTexture ? WebGPUConstants.TextureUsage.StorageBinding : 0;\r\n\r\n        const hasMipMaps = texture.generateMipMaps;\r\n        const layerCount = depth || 1;\r\n        let mipmapCount;\r\n        if (texture._maxLodLevel !== null) {\r\n            mipmapCount = texture._maxLodLevel;\r\n        } else {\r\n            mipmapCount = hasMipMaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;\r\n        }\r\n\r\n        if (texture.isCube) {\r\n            const gpuTexture = this.createCubeTexture(\r\n                { width, height },\r\n                texture.generateMipMaps,\r\n                texture.generateMipMaps,\r\n                texture.invertY,\r\n                false,\r\n                gpuTextureWrapper.format,\r\n                1,\r\n                this._commandEncoderForCreation,\r\n                gpuTextureWrapper.textureUsages,\r\n                gpuTextureWrapper.textureAdditionalUsages,\r\n                texture.label\r\n            );\r\n\r\n            gpuTextureWrapper.set(gpuTexture);\r\n\r\n            const arrayLayerCount = texture.is3D ? 1 : layerCount;\r\n            const format = WebGPUTextureHelper.GetDepthFormatOnly(gpuTextureWrapper.format);\r\n            const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All;\r\n            const dimension = texture.is2DArray ? WebGPUConstants.TextureViewDimension.CubeArray : WebGPUConstants.TextureViewDimension.Cube;\r\n\r\n            gpuTextureWrapper.createView(\r\n                {\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureViewCube${texture.is2DArray ? \"_Array\" + arrayLayerCount : \"\"}_${width}x${height}_${\r\n                        hasMipMaps ? \"wmips\" : \"womips\"\r\n                    }_${format}_${dimension}_${aspect}_${texture.label ?? \"noname\"}`,\r\n                    format,\r\n                    dimension,\r\n                    mipLevelCount: mipmapCount,\r\n                    baseArrayLayer: 0,\r\n                    baseMipLevel: 0,\r\n                    arrayLayerCount: 6,\r\n                    aspect,\r\n                },\r\n                isStorageTexture\r\n            );\r\n        } else {\r\n            const gpuTexture = this.createTexture(\r\n                { width, height, layers: layerCount },\r\n                texture.generateMipMaps,\r\n                texture.generateMipMaps,\r\n                texture.invertY,\r\n                false,\r\n                texture.is3D,\r\n                gpuTextureWrapper.format,\r\n                1,\r\n                this._commandEncoderForCreation,\r\n                gpuTextureWrapper.textureUsages,\r\n                gpuTextureWrapper.textureAdditionalUsages,\r\n                texture.label\r\n            );\r\n\r\n            gpuTextureWrapper.set(gpuTexture);\r\n\r\n            const arrayLayerCount = texture.is3D ? 1 : layerCount;\r\n            const format = WebGPUTextureHelper.GetDepthFormatOnly(gpuTextureWrapper.format);\r\n            const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All;\r\n            const dimension = texture.is2DArray\r\n                ? WebGPUConstants.TextureViewDimension.E2dArray\r\n                : texture.is3D\r\n                  ? WebGPUConstants.TextureDimension.E3d\r\n                  : WebGPUConstants.TextureViewDimension.E2d;\r\n\r\n            gpuTextureWrapper.createView(\r\n                {\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureView${texture.is3D ? \"3D\" : \"2D\"}${\r\n                        texture.is2DArray ? \"_Array\" + arrayLayerCount : \"\"\r\n                    }_${width}x${height}${texture.is3D ? \"x\" + layerCount : \"\"}_${hasMipMaps ? \"wmips\" : \"womips\"}_${format}_${dimension}_${aspect}_${texture.label ?? \"noname\"}`,\r\n                    format,\r\n                    dimension,\r\n                    mipLevelCount: mipmapCount,\r\n                    baseArrayLayer: 0,\r\n                    baseMipLevel: 0,\r\n                    arrayLayerCount,\r\n                    aspect,\r\n                },\r\n                isStorageTexture\r\n            );\r\n        }\r\n\r\n        return gpuTextureWrapper;\r\n    }\r\n\r\n    public createMSAATexture(texture: InternalTexture, samples: number, releaseExisting = true, index = 0): void {\r\n        const gpuTextureWrapper = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (releaseExisting) {\r\n            gpuTextureWrapper?.releaseMSAATexture();\r\n        }\r\n\r\n        if (!gpuTextureWrapper || (samples ?? 1) <= 1) {\r\n            return;\r\n        }\r\n\r\n        const width = texture.width;\r\n        const height = texture.height;\r\n\r\n        const gpuMSAATexture = this.createTexture(\r\n            { width, height, layers: 1 },\r\n            false,\r\n            false,\r\n            false,\r\n            false,\r\n            false,\r\n            gpuTextureWrapper.format,\r\n            samples,\r\n            this._commandEncoderForCreation,\r\n            WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.TextureBinding,\r\n            0,\r\n            texture.label ? \"MSAA_\" + texture.label : \"MSAA\"\r\n        );\r\n        gpuTextureWrapper.setMSAATexture(gpuMSAATexture, index);\r\n    }\r\n\r\n    public resolveMSAADepthTexture(msaaTexture: GPUTexture, outputTexture: GPUTexture, commandEncoder?: GPUCommandEncoder): void {\r\n        const format = outputTexture.format;\r\n\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getPipeline(format, PipelineType.ResolveDepth);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup(`resolve MSAA Depth texture${msaaTexture.label ? \" - \" + msaaTexture.label : \"\"}`);\r\n\r\n        const renderPassDescriptor: GPURenderPassDescriptor = {\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_resolveMSAADepthTexture${msaaTexture.label ? \"_\" + msaaTexture.label : \"\"}`,\r\n            colorAttachments: [\r\n                {\r\n                    view: outputTexture,\r\n                    loadOp: WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ],\r\n        };\r\n        const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n        const descriptor: GPUBindGroupDescriptor = {\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: msaaTexture.createView({\r\n                        format: WebGPUTextureHelper.GetDepthFormatOnly(msaaTexture.format),\r\n                        dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                        mipLevelCount: 1,\r\n                        baseArrayLayer: 0,\r\n                        baseMipLevel: 0,\r\n                        arrayLayerCount: 1,\r\n                        aspect: WebGPUConstants.TextureAspect.DepthOnly,\r\n                    }),\r\n                },\r\n            ],\r\n        };\r\n\r\n        const bindGroup = this._device.createBindGroup(descriptor);\r\n\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.draw(4, 1, 0, 0);\r\n        passEncoder.end();\r\n\r\n        commandEncoder!.popDebugGroup();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                                  Update\r\n    //------------------------------------------------------------------------------\r\n\r\n    public updateCubeTextures(\r\n        imageBitmaps: ImageBitmap[] | Uint8Array[],\r\n        gpuTexture: GPUTexture,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        offsetX = 0,\r\n        offsetY = 0\r\n    ): void {\r\n        const faces = [0, 3, 1, 4, 2, 5];\r\n\r\n        for (let f = 0; f < faces.length; ++f) {\r\n            const imageBitmap = imageBitmaps[faces[f]];\r\n\r\n            this.updateTexture(imageBitmap, gpuTexture, width, height, 1, format, f, 0, invertY, premultiplyAlpha, offsetX, offsetY);\r\n        }\r\n    }\r\n\r\n    // TODO WEBGPU handle data source not being in the same format than the destination texture?\r\n    public updateTexture(\r\n        imageBitmap: ImageBitmap | Uint8Array | ImageData | HTMLImageElement | HTMLVideoElement | VideoFrame | HTMLCanvasElement | OffscreenCanvas,\r\n        texture: GPUTexture | InternalTexture,\r\n        width: number,\r\n        height: number,\r\n        layers: number,\r\n        format: GPUTextureFormat,\r\n        faceIndex: number = 0,\r\n        mipLevel: number = 0,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        offsetX = 0,\r\n        offsetY = 0,\r\n        allowGPUOptimization?: boolean\r\n    ): void {\r\n        const gpuTexture = WebGPUTextureHelper.IsInternalTexture(texture) ? (texture._hardwareTexture as WebGPUHardwareTexture).underlyingResource! : texture;\r\n        const blockInformation = WebGPUTextureHelper.GetBlockInformationFromFormat(format);\r\n        const gpuOrHdwTexture = WebGPUTextureHelper.IsInternalTexture(texture) ? (texture._hardwareTexture as WebGPUHardwareTexture) : texture;\r\n\r\n        const textureCopyView: GPUCopyExternalImageDestInfo = {\r\n            texture: gpuTexture,\r\n            origin: {\r\n                x: offsetX,\r\n                y: offsetY,\r\n                z: Math.max(faceIndex, 0),\r\n            },\r\n            mipLevel: mipLevel,\r\n            premultipliedAlpha: premultiplyAlpha,\r\n        };\r\n\r\n        const textureExtent = {\r\n            width: Math.ceil(width / blockInformation.width) * blockInformation.width,\r\n            height: Math.ceil(height / blockInformation.height) * blockInformation.height,\r\n            depthOrArrayLayers: layers || 1,\r\n        };\r\n\r\n        if ((imageBitmap as Uint8Array).byteLength !== undefined) {\r\n            imageBitmap = imageBitmap as Uint8Array;\r\n\r\n            const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\r\n            const aligned = Math.ceil(bytesPerRow / 256) * 256 === bytesPerRow;\r\n\r\n            if (aligned) {\r\n                const commandEncoder = this._device.createCommandEncoder({});\r\n\r\n                const buffer = this._bufferManager.createRawBuffer(\r\n                    imageBitmap.byteLength,\r\n                    WebGPUConstants.BufferUsage.MapWrite | WebGPUConstants.BufferUsage.CopySrc,\r\n                    true,\r\n                    \"TempBufferForUpdateTexture\" + (gpuTexture ? \"_\" + gpuTexture.label : \"\")\r\n                );\r\n\r\n                const arrayBuffer = buffer.getMappedRange();\r\n\r\n                new Uint8Array(arrayBuffer).set(imageBitmap);\r\n\r\n                buffer.unmap();\r\n\r\n                commandEncoder.copyBufferToTexture(\r\n                    {\r\n                        buffer: buffer,\r\n                        offset: 0,\r\n                        bytesPerRow,\r\n                        rowsPerImage: textureExtent.height / blockInformation.height,\r\n                    },\r\n                    textureCopyView,\r\n                    textureExtent\r\n                );\r\n\r\n                this._device.queue.submit([commandEncoder.finish()]);\r\n\r\n                this._bufferManager.releaseBuffer(buffer);\r\n            } else {\r\n                this._device.queue.writeTexture(\r\n                    textureCopyView,\r\n                    imageBitmap,\r\n                    {\r\n                        offset: 0,\r\n                        bytesPerRow,\r\n                        rowsPerImage: textureExtent.height / blockInformation.height,\r\n                    },\r\n                    textureExtent\r\n                );\r\n            }\r\n\r\n            if (invertY || premultiplyAlpha) {\r\n                if (WebGPUTextureHelper.IsInternalTexture(texture)) {\r\n                    const dontUseRect = offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height;\r\n                    this.invertYPreMultiplyAlpha(\r\n                        gpuOrHdwTexture,\r\n                        texture.width,\r\n                        texture.height,\r\n                        format,\r\n                        invertY,\r\n                        premultiplyAlpha,\r\n                        faceIndex,\r\n                        mipLevel,\r\n                        layers || 1,\r\n                        offsetX,\r\n                        offsetY,\r\n                        dontUseRect ? 0 : width,\r\n                        dontUseRect ? 0 : height,\r\n                        undefined,\r\n                        allowGPUOptimization\r\n                    );\r\n                } else {\r\n                    // we should never take this code path\r\n                    // eslint-disable-next-line no-throw-literal\r\n                    throw \"updateTexture: Can't process the texture data because a GPUTexture was provided instead of an InternalTexture!\";\r\n                }\r\n            }\r\n        } else {\r\n            imageBitmap = imageBitmap as ImageBitmap | ImageData | HTMLImageElement | HTMLVideoElement | VideoFrame | HTMLCanvasElement | OffscreenCanvas;\r\n            this._device.queue.copyExternalImageToTexture({ source: imageBitmap, flipY: invertY }, textureCopyView, textureExtent);\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n    public readPixels(\r\n        texture: GPUTexture,\r\n        x: number,\r\n        y: number,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        faceIndex: number = 0,\r\n        mipLevel: number = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        noDataConversion = false\r\n    ): Promise<ArrayBufferView> {\r\n        const blockInformation = WebGPUTextureHelper.GetBlockInformationFromFormat(format);\r\n\r\n        const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\r\n\r\n        const bytesPerRowAligned = Math.ceil(bytesPerRow / 256) * 256;\r\n\r\n        const size = bytesPerRowAligned * height;\r\n\r\n        const gpuBuffer = this._bufferManager.createRawBuffer(\r\n            size,\r\n            WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst,\r\n            undefined,\r\n            \"TempBufferForReadPixels\" + (texture.label ? \"_\" + texture.label : \"\")\r\n        );\r\n\r\n        const commandEncoder = this._device.createCommandEncoder({});\r\n\r\n        commandEncoder.copyTextureToBuffer(\r\n            {\r\n                texture,\r\n                mipLevel,\r\n                origin: {\r\n                    x,\r\n                    y,\r\n                    z: Math.max(faceIndex, 0),\r\n                },\r\n            },\r\n            {\r\n                buffer: gpuBuffer,\r\n                offset: 0,\r\n                bytesPerRow: bytesPerRowAligned,\r\n            },\r\n            {\r\n                width,\r\n                height,\r\n                depthOrArrayLayers: 1,\r\n            }\r\n        );\r\n\r\n        this._device.queue.submit([commandEncoder.finish()]);\r\n\r\n        return this._bufferManager.readDataFromBuffer(\r\n            gpuBuffer,\r\n            size,\r\n            width,\r\n            height,\r\n            bytesPerRow,\r\n            bytesPerRowAligned,\r\n            WebGPUTextureHelper.GetTextureTypeFromFormat(format),\r\n            0,\r\n            buffer,\r\n            true,\r\n            noDataConversion\r\n        );\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dispose\r\n    //------------------------------------------------------------------------------\r\n\r\n    public releaseTexture(texture: InternalTexture | GPUTexture): void {\r\n        if (WebGPUTextureHelper.IsInternalTexture(texture)) {\r\n            const hardwareTexture = texture._hardwareTexture;\r\n            const irradianceTexture = texture._irradianceTexture;\r\n\r\n            // We can't destroy the objects just now because they could be used in the current frame - we delay the destroying after the end of the frame\r\n            this._deferredReleaseTextures.push([hardwareTexture, irradianceTexture]);\r\n        } else {\r\n            this._deferredReleaseTextures.push([texture, null]);\r\n        }\r\n    }\r\n\r\n    public destroyDeferredTextures(): void {\r\n        for (let i = 0; i < this._deferredReleaseTextures.length; ++i) {\r\n            const [hardwareTexture, irradianceTexture] = this._deferredReleaseTextures[i];\r\n\r\n            if (hardwareTexture) {\r\n                if (WebGPUTextureHelper.IsHardwareTexture(hardwareTexture)) {\r\n                    hardwareTexture.release();\r\n                } else {\r\n                    hardwareTexture.destroy();\r\n                }\r\n            }\r\n            irradianceTexture?.dispose();\r\n        }\r\n\r\n        this._deferredReleaseTextures.length = 0;\r\n    }\r\n}\r\n", "import { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/** @internal */\r\nexport class WebGPUDataBuffer extends DataBuffer {\r\n    private _buffer: Nullable<GPUBuffer>;\r\n\r\n    // Used to make sure the buffer is not recreated twice after a context loss/restoration\r\n    public engineId = -1;\r\n\r\n    public set buffer(buffer: Nullable<GPUBuffer>) {\r\n        this._buffer = buffer;\r\n    }\r\n\r\n    public constructor(resource?: GPUBuffer, capacity = 0) {\r\n        super();\r\n        this.capacity = capacity;\r\n        if (resource) {\r\n            this._buffer = resource;\r\n        }\r\n    }\r\n\r\n    public override get underlyingResource(): any {\r\n        return this._buffer;\r\n    }\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\nimport type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport { FromHalfFloat } from \"../../Misc/textureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { allocateAndCopyTypedBuffer } from \"../abstractEngine.functions\";\r\nimport { Constants } from \"../constants\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\n\r\n/** @internal */\r\nexport class WebGPUBufferManager {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _deferredReleaseBuffers: Array<GPUBuffer> = [];\r\n\r\n    private static _IsGPUBuffer(buffer: DataBuffer | GPUBuffer): buffer is GPUBuffer {\r\n        return (buffer as DataBuffer).underlyingResource === undefined;\r\n    }\r\n\r\n    private static _FlagsToString(flags: GPUBufferUsageFlags, suffix = \"\") {\r\n        let result = suffix;\r\n\r\n        for (let i = 0; i <= 9; ++i) {\r\n            if (flags & (1 << i)) {\r\n                if (result) {\r\n                    result += \"_\";\r\n                }\r\n                result += WebGPUConstants.BufferUsage[1 << i];\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n    }\r\n\r\n    public createRawBuffer(viewOrSize: ArrayBufferView | number, flags: GPUBufferUsageFlags, mappedAtCreation = false, label?: string): GPUBuffer {\r\n        const alignedLength = (viewOrSize as ArrayBufferView).byteLength !== undefined ? ((viewOrSize as ArrayBufferView).byteLength + 3) & ~3 : ((viewOrSize as number) + 3) & ~3; // 4 bytes alignments (because of the upload which requires this)\r\n        const verticesBufferDescriptor = {\r\n            label: \"BabylonWebGPUDevice\" + this._engine.uniqueId + \"_\" + WebGPUBufferManager._FlagsToString(flags, label ?? \"Buffer\") + \"_size\" + alignedLength,\r\n            mappedAtCreation,\r\n            size: alignedLength,\r\n            usage: flags,\r\n        };\r\n\r\n        return this._device.createBuffer(verticesBufferDescriptor);\r\n    }\r\n\r\n    public createBuffer(viewOrSize: ArrayBufferView | number, flags: GPUBufferUsageFlags, label?: string): WebGPUDataBuffer {\r\n        const isView = (viewOrSize as ArrayBufferView).byteLength !== undefined;\r\n        const dataBuffer = new WebGPUDataBuffer();\r\n        const labelId = \"DataBufferUniqueId=\" + dataBuffer.uniqueId;\r\n        dataBuffer.buffer = this.createRawBuffer(viewOrSize, flags, undefined, label ? labelId + \"-\" + label : labelId);\r\n        dataBuffer.references = 1;\r\n        dataBuffer.capacity = isView ? (viewOrSize as ArrayBufferView).byteLength : (viewOrSize as number);\r\n        dataBuffer.engineId = this._engine.uniqueId;\r\n\r\n        if (isView) {\r\n            this.setSubData(dataBuffer, 0, viewOrSize as ArrayBufferView);\r\n        }\r\n\r\n        return dataBuffer;\r\n    }\r\n\r\n    // This calls GPUBuffer.writeBuffer() with no alignment corrections\r\n    // dstByteOffset and byteLength must both be aligned to 4 bytes and bytes moved must be within src and dst arrays\r\n    public setRawData(buffer: GPUBuffer, dstByteOffset: number, src: ArrayBufferView, srcByteOffset: number, byteLength: number): void {\r\n        srcByteOffset += src.byteOffset;\r\n\r\n        this._device.queue.writeBuffer(buffer, dstByteOffset, src.buffer, srcByteOffset, byteLength);\r\n    }\r\n\r\n    // This calls GPUBuffer.writeBuffer() with alignment corrections (dstByteOffset and byteLength will be aligned to 4 byte boundaries)\r\n    // If alignment is needed, src must be a full copy of dataBuffer, or at least should be large enough to cope with the additional bytes copied because of alignment!\r\n    public setSubData(dataBuffer: WebGPUDataBuffer, dstByteOffset: number, src: ArrayBufferView, srcByteOffset = 0, byteLength = 0): void {\r\n        const buffer = dataBuffer.underlyingResource as GPUBuffer;\r\n\r\n        byteLength = byteLength || src.byteLength - srcByteOffset;\r\n\r\n        // Make sure the dst offset is aligned to 4 bytes\r\n        const startPre = dstByteOffset & 3;\r\n\r\n        srcByteOffset -= startPre;\r\n        dstByteOffset -= startPre;\r\n\r\n        // Make sure the byte length is aligned to 4 bytes\r\n        const originalByteLength = byteLength;\r\n\r\n        byteLength = (byteLength + startPre + 3) & ~3;\r\n\r\n        // Check if the backing buffer of src is large enough to cope with the additional bytes copied because of alignment\r\n        const backingBufferSize = src.buffer.byteLength - src.byteOffset;\r\n\r\n        if (backingBufferSize < byteLength) {\r\n            // Not enough place in the backing buffer for the aligned copy.\r\n            // Creates a new buffer and copy the source data to it.\r\n            // The buffer will have byteLength - originalByteLength zeros at the end.\r\n            const tmpBuffer = new Uint8Array(byteLength);\r\n            tmpBuffer.set(new Uint8Array(src.buffer, src.byteOffset + srcByteOffset, originalByteLength));\r\n            src = tmpBuffer;\r\n            srcByteOffset = 0;\r\n        }\r\n\r\n        this.setRawData(buffer, dstByteOffset, src, srcByteOffset, byteLength);\r\n    }\r\n\r\n    private _getHalfFloatAsFloatRGBAArrayBuffer(dataLength: number, arrayBuffer: ArrayBuffer, destArray?: Float32Array): Float32Array {\r\n        if (!destArray) {\r\n            destArray = new Float32Array(dataLength);\r\n        } else {\r\n            dataLength = Math.min(dataLength, destArray.length);\r\n        }\r\n        const srcData = new Uint16Array(arrayBuffer);\r\n        while (dataLength--) {\r\n            destArray[dataLength] = FromHalfFloat(srcData[dataLength]);\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    public readDataFromBuffer(\r\n        gpuBuffer: GPUBuffer,\r\n        size: number,\r\n        width: number,\r\n        height: number,\r\n        bytesPerRow: number,\r\n        bytesPerRowAligned: number,\r\n        type = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        offset = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        destroyBuffer = true,\r\n        noDataConversion = false\r\n    ): Promise<ArrayBufferView> {\r\n        const floatFormat = type === Constants.TEXTURETYPE_FLOAT ? 2 : type === Constants.TEXTURETYPE_HALF_FLOAT ? 1 : 0;\r\n        const engineId = this._engine.uniqueId;\r\n        return new Promise((resolve, reject) => {\r\n            // eslint-disable-next-line github/no-then\r\n            gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, offset, size).then(\r\n                () => {\r\n                    const copyArrayBuffer = gpuBuffer.getMappedRange(offset, size);\r\n                    let data: Nullable<ArrayBufferView> | Uint8Array | Float32Array = buffer;\r\n                    if (noDataConversion) {\r\n                        if (data === null) {\r\n                            data = allocateAndCopyTypedBuffer(type, size, true, copyArrayBuffer);\r\n                        } else {\r\n                            data = allocateAndCopyTypedBuffer(type, data.buffer, undefined, copyArrayBuffer);\r\n                        }\r\n                    } else {\r\n                        if (data === null) {\r\n                            switch (floatFormat) {\r\n                                case 0: // byte format\r\n                                    data = new Uint8Array(size);\r\n                                    (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                                    break;\r\n                                case 1: // half float\r\n                                    // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\r\n                                    data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer);\r\n                                    break;\r\n                                case 2: // float\r\n                                    data = new Float32Array(size / 4);\r\n                                    (data as Float32Array).set(new Float32Array(copyArrayBuffer));\r\n                                    break;\r\n                            }\r\n                        } else {\r\n                            switch (floatFormat) {\r\n                                case 0: // byte format\r\n                                    data = new Uint8Array(data.buffer);\r\n                                    (data as Uint8Array).set(new Uint8Array(copyArrayBuffer, 0, Math.min(data.byteLength, size)));\r\n                                    break;\r\n                                case 1: // half float\r\n                                    // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\r\n                                    data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer, buffer as Float32Array);\r\n                                    break;\r\n                                case 2: // float\r\n                                    data = new Float32Array(data.buffer);\r\n                                    (data as Float32Array).set(new Float32Array(copyArrayBuffer, 0, data.byteLength / 4));\r\n                                    break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (bytesPerRow !== bytesPerRowAligned) {\r\n                        // TODO WEBGPU use computer shaders (or render pass) to build the final buffer data?\r\n                        if (floatFormat === 1 && !noDataConversion) {\r\n                            // half float have been converted to float above\r\n                            bytesPerRow *= 2;\r\n                            bytesPerRowAligned *= 2;\r\n                        }\r\n                        const data2 = new Uint8Array(data.buffer);\r\n                        let offset = bytesPerRow,\r\n                            offset2 = 0;\r\n                        for (let y = 1; y < height; ++y) {\r\n                            offset2 = y * bytesPerRowAligned;\r\n                            for (let x = 0; x < bytesPerRow; ++x) {\r\n                                data2[offset++] = data2[offset2++];\r\n                            }\r\n                        }\r\n                        if (floatFormat !== 0 && !noDataConversion) {\r\n                            data = new Float32Array(data2.buffer, 0, offset / 4);\r\n                        } else {\r\n                            data = new Uint8Array(data2.buffer, 0, offset);\r\n                        }\r\n                    }\r\n                    gpuBuffer.unmap();\r\n                    if (destroyBuffer) {\r\n                        this.releaseBuffer(gpuBuffer);\r\n                    }\r\n                    resolve(data);\r\n                },\r\n                (reason) => {\r\n                    if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {\r\n                        // The engine was disposed while waiting for the promise, or a context loss/restoration has occurred: don't reject\r\n                        resolve(new Uint8Array());\r\n                    } else {\r\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                        reject(reason);\r\n                    }\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    public releaseBuffer(buffer: DataBuffer | GPUBuffer): boolean {\r\n        if (WebGPUBufferManager._IsGPUBuffer(buffer)) {\r\n            this._deferredReleaseBuffers.push(buffer);\r\n            return true;\r\n        }\r\n\r\n        buffer.references--;\r\n\r\n        if (buffer.references === 0) {\r\n            this._deferredReleaseBuffers.push(buffer.underlyingResource as GPUBuffer);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public destroyDeferredBuffers(): void {\r\n        for (let i = 0; i < this._deferredReleaseBuffers.length; ++i) {\r\n            this._deferredReleaseBuffers[i].destroy();\r\n        }\r\n\r\n        this._deferredReleaseBuffers.length = 0;\r\n    }\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Constants } from \"../constants\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Note: we don't make a difference between mipmaps enabled or not when computing these bits (so, TEXTURE_NEAREST_NEAREST and TEXTURE_NEAREST_NEAREST_MIPNEAREST have the same bits, for example).\r\n * There's another bit in the hash code for that (see FilterNoMipToBits).\r\n */\r\nconst FilterToBits = [\r\n    0 | (0 << 1) | (0 << 2), // not used\r\n    0 | (0 << 1) | (0 << 2), // TEXTURE_NEAREST_SAMPLINGMODE / TEXTURE_NEAREST_NEAREST\r\n    1 | (1 << 1) | (0 << 2), // TEXTURE_BILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR\r\n    1 | (1 << 1) | (1 << 2), // TEXTURE_TRILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR_MIPLINEAR\r\n    0 | (0 << 1) | (0 << 2), // TEXTURE_NEAREST_NEAREST_MIPNEAREST\r\n    0 | (1 << 1) | (0 << 2), // TEXTURE_NEAREST_LINEAR_MIPNEAREST\r\n    0 | (1 << 1) | (1 << 2), // TEXTURE_NEAREST_LINEAR_MIPLINEAR\r\n    0 | (1 << 1) | (0 << 2), // TEXTURE_NEAREST_LINEAR\r\n    0 | (0 << 1) | (1 << 2), // TEXTURE_NEAREST_NEAREST_MIPLINEAR\r\n    1 | (0 << 1) | (0 << 2), // TEXTURE_LINEAR_NEAREST_MIPNEAREST\r\n    1 | (0 << 1) | (1 << 2), // TEXTURE_LINEAR_NEAREST_MIPLINEAR\r\n    1 | (1 << 1) | (0 << 2), // TEXTURE_LINEAR_LINEAR_MIPNEAREST\r\n    1 | (0 << 1) | (0 << 2), // TEXTURE_LINEAR_NEAREST\r\n];\r\n\r\n// subtract 0x01FF from the comparison function value before indexing this array!\r\nconst ComparisonFunctionToBits = [\r\n    (0 << 3) | (0 << 4) | (0 << 5) | (0 << 6), // undefined\r\n    (0 << 3) | (0 << 4) | (0 << 5) | (1 << 6), // NEVER\r\n    (0 << 3) | (0 << 4) | (1 << 5) | (0 << 6), // LESS\r\n    (0 << 3) | (0 << 4) | (1 << 5) | (1 << 6), // EQUAL\r\n    (0 << 3) | (1 << 4) | (0 << 5) | (0 << 6), // LEQUAL\r\n    (0 << 3) | (1 << 4) | (0 << 5) | (1 << 6), // GREATER\r\n    (0 << 3) | (1 << 4) | (1 << 5) | (0 << 6), // NOTEQUAL\r\n    (0 << 3) | (1 << 4) | (1 << 5) | (1 << 6), // GEQUAL\r\n    (1 << 3) | (0 << 4) | (0 << 5) | (0 << 6), // ALWAYS\r\n];\r\n\r\nconst FilterNoMipToBits = [\r\n    0 << 7, // not used\r\n    1 << 7, // TEXTURE_NEAREST_SAMPLINGMODE / TEXTURE_NEAREST_NEAREST\r\n    1 << 7, // TEXTURE_BILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR\r\n    0 << 7, // TEXTURE_TRILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR_MIPLINEAR\r\n    0 << 7, // TEXTURE_NEAREST_NEAREST_MIPNEAREST\r\n    0 << 7, // TEXTURE_NEAREST_LINEAR_MIPNEAREST\r\n    0 << 7, // TEXTURE_NEAREST_LINEAR_MIPLINEAR\r\n    1 << 7, // TEXTURE_NEAREST_LINEAR\r\n    0 << 7, // TEXTURE_NEAREST_NEAREST_MIPLINEAR\r\n    0 << 7, // TEXTURE_LINEAR_NEAREST_MIPNEAREST\r\n    0 << 7, // TEXTURE_LINEAR_NEAREST_MIPLINEAR\r\n    0 << 7, // TEXTURE_LINEAR_LINEAR_MIPNEAREST\r\n    1 << 7, // TEXTURE_LINEAR_NEAREST\r\n];\r\n\r\n/** @internal */\r\nexport class WebGPUCacheSampler {\r\n    private _samplers: { [hash: number]: GPUSampler } = {};\r\n    private _device: GPUDevice;\r\n\r\n    public disabled: boolean;\r\n\r\n    constructor(device: GPUDevice) {\r\n        this._device = device;\r\n        this.disabled = false;\r\n    }\r\n\r\n    public static GetSamplerHashCode(sampler: TextureSampler): number {\r\n        // The WebGPU spec currently only allows values 1 and 4 for anisotropy\r\n        const anisotropy = sampler._cachedAnisotropicFilteringLevel ? sampler._cachedAnisotropicFilteringLevel : 1;\r\n        const code =\r\n            FilterToBits[sampler.samplingMode] +\r\n            ComparisonFunctionToBits[(sampler._comparisonFunction || 0x0202) - 0x0200 + 1] +\r\n            FilterNoMipToBits[sampler.samplingMode] + // handle the lodMinClamp = lodMaxClamp = 0 case when no filter used for mip mapping\r\n            ((sampler._cachedWrapU ?? 1) << 8) +\r\n            ((sampler._cachedWrapV ?? 1) << 10) +\r\n            ((sampler._cachedWrapR ?? 1) << 12) +\r\n            ((sampler.useMipMaps ? 1 : 0) << 14) + // need to factor this in because _getSamplerFilterDescriptor depends on samplingMode AND useMipMaps!\r\n            (anisotropy << 15);\r\n\r\n        return code;\r\n    }\r\n\r\n    private static _GetSamplerFilterDescriptor(\r\n        sampler: TextureSampler,\r\n        anisotropy: number\r\n    ): {\r\n        magFilter: GPUFilterMode;\r\n        minFilter: GPUFilterMode;\r\n        mipmapFilter: GPUFilterMode;\r\n        lodMinClamp?: number;\r\n        lodMaxClamp?: number;\r\n        anisotropyEnabled?: boolean;\r\n    } {\r\n        let magFilter: GPUFilterMode, minFilter: GPUFilterMode, mipmapFilter: GPUFilterMode, lodMinClamp: number | undefined, lodMaxClamp: number | undefined;\r\n        const useMipMaps = sampler.useMipMaps;\r\n        switch (sampler.samplingMode) {\r\n            case Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR:\r\n            case Constants.TEXTURE_TRILINEAR_SAMPLINGMODE:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                if (!useMipMaps) {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                } else {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Linear;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                } else {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Linear;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                if (!useMipMaps) {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                } else {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Linear;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_LINEAR:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                lodMinClamp = lodMaxClamp = 0;\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_NEAREST:\r\n            case Constants.TEXTURE_NEAREST_SAMPLINGMODE:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                lodMinClamp = lodMaxClamp = 0;\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                } else {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Linear;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_LINEAR:\r\n            case Constants.TEXTURE_BILINEAR_SAMPLINGMODE:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                // In WebGL, if sampling mode is TEXTURE_BILINEAR_SAMPLINGMODE and anisotropy is greater than 1, anisotropy is enabled for the sampler\r\n                if (anisotropy > 1) {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Linear;\r\n                } else {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_NEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                lodMinClamp = lodMaxClamp = 0;\r\n                break;\r\n            default:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                lodMinClamp = lodMaxClamp = 0;\r\n                break;\r\n        }\r\n\r\n        if (anisotropy > 1 && (lodMinClamp !== 0 || lodMaxClamp !== 0)) {\r\n            return {\r\n                magFilter: WebGPUConstants.FilterMode.Linear,\r\n                minFilter: WebGPUConstants.FilterMode.Linear,\r\n                mipmapFilter: WebGPUConstants.FilterMode.Linear,\r\n                anisotropyEnabled: true,\r\n            };\r\n        }\r\n\r\n        return {\r\n            magFilter,\r\n            minFilter,\r\n            mipmapFilter,\r\n            lodMinClamp,\r\n            lodMaxClamp,\r\n        };\r\n    }\r\n\r\n    private static _GetWrappingMode(mode: number): GPUAddressMode {\r\n        switch (mode) {\r\n            case Constants.TEXTURE_WRAP_ADDRESSMODE:\r\n                return WebGPUConstants.AddressMode.Repeat;\r\n            case Constants.TEXTURE_CLAMP_ADDRESSMODE:\r\n                return WebGPUConstants.AddressMode.ClampToEdge;\r\n            case Constants.TEXTURE_MIRROR_ADDRESSMODE:\r\n                return WebGPUConstants.AddressMode.MirrorRepeat;\r\n        }\r\n        return WebGPUConstants.AddressMode.Repeat;\r\n    }\r\n\r\n    private static _GetSamplerWrappingDescriptor(sampler: TextureSampler): {\r\n        addressModeU: GPUAddressMode;\r\n        addressModeV: GPUAddressMode;\r\n        addressModeW: GPUAddressMode;\r\n    } {\r\n        return {\r\n            addressModeU: this._GetWrappingMode(sampler._cachedWrapU!),\r\n            addressModeV: this._GetWrappingMode(sampler._cachedWrapV!),\r\n            addressModeW: this._GetWrappingMode(sampler._cachedWrapR!),\r\n        };\r\n    }\r\n\r\n    private static _GetSamplerDescriptor(sampler: TextureSampler, label?: string): GPUSamplerDescriptor {\r\n        // The check with Constants.TEXTURE_LINEAR_LINEAR is to be iso with the WebGL implementation\r\n        let anisotropy =\r\n            (sampler.useMipMaps || sampler.samplingMode === Constants.TEXTURE_LINEAR_LINEAR) && sampler._cachedAnisotropicFilteringLevel\r\n                ? sampler._cachedAnisotropicFilteringLevel\r\n                : 1;\r\n        // To be iso with the WebGL implementation\r\n        if (\r\n            sampler.samplingMode !== Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST &&\r\n            sampler.samplingMode !== Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR &&\r\n            sampler.samplingMode !== Constants.TEXTURE_LINEAR_LINEAR\r\n        ) {\r\n            anisotropy = 1;\r\n        }\r\n        const filterDescriptor = this._GetSamplerFilterDescriptor(sampler, anisotropy);\r\n        return {\r\n            label,\r\n            ...filterDescriptor,\r\n            ...this._GetSamplerWrappingDescriptor(sampler),\r\n            compare: sampler._comparisonFunction ? WebGPUCacheSampler.GetCompareFunction(sampler._comparisonFunction) : undefined,\r\n            maxAnisotropy: filterDescriptor.anisotropyEnabled ? anisotropy : 1,\r\n        };\r\n    }\r\n\r\n    public static GetCompareFunction(compareFunction: Nullable<number>): GPUCompareFunction {\r\n        switch (compareFunction) {\r\n            case Constants.ALWAYS:\r\n                return WebGPUConstants.CompareFunction.Always;\r\n            case Constants.EQUAL:\r\n                return WebGPUConstants.CompareFunction.Equal;\r\n            case Constants.GREATER:\r\n                return WebGPUConstants.CompareFunction.Greater;\r\n            case Constants.GEQUAL:\r\n                return WebGPUConstants.CompareFunction.GreaterEqual;\r\n            case Constants.LESS:\r\n                return WebGPUConstants.CompareFunction.Less;\r\n            case Constants.LEQUAL:\r\n                return WebGPUConstants.CompareFunction.LessEqual;\r\n            case Constants.NEVER:\r\n                return WebGPUConstants.CompareFunction.Never;\r\n            case Constants.NOTEQUAL:\r\n                return WebGPUConstants.CompareFunction.NotEqual;\r\n            default:\r\n                return WebGPUConstants.CompareFunction.Less;\r\n        }\r\n    }\r\n\r\n    public getSampler(sampler: TextureSampler, bypassCache = false, hash = 0, label?: string): GPUSampler {\r\n        if (this.disabled) {\r\n            return this._device.createSampler(WebGPUCacheSampler._GetSamplerDescriptor(sampler, label));\r\n        }\r\n\r\n        if (bypassCache) {\r\n            hash = 0;\r\n        } else if (hash === 0) {\r\n            hash = WebGPUCacheSampler.GetSamplerHashCode(sampler);\r\n        }\r\n\r\n        let gpuSampler = bypassCache ? undefined : this._samplers[hash];\r\n        if (!gpuSampler) {\r\n            gpuSampler = this._device.createSampler(WebGPUCacheSampler._GetSamplerDescriptor(sampler, label));\r\n            if (!bypassCache) {\r\n                this._samplers[hash] = gpuSampler;\r\n            }\r\n        }\r\n\r\n        return gpuSampler;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { _IShaderProcessingContext } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\n\r\nconst VertexBufferKindForNonFloatProcessing: { [kind: string]: boolean } = {\r\n    [VertexBuffer.PositionKind]: true,\r\n    [VertexBuffer.NormalKind]: true,\r\n    [VertexBuffer.TangentKind]: true,\r\n    [VertexBuffer.UVKind]: true,\r\n    [VertexBuffer.UV2Kind]: true,\r\n    [VertexBuffer.UV3Kind]: true,\r\n    [VertexBuffer.UV4Kind]: true,\r\n    [VertexBuffer.UV5Kind]: true,\r\n    [VertexBuffer.UV6Kind]: true,\r\n    [VertexBuffer.ColorKind]: true,\r\n    [VertexBuffer.ColorInstanceKind]: true,\r\n    [VertexBuffer.MatricesIndicesKind]: true,\r\n    [VertexBuffer.MatricesWeightsKind]: true,\r\n    [VertexBuffer.MatricesIndicesExtraKind]: true,\r\n    [VertexBuffer.MatricesWeightsExtraKind]: true,\r\n};\r\n\r\n/**\r\n * Indicates if the type is a signed or unsigned type\r\n * @param type Type to check\r\n * @returns True if it is a signed type\r\n */\r\nfunction IsSignedType(type: number): boolean {\r\n    switch (type) {\r\n        case VertexBuffer.BYTE:\r\n        case VertexBuffer.SHORT:\r\n        case VertexBuffer.INT:\r\n        case VertexBuffer.FLOAT:\r\n            return true;\r\n        case VertexBuffer.UNSIGNED_BYTE:\r\n        case VertexBuffer.UNSIGNED_SHORT:\r\n        case VertexBuffer.UNSIGNED_INT:\r\n            return false;\r\n        default:\r\n            throw new Error(`Invalid type '${type}'`);\r\n    }\r\n}\r\n\r\n/**\r\n * Checks whether some vertex buffers that should be of type float are of a different type (int, byte...).\r\n * If so, trigger a shader recompilation to give the shader processor the opportunity to update the code accordingly.\r\n * @param vertexBuffers List of vertex buffers to check\r\n * @param effect The effect (shaders) that should be recompiled if needed\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function checkNonFloatVertexBuffers(vertexBuffers: { [key: string]: Nullable<VertexBuffer> }, effect: Effect): void {\r\n    const engine = effect.getEngine();\r\n    const pipelineContext = effect._pipelineContext;\r\n\r\n    if (!pipelineContext?.vertexBufferKindToType) {\r\n        return;\r\n    }\r\n\r\n    let shaderProcessingContext: Nullable<_IShaderProcessingContext> = null;\r\n\r\n    for (const kind in vertexBuffers) {\r\n        const currentVertexBuffer = vertexBuffers[kind];\r\n\r\n        if (!currentVertexBuffer || !VertexBufferKindForNonFloatProcessing[kind]) {\r\n            continue;\r\n        }\r\n\r\n        const currentVertexBufferType = currentVertexBuffer.normalized ? VertexBuffer.FLOAT : currentVertexBuffer.type;\r\n        const vertexBufferType = pipelineContext.vertexBufferKindToType[kind];\r\n\r\n        if (\r\n            (currentVertexBufferType !== VertexBuffer.FLOAT && vertexBufferType === undefined) ||\r\n            (vertexBufferType !== undefined && vertexBufferType !== currentVertexBufferType)\r\n        ) {\r\n            if (!shaderProcessingContext) {\r\n                shaderProcessingContext = engine._getShaderProcessingContext(effect.shaderLanguage, false)!;\r\n            }\r\n            pipelineContext.vertexBufferKindToType[kind] = currentVertexBufferType;\r\n            if (currentVertexBufferType !== VertexBuffer.FLOAT) {\r\n                shaderProcessingContext.vertexBufferKindToNumberOfComponents![kind] = VertexBuffer.DeduceStride(kind);\r\n                if (IsSignedType(currentVertexBufferType)) {\r\n                    shaderProcessingContext.vertexBufferKindToNumberOfComponents![kind] *= -1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (shaderProcessingContext) {\r\n        // We temporarily disable parallel compilation of shaders because we want new shaders to be compiled after the _processShaderCode call, so that they are in effect for the rest of the frame.\r\n        // There is no additional call to async so the _processShaderCodeAsync will execute synchronously.\r\n        const parallelShaderCompile = engine._caps.parallelShaderCompile;\r\n        engine._caps.parallelShaderCompile = undefined;\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        effect._processShaderCodeAsync(null, engine._features._checkNonFloatVertexBuffersDontRecreatePipelineContext, shaderProcessingContext);\r\n\r\n        engine._caps.parallelShaderCompile = parallelShaderCompile;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport { Constants } from \"../constants\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { Effect } from \"../../Materials/effect\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\nimport { renderableTextureFormatToIndex } from \"./webgpuTextureManager\";\r\nimport { checkNonFloatVertexBuffers } from \"core/Buffers/buffer.nonFloatVertexBuffers\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\nenum StatePosition {\r\n    StencilReadMask = 0,\r\n    StencilWriteMask = 1,\r\n    //DepthBiasClamp = 1, // not used, so remove it to improve perf\r\n    DepthBias = 2,\r\n    DepthBiasSlopeScale = 3,\r\n    DepthStencilState = 4,\r\n    MRTAttachments = 5,\r\n    RasterizationState = 6,\r\n    ColorStates1 = 7,\r\n    ColorStates2 = 8,\r\n    ColorStates3 = 9,\r\n    ColorStates4 = 10,\r\n    ShaderStage = 11,\r\n    TextureStage = 12,\r\n    VertexState = 13, // vertex state will consume positions 13, 14, ... depending on the number of vertex inputs\r\n\r\n    NumStates = 14,\r\n}\r\n\r\nconst alphaBlendFactorToIndex: { [name: number]: number } = {\r\n    0: 1, // Zero\r\n    1: 2, // One\r\n    0x0300: 3, // SrcColor\r\n    0x0301: 4, // OneMinusSrcColor\r\n    0x0302: 5, // SrcAlpha\r\n    0x0303: 6, // OneMinusSrcAlpha\r\n    0x0304: 7, // DstAlpha\r\n    0x0305: 8, // OneMinusDstAlpha\r\n    0x0306: 9, // DstColor\r\n    0x0307: 10, // OneMinusDstColor\r\n    0x0308: 11, // SrcAlphaSaturated\r\n    0x8001: 12, // BlendColor\r\n    0x8002: 13, // OneMinusBlendColor\r\n    0x8003: 14, // BlendColor (alpha)\r\n    0x8004: 15, // OneMinusBlendColor (alpha)\r\n    0x88f9: 16, // Src1Color\r\n    0x88fa: 17, // OneMinusSrc1Color\r\n    0x8589: 18, // Src1Alpha\r\n    0x88fb: 19, // OneMinusSrc1Alpha\r\n};\r\n\r\nconst alphaBlendEquationToIndex: { [name: number]: number } = {\r\n    0x8006: 0, // Add\r\n    0x8007: 1, // Min\r\n    0x8008: 2, // Max\r\n    0x800a: 3, // Subtract\r\n    0x800b: 4, // ReverseSubtract\r\n};\r\n\r\nconst stencilOpToIndex: { [name: number]: number } = {\r\n    0x0000: 0, // ZERO\r\n    0x1e00: 1, // KEEP\r\n    0x1e01: 2, // REPLACE\r\n    0x1e02: 3, // INCR\r\n    0x1e03: 4, // DECR\r\n    0x150a: 5, // INVERT\r\n    0x8507: 6, // INCR_WRAP\r\n    0x8508: 7, // DECR_WRAP\r\n};\r\n\r\nconst colorStates = [0, 0, 0, 0];\r\n\r\n/** @internal */\r\nexport abstract class WebGPUCacheRenderPipeline {\r\n    public static LogErrorIfNoVertexBuffer = false;\r\n\r\n    public static NumCacheHitWithoutHash = 0;\r\n    public static NumCacheHitWithHash = 0;\r\n    public static NumCacheMiss = 0;\r\n    public static NumPipelineCreationLastFrame = 0;\r\n\r\n    public disabled: boolean;\r\n\r\n    private static _NumPipelineCreationCurrentFrame = 0;\r\n\r\n    protected _states: number[];\r\n    protected _statesLength: number;\r\n    protected _stateDirtyLowestIndex: number;\r\n    public lastStateDirtyLowestIndex: number; // for stats only\r\n\r\n    private _device: GPUDevice;\r\n    private _isDirty: boolean;\r\n    private _emptyVertexBuffer: VertexBuffer;\r\n    private _parameter: { token: any; pipeline: Nullable<GPURenderPipeline> };\r\n    private _kMaxVertexBufferStride;\r\n\r\n    private _shaderId: number;\r\n    private _alphaToCoverageEnabled: boolean;\r\n    private _frontFace: number;\r\n    private _cullEnabled: boolean;\r\n    private _cullFace: number;\r\n    private _clampDepth: boolean;\r\n    private _rasterizationState: number;\r\n    private _depthBias: number;\r\n    private _depthBiasClamp: number;\r\n    private _depthBiasSlopeScale: number;\r\n    private _colorFormat: number;\r\n    private _webgpuColorFormat: (GPUTextureFormat | null)[];\r\n    private _mrtAttachments: number;\r\n    private _mrtFormats: (GPUTextureFormat | null)[];\r\n    private _mrtEnabledMask: number;\r\n    private _alphaBlendEnabled: boolean[];\r\n    private _numAlphaBlendTargetsEnabled: number;\r\n    private _alphaBlendFuncParams: Array<Nullable<number>>;\r\n    private _alphaBlendEqParams: Array<Nullable<number>>;\r\n    private _writeMask: number;\r\n    private _depthStencilFormat: number;\r\n    private _webgpuDepthStencilFormat: GPUTextureFormat | undefined;\r\n    private _depthTestEnabled: boolean;\r\n    private _depthWriteEnabled: boolean;\r\n    private _depthCompare: number;\r\n    private _stencilEnabled: boolean;\r\n    private _stencilFrontCompare: number;\r\n    private _stencilFrontDepthFailOp: number;\r\n    private _stencilFrontPassOp: number;\r\n    private _stencilFrontFailOp: number;\r\n    private _stencilBackCompare: number;\r\n    private _stencilBackDepthFailOp: number;\r\n    private _stencilBackPassOp: number;\r\n    private _stencilBackFailOp: number;\r\n    private _stencilReadMask: number;\r\n    private _stencilWriteMask: number;\r\n    private _depthStencilState: number;\r\n    private _vertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>;\r\n    private _overrideVertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>;\r\n    private _textureState: number;\r\n    private _useTextureStage: boolean;\r\n\r\n    constructor(device: GPUDevice, emptyVertexBuffer: VertexBuffer) {\r\n        this._device = device;\r\n        this._useTextureStage = true; // we force usage because we must handle depth textures with \"float\" filtering, which can't be fixed by a caps (like \"textureFloatLinearFiltering\" can for float textures)\r\n        this._states = new Array(30); // pre-allocate enough room so that no new allocation will take place afterwards\r\n        this._statesLength = 0;\r\n        this._stateDirtyLowestIndex = 0;\r\n        this._emptyVertexBuffer = emptyVertexBuffer;\r\n        this._mrtFormats = [];\r\n        this._parameter = { token: undefined, pipeline: null };\r\n        this.disabled = false;\r\n        this.vertexBuffers = [];\r\n        this._kMaxVertexBufferStride = device.limits.maxVertexBufferArrayStride || 2048;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this._isDirty = true;\r\n        this.vertexBuffers.length = 0;\r\n        this.setAlphaToCoverage(false);\r\n        this.resetDepthCullingState();\r\n        this.setClampDepth(false);\r\n        this.setDepthBias(0);\r\n        //this.setDepthBiasClamp(0);\r\n        this._webgpuColorFormat = [WebGPUConstants.TextureFormat.BGRA8Unorm];\r\n        this.setColorFormat(WebGPUConstants.TextureFormat.BGRA8Unorm);\r\n        this.setMRT([]);\r\n        this.setAlphaBlendEnabled([false], 1);\r\n        this.setAlphaBlendFactors([null, null, null, null], [null, null]);\r\n        this.setWriteMask(0xf);\r\n        this.setDepthStencilFormat(WebGPUConstants.TextureFormat.Depth24PlusStencil8);\r\n        this.setStencilEnabled(false);\r\n        this.resetStencilState();\r\n        this.setBuffers(null, null, null);\r\n        this._setTextureState(0);\r\n    }\r\n\r\n    protected abstract _getRenderPipeline(param: { token: any; pipeline: Nullable<GPURenderPipeline> }): void;\r\n    protected abstract _setRenderPipeline(param: { token: any; pipeline: Nullable<GPURenderPipeline> }): void;\r\n\r\n    public readonly vertexBuffers: VertexBuffer[];\r\n    public readonly indexBuffer: Nullable<DataBuffer>;\r\n\r\n    public get colorFormats(): (GPUTextureFormat | null)[] {\r\n        return this._mrtAttachments > 0 ? this._mrtFormats : this._webgpuColorFormat;\r\n    }\r\n\r\n    public readonly mrtAttachments: number[];\r\n    public readonly mrtTextureArray: InternalTexture[];\r\n    public readonly mrtTextureCount: number = 0;\r\n\r\n    public getRenderPipeline(fillMode: number, effect: Effect, sampleCount: number, textureState = 0): GPURenderPipeline {\r\n        sampleCount = WebGPUTextureHelper.GetSample(sampleCount);\r\n\r\n        if (this.disabled) {\r\n            const topology = WebGPUCacheRenderPipeline._GetTopology(fillMode);\r\n\r\n            this._setVertexState(effect); // to fill this.vertexBuffers with correct data\r\n            this._setTextureState(textureState);\r\n\r\n            this._parameter.pipeline = this._createRenderPipeline(effect, topology, sampleCount);\r\n\r\n            WebGPUCacheRenderPipeline.NumCacheMiss++;\r\n            WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;\r\n\r\n            return this._parameter.pipeline;\r\n        }\r\n\r\n        this._setShaderStage(effect.uniqueId);\r\n        this._setRasterizationState(fillMode, sampleCount);\r\n        this._setColorStates();\r\n        this._setDepthStencilState();\r\n        this._setVertexState(effect);\r\n        this._setTextureState(textureState);\r\n\r\n        this.lastStateDirtyLowestIndex = this._stateDirtyLowestIndex;\r\n\r\n        if (!this._isDirty && this._parameter.pipeline) {\r\n            this._stateDirtyLowestIndex = this._statesLength;\r\n            WebGPUCacheRenderPipeline.NumCacheHitWithoutHash++;\r\n            return this._parameter.pipeline;\r\n        }\r\n\r\n        this._getRenderPipeline(this._parameter);\r\n\r\n        this._isDirty = false;\r\n        this._stateDirtyLowestIndex = this._statesLength;\r\n\r\n        if (this._parameter.pipeline) {\r\n            WebGPUCacheRenderPipeline.NumCacheHitWithHash++;\r\n            return this._parameter.pipeline;\r\n        }\r\n\r\n        const topology = WebGPUCacheRenderPipeline._GetTopology(fillMode);\r\n\r\n        this._parameter.pipeline = this._createRenderPipeline(effect, topology, sampleCount);\r\n        this._setRenderPipeline(this._parameter);\r\n\r\n        WebGPUCacheRenderPipeline.NumCacheMiss++;\r\n        WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;\r\n\r\n        return this._parameter.pipeline;\r\n    }\r\n\r\n    public endFrame(): void {\r\n        WebGPUCacheRenderPipeline.NumPipelineCreationLastFrame = WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame;\r\n        WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame = 0;\r\n    }\r\n\r\n    public setAlphaToCoverage(enabled: boolean): void {\r\n        this._alphaToCoverageEnabled = enabled;\r\n    }\r\n\r\n    public setFrontFace(frontFace: number): void {\r\n        this._frontFace = frontFace;\r\n    }\r\n\r\n    public setCullEnabled(enabled: boolean): void {\r\n        this._cullEnabled = enabled;\r\n    }\r\n\r\n    public setCullFace(cullFace: number): void {\r\n        this._cullFace = cullFace;\r\n    }\r\n\r\n    public setClampDepth(clampDepth: boolean): void {\r\n        this._clampDepth = clampDepth;\r\n    }\r\n\r\n    public resetDepthCullingState(): void {\r\n        this.setDepthCullingState(false, 2, 1, 0, 0, true, true, Constants.ALWAYS);\r\n    }\r\n\r\n    public setDepthCullingState(\r\n        cullEnabled: boolean,\r\n        frontFace: number,\r\n        cullFace: number,\r\n        zOffset: number,\r\n        zOffsetUnits: number,\r\n        depthTestEnabled: boolean,\r\n        depthWriteEnabled: boolean,\r\n        depthCompare: Nullable<number>\r\n    ): void {\r\n        this._depthWriteEnabled = depthWriteEnabled;\r\n        this._depthTestEnabled = depthTestEnabled;\r\n        this._depthCompare = (depthCompare ?? Constants.ALWAYS) - 0x0200;\r\n        this._cullFace = cullFace;\r\n        this._cullEnabled = cullEnabled;\r\n        this._frontFace = frontFace;\r\n        this.setDepthBiasSlopeScale(zOffset);\r\n        this.setDepthBias(zOffsetUnits);\r\n    }\r\n\r\n    public setDepthBias(depthBias: number): void {\r\n        if (this._depthBias !== depthBias) {\r\n            this._depthBias = depthBias;\r\n            this._states[StatePosition.DepthBias] = depthBias;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBias);\r\n        }\r\n    }\r\n\r\n    /*public setDepthBiasClamp(depthBiasClamp: number): void {\r\n        if (this._depthBiasClamp !== depthBiasClamp) {\r\n            this._depthBiasClamp = depthBiasClamp;\r\n            this._states[StatePosition.DepthBiasClamp] = depthBiasClamp.toString();\r\n            this._isDirty = true;\r\n        }\r\n    }*/\r\n\r\n    public setDepthBiasSlopeScale(depthBiasSlopeScale: number): void {\r\n        if (this._depthBiasSlopeScale !== depthBiasSlopeScale) {\r\n            this._depthBiasSlopeScale = depthBiasSlopeScale;\r\n            this._states[StatePosition.DepthBiasSlopeScale] = depthBiasSlopeScale;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBiasSlopeScale);\r\n        }\r\n    }\r\n\r\n    public setColorFormat(format: GPUTextureFormat | null): void {\r\n        this._webgpuColorFormat[0] = format;\r\n        this._colorFormat = renderableTextureFormatToIndex[format ?? \"\"];\r\n    }\r\n\r\n    // Must be called after setMRT!\r\n    public setMRTAttachments(attachments: number[]): void {\r\n        (this.mrtAttachments as any) = attachments;\r\n        let mask = 0;\r\n        for (let i = 0; i < attachments.length; ++i) {\r\n            if (attachments[i] !== 0) {\r\n                mask += 1 << i;\r\n            }\r\n        }\r\n        if (this._mrtEnabledMask !== mask) {\r\n            this._mrtEnabledMask = mask;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments);\r\n        }\r\n    }\r\n\r\n    public setMRT(textureArray: InternalTexture[], textureCount?: number): void {\r\n        textureCount = textureCount ?? textureArray.length;\r\n        if (textureCount > 8) {\r\n            // We only support 8 MRTs in WebGPU, so we throw an error if we try to set more than that.\r\n            throw new Error(\"Can't handle more than 8 attachments for a MRT in cache render pipeline!\");\r\n        }\r\n        (this.mrtTextureArray as any) = textureArray;\r\n        (this.mrtTextureCount as any) = textureCount;\r\n\r\n        // Since we need approximately 45 different values per texture format (see WebGPUTextureManager.renderableTextureFormatToIndex), we use 6 bits to encode a texture format,\r\n        // which means we can encode 8 texture formats in 48 bits (a double can represent integers exactly up until 2^53, so 48 bits is ok).\r\n\r\n        this._mrtEnabledMask = 0xffff; // all textures are enabled at start (meaning we can write to them). Calls to setMRTAttachments may disable some\r\n\r\n        let mrtAttachments = 0;\r\n        let mask = 0;\r\n\r\n        for (let i = 0; i < textureCount; ++i) {\r\n            const texture = textureArray[i];\r\n            const gpuWrapper = texture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n            this._mrtFormats[i] = gpuWrapper?.format ?? this._webgpuColorFormat[0];\r\n\r\n            mrtAttachments += renderableTextureFormatToIndex[this._mrtFormats[i] ?? \"\"] * 2 ** mask;\r\n            mask += 6;\r\n        }\r\n        this._mrtFormats.length = textureCount;\r\n        if (this._mrtAttachments !== mrtAttachments) {\r\n            this._mrtAttachments = mrtAttachments;\r\n            this._states[StatePosition.MRTAttachments] = mrtAttachments;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments);\r\n        }\r\n    }\r\n\r\n    public setAlphaBlendEnabled(enabled: boolean[], numAlphaBlendTargetsEnabled: number): void {\r\n        this._alphaBlendEnabled = enabled;\r\n        this._numAlphaBlendTargetsEnabled = numAlphaBlendTargetsEnabled;\r\n    }\r\n\r\n    public setAlphaBlendFactors(factors: Array<Nullable<number>>, operations: Array<Nullable<number>>): void {\r\n        this._alphaBlendFuncParams = factors;\r\n        this._alphaBlendEqParams = operations;\r\n    }\r\n\r\n    public setWriteMask(mask: number): void {\r\n        this._writeMask = mask;\r\n    }\r\n\r\n    public setDepthStencilFormat(format: GPUTextureFormat | undefined): void {\r\n        this._webgpuDepthStencilFormat = format;\r\n        this._depthStencilFormat = format === undefined ? 0 : renderableTextureFormatToIndex[format];\r\n    }\r\n\r\n    public setDepthTestEnabled(enabled: boolean): void {\r\n        this._depthTestEnabled = enabled;\r\n    }\r\n\r\n    public setDepthWriteEnabled(enabled: boolean): void {\r\n        this._depthWriteEnabled = enabled;\r\n    }\r\n\r\n    public setDepthCompare(func: Nullable<number>): void {\r\n        this._depthCompare = (func ?? Constants.ALWAYS) - 0x0200;\r\n    }\r\n\r\n    public setStencilEnabled(enabled: boolean): void {\r\n        this._stencilEnabled = enabled;\r\n    }\r\n\r\n    public setStencilCompare(func: Nullable<number>): void {\r\n        this._stencilFrontCompare = (func ?? Constants.ALWAYS) - 0x0200;\r\n    }\r\n\r\n    public setStencilDepthFailOp(op: Nullable<number>): void {\r\n        this._stencilFrontDepthFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilPassOp(op: Nullable<number>): void {\r\n        this._stencilFrontPassOp = op === null ? 2 /* REPLACE */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilFailOp(op: Nullable<number>): void {\r\n        this._stencilFrontFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilBackCompare(func: Nullable<number>): void {\r\n        this._stencilBackCompare = (func ?? Constants.ALWAYS) - 0x0200;\r\n    }\r\n\r\n    public setStencilBackDepthFailOp(op: Nullable<number>): void {\r\n        this._stencilBackDepthFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilBackPassOp(op: Nullable<number>): void {\r\n        this._stencilBackPassOp = op === null ? 2 /* REPLACE */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilBackFailOp(op: Nullable<number>): void {\r\n        this._stencilBackFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilReadMask(mask: number): void {\r\n        if (this._stencilReadMask !== mask) {\r\n            this._stencilReadMask = mask;\r\n            this._states[StatePosition.StencilReadMask] = mask;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilReadMask);\r\n        }\r\n    }\r\n\r\n    public setStencilWriteMask(mask: number): void {\r\n        if (this._stencilWriteMask !== mask) {\r\n            this._stencilWriteMask = mask;\r\n            this._states[StatePosition.StencilWriteMask] = mask;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilWriteMask);\r\n        }\r\n    }\r\n\r\n    public resetStencilState(): void {\r\n        this.setStencilState(false, Constants.ALWAYS, Constants.KEEP, Constants.REPLACE, Constants.KEEP, 0xff, 0xff);\r\n    }\r\n\r\n    public setStencilState(\r\n        stencilEnabled: boolean,\r\n        compare: Nullable<number>,\r\n        depthFailOp: Nullable<number>,\r\n        passOp: Nullable<number>,\r\n        failOp: Nullable<number>,\r\n        readMask: number,\r\n        writeMask: number,\r\n        backCompare: Nullable<number> = null,\r\n        backDepthFailOp: Nullable<number> = null,\r\n        backPassOp: Nullable<number> = null,\r\n        backFailOp: Nullable<number> = null\r\n    ): void {\r\n        this._stencilEnabled = stencilEnabled;\r\n        this._stencilFrontCompare = (compare ?? Constants.ALWAYS) - 0x0200;\r\n        this._stencilFrontDepthFailOp = depthFailOp === null ? 1 /* KEEP */ : stencilOpToIndex[depthFailOp];\r\n        this._stencilFrontPassOp = passOp === null ? 2 /* REPLACE */ : stencilOpToIndex[passOp];\r\n        this._stencilFrontFailOp = failOp === null ? 1 /* KEEP */ : stencilOpToIndex[failOp];\r\n        this._stencilBackCompare = (backCompare ?? Constants.ALWAYS) - 0x0200;\r\n        this._stencilBackDepthFailOp = backDepthFailOp === null ? 1 /* KEEP */ : stencilOpToIndex[backDepthFailOp];\r\n        this._stencilBackPassOp = backPassOp === null ? 2 /* REPLACE */ : stencilOpToIndex[backPassOp];\r\n        this._stencilBackFailOp = backFailOp === null ? 1 /* KEEP */ : stencilOpToIndex[backFailOp];\r\n        this.setStencilReadMask(readMask);\r\n        this.setStencilWriteMask(writeMask);\r\n    }\r\n\r\n    public setBuffers(\r\n        vertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>,\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        overrideVertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>\r\n    ): void {\r\n        this._vertexBuffers = vertexBuffers;\r\n        this._overrideVertexBuffers = overrideVertexBuffers;\r\n        (this.indexBuffer as Nullable<DataBuffer>) = indexBuffer;\r\n    }\r\n\r\n    private static _GetTopology(fillMode: number): GPUPrimitiveTopology {\r\n        switch (fillMode) {\r\n            // Triangle views\r\n            case Constants.MATERIAL_TriangleFillMode:\r\n                return WebGPUConstants.PrimitiveTopology.TriangleList;\r\n            case Constants.MATERIAL_PointFillMode:\r\n                return WebGPUConstants.PrimitiveTopology.PointList;\r\n            case Constants.MATERIAL_WireFrameFillMode:\r\n                return WebGPUConstants.PrimitiveTopology.LineList;\r\n            // Draw modes\r\n            case Constants.MATERIAL_PointListDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.PointList;\r\n            case Constants.MATERIAL_LineListDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.LineList;\r\n            case Constants.MATERIAL_LineLoopDrawMode:\r\n                // return this._gl.LINE_LOOP;\r\n                // TODO WEBGPU. Line Loop Mode Fallback at buffer load time.\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"LineLoop is an unsupported fillmode in WebGPU\";\r\n            case Constants.MATERIAL_LineStripDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.LineStrip;\r\n            case Constants.MATERIAL_TriangleStripDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.TriangleStrip;\r\n            case Constants.MATERIAL_TriangleFanDrawMode:\r\n                // return this._gl.TRIANGLE_FAN;\r\n                // TODO WEBGPU. Triangle Fan Mode Fallback at buffer load time.\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"TriangleFan is an unsupported fillmode in WebGPU\";\r\n            default:\r\n                return WebGPUConstants.PrimitiveTopology.TriangleList;\r\n        }\r\n    }\r\n\r\n    private static _GetAphaBlendOperation(operation: Nullable<number>): GPUBlendOperation {\r\n        switch (operation) {\r\n            case Constants.GL_ALPHA_EQUATION_ADD:\r\n                return WebGPUConstants.BlendOperation.Add;\r\n            case Constants.GL_ALPHA_EQUATION_SUBTRACT:\r\n                return WebGPUConstants.BlendOperation.Subtract;\r\n            case Constants.GL_ALPHA_EQUATION_REVERSE_SUBTRACT:\r\n                return WebGPUConstants.BlendOperation.ReverseSubtract;\r\n            case Constants.GL_ALPHA_EQUATION_MIN:\r\n                return WebGPUConstants.BlendOperation.Min;\r\n            case Constants.GL_ALPHA_EQUATION_MAX:\r\n                return WebGPUConstants.BlendOperation.Max;\r\n            default:\r\n                return WebGPUConstants.BlendOperation.Add;\r\n        }\r\n    }\r\n\r\n    private static _GetAphaBlendFactor(factor: Nullable<number>): GPUBlendFactor {\r\n        switch (factor) {\r\n            case 0:\r\n                return WebGPUConstants.BlendFactor.Zero;\r\n            case 1:\r\n                return WebGPUConstants.BlendFactor.One;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC:\r\n                return WebGPUConstants.BlendFactor.Src;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR:\r\n                return WebGPUConstants.BlendFactor.OneMinusSrc;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC_ALPHA:\r\n                return WebGPUConstants.BlendFactor.SrcAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA:\r\n                return WebGPUConstants.BlendFactor.OneMinusSrcAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_DST_ALPHA:\r\n                return WebGPUConstants.BlendFactor.DstAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA:\r\n                return WebGPUConstants.BlendFactor.OneMinusDstAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_DST_COLOR:\r\n                return WebGPUConstants.BlendFactor.Dst;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR:\r\n                return WebGPUConstants.BlendFactor.OneMinusDst;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED:\r\n                return WebGPUConstants.BlendFactor.SrcAlphaSaturated;\r\n            case Constants.GL_ALPHA_FUNCTION_CONSTANT_COLOR:\r\n            case Constants.GL_ALPHA_FUNCTION_CONSTANT_ALPHA:\r\n                return WebGPUConstants.BlendFactor.Constant;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR:\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA:\r\n                return WebGPUConstants.BlendFactor.OneMinusConstant;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC1_COLOR:\r\n                return WebGPUConstants.BlendFactor.Src1;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC1_COLOR:\r\n                return WebGPUConstants.BlendFactor.OneMinusSrc1;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC1_ALPHA:\r\n                return WebGPUConstants.BlendFactor.Src1Alpha;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC1_ALPHA:\r\n                return WebGPUConstants.BlendFactor.OneMinusSrc1Alpha;\r\n            default:\r\n                return WebGPUConstants.BlendFactor.One;\r\n        }\r\n    }\r\n\r\n    private static _GetCompareFunction(compareFunction: number): GPUCompareFunction {\r\n        switch (compareFunction) {\r\n            case 0: // NEVER\r\n                return WebGPUConstants.CompareFunction.Never;\r\n            case 1: // LESS\r\n                return WebGPUConstants.CompareFunction.Less;\r\n            case 2: // EQUAL\r\n                return WebGPUConstants.CompareFunction.Equal;\r\n            case 3: // LEQUAL\r\n                return WebGPUConstants.CompareFunction.LessEqual;\r\n            case 4: // GREATER\r\n                return WebGPUConstants.CompareFunction.Greater;\r\n            case 5: // NOTEQUAL\r\n                return WebGPUConstants.CompareFunction.NotEqual;\r\n            case 6: // GEQUAL\r\n                return WebGPUConstants.CompareFunction.GreaterEqual;\r\n            case 7: // ALWAYS\r\n                return WebGPUConstants.CompareFunction.Always;\r\n        }\r\n        return WebGPUConstants.CompareFunction.Never;\r\n    }\r\n\r\n    private static _GetStencilOpFunction(operation: number): GPUStencilOperation {\r\n        switch (operation) {\r\n            case 0:\r\n                return WebGPUConstants.StencilOperation.Zero;\r\n            case 1:\r\n                return WebGPUConstants.StencilOperation.Keep;\r\n            case 2:\r\n                return WebGPUConstants.StencilOperation.Replace;\r\n            case 3:\r\n                return WebGPUConstants.StencilOperation.IncrementClamp;\r\n            case 4:\r\n                return WebGPUConstants.StencilOperation.DecrementClamp;\r\n            case 5:\r\n                return WebGPUConstants.StencilOperation.Invert;\r\n            case 6:\r\n                return WebGPUConstants.StencilOperation.IncrementWrap;\r\n            case 7:\r\n                return WebGPUConstants.StencilOperation.DecrementWrap;\r\n        }\r\n        return WebGPUConstants.StencilOperation.Keep;\r\n    }\r\n\r\n    private static _GetVertexInputDescriptorFormat(vertexBuffer: VertexBuffer): GPUVertexFormat {\r\n        const type = vertexBuffer.type;\r\n        const normalized = vertexBuffer.normalized;\r\n        const size = vertexBuffer.getSize();\r\n\r\n        switch (type) {\r\n            case VertexBuffer.BYTE:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm8x2 : WebGPUConstants.VertexFormat.Sint8x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm8x4 : WebGPUConstants.VertexFormat.Sint8x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.UNSIGNED_BYTE:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm8x2 : WebGPUConstants.VertexFormat.Uint8x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm8x4 : WebGPUConstants.VertexFormat.Uint8x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.SHORT:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm16x2 : WebGPUConstants.VertexFormat.Sint16x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm16x4 : WebGPUConstants.VertexFormat.Sint16x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.UNSIGNED_SHORT:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm16x2 : WebGPUConstants.VertexFormat.Uint16x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm16x4 : WebGPUConstants.VertexFormat.Uint16x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.INT:\r\n                switch (size) {\r\n                    case 1:\r\n                        return WebGPUConstants.VertexFormat.Sint32;\r\n                    case 2:\r\n                        return WebGPUConstants.VertexFormat.Sint32x2;\r\n                    case 3:\r\n                        return WebGPUConstants.VertexFormat.Sint32x3;\r\n                    case 4:\r\n                        return WebGPUConstants.VertexFormat.Sint32x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.UNSIGNED_INT:\r\n                switch (size) {\r\n                    case 1:\r\n                        return WebGPUConstants.VertexFormat.Uint32;\r\n                    case 2:\r\n                        return WebGPUConstants.VertexFormat.Uint32x2;\r\n                    case 3:\r\n                        return WebGPUConstants.VertexFormat.Uint32x3;\r\n                    case 4:\r\n                        return WebGPUConstants.VertexFormat.Uint32x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.FLOAT:\r\n                switch (size) {\r\n                    case 1:\r\n                        return WebGPUConstants.VertexFormat.Float32;\r\n                    case 2:\r\n                        return WebGPUConstants.VertexFormat.Float32x2;\r\n                    case 3:\r\n                        return WebGPUConstants.VertexFormat.Float32x3;\r\n                    case 4:\r\n                        return WebGPUConstants.VertexFormat.Float32x4;\r\n                }\r\n                break;\r\n        }\r\n\r\n        throw new Error(`Invalid Format '${vertexBuffer.getKind()}' - type=${type}, normalized=${normalized}, size=${size}`);\r\n    }\r\n\r\n    private _getAphaBlendState(targetIndex: number): Nullable<GPUBlendComponent> {\r\n        if (!this._alphaBlendEnabled[targetIndex]) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            srcFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[targetIndex * 4 + 2]),\r\n            dstFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[targetIndex * 4 + 3]),\r\n            operation: WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[targetIndex * 2 + 1]),\r\n        };\r\n    }\r\n\r\n    private _getColorBlendState(targetIndex: number): Nullable<GPUBlendComponent> {\r\n        if (!this._alphaBlendEnabled) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            srcFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[targetIndex * 4 + 0]),\r\n            dstFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[targetIndex * 4 + 1]),\r\n            operation: WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[targetIndex * 2 + 0]),\r\n        };\r\n    }\r\n\r\n    private _setShaderStage(id: number): void {\r\n        if (this._shaderId !== id) {\r\n            this._shaderId = id;\r\n            this._states[StatePosition.ShaderStage] = id;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ShaderStage);\r\n        }\r\n    }\r\n\r\n    private _setRasterizationState(topology: number, sampleCount: number): void {\r\n        const frontFace = this._frontFace;\r\n        const cullMode = this._cullEnabled ? this._cullFace : 0;\r\n        const clampDepth = this._clampDepth ? 1 : 0;\r\n        const alphaToCoverage = this._alphaToCoverageEnabled ? 1 : 0;\r\n        const rasterizationState = frontFace - 1 + (cullMode << 1) + (clampDepth << 3) + (alphaToCoverage << 4) + (topology << 5) + (sampleCount << 8);\r\n\r\n        if (this._rasterizationState !== rasterizationState) {\r\n            this._rasterizationState = rasterizationState;\r\n            this._states[StatePosition.RasterizationState] = this._rasterizationState;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.RasterizationState);\r\n        }\r\n    }\r\n\r\n    private _setColorStates(): void {\r\n        // Note that _depthWriteEnabled state has been moved from depthStencilState here because alpha and depth are related (generally when alpha is on, depth write is off and the other way around)\r\n\r\n        // We need 4 color states because we will be grouping 2 blend targets in each state (and WebGPU supports up to 8 targets).\r\n        // Integers can only be represented exactly in 53 bits with a double, so we can only use 53 bits for each state.\r\n        // We use 25 bits for each blend target (5 bits for the 2 (color/alpha) equations and 4*5 bits for the 4 factors (src/dst color and src/dst alpha)).\r\n        // This means that we need 25*2=50 bits to pack 2 blend targets, and we can use the remaining 3 bits for other states (write mask, depth write, color format).\r\n        // The color format is encoded on 6 bits, so we dispatch it over 3 bits to the last two color states.\r\n\r\n        colorStates[0] = (this._writeMask ? 1 : 0) * 2 ** 53;\r\n        colorStates[1] = (this._depthWriteEnabled ? 1 : 0) * 2 ** 53;\r\n        colorStates[2] = (this._colorFormat & 0x07) * 2 ** 50;\r\n        colorStates[3] = (this._colorFormat & 0x38) * 2 ** 47;\r\n\r\n        let colorStateIndex = 0;\r\n        let isDirty = false;\r\n\r\n        for (let i = 0; i < 8; i++) {\r\n            if (this._alphaBlendEnabled[i]) {\r\n                const index0 = i * 4 + 0;\r\n                const index1 = i * 4 + 1;\r\n                const index2 = i * 4 + 2;\r\n                const index3 = i * 4 + 3;\r\n                const indexEq0 = i * 2 + 0;\r\n                const indexEq1 = i * 2 + 1;\r\n                const eq0 = this._alphaBlendEqParams[indexEq0] === null ? 0 : alphaBlendEquationToIndex[this._alphaBlendEqParams[indexEq0]];\r\n                const eq1 = this._alphaBlendEqParams[indexEq1] === null ? 0 : alphaBlendEquationToIndex[this._alphaBlendEqParams[indexEq1]];\r\n\r\n                colorStates[colorStateIndex] +=\r\n                    ((this._alphaBlendFuncParams[index0] === null ? 1 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[index0]]) << 0) +\r\n                    ((this._alphaBlendFuncParams[index1] === null ? 1 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[index1]]) << 5) +\r\n                    ((this._alphaBlendFuncParams[index2] === null ? 1 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[index2]]) << 10) +\r\n                    ((this._alphaBlendFuncParams[index3] === null ? 1 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[index3]]) << 15) +\r\n                    (eq0 + eq1 * 5) * (1 << 20);\r\n            }\r\n\r\n            if (i & 1) {\r\n                isDirty = isDirty || this._states[StatePosition.ColorStates1 + colorStateIndex] !== colorStates[colorStateIndex];\r\n                this._states[StatePosition.ColorStates1 + colorStateIndex] = colorStates[colorStateIndex];\r\n                colorStateIndex++;\r\n            }\r\n        }\r\n\r\n        if (isDirty) {\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ColorStates1);\r\n        }\r\n    }\r\n\r\n    private _setDepthStencilState(): void {\r\n        const stencilState = !this._stencilEnabled\r\n            ? 7 /* ALWAYS */ +\r\n              (1 /* KEEP */ << 3) +\r\n              (1 /* KEEP */ << 6) +\r\n              (1 /* KEEP */ << 9) + // front\r\n              (7 /* ALWAYS */ << 12) +\r\n              (1 /* KEEP */ << 15) +\r\n              (1 /* KEEP */ << 18) +\r\n              (1 /* KEEP */ << 21) // back\r\n            : this._stencilFrontCompare +\r\n              (this._stencilFrontDepthFailOp << 3) +\r\n              (this._stencilFrontPassOp << 6) +\r\n              (this._stencilFrontFailOp << 9) + // front\r\n              (this._stencilBackCompare << 12) +\r\n              (this._stencilBackDepthFailOp << 15) +\r\n              (this._stencilBackPassOp << 18) +\r\n              (this._stencilBackFailOp << 21); // back\r\n\r\n        const depthStencilState = this._depthStencilFormat + ((this._depthTestEnabled ? this._depthCompare : 7) /* ALWAYS */ << 6) + stencilState * (1 << 10); // stencil front + back\r\n\r\n        if (this._depthStencilState !== depthStencilState) {\r\n            this._depthStencilState = depthStencilState;\r\n            this._states[StatePosition.DepthStencilState] = this._depthStencilState;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthStencilState);\r\n        }\r\n    }\r\n\r\n    private _setVertexState(effect: Effect): void {\r\n        const currStateLen = this._statesLength;\r\n        let newNumStates = StatePosition.VertexState;\r\n\r\n        const webgpuPipelineContext = effect._pipelineContext as WebGPUPipelineContext;\r\n        const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;\r\n        const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;\r\n\r\n        let currentGPUBuffer;\r\n        let numVertexBuffers = 0;\r\n        for (let index = 0; index < attributes.length; index++) {\r\n            const location = locations[index];\r\n            let vertexBuffer = (this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) ?? this._vertexBuffers![attributes[index]];\r\n            if (!vertexBuffer) {\r\n                // In WebGL it's valid to not bind a vertex buffer to an attribute, but it's not valid in WebGPU\r\n                // So we must bind a dummy buffer when we are not given one for a specific attribute\r\n                vertexBuffer = this._emptyVertexBuffer;\r\n                if (WebGPUCacheRenderPipeline.LogErrorIfNoVertexBuffer) {\r\n                    Logger.Error(\r\n                        `No vertex buffer is provided for the \"${attributes[index]}\" attribute. A default empty vertex buffer will be used, but this may generate errors in some browsers.`\r\n                    );\r\n                }\r\n            }\r\n\r\n            const buffer = vertexBuffer.effectiveBuffer?.underlyingResource;\r\n\r\n            // We optimize usage of GPUVertexBufferLayout: we will create a single GPUVertexBufferLayout for all the attributes which follow each other and which use the same GPU buffer\r\n            // However, there are some constraints in the attribute.offset value range, so we must check for them before being able to reuse the same GPUVertexBufferLayout\r\n            // See _getVertexInputDescriptor() below\r\n            if (vertexBuffer._validOffsetRange === undefined) {\r\n                const offset = vertexBuffer.effectiveByteOffset;\r\n                const formatSize = vertexBuffer.getSize(true);\r\n                const byteStride = vertexBuffer.effectiveByteStride;\r\n\r\n                vertexBuffer._validOffsetRange =\r\n                    (offset + formatSize <= this._kMaxVertexBufferStride && byteStride === 0) || (byteStride !== 0 && offset + formatSize <= byteStride);\r\n            }\r\n\r\n            if (!(currentGPUBuffer && currentGPUBuffer === buffer && vertexBuffer._validOffsetRange)) {\r\n                // we can't combine the previous vertexBuffer with the current one\r\n                this.vertexBuffers[numVertexBuffers++] = vertexBuffer;\r\n                currentGPUBuffer = vertexBuffer._validOffsetRange ? buffer : null;\r\n            }\r\n\r\n            const vid = vertexBuffer.hashCode + (location << 7);\r\n\r\n            this._isDirty = this._isDirty || this._states[newNumStates] !== vid;\r\n            this._states[newNumStates++] = vid;\r\n        }\r\n\r\n        this.vertexBuffers.length = numVertexBuffers;\r\n\r\n        this._statesLength = newNumStates;\r\n        this._isDirty = this._isDirty || newNumStates !== currStateLen;\r\n        if (this._isDirty) {\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.VertexState);\r\n        }\r\n    }\r\n\r\n    private _setTextureState(textureState: number): void {\r\n        if (this._textureState !== textureState) {\r\n            this._textureState = textureState;\r\n            this._states[StatePosition.TextureStage] = this._textureState;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.TextureStage);\r\n        }\r\n    }\r\n\r\n    private _createPipelineLayout(webgpuPipelineContext: WebGPUPipelineContext): GPUPipelineLayout {\r\n        if (this._useTextureStage) {\r\n            return this._createPipelineLayoutWithTextureStage(webgpuPipelineContext);\r\n        }\r\n\r\n        const bindGroupLayouts: GPUBindGroupLayout[] = [];\r\n        const bindGroupLayoutEntries = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries;\r\n\r\n        for (let i = 0; i < bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = bindGroupLayoutEntries[i];\r\n\r\n            bindGroupLayouts[i] = this._device.createBindGroupLayout({\r\n                entries: setDefinition,\r\n            });\r\n        }\r\n\r\n        webgpuPipelineContext.bindGroupLayouts[0] = bindGroupLayouts;\r\n\r\n        return this._device.createPipelineLayout({ bindGroupLayouts });\r\n    }\r\n\r\n    private _createPipelineLayoutWithTextureStage(webgpuPipelineContext: WebGPUPipelineContext): GPUPipelineLayout {\r\n        const shaderProcessingContext = webgpuPipelineContext.shaderProcessingContext;\r\n        const bindGroupLayoutEntries = shaderProcessingContext.bindGroupLayoutEntries;\r\n\r\n        let bitVal = 1;\r\n        for (let i = 0; i < bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = bindGroupLayoutEntries[i];\r\n\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = bindGroupLayoutEntries[i][j];\r\n\r\n                if (entry.texture) {\r\n                    const name = shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].name;\r\n                    const textureInfo = shaderProcessingContext.availableTextures[name];\r\n                    const samplerInfo = textureInfo.autoBindSampler ? shaderProcessingContext.availableSamplers[name + Constants.AUTOSAMPLERSUFFIX] : null;\r\n\r\n                    let sampleType = textureInfo.sampleType;\r\n                    let samplerType = samplerInfo?.type ?? WebGPUConstants.SamplerBindingType.Filtering;\r\n\r\n                    if (this._textureState & bitVal && sampleType !== WebGPUConstants.TextureSampleType.Depth) {\r\n                        // The texture is a 32 bits float texture but the system does not support linear filtering for them OR the texture is a depth texture with \"float\" filtering:\r\n                        // we set the sampler to \"non-filtering\" and the texture sample type to \"unfilterable-float\"\r\n                        if (textureInfo.autoBindSampler) {\r\n                            samplerType = WebGPUConstants.SamplerBindingType.NonFiltering;\r\n                        }\r\n                        sampleType = WebGPUConstants.TextureSampleType.UnfilterableFloat;\r\n                    }\r\n\r\n                    entry.texture.sampleType = sampleType;\r\n\r\n                    if (samplerInfo) {\r\n                        const binding = shaderProcessingContext.bindGroupLayoutEntryInfo[samplerInfo.binding.groupIndex][samplerInfo.binding.bindingIndex].index;\r\n                        bindGroupLayoutEntries[samplerInfo.binding.groupIndex][binding].sampler!.type = samplerType;\r\n                    }\r\n\r\n                    bitVal = bitVal << 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        const bindGroupLayouts: GPUBindGroupLayout[] = [];\r\n\r\n        for (let i = 0; i < bindGroupLayoutEntries.length; ++i) {\r\n            bindGroupLayouts[i] = this._device.createBindGroupLayout({\r\n                entries: bindGroupLayoutEntries[i],\r\n            });\r\n        }\r\n\r\n        webgpuPipelineContext.bindGroupLayouts[this._textureState] = bindGroupLayouts;\r\n\r\n        return this._device.createPipelineLayout({ bindGroupLayouts });\r\n    }\r\n\r\n    private _getVertexInputDescriptor(effect: Effect): GPUVertexBufferLayout[] {\r\n        const descriptors: GPUVertexBufferLayout[] = [];\r\n        const webgpuPipelineContext = effect._pipelineContext as WebGPUPipelineContext;\r\n        const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;\r\n        const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;\r\n\r\n        let currentGPUBuffer;\r\n        let currentGPUAttributes: GPUVertexAttribute[] | undefined;\r\n        for (let index = 0; index < attributes.length; index++) {\r\n            const location = locations[index];\r\n            let vertexBuffer = (this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) ?? this._vertexBuffers![attributes[index]];\r\n            if (!vertexBuffer) {\r\n                // In WebGL it's valid to not bind a vertex buffer to an attribute, but it's not valid in WebGPU\r\n                // So we must bind a dummy buffer when we are not given one for a specific attribute\r\n                vertexBuffer = this._emptyVertexBuffer;\r\n            }\r\n\r\n            let buffer = vertexBuffer.effectiveBuffer?.underlyingResource;\r\n\r\n            // We reuse the same GPUVertexBufferLayout for all attributes that use the same underlying GPU buffer (and for attributes that follow each other in the attributes array)\r\n            let offset = vertexBuffer.effectiveByteOffset;\r\n            const invalidOffsetRange = !vertexBuffer._validOffsetRange;\r\n            if (!(currentGPUBuffer && currentGPUAttributes && currentGPUBuffer === buffer) || invalidOffsetRange) {\r\n                const vertexBufferDescriptor: GPUVertexBufferLayout = {\r\n                    arrayStride: vertexBuffer.effectiveByteStride,\r\n                    stepMode: vertexBuffer.getIsInstanced() ? WebGPUConstants.VertexStepMode.Instance : WebGPUConstants.VertexStepMode.Vertex,\r\n                    attributes: [],\r\n                };\r\n\r\n                descriptors.push(vertexBufferDescriptor);\r\n                currentGPUAttributes = vertexBufferDescriptor.attributes;\r\n                if (invalidOffsetRange) {\r\n                    offset = 0; // the offset will be set directly in the setVertexBuffer call\r\n                    buffer = null; // buffer can't be reused\r\n                }\r\n            }\r\n\r\n            currentGPUAttributes.push({\r\n                shaderLocation: location,\r\n                offset,\r\n                format: WebGPUCacheRenderPipeline._GetVertexInputDescriptorFormat(vertexBuffer),\r\n            });\r\n\r\n            currentGPUBuffer = buffer;\r\n        }\r\n\r\n        return descriptors;\r\n    }\r\n\r\n    private _createRenderPipeline(effect: Effect, topology: GPUPrimitiveTopology, sampleCount: number): GPURenderPipeline {\r\n        const webgpuPipelineContext = effect._pipelineContext as WebGPUPipelineContext;\r\n        const inputStateDescriptor = this._getVertexInputDescriptor(effect);\r\n        const pipelineLayout = this._createPipelineLayout(webgpuPipelineContext);\r\n\r\n        const colorStates: Array<GPUColorTargetState | null> = [];\r\n\r\n        if (this._vertexBuffers) {\r\n            checkNonFloatVertexBuffers(this._vertexBuffers, effect);\r\n        }\r\n\r\n        if (this._mrtAttachments > 0) {\r\n            for (let i = 0; i < this._mrtFormats.length; ++i) {\r\n                const format = this._mrtFormats[i];\r\n                if (format) {\r\n                    const descr: GPUColorTargetState = {\r\n                        format,\r\n                        writeMask: (this._mrtEnabledMask & (1 << i)) !== 0 ? this._writeMask : 0,\r\n                    };\r\n                    const alphaBlend = this._getAphaBlendState(i < this._numAlphaBlendTargetsEnabled ? i : 0);\r\n                    const colorBlend = this._getColorBlendState(i < this._numAlphaBlendTargetsEnabled ? i : 0);\r\n\r\n                    if (alphaBlend && colorBlend) {\r\n                        descr.blend = {\r\n                            alpha: alphaBlend,\r\n                            color: colorBlend,\r\n                        };\r\n                    }\r\n                    colorStates.push(descr);\r\n                } else {\r\n                    colorStates.push(null);\r\n                }\r\n            }\r\n        } else {\r\n            if (this._webgpuColorFormat[0]) {\r\n                const descr: GPUColorTargetState = {\r\n                    format: this._webgpuColorFormat[0],\r\n                    writeMask: this._writeMask,\r\n                };\r\n                const alphaBlend = this._getAphaBlendState(0);\r\n                const colorBlend = this._getColorBlendState(0);\r\n\r\n                if (alphaBlend && colorBlend) {\r\n                    descr.blend = {\r\n                        alpha: alphaBlend,\r\n                        color: colorBlend,\r\n                    };\r\n                }\r\n                colorStates.push(descr);\r\n            } else {\r\n                colorStates.push(null);\r\n            }\r\n        }\r\n\r\n        const stencilFront: GPUStencilFaceState = {\r\n            compare: WebGPUCacheRenderPipeline._GetCompareFunction(this._stencilEnabled ? this._stencilFrontCompare : 7 /* ALWAYS */),\r\n            depthFailOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontDepthFailOp : 1 /* KEEP */),\r\n            failOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontFailOp : 1 /* KEEP */),\r\n            passOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontPassOp : 1 /* KEEP */),\r\n        };\r\n\r\n        const stencilBack: GPUStencilFaceState = {\r\n            compare: WebGPUCacheRenderPipeline._GetCompareFunction(this._stencilEnabled ? this._stencilBackCompare : 7 /* ALWAYS */),\r\n            depthFailOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilBackDepthFailOp : 1 /* KEEP */),\r\n            failOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilBackFailOp : 1 /* KEEP */),\r\n            passOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilBackPassOp : 1 /* KEEP */),\r\n        };\r\n\r\n        const topologyIsTriangle = topology === WebGPUConstants.PrimitiveTopology.TriangleList || topology === WebGPUConstants.PrimitiveTopology.TriangleStrip;\r\n\r\n        let stripIndexFormat: GPUIndexFormat | undefined = undefined;\r\n        if (topology === WebGPUConstants.PrimitiveTopology.LineStrip || topology === WebGPUConstants.PrimitiveTopology.TriangleStrip) {\r\n            stripIndexFormat = !this.indexBuffer || this.indexBuffer.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16;\r\n        }\r\n\r\n        const depthStencilFormatHasStencil = this._webgpuDepthStencilFormat ? WebGPUTextureHelper.HasStencilAspect(this._webgpuDepthStencilFormat) : false;\r\n\r\n        return this._device.createRenderPipeline({\r\n            label: `RenderPipeline_${colorStates[0]?.format ?? \"nooutput\"}_${this._webgpuDepthStencilFormat ?? \"nodepth\"}_samples${sampleCount}_textureState${this._textureState}`,\r\n            layout: pipelineLayout,\r\n            vertex: {\r\n                module: webgpuPipelineContext.stages!.vertexStage.module,\r\n                entryPoint: webgpuPipelineContext.stages!.vertexStage.entryPoint,\r\n                buffers: inputStateDescriptor,\r\n            },\r\n            primitive: {\r\n                topology,\r\n                stripIndexFormat,\r\n                frontFace: this._frontFace === 1 ? WebGPUConstants.FrontFace.CCW : WebGPUConstants.FrontFace.CW,\r\n                cullMode: !this._cullEnabled ? WebGPUConstants.CullMode.None : this._cullFace === 2 ? WebGPUConstants.CullMode.Front : WebGPUConstants.CullMode.Back,\r\n            },\r\n            fragment: !webgpuPipelineContext.stages!.fragmentStage\r\n                ? undefined\r\n                : {\r\n                      module: webgpuPipelineContext.stages!.fragmentStage.module,\r\n                      entryPoint: webgpuPipelineContext.stages!.fragmentStage.entryPoint,\r\n                      targets: colorStates,\r\n                  },\r\n\r\n            multisample: {\r\n                count: sampleCount,\r\n                /*mask,\r\n                alphaToCoverageEnabled,*/\r\n            },\r\n            depthStencil:\r\n                this._webgpuDepthStencilFormat === undefined\r\n                    ? undefined\r\n                    : {\r\n                          depthWriteEnabled: this._depthWriteEnabled,\r\n                          depthCompare: this._depthTestEnabled ? WebGPUCacheRenderPipeline._GetCompareFunction(this._depthCompare) : WebGPUConstants.CompareFunction.Always,\r\n                          format: this._webgpuDepthStencilFormat,\r\n                          stencilFront: this._stencilEnabled && depthStencilFormatHasStencil ? stencilFront : undefined,\r\n                          stencilBack: this._stencilEnabled && depthStencilFormatHasStencil ? stencilBack : undefined,\r\n                          stencilReadMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilReadMask : undefined,\r\n                          stencilWriteMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilWriteMask : undefined,\r\n                          depthBias: this._depthBias,\r\n                          depthBiasClamp: topologyIsTriangle ? this._depthBiasClamp : 0,\r\n                          depthBiasSlopeScale: topologyIsTriangle ? this._depthBiasSlopeScale : 0,\r\n                      },\r\n        });\r\n    }\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebGPUCacheRenderPipeline } from \"./webgpuCacheRenderPipeline\";\r\n\r\n/** @internal */\r\nclass NodeState {\r\n    public values: { [id: number]: NodeState };\r\n    public pipeline: GPURenderPipeline;\r\n\r\n    constructor() {\r\n        this.values = {};\r\n    }\r\n\r\n    public count(): [number, number] {\r\n        let countNode = 0,\r\n            countPipeline = this.pipeline ? 1 : 0;\r\n        for (const value in this.values) {\r\n            const node = this.values[value];\r\n            const [childCountNodes, childCoundPipeline] = node.count();\r\n            countNode += childCountNodes;\r\n            countPipeline += childCoundPipeline;\r\n            countNode++;\r\n        }\r\n        return [countNode, countPipeline];\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUCacheRenderPipelineTree extends WebGPUCacheRenderPipeline {\r\n    private static _Cache: NodeState = new NodeState();\r\n\r\n    private _nodeStack: NodeState[];\r\n\r\n    public static GetNodeCounts(): { nodeCount: number; pipelineCount: number } {\r\n        const counts = WebGPUCacheRenderPipelineTree._Cache.count();\r\n\r\n        return { nodeCount: counts[0], pipelineCount: counts[1] };\r\n    }\r\n\r\n    public static _GetPipelines(node: NodeState, pipelines: Array<Array<number>>, curPath: Array<number>, curPathLen: number): void {\r\n        if (node.pipeline) {\r\n            const path = curPath.slice();\r\n            path.length = curPathLen;\r\n            pipelines.push(path);\r\n        }\r\n        for (const value in node.values) {\r\n            const nnode = node.values[value];\r\n            curPath[curPathLen] = parseInt(value);\r\n            WebGPUCacheRenderPipelineTree._GetPipelines(nnode, pipelines, curPath, curPathLen + 1);\r\n        }\r\n    }\r\n\r\n    public static GetPipelines(): Array<Array<number>> {\r\n        const pipelines: Array<Array<number>> = [];\r\n        WebGPUCacheRenderPipelineTree._GetPipelines(WebGPUCacheRenderPipelineTree._Cache, pipelines, [], 0);\r\n        return pipelines;\r\n    }\r\n\r\n    public static ResetCache() {\r\n        WebGPUCacheRenderPipelineTree._Cache = new NodeState();\r\n    }\r\n\r\n    public override reset(): void {\r\n        this._nodeStack = [];\r\n        this._nodeStack[0] = WebGPUCacheRenderPipelineTree._Cache;\r\n        super.reset();\r\n    }\r\n\r\n    protected _getRenderPipeline(param: { token: any; pipeline: Nullable<GPURenderPipeline> }): void {\r\n        let node = this._nodeStack[this._stateDirtyLowestIndex];\r\n        for (let i = this._stateDirtyLowestIndex; i < this._statesLength; ++i) {\r\n            let nn: NodeState | undefined = node.values[this._states[i]];\r\n            if (!nn) {\r\n                nn = new NodeState();\r\n                node.values[this._states[i]] = nn;\r\n            }\r\n            node = nn;\r\n            this._nodeStack[i + 1] = node;\r\n        }\r\n\r\n        param.token = node;\r\n        param.pipeline = node.pipeline;\r\n    }\r\n\r\n    protected _setRenderPipeline(param: { token: NodeState; pipeline: Nullable<GPURenderPipeline> }): void {\r\n        param.token.pipeline = param.pipeline!;\r\n    }\r\n}\r\n", "import type { WebGPUCacheRenderPipeline } from \"./webgpuCacheRenderPipeline\";\r\nimport { StencilStateComposer } from \"../../States/stencilStateComposer\";\r\n\r\n/**\r\n * @internal\r\n **/\r\nexport class WebGPUStencilStateComposer extends StencilStateComposer {\r\n    private _cache: WebGPUCacheRenderPipeline;\r\n\r\n    public constructor(cache: WebGPUCacheRenderPipeline) {\r\n        super(false);\r\n        this._cache = cache;\r\n        this.reset();\r\n    }\r\n\r\n    public override get func(): number {\r\n        return this._func;\r\n    }\r\n\r\n    public override set func(value: number) {\r\n        if (this._func === value) {\r\n            return;\r\n        }\r\n\r\n        this._func = value;\r\n        this._cache.setStencilCompare(value);\r\n    }\r\n\r\n    public override get backFunc(): number {\r\n        return this._backFunc;\r\n    }\r\n\r\n    public override set backFunc(value: number) {\r\n        if (this._backFunc === value) {\r\n            return;\r\n        }\r\n\r\n        this._backFunc = value;\r\n        this._cache.setStencilBackCompare(value);\r\n    }\r\n\r\n    public override get funcMask(): number {\r\n        return this._funcMask;\r\n    }\r\n\r\n    public override set funcMask(value: number) {\r\n        if (this._funcMask === value) {\r\n            return;\r\n        }\r\n\r\n        this._funcMask = value;\r\n        this._cache.setStencilReadMask(value);\r\n    }\r\n\r\n    public override get opStencilFail(): number {\r\n        return this._opStencilFail;\r\n    }\r\n\r\n    public override set opStencilFail(value: number) {\r\n        if (this._opStencilFail === value) {\r\n            return;\r\n        }\r\n\r\n        this._opStencilFail = value;\r\n        this._cache.setStencilFailOp(value);\r\n    }\r\n\r\n    public override get opDepthFail(): number {\r\n        return this._opDepthFail;\r\n    }\r\n\r\n    public override set opDepthFail(value: number) {\r\n        if (this._opDepthFail === value) {\r\n            return;\r\n        }\r\n\r\n        this._opDepthFail = value;\r\n        this._cache.setStencilDepthFailOp(value);\r\n    }\r\n\r\n    public override get opStencilDepthPass(): number {\r\n        return this._opStencilDepthPass;\r\n    }\r\n\r\n    public override set opStencilDepthPass(value: number) {\r\n        if (this._opStencilDepthPass === value) {\r\n            return;\r\n        }\r\n\r\n        this._opStencilDepthPass = value;\r\n        this._cache.setStencilPassOp(value);\r\n    }\r\n\r\n    public override get backOpStencilFail(): number {\r\n        return this._backOpStencilFail;\r\n    }\r\n\r\n    public override set backOpStencilFail(value: number) {\r\n        if (this._backOpStencilFail === value) {\r\n            return;\r\n        }\r\n\r\n        this._backOpStencilFail = value;\r\n        this._cache.setStencilBackFailOp(value);\r\n    }\r\n\r\n    public override get backOpDepthFail(): number {\r\n        return this._backOpDepthFail;\r\n    }\r\n\r\n    public override set backOpDepthFail(value: number) {\r\n        if (this._backOpDepthFail === value) {\r\n            return;\r\n        }\r\n\r\n        this._backOpDepthFail = value;\r\n        this._cache.setStencilBackDepthFailOp(value);\r\n    }\r\n\r\n    public override get backOpStencilDepthPass(): number {\r\n        return this._backOpStencilDepthPass;\r\n    }\r\n\r\n    public override set backOpStencilDepthPass(value: number) {\r\n        if (this._backOpStencilDepthPass === value) {\r\n            return;\r\n        }\r\n\r\n        this._backOpStencilDepthPass = value;\r\n        this._cache.setStencilBackPassOp(value);\r\n    }\r\n\r\n    public override get mask(): number {\r\n        return this._mask;\r\n    }\r\n\r\n    public override set mask(value: number) {\r\n        if (this._mask === value) {\r\n            return;\r\n        }\r\n\r\n        this._mask = value;\r\n        this._cache.setStencilWriteMask(value);\r\n    }\r\n\r\n    public override get enabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public override set enabled(value: boolean) {\r\n        if (this._enabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._enabled = value;\r\n        this._cache.setStencilEnabled(value);\r\n    }\r\n\r\n    public override reset() {\r\n        super.reset();\r\n        this._cache.resetStencilState();\r\n    }\r\n\r\n    public override apply() {\r\n        const stencilMaterialEnabled = !this.useStencilGlobalOnly && !!this.stencilMaterial?.enabled;\r\n\r\n        this.enabled = stencilMaterialEnabled ? this.stencilMaterial!.enabled : this.stencilGlobal.enabled;\r\n        if (!this.enabled) {\r\n            return;\r\n        }\r\n\r\n        this.mask = stencilMaterialEnabled ? this.stencilMaterial!.mask : this.stencilGlobal.mask;\r\n        this.funcRef = stencilMaterialEnabled ? this.stencilMaterial!.funcRef : this.stencilGlobal.funcRef;\r\n        this.funcMask = stencilMaterialEnabled ? this.stencilMaterial!.funcMask : this.stencilGlobal.funcMask;\r\n        this.func = stencilMaterialEnabled ? this.stencilMaterial!.func : this.stencilGlobal.func;\r\n        this.opStencilFail = stencilMaterialEnabled ? this.stencilMaterial!.opStencilFail : this.stencilGlobal.opStencilFail;\r\n        this.opDepthFail = stencilMaterialEnabled ? this.stencilMaterial!.opDepthFail : this.stencilGlobal.opDepthFail;\r\n        this.opStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial!.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass;\r\n        this.backFunc = stencilMaterialEnabled ? this.stencilMaterial!.backFunc : this.stencilGlobal.backFunc;\r\n        this.backOpStencilFail = stencilMaterialEnabled ? this.stencilMaterial!.backOpStencilFail : this.stencilGlobal.backOpStencilFail;\r\n        this.backOpDepthFail = stencilMaterialEnabled ? this.stencilMaterial!.backOpDepthFail : this.stencilGlobal.backOpDepthFail;\r\n        this.backOpStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial!.backOpStencilDepthPass : this.stencilGlobal.backOpStencilDepthPass;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { WebGPUCacheRenderPipeline } from \"./webgpuCacheRenderPipeline\";\r\nimport { DepthCullingState } from \"../../States/depthCullingState\";\r\n\r\n/**\r\n * @internal\r\n **/\r\nexport class WebGPUDepthCullingState extends DepthCullingState {\r\n    private _cache: WebGPUCacheRenderPipeline;\r\n\r\n    /**\r\n     * Initializes the state.\r\n     * @param cache\r\n     */\r\n    public constructor(cache: WebGPUCacheRenderPipeline) {\r\n        super(false);\r\n        this._cache = cache;\r\n        this.reset();\r\n    }\r\n\r\n    public override get zOffset(): number {\r\n        return this._zOffset;\r\n    }\r\n\r\n    public override set zOffset(value: number) {\r\n        if (this._zOffset === value) {\r\n            return;\r\n        }\r\n\r\n        this._zOffset = value;\r\n        this._isZOffsetDirty = true;\r\n        this._cache.setDepthBiasSlopeScale(value);\r\n    }\r\n\r\n    public override get zOffsetUnits(): number {\r\n        return this._zOffsetUnits;\r\n    }\r\n\r\n    public override set zOffsetUnits(value: number) {\r\n        if (this._zOffsetUnits === value) {\r\n            return;\r\n        }\r\n\r\n        this._zOffsetUnits = value;\r\n        this._isZOffsetDirty = true;\r\n        this._cache.setDepthBias(value);\r\n    }\r\n\r\n    public override get cullFace(): Nullable<number> {\r\n        return this._cullFace;\r\n    }\r\n\r\n    public override set cullFace(value: Nullable<number>) {\r\n        if (this._cullFace === value) {\r\n            return;\r\n        }\r\n\r\n        this._cullFace = value;\r\n        this._isCullFaceDirty = true;\r\n        this._cache.setCullFace(value ?? 1);\r\n    }\r\n\r\n    public override get cull(): Nullable<boolean> {\r\n        return this._cull;\r\n    }\r\n\r\n    public override set cull(value: Nullable<boolean>) {\r\n        if (this._cull === value) {\r\n            return;\r\n        }\r\n\r\n        this._cull = value;\r\n        this._isCullDirty = true;\r\n        this._cache.setCullEnabled(!!value);\r\n    }\r\n\r\n    public override get depthFunc(): Nullable<number> {\r\n        return this._depthFunc;\r\n    }\r\n\r\n    public override set depthFunc(value: Nullable<number>) {\r\n        if (this._depthFunc === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthFunc = value;\r\n        this._isDepthFuncDirty = true;\r\n        this._cache.setDepthCompare(value);\r\n    }\r\n\r\n    public override get depthMask(): boolean {\r\n        return this._depthMask;\r\n    }\r\n\r\n    public override set depthMask(value: boolean) {\r\n        if (this._depthMask === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthMask = value;\r\n        this._isDepthMaskDirty = true;\r\n        this._cache.setDepthWriteEnabled(value);\r\n    }\r\n\r\n    public override get depthTest(): boolean {\r\n        return this._depthTest;\r\n    }\r\n\r\n    public override set depthTest(value: boolean) {\r\n        if (this._depthTest === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthTest = value;\r\n        this._isDepthTestDirty = true;\r\n        this._cache.setDepthTestEnabled(value);\r\n    }\r\n\r\n    public override get frontFace(): Nullable<number> {\r\n        return this._frontFace;\r\n    }\r\n\r\n    public override set frontFace(value: Nullable<number>) {\r\n        if (this._frontFace === value) {\r\n            return;\r\n        }\r\n\r\n        this._frontFace = value;\r\n        this._isFrontFaceDirty = true;\r\n        this._cache.setFrontFace(value ?? 2);\r\n    }\r\n\r\n    public override reset() {\r\n        super.reset();\r\n        this._cache.resetDepthCullingState();\r\n    }\r\n\r\n    public override apply() {\r\n        // nothing to do\r\n    }\r\n}\r\n", "import { Constants } from \"../../Engines/constants\";\r\nimport { InternalTexture } from \"./internalTexture\";\r\n\r\n/**\r\n * Class used to store an external texture (like GPUExternalTexture in WebGPU)\r\n */\r\nexport class ExternalTexture {\r\n    /**\r\n     * Checks if a texture is an external or internal texture\r\n     * @param texture the external or internal texture\r\n     * @returns true if the texture is an external texture, else false\r\n     */\r\n    public static IsExternalTexture(texture: ExternalTexture | InternalTexture): texture is ExternalTexture {\r\n        return (texture as ExternalTexture).underlyingResource !== undefined;\r\n    }\r\n\r\n    private _video: HTMLVideoElement;\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"ExternalTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ExternalTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying texture object\r\n     */\r\n    public get underlyingResource(): any {\r\n        return this._video;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the texture uses mipmaps\r\n     */\r\n    public useMipMaps: boolean = false;\r\n\r\n    /**\r\n     * The type of the underlying texture is implementation dependent, so return \"UNDEFINED\" for the type\r\n     */\r\n    public readonly type = Constants.TEXTURETYPE_UNDEFINED;\r\n\r\n    /**\r\n     * The format of the underlying texture is implementation dependent, so return \"UNDEFINED\" for the format\r\n     */\r\n    public readonly format = Constants.TEXTUREFORMAT_UNDEFINED;\r\n\r\n    /**\r\n     * Gets the unique id of this texture\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * Constructs the texture\r\n     * @param video The video the texture should be wrapped around\r\n     */\r\n    constructor(video: HTMLVideoElement) {\r\n        this._video = video;\r\n        this.uniqueId = InternalTexture._Counter++;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    public isReady(): boolean {\r\n        return this._video.readyState >= this._video.HAVE_CURRENT_DATA;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {}\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { IMaterialContext } from \"../IMaterialContext\";\r\nimport { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\n\r\n/** @internal */\r\ninterface IWebGPUMaterialContextSamplerCache {\r\n    sampler: Nullable<TextureSampler>;\r\n    hashCode: number;\r\n}\r\n\r\n/** @internal */\r\ninterface IWebGPUMaterialContextTextureCache {\r\n    texture: Nullable<InternalTexture | ExternalTexture>;\r\n    isFloatOrDepthTexture: boolean;\r\n    isExternalTexture: boolean;\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUMaterialContext implements IMaterialContext {\r\n    private static _Counter = 0;\r\n\r\n    public uniqueId: number;\r\n    public updateId: number;\r\n    public isDirty: boolean;\r\n    public samplers: { [name: string]: Nullable<IWebGPUMaterialContextSamplerCache> };\r\n    public textures: { [name: string]: Nullable<IWebGPUMaterialContextTextureCache> };\r\n\r\n    // The texture state is a bitfield where each bit is set if the texture is a float32 texture (calculated in @WebGPUEngine._draw).\r\n    // Float32 textures must be handled differently because float filtering may not be supported by the underlying browser implementation.\r\n    // In this case, we must configure the sampler as \"non filtering\", as well as set the texture sample type to \"unfilterable-float\" when creating the bind group layout.\r\n    // When that happens, we end up with different bind group layouts (depending on which type of textures have been set in the material), that we must all store\r\n    // in the WebGPUPipelineContext (see @WebGPUPipelineContext.bindGroupLayouts) for later retrieval in the bind group cache implementation (see @WebGPUCacheBindGroups.getBindGroups), thanks to this property.\r\n    // There's the same problem with depth textures, where \"float\" filtering is not supported either.\r\n    public textureState: number;\r\n\r\n    public useVertexPulling = false;\r\n\r\n    public get forceBindGroupCreation() {\r\n        // If there is at least one external texture to bind, we must recreate the bind groups each time\r\n        // because we need to retrieve a new texture each frame (by calling device.importExternalTexture)\r\n        return this._numExternalTextures > 0;\r\n    }\r\n\r\n    public get hasFloatOrDepthTextures() {\r\n        return this._numFloatOrDepthTextures > 0;\r\n    }\r\n\r\n    protected _numFloatOrDepthTextures: number;\r\n    protected _numExternalTextures: number;\r\n\r\n    constructor() {\r\n        this.uniqueId = WebGPUMaterialContext._Counter++;\r\n        this.updateId = 0;\r\n        this.textureState = 0;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.samplers = {};\r\n        this.textures = {};\r\n        this.isDirty = true;\r\n        this._numFloatOrDepthTextures = 0;\r\n        this._numExternalTextures = 0;\r\n    }\r\n\r\n    public setSampler(name: string, sampler: Nullable<TextureSampler>): void {\r\n        let samplerCache = this.samplers[name];\r\n        let currentHashCode = -1;\r\n        if (!samplerCache) {\r\n            this.samplers[name] = samplerCache = { sampler, hashCode: 0 };\r\n        } else {\r\n            currentHashCode = samplerCache.hashCode;\r\n        }\r\n\r\n        samplerCache.sampler = sampler;\r\n        samplerCache.hashCode = sampler ? WebGPUCacheSampler.GetSamplerHashCode(sampler) : 0;\r\n\r\n        const isDirty = currentHashCode !== samplerCache.hashCode;\r\n        if (isDirty) {\r\n            this.updateId++;\r\n        }\r\n\r\n        this.isDirty ||= isDirty;\r\n    }\r\n\r\n    public setTexture(name: string, texture: Nullable<InternalTexture | ExternalTexture>): void {\r\n        let textureCache = this.textures[name];\r\n        let currentTextureId = -1;\r\n        if (!textureCache) {\r\n            this.textures[name] = textureCache = { texture, isFloatOrDepthTexture: false, isExternalTexture: false };\r\n        } else {\r\n            currentTextureId = textureCache.texture?.uniqueId ?? -1;\r\n        }\r\n\r\n        if (textureCache.isExternalTexture) {\r\n            this._numExternalTextures--;\r\n        }\r\n        if (textureCache.isFloatOrDepthTexture) {\r\n            this._numFloatOrDepthTextures--;\r\n        }\r\n\r\n        if (texture) {\r\n            textureCache.isFloatOrDepthTexture =\r\n                texture.type === Constants.TEXTURETYPE_FLOAT ||\r\n                (texture.format >= Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 && texture.format <= Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8);\r\n            textureCache.isExternalTexture = ExternalTexture.IsExternalTexture(texture);\r\n            if (textureCache.isFloatOrDepthTexture) {\r\n                this._numFloatOrDepthTextures++;\r\n            }\r\n            if (textureCache.isExternalTexture) {\r\n                this._numExternalTextures++;\r\n            }\r\n        } else {\r\n            textureCache.isFloatOrDepthTexture = false;\r\n            textureCache.isExternalTexture = false;\r\n        }\r\n\r\n        textureCache.texture = texture;\r\n\r\n        const isDirty = currentTextureId !== (texture?.uniqueId ?? -1);\r\n        if (isDirty) {\r\n            this.updateId++;\r\n        }\r\n\r\n        this.isDirty ||= isDirty;\r\n    }\r\n}\r\n", "import type { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport type { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IDrawContext } from \"../IDrawContext\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\n\r\n/**\r\n * WebGPU implementation of the IDrawContext interface.\r\n * This class manages the draw context for WebGPU, including buffers and indirect draw data.\r\n */\r\nexport class WebGPUDrawContext implements IDrawContext {\r\n    private static _Counter = 0;\r\n\r\n    /**\r\n     * Bundle used in fast mode (when compatibilityMode==false)\r\n     */\r\n    public fastBundle?: GPURenderBundle;\r\n    /**\r\n     * Cache of the bind groups. Will be reused for the next draw if isDirty==false (and materialContext.isDirty==false)\r\n     */\r\n    public bindGroups?: GPUBindGroup[];\r\n\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * @internal\r\n     * By default, indirect draws are enabled in NON compatibility mode only\r\n     * To enable indirect draws in compatibility mode (done by the end user), enableIndirectDraw must be set to true\r\n     */\r\n    public _enableIndirectDrawInCompatMode = false;\r\n\r\n    /**\r\n     * Buffers (uniform / storage) used for the draw call\r\n     */\r\n    public buffers: { [name: string]: Nullable<WebGPUDataBuffer> };\r\n\r\n    public indirectDrawBuffer?: GPUBuffer;\r\n\r\n    private _materialContextUpdateId: number;\r\n    private _bufferManager: WebGPUBufferManager;\r\n    private _useInstancing: boolean;\r\n    private _indirectDrawData?: Uint32Array;\r\n    private _currentInstanceCount: number;\r\n    private _isDirty: boolean;\r\n    private _enableIndirectDraw: boolean;\r\n    private _vertexPullingEnabled: boolean;\r\n\r\n    /**\r\n     * Checks if the draw context is dirty.\r\n     * @param materialContextUpdateId The update ID of the material context associated with the draw context.\r\n     * @returns True if the draw or material context is dirty, false otherwise.\r\n     */\r\n    public isDirty(materialContextUpdateId: number): boolean {\r\n        return this._isDirty || this._materialContextUpdateId !== materialContextUpdateId;\r\n    }\r\n\r\n    /**\r\n     * Resets the dirty state of the draw context.\r\n     * @param materialContextUpdateId The update ID of the material context associated with the draw context.\r\n     */\r\n    public resetIsDirty(materialContextUpdateId: number): void {\r\n        this._isDirty = false;\r\n        this._materialContextUpdateId = materialContextUpdateId;\r\n    }\r\n\r\n    public get enableIndirectDraw() {\r\n        return this._enableIndirectDraw;\r\n    }\r\n\r\n    public set enableIndirectDraw(enable: boolean) {\r\n        this._enableIndirectDrawInCompatMode = true;\r\n\r\n        if (this._enableIndirectDraw === enable) {\r\n            return;\r\n        }\r\n\r\n        this._enableIndirectDraw = enable;\r\n\r\n        if (!enable && !this._useInstancing && this.indirectDrawBuffer) {\r\n            this._bufferManager.releaseBuffer(this.indirectDrawBuffer);\r\n            this.indirectDrawBuffer = undefined;\r\n            this._indirectDrawData = undefined;\r\n        } else if (enable && !this.indirectDrawBuffer) {\r\n            this.indirectDrawBuffer = this._bufferManager.createRawBuffer(\r\n                20,\r\n                WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.Indirect | WebGPUConstants.BufferUsage.Storage,\r\n                undefined,\r\n                \"IndirectDrawBuffer\"\r\n            );\r\n            this._indirectDrawData = new Uint32Array(5);\r\n            this._indirectDrawData[3] = 0;\r\n            this._indirectDrawData[4] = 0;\r\n        }\r\n    }\r\n\r\n    public get useInstancing() {\r\n        return this._useInstancing;\r\n    }\r\n\r\n    public set useInstancing(use: boolean) {\r\n        if (this._useInstancing === use) {\r\n            return;\r\n        }\r\n\r\n        this._useInstancing = use;\r\n        this._currentInstanceCount = -1;\r\n\r\n        const enableIndirectDrawInCompatMode = this._enableIndirectDrawInCompatMode;\r\n\r\n        this.enableIndirectDraw = use;\r\n\r\n        this._enableIndirectDrawInCompatMode = enableIndirectDrawInCompatMode;\r\n    }\r\n\r\n    /**\r\n     * Creates a new WebGPUDrawContext.\r\n     * @param bufferManager The buffer manager used to manage WebGPU buffers.\r\n     * @param _dummyIndexBuffer A dummy index buffer to be bound as the \"indices\"\r\n     * storage buffer when no index buffer is provided.\r\n     */\r\n    constructor(\r\n        bufferManager: WebGPUBufferManager,\r\n        private _dummyIndexBuffer: WebGPUDataBuffer\r\n    ) {\r\n        this._bufferManager = bufferManager;\r\n        this.uniqueId = WebGPUDrawContext._Counter++;\r\n        this._useInstancing = false;\r\n        this._currentInstanceCount = 0;\r\n        this._enableIndirectDraw = false;\r\n        this._vertexPullingEnabled = false;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.buffers = {};\r\n        this._isDirty = true;\r\n        this._materialContextUpdateId = 0;\r\n        this.fastBundle = undefined;\r\n        this.bindGroups = undefined;\r\n        this._vertexPullingEnabled = false;\r\n    }\r\n\r\n    /**\r\n     * Associates a buffer to the draw context.\r\n     * @param name The name of the buffer.\r\n     * @param buffer The buffer to set.\r\n     */\r\n    public setBuffer(name: string, buffer: Nullable<WebGPUDataBuffer>): void {\r\n        this._isDirty ||= buffer?.uniqueId !== this.buffers[name]?.uniqueId;\r\n\r\n        this.buffers[name] = buffer;\r\n    }\r\n\r\n    public setIndirectData(indexOrVertexCount: number, instanceCount: number, firstIndexOrVertex: number, forceUpdate = false): void {\r\n        if ((!forceUpdate && instanceCount === this._currentInstanceCount) || !this.indirectDrawBuffer || !this._indirectDrawData) {\r\n            // The current buffer is already up to date so do nothing\r\n            // Note that we only check for instanceCount and not indexOrVertexCount nor firstIndexOrVertex because those values\r\n            // are supposed to not change during the lifetime of a draw context\r\n            return;\r\n        }\r\n        this._currentInstanceCount = instanceCount;\r\n\r\n        this._indirectDrawData[0] = indexOrVertexCount;\r\n        this._indirectDrawData[1] = instanceCount;\r\n        this._indirectDrawData[2] = firstIndexOrVertex;\r\n\r\n        this._bufferManager.setRawData(this.indirectDrawBuffer, 0, this._indirectDrawData, 0, 20);\r\n    }\r\n\r\n    public setVertexPulling(\r\n        useVertexPulling: boolean,\r\n        webgpuPipelineContext: WebGPUPipelineContext,\r\n        vertexBuffers: { [key: string]: Nullable<VertexBuffer> },\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        overrideVertexBuffers: Nullable<{ [kind: string]: Nullable<VertexBuffer> }>\r\n    ): void {\r\n        if (this._vertexPullingEnabled === useVertexPulling) {\r\n            return;\r\n        }\r\n\r\n        this._vertexPullingEnabled = useVertexPulling;\r\n        this._isDirty = true;\r\n\r\n        const bufferNames = webgpuPipelineContext.shaderProcessingContext.bufferNames;\r\n\r\n        if (overrideVertexBuffers) {\r\n            for (const attributeName in overrideVertexBuffers) {\r\n                const vertexBuffer = overrideVertexBuffers[attributeName];\r\n                if (!vertexBuffer || bufferNames.indexOf(attributeName) === -1) {\r\n                    continue;\r\n                }\r\n\r\n                const buffer = vertexBuffer.effectiveBuffer as Nullable<WebGPUDataBuffer>;\r\n\r\n                this.setBuffer(attributeName, useVertexPulling ? buffer : null);\r\n            }\r\n        }\r\n\r\n        for (const attributeName in vertexBuffers) {\r\n            if (overrideVertexBuffers && attributeName in overrideVertexBuffers) {\r\n                continue;\r\n            }\r\n\r\n            const vertexBuffer = vertexBuffers[attributeName];\r\n            if (!vertexBuffer || bufferNames.indexOf(attributeName) === -1) {\r\n                continue;\r\n            }\r\n\r\n            const buffer = vertexBuffer.effectiveBuffer as Nullable<WebGPUDataBuffer>;\r\n\r\n            this.setBuffer(attributeName, useVertexPulling ? buffer : null);\r\n        }\r\n\r\n        if (bufferNames.indexOf(\"indices\") !== -1) {\r\n            this.setBuffer(\"indices\", !useVertexPulling ? null : ((indexBuffer as WebGPUDataBuffer) ?? this._dummyIndexBuffer));\r\n        }\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (this.indirectDrawBuffer) {\r\n            this._bufferManager.releaseBuffer(this.indirectDrawBuffer);\r\n            this.indirectDrawBuffer = undefined;\r\n            this._indirectDrawData = undefined;\r\n        }\r\n        this.fastBundle = undefined;\r\n        this.bindGroups = undefined;\r\n        this.buffers = undefined as any;\r\n        this._enableIndirectDraw = false;\r\n    }\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\nimport type { WebGPUMaterialContext } from \"./webgpuMaterialContext\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { WebGPUDrawContext } from \"./webgpuDrawContext\";\r\n\r\n/**\r\n * Sampler hash codes are 19 bits long, so using a start value of 2^20 for buffer ids will ensure we can't have any collision with the sampler hash codes\r\n */\r\nconst BufferIdStart = 1 << 20;\r\n\r\n/**\r\n * textureIdStart is added to texture ids to ensure we can't have any collision with the buffer ids / sampler hash codes.\r\n * 2^35 for textureIdStart means we can have:\r\n * - 2^(35-20) = 2^15 = 32768 possible buffer ids\r\n * - 2^(53-35) = 2^18 = 524288 possible texture ids\r\n */\r\nconst TextureIdStart = 2 ** 35;\r\n\r\nclass WebGPUBindGroupCacheNode {\r\n    public values: { [id: number]: WebGPUBindGroupCacheNode };\r\n    public bindGroups: GPUBindGroup[];\r\n\r\n    constructor() {\r\n        this.values = {};\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUCacheBindGroups {\r\n    public static NumBindGroupsCreatedTotal = 0;\r\n    public static NumBindGroupsCreatedLastFrame = 0;\r\n    public static NumBindGroupsLookupLastFrame = 0;\r\n    public static NumBindGroupsNoLookupLastFrame = 0;\r\n\r\n    private static _Cache: WebGPUBindGroupCacheNode = new WebGPUBindGroupCacheNode();\r\n\r\n    private static _NumBindGroupsCreatedCurrentFrame = 0;\r\n    private static _NumBindGroupsLookupCurrentFrame = 0;\r\n    private static _NumBindGroupsNoLookupCurrentFrame = 0;\r\n\r\n    private _device: GPUDevice;\r\n    private _cacheSampler: WebGPUCacheSampler;\r\n    private _engine: WebGPUEngine;\r\n\r\n    public disabled = false;\r\n\r\n    public static get Statistics() {\r\n        return {\r\n            totalCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedTotal,\r\n            lastFrameCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame,\r\n            lookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame,\r\n            noLookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame,\r\n        };\r\n    }\r\n\r\n    public static ResetCache() {\r\n        WebGPUCacheBindGroups._Cache = new WebGPUBindGroupCacheNode();\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedTotal = 0;\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = 0;\r\n        WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = 0;\r\n        WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\r\n    }\r\n\r\n    constructor(device: GPUDevice, cacheSampler: WebGPUCacheSampler, engine: WebGPUEngine) {\r\n        this._device = device;\r\n        this._cacheSampler = cacheSampler;\r\n        this._engine = engine;\r\n    }\r\n\r\n    public endFrame(): void {\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame;\r\n        WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame;\r\n        WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\r\n    }\r\n\r\n    /**\r\n     * Cache is currently based on the uniform/storage buffers, samplers and textures used by the binding groups.\r\n     * Note that all uniform buffers have an offset of 0 in Babylon and we don't have a use case where we would have the same buffer used with different capacity values:\r\n     * that means we don't need to factor in the offset/size of the buffer in the cache, only the id\r\n     * @param webgpuPipelineContext\r\n     * @param drawContext\r\n     * @param materialContext\r\n     * @returns a bind group array\r\n     */\r\n    public getBindGroups(webgpuPipelineContext: WebGPUPipelineContext, drawContext: WebGPUDrawContext, materialContext: WebGPUMaterialContext): GPUBindGroup[] {\r\n        let bindGroups: GPUBindGroup[] | undefined = undefined;\r\n        let node = WebGPUCacheBindGroups._Cache;\r\n\r\n        const cacheIsDisabled = this.disabled || materialContext.forceBindGroupCreation;\r\n        if (!cacheIsDisabled) {\r\n            if (!drawContext.isDirty(materialContext.updateId) && !materialContext.isDirty) {\r\n                WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame++;\r\n                return drawContext.bindGroups!;\r\n            }\r\n\r\n            for (const bufferName of webgpuPipelineContext.shaderProcessingContext.bufferNames) {\r\n                const uboId = (drawContext.buffers[bufferName]?.uniqueId ?? 0) + BufferIdStart;\r\n                let nextNode = node.values[uboId];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[uboId] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            for (const samplerName of webgpuPipelineContext.shaderProcessingContext.samplerNames) {\r\n                const samplerHashCode = materialContext.samplers[samplerName]?.hashCode ?? 0;\r\n                let nextNode = node.values[samplerHashCode];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[samplerHashCode] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            for (const textureName of webgpuPipelineContext.shaderProcessingContext.textureNames) {\r\n                const textureId = (materialContext.textures[textureName]?.texture?.uniqueId ?? 0) + TextureIdStart;\r\n                let nextNode = node.values[textureId];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[textureId] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            bindGroups = node.bindGroups;\r\n        }\r\n\r\n        drawContext.resetIsDirty(materialContext.updateId);\r\n        materialContext.isDirty = false;\r\n\r\n        if (bindGroups) {\r\n            drawContext.bindGroups = bindGroups;\r\n            WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame++;\r\n            return bindGroups;\r\n        }\r\n\r\n        bindGroups = [];\r\n        drawContext.bindGroups = bindGroups;\r\n\r\n        if (!cacheIsDisabled) {\r\n            node.bindGroups = bindGroups;\r\n        }\r\n\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedTotal++;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame++;\r\n\r\n        const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts[materialContext.textureState];\r\n        for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i];\r\n\r\n            const entries = webgpuPipelineContext.shaderProcessingContext.bindGroupEntries[i];\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i][j];\r\n                const entryInfo = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding];\r\n                const name = entryInfo.nameInArrayOfTexture ?? entryInfo.name;\r\n\r\n                if (entry.sampler) {\r\n                    const bindingInfo = materialContext.samplers[name];\r\n                    if (bindingInfo) {\r\n                        const sampler = bindingInfo.sampler;\r\n                        if (!sampler) {\r\n                            if (this._engine.dbgSanityChecks) {\r\n                                Logger.Error(\r\n                                    `Trying to bind a null sampler! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                        bindingInfo,\r\n                                        (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                    )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                    50\r\n                                );\r\n                            }\r\n                            continue;\r\n                        }\r\n                        entries[j].resource = this._cacheSampler.getSampler(sampler, false, bindingInfo.hashCode, sampler.label);\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Sampler \"${name}\" not found in the material context. Make sure you bound it. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(\r\n                                materialContext,\r\n                                (key: string, value: any) => (key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.texture || entry.storageTexture) {\r\n                    const bindingInfo = materialContext.textures[name];\r\n                    if (bindingInfo) {\r\n                        if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null texture! name=\"${name}\", entry=${JSON.stringify(entry)}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n                        const hardwareTexture = (bindingInfo.texture as InternalTexture)._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n                        if (\r\n                            this._engine.dbgSanityChecks &&\r\n                            (!hardwareTexture || (entry.texture && !hardwareTexture.view) || (entry.storageTexture && !hardwareTexture.viewForWriting))\r\n                        ) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null gpu texture or view! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        entries[j].resource = entry.storageTexture ? hardwareTexture.viewForWriting! : hardwareTexture.view!;\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Texture \"${name}\" not found in the material context. Make sure you bound it (something like effect.setTexture(\"${name}\", texture)). entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(\r\n                                materialContext,\r\n                                (key: string, value: any) => (key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.externalTexture) {\r\n                    const bindingInfo = materialContext.textures[name];\r\n                    if (bindingInfo) {\r\n                        if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n                        const externalTexture = (bindingInfo.texture as ExternalTexture).underlyingResource;\r\n\r\n                        if (this._engine.dbgSanityChecks && !externalTexture) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null gpu external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        entries[j].resource = this._device.importExternalTexture({ source: externalTexture });\r\n                    } else {\r\n                        Logger.Error(\r\n                            `External texture \"${name}\" not found in the material context. Make sure you bound it. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(\r\n                                materialContext,\r\n                                (key: string, value: any) => (key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.buffer) {\r\n                    const dataBuffer = drawContext.buffers[name];\r\n                    if (dataBuffer) {\r\n                        const webgpuBuffer = dataBuffer.underlyingResource as GPUBuffer;\r\n                        (entries[j].resource as GPUBufferBinding).buffer = webgpuBuffer;\r\n                        (entries[j].resource as GPUBufferBinding).size = dataBuffer.capacity;\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Can't find buffer \"${name}\" in the draw context. Make sure you bound it. entry=${JSON.stringify(entry)}, buffers=${JSON.stringify(drawContext.buffers)}, drawContext.uniqueId=${\r\n                                drawContext.uniqueId\r\n                            }`,\r\n                            50\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            const groupLayout = bindGroupLayouts[i];\r\n            bindGroups[i] = this._device.createBindGroup({\r\n                layout: groupLayout,\r\n                entries,\r\n            });\r\n        }\r\n\r\n        return bindGroups;\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"clearQuadVertexShader\";\nconst shader = `uniform depthValue: f32;const pos=array(\nvec2f(-1.0,1.0),\nvec2f(1.0,1.0),\nvec2f(-1.0,-1.0),\nvec2f(1.0,-1.0)\n);\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvertexOutputs.position=vec4f(pos[input.vertexIndex],uniforms.depthValue,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const clearQuadVertexShaderWGSL = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"clearQuadPixelShader\";\nconst shader = `uniform color: vec4f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=uniforms.color;}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const clearQuadPixelShaderWGSL = { name, shader };\n", "import type { Effect } from \"../../Materials/effect\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { IColor4Like } from \"../../Maths/math.like\";\r\nimport type { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUCacheRenderPipeline } from \"./webgpuCacheRenderPipeline\";\r\nimport { WebGPUCacheRenderPipelineTree } from \"./webgpuCacheRenderPipelineTree\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\nimport { renderableTextureFormatToIndex } from \"./webgpuTextureManager\";\r\n\r\nimport \"../../ShadersWGSL/clearQuad.vertex\";\r\nimport \"../../ShadersWGSL/clearQuad.fragment\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\n/** @internal */\r\nexport class WebGPUClearQuad {\r\n    private _device: GPUDevice;\r\n    private _engine: WebGPUEngine;\r\n    private _cacheRenderPipeline: WebGPUCacheRenderPipeline;\r\n    private _effect: Effect;\r\n    private _bindGroups: { [id: string]: GPUBindGroup[] } = {};\r\n    private _depthTextureFormat: GPUTextureFormat | undefined;\r\n    private _bundleCache: { [key: string]: GPURenderBundle } = {};\r\n    private _keyTemp: number[] = [];\r\n\r\n    public setDepthStencilFormat(format: GPUTextureFormat | undefined): void {\r\n        this._depthTextureFormat = format;\r\n        this._cacheRenderPipeline.setDepthStencilFormat(format);\r\n    }\r\n\r\n    public setColorFormat(format: GPUTextureFormat | null): void {\r\n        this._cacheRenderPipeline.setColorFormat(format);\r\n    }\r\n\r\n    public setMRTAttachments(attachments: number[], textureArray: InternalTexture[], textureCount: number): void {\r\n        this._cacheRenderPipeline.setMRT(textureArray, textureCount);\r\n        this._cacheRenderPipeline.setMRTAttachments(attachments);\r\n    }\r\n\r\n    constructor(device: GPUDevice, engine: WebGPUEngine, emptyVertexBuffer: VertexBuffer) {\r\n        this._device = device;\r\n        this._engine = engine;\r\n\r\n        this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, emptyVertexBuffer);\r\n        this._cacheRenderPipeline.setDepthTestEnabled(false);\r\n        this._cacheRenderPipeline.setStencilReadMask(0xff);\r\n\r\n        this._effect = engine.createEffect(\"clearQuad\", [], [\"color\", \"depthValue\"], undefined, undefined, undefined, undefined, undefined, undefined, ShaderLanguage.WGSL);\r\n    }\r\n\r\n    public clear(\r\n        renderPass: Nullable<GPURenderPassEncoder>,\r\n        clearColor?: Nullable<IColor4Like>,\r\n        clearDepth?: boolean,\r\n        clearStencil?: boolean,\r\n        sampleCount = 1\r\n    ): Nullable<GPURenderBundle> {\r\n        let renderPass2: GPURenderPassEncoder | GPURenderBundleEncoder;\r\n        let bundle: Nullable<GPURenderBundle> = null;\r\n        let bundleKey: string;\r\n\r\n        const isRTTPass = !!this._engine._currentRenderTarget;\r\n\r\n        if (renderPass) {\r\n            renderPass2 = renderPass;\r\n        } else {\r\n            let idx = 0;\r\n            this._keyTemp.length = 0;\r\n            for (let i = 0; i < this._cacheRenderPipeline.colorFormats.length; ++i) {\r\n                this._keyTemp[idx++] = renderableTextureFormatToIndex[this._cacheRenderPipeline.colorFormats[i] ?? \"\"];\r\n            }\r\n\r\n            const depthStencilFormatIndex = renderableTextureFormatToIndex[this._depthTextureFormat ?? 0];\r\n\r\n            this._keyTemp[idx] =\r\n                (clearColor ? clearColor.r + clearColor.g * 256 + clearColor.b * 256 * 256 + clearColor.a * 256 * 256 * 256 : 0) +\r\n                (clearDepth ? 2 ** 32 : 0) +\r\n                (clearStencil ? 2 ** 33 : 0) +\r\n                (this._engine.useReverseDepthBuffer ? 2 ** 34 : 0) +\r\n                (isRTTPass ? 2 ** 35 : 0) +\r\n                (sampleCount > 1 ? 2 ** 36 : 0) +\r\n                depthStencilFormatIndex * 2 ** 37;\r\n\r\n            bundleKey = this._keyTemp.join(\"_\");\r\n            bundle = this._bundleCache[bundleKey];\r\n\r\n            if (bundle) {\r\n                return bundle;\r\n            }\r\n\r\n            renderPass2 = this._device.createRenderBundleEncoder({\r\n                label: \"clearQuadRenderBundle\",\r\n                colorFormats: this._cacheRenderPipeline.colorFormats,\r\n                depthStencilFormat: this._depthTextureFormat,\r\n                sampleCount: WebGPUTextureHelper.GetSample(sampleCount),\r\n            });\r\n        }\r\n\r\n        this._cacheRenderPipeline.setDepthWriteEnabled(!!clearDepth);\r\n        this._cacheRenderPipeline.setStencilEnabled(!!clearStencil && !!this._depthTextureFormat && WebGPUTextureHelper.HasStencilAspect(this._depthTextureFormat));\r\n        this._cacheRenderPipeline.setStencilWriteMask(clearStencil ? 0xff : 0);\r\n        this._cacheRenderPipeline.setStencilCompare(clearStencil ? Constants.ALWAYS : Constants.NEVER);\r\n        this._cacheRenderPipeline.setStencilPassOp(clearStencil ? Constants.REPLACE : Constants.KEEP);\r\n        this._cacheRenderPipeline.setWriteMask(clearColor ? 0xf : 0);\r\n\r\n        const pipeline = this._cacheRenderPipeline.getRenderPipeline(Constants.MATERIAL_TriangleStripDrawMode, this._effect, sampleCount);\r\n\r\n        const webgpuPipelineContext = this._effect._pipelineContext as WebGPUPipelineContext;\r\n\r\n        if (clearColor) {\r\n            this._effect.setDirectColor4(\"color\", clearColor);\r\n        }\r\n\r\n        this._effect.setFloat(\"depthValue\", this._engine.useReverseDepthBuffer ? this._engine._clearReverseDepthValue : this._engine._clearDepthValue);\r\n\r\n        webgpuPipelineContext.uniformBuffer!.update();\r\n\r\n        const bufferInternals = isRTTPass ? this._engine._ubInvertY : this._engine._ubDontInvertY;\r\n        const bufferLeftOver = webgpuPipelineContext.uniformBuffer!.getBuffer() as WebGPUDataBuffer;\r\n\r\n        const key = bufferLeftOver.uniqueId + \"-\" + bufferInternals.uniqueId;\r\n\r\n        let bindGroups = this._bindGroups[key];\r\n\r\n        if (!bindGroups) {\r\n            const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts[0];\r\n            bindGroups = this._bindGroups[key] = [];\r\n            bindGroups.push(\r\n                this._device.createBindGroup({\r\n                    label: `clearQuadBindGroup0-${key}`,\r\n                    layout: bindGroupLayouts[0],\r\n                    entries: [],\r\n                })\r\n            );\r\n            if (!WebGPUShaderProcessingContext._SimplifiedKnownBindings) {\r\n                bindGroups.push(\r\n                    this._device.createBindGroup({\r\n                        label: `clearQuadBindGroup1-${key}`,\r\n                        layout: bindGroupLayouts[1],\r\n                        entries: [],\r\n                    })\r\n                );\r\n            }\r\n            bindGroups.push(\r\n                this._device.createBindGroup({\r\n                    label: `clearQuadBindGroup${WebGPUShaderProcessingContext._SimplifiedKnownBindings ? 1 : 2}-${key}`,\r\n                    layout: bindGroupLayouts[WebGPUShaderProcessingContext._SimplifiedKnownBindings ? 1 : 2],\r\n                    entries: [\r\n                        {\r\n                            binding: 0,\r\n                            resource: {\r\n                                buffer: bufferInternals.underlyingResource,\r\n                                size: bufferInternals.capacity,\r\n                            },\r\n                        },\r\n                        {\r\n                            binding: 1,\r\n                            resource: {\r\n                                buffer: bufferLeftOver.underlyingResource,\r\n                                size: bufferLeftOver.capacity,\r\n                            },\r\n                        },\r\n                    ],\r\n                })\r\n            );\r\n        }\r\n\r\n        renderPass2.setPipeline(pipeline);\r\n        for (let i = 0; i < bindGroups.length; ++i) {\r\n            renderPass2.setBindGroup(i, bindGroups[i]);\r\n        }\r\n        renderPass2.draw(4, 1, 0, 0);\r\n\r\n        if (!renderPass) {\r\n            bundle = (renderPass2 as GPURenderBundleEncoder).finish();\r\n            this._bundleCache[bundleKey!] = bundle;\r\n        }\r\n\r\n        return bundle;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\n\r\n/** @internal */\r\ninterface IWebGPURenderItem {\r\n    run(renderPass: GPURenderPassEncoder): void;\r\n    clone(): IWebGPURenderItem;\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemViewport implements IWebGPURenderItem {\r\n    public x: number;\r\n    public y: number;\r\n    public w: number;\r\n    public h: number;\r\n\r\n    public constructor(x: number, y: number, w: number, h: number) {\r\n        this.x = Math.floor(x);\r\n        this.y = Math.floor(y);\r\n        this.w = Math.floor(w);\r\n        this.h = Math.floor(h);\r\n    }\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.setViewport(this.x, this.y, this.w, this.h, 0, 1);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemViewport {\r\n        return new WebGPURenderItemViewport(this.x, this.y, this.w, this.h);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemScissor implements IWebGPURenderItem {\r\n    public constructor(\r\n        public x: number,\r\n        public y: number,\r\n        public w: number,\r\n        public h: number\r\n    ) {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.setScissorRect(this.x, this.y, this.w, this.h);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemScissor {\r\n        return new WebGPURenderItemScissor(this.x, this.y, this.w, this.h);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemStencilRef implements IWebGPURenderItem {\r\n    public constructor(public ref: number) {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.setStencilReference(this.ref);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemStencilRef {\r\n        return new WebGPURenderItemStencilRef(this.ref);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemBlendColor implements IWebGPURenderItem {\r\n    public constructor(public color: Nullable<number>[]) {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.setBlendConstant(this.color as GPUColor);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemBlendColor {\r\n        return new WebGPURenderItemBlendColor(this.color);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemBeginOcclusionQuery implements IWebGPURenderItem {\r\n    public constructor(public query: number) {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.beginOcclusionQuery(this.query);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemBeginOcclusionQuery {\r\n        return new WebGPURenderItemBeginOcclusionQuery(this.query);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemEndOcclusionQuery implements IWebGPURenderItem {\r\n    public constructor() {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.endOcclusionQuery();\r\n    }\r\n\r\n    public clone(): WebGPURenderItemEndOcclusionQuery {\r\n        return new WebGPURenderItemEndOcclusionQuery();\r\n    }\r\n}\r\n\r\nclass WebGPURenderItemBundles implements IWebGPURenderItem {\r\n    public bundles: GPURenderBundle[];\r\n\r\n    public constructor() {\r\n        this.bundles = [];\r\n    }\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.executeBundles(this.bundles);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemBundles {\r\n        const cloned = new WebGPURenderItemBundles();\r\n        cloned.bundles = this.bundles;\r\n        return cloned;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUBundleList {\r\n    private _device: GPUDevice;\r\n    private _bundleEncoder: GPURenderBundleEncoder | undefined;\r\n\r\n    private _list: IWebGPURenderItem[];\r\n    private _listLength: number;\r\n\r\n    private _currentItemIsBundle: boolean;\r\n    private _currentBundleList: GPURenderBundle[];\r\n\r\n    public numDrawCalls = 0;\r\n\r\n    public constructor(device: GPUDevice) {\r\n        this._device = device;\r\n        this._list = new Array(10);\r\n        this._listLength = 0;\r\n    }\r\n\r\n    public addBundle(bundle?: GPURenderBundle): void {\r\n        if (!this._currentItemIsBundle) {\r\n            const item = new WebGPURenderItemBundles();\r\n\r\n            this._list[this._listLength++] = item;\r\n            this._currentBundleList = item.bundles;\r\n            this._currentItemIsBundle = true;\r\n        }\r\n        if (bundle) {\r\n            this._currentBundleList.push(bundle);\r\n        }\r\n    }\r\n\r\n    private _finishBundle(): void {\r\n        if (this._currentItemIsBundle && this._bundleEncoder) {\r\n            this._currentBundleList.push(this._bundleEncoder.finish());\r\n            this._bundleEncoder = undefined;\r\n            this._currentItemIsBundle = false;\r\n        }\r\n    }\r\n\r\n    public addItem(item: IWebGPURenderItem) {\r\n        this._finishBundle();\r\n        this._list[this._listLength++] = item;\r\n        this._currentItemIsBundle = false;\r\n    }\r\n\r\n    public getBundleEncoder(colorFormats: (GPUTextureFormat | null)[], depthStencilFormat: GPUTextureFormat | undefined, sampleCount: number): GPURenderBundleEncoder {\r\n        if (!this._currentItemIsBundle) {\r\n            this.addBundle();\r\n            this._bundleEncoder = this._device.createRenderBundleEncoder({\r\n                colorFormats,\r\n                depthStencilFormat,\r\n                sampleCount: WebGPUTextureHelper.GetSample(sampleCount),\r\n            });\r\n        }\r\n        return this._bundleEncoder!;\r\n    }\r\n\r\n    public close(): void {\r\n        this._finishBundle();\r\n    }\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        this.close();\r\n        for (let i = 0; i < this._listLength; ++i) {\r\n            this._list[i].run(renderPass);\r\n        }\r\n    }\r\n\r\n    public reset() {\r\n        this._listLength = 0;\r\n        this._currentItemIsBundle = false;\r\n        this.numDrawCalls = 0;\r\n    }\r\n\r\n    public clone(): WebGPUBundleList {\r\n        this.close();\r\n\r\n        const cloned = new WebGPUBundleList(this._device);\r\n\r\n        cloned._list = new Array(this._listLength);\r\n        cloned._listLength = this._listLength;\r\n        cloned.numDrawCalls = this.numDrawCalls;\r\n\r\n        for (let i = 0; i < this._listLength; ++i) {\r\n            cloned._list[i] = this._list[i].clone();\r\n        }\r\n\r\n        return cloned;\r\n    }\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { QueryType } from \"./webgpuConstants\";\r\n\r\n/** @internal */\r\nexport class WebGPUQuerySet {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _bufferManager: WebGPUBufferManager;\r\n\r\n    private _count: number;\r\n    private _canUseMultipleBuffers: boolean;\r\n    private _querySet: GPUQuerySet;\r\n    private _queryBuffer: GPUBuffer;\r\n    private _dstBuffers: GPUBuffer[] = [];\r\n\r\n    public get querySet(): GPUQuerySet {\r\n        return this._querySet;\r\n    }\r\n\r\n    constructor(engine: WebGPUEngine, count: number, type: QueryType, device: GPUDevice, bufferManager: WebGPUBufferManager, canUseMultipleBuffers = true, label?: string) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n        this._bufferManager = bufferManager;\r\n        this._count = count;\r\n        this._canUseMultipleBuffers = canUseMultipleBuffers;\r\n\r\n        this._querySet = device.createQuerySet({\r\n            label: label ?? \"QuerySet\",\r\n            type,\r\n            count,\r\n        });\r\n\r\n        this._queryBuffer = bufferManager.createRawBuffer(8 * count, WebGPUConstants.BufferUsage.QueryResolve | WebGPUConstants.BufferUsage.CopySrc, undefined, \"QueryBuffer\");\r\n\r\n        if (!canUseMultipleBuffers) {\r\n            this._dstBuffers.push(\r\n                this._bufferManager.createRawBuffer(\r\n                    8 * this._count,\r\n                    WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst,\r\n                    undefined,\r\n                    \"QueryBufferNoMultipleBuffers\"\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    private _getBuffer(firstQuery: number, queryCount: number): GPUBuffer | null {\r\n        if (!this._canUseMultipleBuffers && this._dstBuffers.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        const encoderResult = this._device.createCommandEncoder();\r\n\r\n        let buffer: GPUBuffer;\r\n        if (this._dstBuffers.length === 0) {\r\n            buffer = this._bufferManager.createRawBuffer(\r\n                8 * this._count,\r\n                WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst,\r\n                undefined,\r\n                \"QueryBufferAdditionalBuffer\"\r\n            );\r\n        } else {\r\n            buffer = this._dstBuffers[this._dstBuffers.length - 1];\r\n            this._dstBuffers.length--;\r\n        }\r\n\r\n        encoderResult.resolveQuerySet(this._querySet, firstQuery, queryCount, this._queryBuffer, 0);\r\n        encoderResult.copyBufferToBuffer(this._queryBuffer, 0, buffer, 0, 8 * queryCount);\r\n\r\n        this._device.queue.submit([encoderResult.finish()]);\r\n\r\n        return buffer;\r\n    }\r\n\r\n    public async readValues(firstQuery = 0, queryCount = 1): Promise<BigUint64Array | null> {\r\n        const buffer = this._getBuffer(firstQuery, queryCount);\r\n        if (buffer === null) {\r\n            return null;\r\n        }\r\n        const engineId = this._engine.uniqueId;\r\n\r\n        try {\r\n            await buffer.mapAsync(WebGPUConstants.MapMode.Read);\r\n            const arrayBuf = new BigUint64Array(buffer.getMappedRange()).slice();\r\n\r\n            buffer.unmap();\r\n\r\n            this._dstBuffers[this._dstBuffers.length] = buffer;\r\n\r\n            return arrayBuf;\r\n        } catch (err) {\r\n            if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {\r\n                // Engine disposed or context loss/restoration\r\n                return null;\r\n            }\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    public async readValue(firstQuery = 0): Promise<number | null> {\r\n        const buffer = this._getBuffer(firstQuery, 1);\r\n        if (buffer === null) {\r\n            return null;\r\n        }\r\n        const engineId = this._engine.uniqueId;\r\n\r\n        try {\r\n            await buffer.mapAsync(WebGPUConstants.MapMode.Read);\r\n            const arrayBuf = new BigUint64Array(buffer.getMappedRange());\r\n            const value = Number(arrayBuf[0]);\r\n\r\n            buffer.unmap();\r\n\r\n            this._dstBuffers[this._dstBuffers.length] = buffer;\r\n\r\n            return value;\r\n        } catch (err) {\r\n            if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {\r\n                // Engine disposed or context loss/restoration\r\n                return 0;\r\n            }\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    public async readTwoValuesAndSubtract(firstQuery = 0): Promise<number | null> {\r\n        const buffer = this._getBuffer(firstQuery, 2);\r\n        if (buffer === null) {\r\n            return null;\r\n        }\r\n        const engineId = this._engine.uniqueId;\r\n\r\n        try {\r\n            await buffer.mapAsync(WebGPUConstants.MapMode.Read);\r\n            const arrayBuf = new BigUint64Array(buffer.getMappedRange());\r\n            const value = Number(arrayBuf[1] - arrayBuf[0]);\r\n\r\n            buffer.unmap();\r\n\r\n            this._dstBuffers[this._dstBuffers.length] = buffer;\r\n\r\n            return value;\r\n        } catch (err) {\r\n            if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {\r\n                // Engine disposed or context loss/restoration\r\n                return 0;\r\n            }\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    public dispose() {\r\n        this._querySet.destroy();\r\n        this._bufferManager.releaseBuffer(this._queryBuffer);\r\n        for (let i = 0; i < this._dstBuffers.length; ++i) {\r\n            this._bufferManager.releaseBuffer(this._dstBuffers[i]);\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { PerfCounter } from \"../../Misc/perfCounter\";\r\nimport { WebGPUQuerySet } from \"./webgpuQuerySet\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUPerfCounter } from \"./webgpuPerfCounter\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/** @internal */\r\nexport class WebGPUTimestampQuery {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _bufferManager: WebGPUBufferManager;\r\n\r\n    private _enabled = false;\r\n    private _gpuFrameTimeCounter: PerfCounter = new PerfCounter();\r\n    private _measureDuration: WebGPUDurationMeasure;\r\n    private _measureDurationState = 0;\r\n\r\n    public get gpuFrameTimeCounter() {\r\n        return this._gpuFrameTimeCounter;\r\n    }\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice, bufferManager: WebGPUBufferManager) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n        this._bufferManager = bufferManager;\r\n    }\r\n\r\n    public get enable(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public set enable(value: boolean) {\r\n        if (this._enabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._enabled = value;\r\n        this._measureDurationState = 0;\r\n        if (value) {\r\n            try {\r\n                this._measureDuration = new WebGPUDurationMeasure(this._engine, this._device, this._bufferManager, 2000, \"QuerySet_TimestampQuery\");\r\n            } catch (e) {\r\n                this._enabled = false;\r\n                Logger.Error(\"Could not create a WebGPUDurationMeasure!\\nError: \" + e.message + \"\\nMake sure timestamp query is supported and enabled in your browser.\");\r\n                return;\r\n            }\r\n        } else {\r\n            this._measureDuration.dispose();\r\n        }\r\n    }\r\n\r\n    public startFrame(commandEncoder: GPUCommandEncoder): void {\r\n        if (this._enabled && this._measureDurationState === 0) {\r\n            this._measureDuration.start(commandEncoder);\r\n            this._measureDurationState = 1;\r\n        }\r\n    }\r\n\r\n    public endFrame(commandEncoder: GPUCommandEncoder): void {\r\n        if (this._measureDurationState === 1) {\r\n            this._measureDurationState = 2;\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            this._measureDuration.stop(commandEncoder).then((duration) => {\r\n                if (duration !== null && duration >= 0) {\r\n                    this._gpuFrameTimeCounter.fetchNewFrame();\r\n                    this._gpuFrameTimeCounter.addCount(duration, true);\r\n                }\r\n                this._measureDurationState = 0;\r\n            });\r\n        }\r\n    }\r\n\r\n    public startPass(descriptor: GPURenderPassDescriptor | GPUComputePassDescriptor, index: number): void {\r\n        if (this._enabled) {\r\n            this._measureDuration.startPass(descriptor, index);\r\n        } else {\r\n            descriptor.timestampWrites = undefined;\r\n        }\r\n    }\r\n\r\n    public endPass(index: number, gpuPerfCounter?: WebGPUPerfCounter): void {\r\n        if (!this._enabled || !gpuPerfCounter) {\r\n            return;\r\n        }\r\n\r\n        const currentFrameId = this._engine.frameId;\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n        this._measureDuration.stopPass(index).then((duration_) => {\r\n            gpuPerfCounter._addDuration(currentFrameId, duration_ !== null && duration_ > 0 ? duration_ : 0);\r\n        });\r\n    }\r\n\r\n    public dispose() {\r\n        this._measureDuration?.dispose();\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUDurationMeasure {\r\n    private _querySet: WebGPUQuerySet;\r\n    private _count: number;\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice, bufferManager: WebGPUBufferManager, count = 2, querySetLabel?: string) {\r\n        this._count = count;\r\n        this._querySet = new WebGPUQuerySet(engine, count, WebGPUConstants.QueryType.Timestamp, device, bufferManager, true, querySetLabel);\r\n    }\r\n\r\n    public start(encoder: GPUCommandEncoder): void {\r\n        encoder.writeTimestamp?.(this._querySet.querySet, 0);\r\n    }\r\n\r\n    public async stop(encoder: GPUCommandEncoder): Promise<number | null> {\r\n        encoder.writeTimestamp?.(this._querySet.querySet, 1);\r\n\r\n        return encoder.writeTimestamp ? await this._querySet.readTwoValuesAndSubtract(0) : 0;\r\n    }\r\n\r\n    public startPass(descriptor: GPURenderPassDescriptor | GPUComputePassDescriptor, index: number): void {\r\n        if (index + 3 > this._count) {\r\n            throw new Error(\"WebGPUDurationMeasure: index out of range (\" + index + \")\");\r\n        }\r\n\r\n        descriptor.timestampWrites = {\r\n            querySet: this._querySet.querySet,\r\n            beginningOfPassWriteIndex: index + 2,\r\n            endOfPassWriteIndex: index + 3,\r\n        };\r\n    }\r\n\r\n    public async stopPass(index: number): Promise<number | null> {\r\n        return await this._querySet.readTwoValuesAndSubtract(index + 2);\r\n    }\r\n\r\n    public dispose() {\r\n        this._querySet.dispose();\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { WebGPUQuerySet } from \"./webgpuQuerySet\";\r\n\r\n/** @internal */\r\nexport class WebGPUOcclusionQuery {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _bufferManager: WebGPUBufferManager;\r\n\r\n    private _currentTotalIndices: number;\r\n    private _countIncrement: number;\r\n    private _querySet: WebGPUQuerySet;\r\n    private _availableIndices: number[] = [];\r\n    private _lastBuffer: Nullable<BigUint64Array>;\r\n    private _frameLastBuffer: number;\r\n    private _frameQuerySetIsDirty = -1;\r\n    private _queryFrameId: number[] = [];\r\n\r\n    public get querySet(): GPUQuerySet {\r\n        return this._querySet.querySet;\r\n    }\r\n\r\n    public get hasQueries(): boolean {\r\n        return this._currentTotalIndices !== this._availableIndices.length;\r\n    }\r\n\r\n    public canBeginQuery(index: number): boolean {\r\n        if (this._frameQuerySetIsDirty === this._engine.frameId || this._queryFrameId[index] === this._engine.frameId) {\r\n            return false;\r\n        }\r\n\r\n        const canBegin = this._engine._getCurrentRenderPassWrapper().renderPassDescriptor!.occlusionQuerySet !== undefined;\r\n\r\n        if (canBegin) {\r\n            this._queryFrameId[index] = this._engine.frameId;\r\n        }\r\n\r\n        return canBegin;\r\n    }\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice, bufferManager: WebGPUBufferManager, startCount = 50, incrementCount = 100) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n        this._bufferManager = bufferManager;\r\n\r\n        this._frameLastBuffer = -1;\r\n        this._currentTotalIndices = 0;\r\n        this._countIncrement = incrementCount;\r\n\r\n        this._allocateNewIndices(startCount);\r\n    }\r\n\r\n    public createQuery(): number {\r\n        if (this._availableIndices.length === 0) {\r\n            this._allocateNewIndices();\r\n        }\r\n\r\n        const index = this._availableIndices[this._availableIndices.length - 1];\r\n        this._availableIndices.length--;\r\n\r\n        return index;\r\n    }\r\n\r\n    public deleteQuery(index: number): void {\r\n        this._availableIndices[this._availableIndices.length] = index;\r\n    }\r\n\r\n    public isQueryResultAvailable(index: number): boolean {\r\n        this._retrieveQueryBuffer();\r\n\r\n        return !!this._lastBuffer && index < this._lastBuffer.length;\r\n    }\r\n\r\n    public getQueryResult(index: number): number {\r\n        return Number(this._lastBuffer?.[index] ?? -1);\r\n    }\r\n\r\n    private _retrieveQueryBuffer(): void {\r\n        if (this._lastBuffer && this._frameLastBuffer === this._engine.frameId) {\r\n            return;\r\n        }\r\n\r\n        if (this._frameLastBuffer !== this._engine.frameId) {\r\n            this._frameLastBuffer = this._engine.frameId;\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            this._querySet.readValues(0, this._currentTotalIndices).then((arrayBuffer) => {\r\n                this._lastBuffer = arrayBuffer;\r\n            });\r\n        }\r\n    }\r\n\r\n    private _allocateNewIndices(numIndices?: number): void {\r\n        numIndices = numIndices ?? this._countIncrement;\r\n\r\n        this._delayQuerySetDispose();\r\n\r\n        for (let i = 0; i < numIndices; ++i) {\r\n            this._availableIndices.push(this._currentTotalIndices + i);\r\n        }\r\n\r\n        this._currentTotalIndices += numIndices;\r\n        this._querySet = new WebGPUQuerySet(\r\n            this._engine,\r\n            this._currentTotalIndices,\r\n            WebGPUConstants.QueryType.Occlusion,\r\n            this._device,\r\n            this._bufferManager,\r\n            false,\r\n            \"QuerySet_OcclusionQuery_count_\" + this._currentTotalIndices\r\n        );\r\n\r\n        this._frameQuerySetIsDirty = this._engine.frameId;\r\n    }\r\n\r\n    private _delayQuerySetDispose(): void {\r\n        const querySet = this._querySet;\r\n        if (querySet) {\r\n            // Wait a bit before disposing of the queryset, in case some queries are still running for it\r\n            setTimeout(() => querySet.dispose, 1000);\r\n        }\r\n    }\r\n\r\n    public dispose(): void {\r\n        this._querySet?.dispose();\r\n        this._availableIndices.length = 0;\r\n    }\r\n}\r\n", "import { Logger } from \"core/Misc/logger\";\r\nimport { EscapeRegExp, ExtractBetweenMarkers, FindBackward, IsIdentifierChar, RemoveComments, SkipWhitespaces } from \"../../Misc/codeStringParsingTools\";\r\n\r\ninterface IInlineFunctionDescr {\r\n    name: string;\r\n    type: string;\r\n    parameters: string[];\r\n    body: string;\r\n    callIndex: number;\r\n}\r\n\r\n/**\r\n * Class used to inline functions in shader code\r\n */\r\nexport class ShaderCodeInliner {\r\n    private static readonly _RegexpFindFunctionNameAndType = /((\\s+?)(\\w+)\\s+(\\w+)\\s*?)$/;\r\n\r\n    private _sourceCode: string;\r\n    private _functionDescr: IInlineFunctionDescr[];\r\n    private _numMaxIterations: number;\r\n\r\n    /** Gets or sets the token used to mark the functions to inline */\r\n    public inlineToken: string;\r\n\r\n    /** Gets or sets the debug mode */\r\n    public debug: boolean = false;\r\n\r\n    /** Gets the code after the inlining process */\r\n    public get code(): string {\r\n        return this._sourceCode;\r\n    }\r\n\r\n    /**\r\n     * Initializes the inliner\r\n     * @param sourceCode shader code source to inline\r\n     * @param numMaxIterations maximum number of iterations (used to detect recursive calls)\r\n     */\r\n    constructor(sourceCode: string, numMaxIterations = 20) {\r\n        this._sourceCode = sourceCode;\r\n        this._numMaxIterations = numMaxIterations;\r\n        this._functionDescr = [];\r\n        this.inlineToken = \"#define inline\";\r\n    }\r\n\r\n    /**\r\n     * Start the processing of the shader code\r\n     */\r\n    public processCode() {\r\n        if (this.debug) {\r\n            Logger.Log(`Start inlining process (code size=${this._sourceCode.length})...`);\r\n        }\r\n        this._collectFunctions();\r\n        this._processInlining(this._numMaxIterations);\r\n        if (this.debug) {\r\n            Logger.Log(\"End of inlining process.\");\r\n        }\r\n    }\r\n\r\n    private _collectFunctions() {\r\n        let startIndex = 0;\r\n\r\n        while (startIndex < this._sourceCode.length) {\r\n            // locate the function to inline and extract its name\r\n            const inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);\r\n            if (inlineTokenIndex < 0) {\r\n                break;\r\n            }\r\n\r\n            const funcParamsStartIndex = this._sourceCode.indexOf(\"(\", inlineTokenIndex + this.inlineToken.length);\r\n            if (funcParamsStartIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not find the opening parenthesis after the token. startIndex=${startIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(\r\n                this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)\r\n            );\r\n            if (!funcNameMatch) {\r\n                if (this.debug) {\r\n                    Logger.Warn(\r\n                        `Could not extract the name/type of the function from: ${this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)}`\r\n                    );\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const [funcType, funcName] = [funcNameMatch[3], funcNameMatch[4]];\r\n\r\n            // extract the parameters of the function as a whole string (without the leading / trailing parenthesis)\r\n            const funcParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, funcParamsStartIndex);\r\n            if (funcParamsEndIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the parameters the function '${funcName}' (type=${funcType}). funcParamsStartIndex=${funcParamsStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex);\r\n\r\n            // extract the body of the function (with the curly brackets)\r\n            const funcBodyStartIndex = SkipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);\r\n            if (funcBodyStartIndex === this._sourceCode.length) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcParamsEndIndex=${funcParamsEndIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcBodyEndIndex = ExtractBetweenMarkers(\"{\", \"}\", this._sourceCode, funcBodyStartIndex);\r\n            if (funcBodyEndIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcBodyStartIndex=${funcBodyStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1);\r\n\r\n            // process the parameters: extract each names\r\n            const params = RemoveComments(funcParams).split(\",\");\r\n            const paramNames = [];\r\n\r\n            for (let p = 0; p < params.length; ++p) {\r\n                const param = params[p].trim();\r\n                const idx = param.lastIndexOf(\" \");\r\n\r\n                if (idx >= 0) {\r\n                    paramNames.push(param.substring(idx + 1));\r\n                }\r\n            }\r\n\r\n            if (funcType !== \"void\") {\r\n                // for functions that return a value, we will replace \"return\" by \"tempvarname = \", tempvarname being a unique generated name\r\n                paramNames.push(\"return\");\r\n            }\r\n\r\n            // collect the function\r\n            this._functionDescr.push({\r\n                name: funcName,\r\n                type: funcType,\r\n                parameters: paramNames,\r\n                body: funcBody,\r\n                callIndex: 0,\r\n            });\r\n\r\n            startIndex = funcBodyEndIndex + 1;\r\n\r\n            // remove the function from the source code\r\n            const partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : \"\";\r\n            const partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : \"\";\r\n\r\n            this._sourceCode = partBefore + partAfter;\r\n\r\n            startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;\r\n        }\r\n\r\n        if (this.debug) {\r\n            Logger.Log(`Collect functions: ${this._functionDescr.length} functions found. functionDescr=${this._functionDescr}`);\r\n        }\r\n    }\r\n\r\n    private _processInlining(numMaxIterations: number = 20): boolean {\r\n        while (numMaxIterations-- >= 0) {\r\n            if (!this._replaceFunctionCallsByCode()) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (this.debug) {\r\n            Logger.Log(`numMaxIterations is ${numMaxIterations} after inlining process`);\r\n        }\r\n\r\n        return numMaxIterations >= 0;\r\n    }\r\n\r\n    private _replaceFunctionCallsByCode(): boolean {\r\n        let doAgain = false;\r\n\r\n        for (const func of this._functionDescr) {\r\n            const { name, type, parameters, body } = func;\r\n\r\n            let startIndex = 0;\r\n\r\n            while (startIndex < this._sourceCode.length) {\r\n                // Look for the function name in the source code\r\n                const functionCallIndex = this._sourceCode.indexOf(name, startIndex);\r\n\r\n                if (functionCallIndex < 0) {\r\n                    break;\r\n                }\r\n\r\n                // Make sure \"name\" is not part of a bigger string\r\n                if (functionCallIndex === 0 || IsIdentifierChar(this._sourceCode.charAt(functionCallIndex - 1))) {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // Find the opening parenthesis\r\n                const callParamsStartIndex = SkipWhitespaces(this._sourceCode, functionCallIndex + name.length);\r\n                if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== \"(\") {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // extract the parameters of the function call as a whole string (without the leading / trailing parenthesis)\r\n                const callParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, callParamsStartIndex);\r\n                if (callParamsEndIndex < 0) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(`Could not extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}`);\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n                const callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex);\r\n\r\n                // process the parameter call: extract each names\r\n\r\n                // this function split the parameter list used in the function call at ',' boundaries by taking care of potential parenthesis like in:\r\n                //      myfunc(a, vec2(1., 0.), 4.)\r\n                const splitParameterCall = (s: string) => {\r\n                    const parameters = [];\r\n                    let curIdx = 0,\r\n                        startParamIdx = 0;\r\n                    while (curIdx < s.length) {\r\n                        if (s.charAt(curIdx) === \"(\") {\r\n                            const idx2 = ExtractBetweenMarkers(\"(\", \")\", s, curIdx);\r\n                            if (idx2 < 0) {\r\n                                return null;\r\n                            }\r\n                            curIdx = idx2;\r\n                        } else if (s.charAt(curIdx) === \",\") {\r\n                            parameters.push(s.substring(startParamIdx, curIdx));\r\n                            startParamIdx = curIdx + 1;\r\n                        }\r\n                        curIdx++;\r\n                    }\r\n                    if (startParamIdx < curIdx) {\r\n                        parameters.push(s.substring(startParamIdx, curIdx));\r\n                    }\r\n                    return parameters;\r\n                };\r\n\r\n                const params = splitParameterCall(RemoveComments(callParams));\r\n\r\n                if (params === null) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(\r\n                            `Invalid function call: can't extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}, callParams=` +\r\n                                callParams\r\n                        );\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                const paramNames = [];\r\n\r\n                for (let p = 0; p < params.length; ++p) {\r\n                    const param = params[p].trim();\r\n                    paramNames.push(param);\r\n                }\r\n\r\n                const retParamName = type !== \"void\" ? name + \"_\" + func.callIndex++ : null;\r\n\r\n                if (retParamName) {\r\n                    paramNames.push(retParamName + \" =\");\r\n                }\r\n\r\n                if (paramNames.length !== parameters.length) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(\r\n                            `Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '${name}' (type=${type}). function parameters=${parameters}, call parameters=${paramNames}`\r\n                        );\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                startIndex = callParamsEndIndex + 1;\r\n\r\n                // replace the function call by the body function\r\n                const funcBody = this._replaceNames(body, parameters, paramNames);\r\n\r\n                let partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : \"\";\r\n                const partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : \"\";\r\n\r\n                if (retParamName) {\r\n                    // case where the function returns a value. We generate:\r\n                    // FUNCTYPE retParamName;\r\n                    // {function body}\r\n                    // and replace the function call by retParamName\r\n                    const injectDeclarationIndex = FindBackward(this._sourceCode, functionCallIndex - 1, \"\\n\", \"{\");\r\n\r\n                    partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);\r\n                    const partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);\r\n\r\n                    this._sourceCode = partBefore + type + \" \" + retParamName + \";\\n\" + funcBody + \"\\n\" + partBetween + retParamName + partAfter;\r\n\r\n                    if (this.debug) {\r\n                        Logger.Log(\r\n                            `Replace function call by code. Function '${name}' (type=${type}). injectDeclarationIndex=${injectDeclarationIndex}, call parameters=${paramNames}`\r\n                        );\r\n                    }\r\n                } else {\r\n                    // simple case where the return value of the function is \"void\"\r\n                    this._sourceCode = partBefore + funcBody + partAfter;\r\n\r\n                    startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);\r\n\r\n                    if (this.debug) {\r\n                        Logger.Log(`Replace function call by code. Function '${name}' (type=${type}). functionCallIndex=${functionCallIndex}, call parameters=${paramNames}`);\r\n                    }\r\n                }\r\n\r\n                doAgain = true;\r\n            }\r\n        }\r\n\r\n        return doAgain;\r\n    }\r\n\r\n    private _replaceNames(code: string, sources: string[], destinations: string[]): string {\r\n        for (let i = 0; i < sources.length; ++i) {\r\n            const source = new RegExp(EscapeRegExp(sources[i]), \"g\"),\r\n                sourceLen = sources[i].length,\r\n                destination = destinations[i];\r\n\r\n            code = code.replace(source, (match, ...args) => {\r\n                const offset: number = args[0];\r\n                // Make sure \"source\" is not part of a bigger identifier (for eg, if source=view and we matched it with viewDirection)\r\n                if (IsIdentifierChar(code.charAt(offset - 1)) || IsIdentifierChar(code.charAt(offset + sourceLen))) {\r\n                    return sources[i];\r\n                }\r\n                return destination;\r\n            });\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n", "import { Logger } from \"core/Misc/logger\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Options to load the associated Twgsl library\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface TwgslOptions {\r\n    /**\r\n     * Defines an existing instance of Twgsl (useful in modules who do not access the global instance).\r\n     */\r\n    twgsl?: any;\r\n    /**\r\n     * Defines the URL of the twgsl JS File.\r\n     */\r\n    jsPath?: string;\r\n    /**\r\n     * Defines the URL of the twgsl WASM File.\r\n     */\r\n    wasmPath?: string;\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUTintWASM {\r\n    // Default twgsl options.\r\n    private static readonly _TwgslDefaultOptions: TwgslOptions = {\r\n        jsPath: `${Tools._DefaultCdnUrl}/twgsl/twgsl.js`,\r\n        wasmPath: `${Tools._DefaultCdnUrl}/twgsl/twgsl.wasm`,\r\n    };\r\n\r\n    public static ShowWGSLShaderCode = false;\r\n\r\n    public static DisableUniformityAnalysis = false;\r\n\r\n    private static _Twgsl: any = null;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public async initTwgsl(twgslOptions?: TwgslOptions): Promise<void> {\r\n        if (WebGPUTintWASM._Twgsl) {\r\n            return;\r\n        }\r\n\r\n        twgslOptions = twgslOptions || {};\r\n        twgslOptions = {\r\n            ...WebGPUTintWASM._TwgslDefaultOptions,\r\n            ...twgslOptions,\r\n        };\r\n\r\n        if (twgslOptions.twgsl) {\r\n            WebGPUTintWASM._Twgsl = twgslOptions.twgsl;\r\n            return;\r\n        }\r\n\r\n        if (twgslOptions.jsPath && twgslOptions.wasmPath) {\r\n            await Tools.LoadBabylonScriptAsync(twgslOptions.jsPath);\r\n        }\r\n\r\n        if ((self as any).twgsl) {\r\n            // eslint-disable-next-line require-atomic-updates\r\n            WebGPUTintWASM._Twgsl = await (self as any).twgsl(Tools.GetBabylonScriptURL(twgslOptions.wasmPath!));\r\n            return;\r\n        }\r\n\r\n        throw new Error(\"twgsl is not available.\");\r\n    }\r\n\r\n    public convertSpirV2WGSL(code: Uint32Array, disableUniformityAnalysis = false): string {\r\n        const ccode = WebGPUTintWASM._Twgsl.convertSpirV2WGSL(code, WebGPUTintWASM.DisableUniformityAnalysis || disableUniformityAnalysis);\r\n        if (WebGPUTintWASM.ShowWGSLShaderCode) {\r\n            Logger.Log(ccode);\r\n            Logger.Log(\"***********************************************\");\r\n        }\r\n        return WebGPUTintWASM.DisableUniformityAnalysis || disableUniformityAnalysis ? \"diagnostic(off, derivative_uniformity);\\n\" + ccode : ccode;\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUBundleList } from \"./webgpuBundleList\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/** @internal */\r\nexport class WebGPUSnapshotRendering {\r\n    private _engine: WebGPUEngine;\r\n\r\n    private _record = false;\r\n    private _play = false;\r\n    private _playBundleListIndex = 0;\r\n    private _allBundleLists: WebGPUBundleList[] = [];\r\n    private _modeSaved: number;\r\n    private _bundleList: WebGPUBundleList;\r\n\r\n    private _enabled = false;\r\n    private _mode: number;\r\n\r\n    constructor(engine: WebGPUEngine, renderingMode: number, bundleList: WebGPUBundleList) {\r\n        this._engine = engine;\r\n        this._mode = renderingMode;\r\n        this._bundleList = bundleList;\r\n    }\r\n\r\n    public showDebugLogs = false;\r\n\r\n    public get enabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public get play() {\r\n        return this._play;\r\n    }\r\n\r\n    public get record() {\r\n        return this._record;\r\n    }\r\n\r\n    public set enabled(activate: boolean) {\r\n        this._log(\"enabled\", `activate=${activate}, mode=${this._mode}`);\r\n\r\n        this._allBundleLists.length = 0;\r\n        this._record = this._enabled = activate;\r\n        this._play = false;\r\n        if (activate) {\r\n            this._modeSaved = this._mode;\r\n            this._mode = Constants.SNAPSHOTRENDERING_STANDARD; // need to reset to standard for the recording pass to avoid some code being bypassed\r\n        }\r\n    }\r\n\r\n    public get mode(): number {\r\n        return this._mode;\r\n    }\r\n\r\n    public set mode(mode: number) {\r\n        if (this._record) {\r\n            this._modeSaved = mode;\r\n        } else {\r\n            this._mode = mode;\r\n        }\r\n    }\r\n\r\n    public endRenderPass(currentRenderPass: GPURenderPassEncoder): boolean {\r\n        if (!this._record && !this._play) {\r\n            // Snapshot rendering mode is not enabled\r\n            return false;\r\n        }\r\n\r\n        let bundleList: Nullable<WebGPUBundleList> = null;\r\n\r\n        if (this._record) {\r\n            bundleList = this._bundleList.clone();\r\n            this._allBundleLists.push(bundleList);\r\n            this._bundleList.reset();\r\n            this._log(\"endRenderPass\", `bundleList recorded at position #${this._allBundleLists.length - 1}`);\r\n        } else {\r\n            // We are playing the snapshot\r\n            if (this._playBundleListIndex >= this._allBundleLists.length) {\r\n                this._log(\r\n                    \"endRenderPass\",\r\n                    `empty or out-of-sync bundleList (_allBundleLists.length=${this._allBundleLists.length}, playBundleListIndex=${this._playBundleListIndex})`\r\n                );\r\n            } else {\r\n                this._log(\"endRenderPass\", `run bundleList #${this._playBundleListIndex}`);\r\n                bundleList = this._allBundleLists[this._playBundleListIndex++];\r\n            }\r\n        }\r\n\r\n        if (bundleList) {\r\n            bundleList.run(currentRenderPass);\r\n\r\n            if (this._mode === Constants.SNAPSHOTRENDERING_FAST) {\r\n                this._engine._reportDrawCall(bundleList.numDrawCalls);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public endFrame(): void {\r\n        if (this._record) {\r\n            // We stop recording and switch to replay mode for the next frames\r\n            this._record = false;\r\n            this._play = true;\r\n            this._mode = this._modeSaved;\r\n            this._log(\"endFrame\", \"bundles recorded, switching to play mode\");\r\n        }\r\n\r\n        this._playBundleListIndex = 0;\r\n    }\r\n\r\n    public reset(): void {\r\n        this._log(\"reset\", \"called\");\r\n        if (this._record) {\r\n            this._mode = this._modeSaved;\r\n        }\r\n        this.enabled = false;\r\n        this.enabled = true;\r\n    }\r\n\r\n    private _log(funcName: string, message: string) {\r\n        if (this.showDebugLogs) {\r\n            Logger.Log(`[Frame: ${this._engine.frameId}] WebGPUSnapshotRendering:${funcName} - ${message}`);\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { DataBuffer } from \"./dataBuffer\";\r\nimport { Buffer, VertexBuffer } from \"./buffer\";\r\nimport { GetTypeByteLength } from \"./bufferUtils\";\r\n\r\nconst IsLittleEndian = (() => {\r\n    const array = new Uint8Array(4);\r\n    const view = new Uint32Array(array.buffer);\r\n\r\n    return !!((view[0] = 1) & array[0]);\r\n})();\r\n\r\ndeclare module \"./buffer\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface VertexBuffer {\r\n        /**\r\n         * Gets the effective byte stride, that is the byte stride of the buffer that is actually sent to the GPU.\r\n         * It could be different from VertexBuffer.byteStride if a new buffer must be created under the hood because of the forceVertexBufferStrideAndOffsetMultiple4Bytes engine flag.\r\n         */\r\n        effectiveByteStride: number;\r\n\r\n        /**\r\n         * Gets the effective byte offset, that is the byte offset of the buffer that is actually sent to the GPU.\r\n         * It could be different from VertexBuffer.byteOffset if a new buffer must be created under the hood because of the forceVertexBufferStrideAndOffsetMultiple4Bytes engine flag.\r\n         */\r\n        effectiveByteOffset: number;\r\n\r\n        /**\r\n         * Gets the effective buffer, that is the buffer that is actually sent to the GPU.\r\n         * It could be different from VertexBuffer.getBuffer() if a new buffer must be created under the hood because of the forceVertexBufferStrideAndOffsetMultiple4Bytes engine flag.\r\n         */\r\n        effectiveBuffer: Nullable<DataBuffer>;\r\n\r\n        /** @internal */\r\n        _alignBuffer(): void;\r\n\r\n        /** @internal */\r\n        _alignedBuffer?: Buffer;\r\n    }\r\n}\r\n\r\nObject.defineProperty(VertexBuffer.prototype, \"effectiveByteStride\", {\r\n    get: function (this: VertexBuffer) {\r\n        return (this._alignedBuffer && this._alignedBuffer.byteStride) || this.byteStride;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(VertexBuffer.prototype, \"effectiveByteOffset\", {\r\n    get: function (this: VertexBuffer) {\r\n        return this._alignedBuffer ? 0 : this.byteOffset;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(VertexBuffer.prototype, \"effectiveBuffer\", {\r\n    get: function (this: VertexBuffer) {\r\n        return (this._alignedBuffer && this._alignedBuffer.getBuffer()) || this._buffer.getBuffer();\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nVertexBuffer.prototype._rebuild = function (): void {\r\n    this._buffer?._rebuild();\r\n    this._alignedBuffer?._rebuild();\r\n};\r\n\r\nVertexBuffer.prototype.dispose = function (): void {\r\n    if (this._ownsBuffer) {\r\n        this._buffer.dispose();\r\n    }\r\n\r\n    this._alignedBuffer?.dispose();\r\n    this._alignedBuffer = undefined;\r\n\r\n    this._isDisposed = true;\r\n};\r\n\r\nVertexBuffer.prototype.getWrapperBuffer = function (): Buffer {\r\n    return this._alignedBuffer || this._buffer;\r\n};\r\n\r\nVertexBuffer.prototype._alignBuffer = function (): void {\r\n    const data = this._buffer.getData();\r\n\r\n    if (!this.engine._features.forceVertexBufferStrideAndOffsetMultiple4Bytes || (this.byteStride % 4 === 0 && this.byteOffset % 4 === 0) || !data) {\r\n        return;\r\n    }\r\n\r\n    const typeByteLength = GetTypeByteLength(this.type);\r\n    const alignedByteStride = (this.byteStride + 3) & ~3;\r\n    const alignedSize = alignedByteStride / typeByteLength;\r\n    const totalVertices = this._maxVerticesCount;\r\n    const totalByteLength = totalVertices * alignedByteStride;\r\n    const totalLength = totalByteLength / typeByteLength;\r\n\r\n    let sourceData: DataView;\r\n\r\n    if (Array.isArray(data)) {\r\n        const sourceDataAsFloat = new Float32Array(data);\r\n        sourceData = new DataView(sourceDataAsFloat.buffer, sourceDataAsFloat.byteOffset, sourceDataAsFloat.byteLength);\r\n    } else if (data instanceof ArrayBuffer) {\r\n        sourceData = new DataView(data, 0, data.byteLength);\r\n    } else {\r\n        sourceData = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    }\r\n\r\n    let alignedData: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array;\r\n\r\n    if (this.type === VertexBuffer.BYTE) {\r\n        alignedData = new Int8Array(totalLength);\r\n    } else if (this.type === VertexBuffer.UNSIGNED_BYTE) {\r\n        alignedData = new Uint8Array(totalLength);\r\n    } else if (this.type === VertexBuffer.SHORT) {\r\n        alignedData = new Int16Array(totalLength);\r\n    } else if (this.type === VertexBuffer.UNSIGNED_SHORT) {\r\n        alignedData = new Uint16Array(totalLength);\r\n    } else if (this.type === VertexBuffer.INT) {\r\n        alignedData = new Int32Array(totalLength);\r\n    } else if (this.type === VertexBuffer.UNSIGNED_INT) {\r\n        alignedData = new Uint32Array(totalLength);\r\n    } else {\r\n        alignedData = new Float32Array(totalLength);\r\n    }\r\n\r\n    const numComponents = this.getSize();\r\n\r\n    let sourceOffset = this.byteOffset;\r\n\r\n    for (let i = 0; i < totalVertices; ++i) {\r\n        for (let j = 0; j < numComponents; ++j) {\r\n            switch (this.type) {\r\n                case VertexBuffer.BYTE:\r\n                    alignedData[i * alignedSize + j] = sourceData.getInt8(sourceOffset + j);\r\n                    break;\r\n                case VertexBuffer.UNSIGNED_BYTE:\r\n                    alignedData[i * alignedSize + j] = sourceData.getUint8(sourceOffset + j);\r\n                    break;\r\n                case VertexBuffer.SHORT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getInt16(sourceOffset + j * 2, IsLittleEndian);\r\n                    break;\r\n                case VertexBuffer.UNSIGNED_SHORT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getUint16(sourceOffset + j * 2, IsLittleEndian);\r\n                    break;\r\n                case VertexBuffer.INT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getInt32(sourceOffset + j * 4, IsLittleEndian);\r\n                    break;\r\n                case VertexBuffer.UNSIGNED_INT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getUint32(sourceOffset + j * 4, IsLittleEndian);\r\n                    break;\r\n                case VertexBuffer.FLOAT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getFloat32(sourceOffset + j * 4, IsLittleEndian);\r\n                    break;\r\n            }\r\n        }\r\n        sourceOffset += this.byteStride;\r\n    }\r\n\r\n    this._alignedBuffer?.dispose();\r\n    this._alignedBuffer = new Buffer(\r\n        this.engine,\r\n        alignedData,\r\n        false,\r\n        alignedByteStride,\r\n        false,\r\n        this.getIsInstanced(),\r\n        true,\r\n        this.instanceDivisor,\r\n        (this._label ?? \"VertexBuffer\") + \"_aligned\"\r\n    );\r\n};\r\n", "import type { Nullable } from \"../../types\";\nimport type { IAudioParameterRampOptions } from \"../audioParameter\";\nimport type { AbstractAudioNode, AbstractNamedAudioNode } from \"./abstractAudioNode\";\nimport type { AbstractSound } from \"./abstractSound\";\nimport type { AbstractSoundSource, ISoundSourceOptions } from \"./abstractSoundSource\";\nimport type { AudioBus, IAudioBusOptions } from \"./audioBus\";\nimport type { IMainAudioBusOptions, MainAudioBus } from \"./mainAudioBus\";\nimport type { IStaticSoundOptions, StaticSound } from \"./staticSound\";\nimport type { IStaticSoundBufferOptions, StaticSoundBuffer } from \"./staticSoundBuffer\";\nimport type { IStreamingSoundOptions, StreamingSound } from \"./streamingSound\";\nimport type { AbstractSpatialAudioListener, ISpatialAudioListenerOptions } from \"./subProperties/abstractSpatialAudioListener\";\n\nconst Instances: AudioEngineV2[] = [];\n\n/**\n * Gets the most recently created v2 audio engine.\n * @returns The most recently created v2 audio engine.\n */\nexport function LastCreatedAudioEngine(): Nullable<AudioEngineV2> {\n    if (Instances.length === 0) {\n        return null;\n    }\n\n    return Instances[Instances.length - 1];\n}\n\n/**\n * Options for creating a v2 audio engine.\n */\nexport interface IAudioEngineV2Options extends ISpatialAudioListenerOptions {\n    /**\n     * The smoothing duration to use when changing audio parameters, in seconds. Defaults to `0.01` (10 milliseconds).\n     */\n    parameterRampDuration: number;\n    /**\n     * The initial output volume of the audio engine. Defaults to `1`.\n     */\n    volume: number;\n}\n\n/**\n * The state of a v2 audio engine.\n * @see {@link AudioEngineV2.state}\n */\nexport type AudioEngineV2State = \"closed\" | \"interrupted\" | \"running\" | \"suspended\";\n\n/**\n * Abstract base class for v2 audio engines.\n *\n * A v2 audio engine based on the WebAudio API can be created with the {@link CreateAudioEngineAsync} function.\n */\nexport abstract class AudioEngineV2 {\n    /** Not owned, but all items should be in `_nodes` container, too, which is owned. */\n    private readonly _mainBuses = new Set<MainAudioBus>();\n    private readonly _sounds = new Set<AbstractSound>();\n    private _soundsArray: Nullable<Array<AbstractSound>> = null;\n\n    /** Owned top-level sound and bus nodes. */\n    private readonly _nodes = new Set<AbstractNamedAudioNode>();\n\n    private _defaultMainBus: Nullable<MainAudioBus> = null;\n\n    private _parameterRampDuration: number = 0.01;\n\n    protected constructor(options: Partial<IAudioEngineV2Options>) {\n        Instances.push(this);\n\n        if (typeof options.parameterRampDuration === \"number\") {\n            this.parameterRampDuration = options.parameterRampDuration;\n        }\n    }\n\n    /**\n     * The elapsed time since the audio engine was started, in seconds.\n     */\n    public abstract readonly currentTime: number;\n\n    /**\n     * The default main bus that will be used for audio buses and sounds if their `outBus` option is not set.\n     * @see {@link IAudioBusOptions.outBus}\n     * @see {@link IAbstractSoundOptions.outBus}\n     */\n    public get defaultMainBus(): Nullable<MainAudioBus> {\n        if (this._mainBuses.size === 0) {\n            return null;\n        }\n\n        if (!this._defaultMainBus) {\n            this._defaultMainBus = Array.from(this._mainBuses)[0];\n        }\n\n        return this._defaultMainBus;\n    }\n\n    /**\n     * The spatial audio listener properties for the audio engine.\n     * - Each audio engine has exactly one listener.\n     */\n    public abstract readonly listener: AbstractSpatialAudioListener;\n\n    /**\n     * The main output node.\n     * - This is the last node in the audio graph before the audio is sent to the speakers.\n     */\n    public abstract readonly mainOut: AbstractAudioNode;\n\n    /**\n     * The current state of the audio engine.\n     *\n     * Possible values are:\n     * - `\"closed\"`: The audio engine has been closed.\n     * - `\"interrupted\"`: The audio engine has been interrupted and is not running.\n     * - `\"running\"`: The audio engine is running normally.\n     * - `\"suspended\"`: The audio engine is suspended and is not running.\n     */\n    public abstract readonly state: AudioEngineV2State;\n\n    /**\n     * The output volume of the audio engine.\n     */\n    public abstract volume: number;\n\n    /**\n     * The smoothing duration to use when changing audio parameters, in seconds. Defaults to `0.01` (10 milliseconds).\n     */\n    public get parameterRampDuration(): number {\n        return this._parameterRampDuration;\n    }\n\n    public set parameterRampDuration(value: number) {\n        this._parameterRampDuration = Math.max(0, value);\n    }\n\n    /**\n     * The list of static and streaming sounds created by the audio engine.\n     */\n    public get sounds(): ReadonlyArray<AbstractSound> {\n        if (!this._soundsArray) {\n            this._soundsArray = Array.from(this._sounds);\n        }\n        return this._soundsArray;\n    }\n\n    /**\n     * Creates a new audio bus.\n     * @param name - The name of the audio bus.\n     * @param options - The options to use when creating the audio bus.\n     * @returns A promise that resolves with the created audio bus.\n     */\n    public abstract createBusAsync(name: string, options?: Partial<IAudioBusOptions>): Promise<AudioBus>;\n\n    /**\n     * Creates a new main audio bus.\n     * @param name - The name of the main audio bus.\n     * @param options - The options to use when creating the main audio bus.\n     * @returns A promise that resolves with the created main audio bus.\n     */\n    public abstract createMainBusAsync(name: string, options?: Partial<IMainAudioBusOptions>): Promise<MainAudioBus>;\n\n    /**\n     * Creates a new microphone sound source.\n     * @param name - The name of the sound.\n     * @param options - The options for the sound source.\n     * @returns A promise that resolves to the created sound source.\n     */\n    public abstract createMicrophoneSoundSourceAsync(name: string, options?: Partial<ISoundSourceOptions>): Promise<AbstractSoundSource>;\n\n    /**\n     * Creates a new static sound.\n     * @param name - The name of the sound.\n     * @param source - The source of the sound.\n     * @param options - The options for the static sound.\n     * @returns A promise that resolves to the created static sound.\n     */\n    public abstract createSoundAsync(\n        name: string,\n        source: ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[],\n        options?: Partial<IStaticSoundOptions>\n    ): Promise<StaticSound>;\n\n    /**\n     * Creates a new static sound buffer.\n     * @param source - The source of the sound buffer.\n     * @param options - The options for the static sound buffer.\n     * @returns A promise that resolves to the created static sound buffer.\n     */\n    public abstract createSoundBufferAsync(\n        source: ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[],\n        options?: Partial<IStaticSoundBufferOptions>\n    ): Promise<StaticSoundBuffer>;\n\n    /**\n     * Creates a new sound source.\n     * @param name - The name of the sound.\n     * @param source - The source of the sound.\n     * @param options - The options for the sound source.\n     * @returns A promise that resolves to the created sound source.\n     */\n    public abstract createSoundSourceAsync(name: string, source: AudioNode, options?: Partial<ISoundSourceOptions>): Promise<AbstractSoundSource>;\n\n    /**\n     * Creates a new streaming sound.\n     * @param name - The name of the sound.\n     * @param source - The source of the sound.\n     * @param options - The options for the streaming sound.\n     * @returns A promise that resolves to the created streaming sound.\n     */\n    public abstract createStreamingSoundAsync(name: string, source: HTMLMediaElement | string | string[], options?: Partial<IStreamingSoundOptions>): Promise<StreamingSound>;\n\n    /**\n     * Releases associated resources.\n     */\n    public dispose(): void {\n        if (Instances.includes(this)) {\n            Instances.splice(Instances.indexOf(this), 1);\n        }\n\n        const nodeIt = this._nodes.values();\n        for (let next = nodeIt.next(); !next.done; next = nodeIt.next()) {\n            next.value.dispose();\n        }\n\n        this._mainBuses.clear();\n        this._nodes.clear();\n        this._sounds.clear();\n\n        this._disposeSoundsArray();\n\n        this._defaultMainBus = null;\n    }\n\n    /**\n     * Checks if the specified format is valid.\n     * @param format The format to check as an audio file extension like \"mp3\" or \"wav\".\n     * @returns `true` if the format is valid; otherwise `false`.\n     */\n    public abstract isFormatValid(format: string): boolean;\n\n    /**\n     * Pauses the audio engine if it is running.\n     * @returns A promise that resolves when the audio engine is paused.\n     */\n    public abstract pauseAsync(): Promise<void>;\n\n    /**\n     * Resumes the audio engine if it is not running.\n     * @returns A promise that resolves when the audio engine is running.\n     */\n    public abstract resumeAsync(): Promise<void>;\n\n    /**\n     * Sets the audio output volume with optional ramping.\n     * If the duration is 0 then the volume is set immediately, otherwise it is ramped to the new value over the given duration using the given shape.\n     * If a ramp is already in progress then the volume is not set and an error is thrown.\n     * @param value The value to set the volume to.\n     * @param options The options to use for ramping the volume change.\n     */\n    public abstract setVolume(value: number, options?: Partial<IAudioParameterRampOptions>): void;\n\n    /**\n     * Unlocks the audio engine if it is locked.\n     * - Note that the returned promise may already be resolved if the audio engine is already unlocked.\n     * @returns A promise that is resolved when the audio engine is unlocked.\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    public unlockAsync(): Promise<void> {\n        return this.resumeAsync();\n    }\n\n    protected _addMainBus(mainBus: MainAudioBus): void {\n        this._mainBuses.add(mainBus);\n\n        this._addNode(mainBus);\n    }\n\n    protected _removeMainBus(mainBus: MainAudioBus): void {\n        this._mainBuses.delete(mainBus);\n        this._defaultMainBus = null;\n\n        this._removeNode(mainBus);\n    }\n\n    protected _addNode(node: AbstractNamedAudioNode): void {\n        this._nodes.add(node);\n    }\n\n    protected _removeNode(node: AbstractNamedAudioNode): void {\n        this._nodes.delete(node);\n    }\n\n    protected _addSound(sound: AbstractSound): void {\n        this._disposeSoundsArray();\n        this._sounds.add(sound);\n        this._addNode(sound);\n    }\n\n    protected _removeSound(sound: AbstractSound): void {\n        this._disposeSoundsArray();\n        this._sounds.delete(sound);\n        this._removeNode(sound);\n    }\n\n    private _disposeSoundsArray(): void {\n        if (this._soundsArray) {\n            this._soundsArray.length = 0;\n            this._soundsArray = null;\n        }\n    }\n}\n\n/**\n * @internal\n * @param engine - The given audio engine. If `null` then the last created audio engine is used.\n * @returns the given audio engine or the last created audio engine.\n * @throws An error if the resulting engine is `null`.\n */\nexport function _GetAudioEngine(engine: Nullable<AudioEngineV2>): AudioEngineV2 {\n    if (!engine) {\n        engine = LastCreatedAudioEngine();\n    }\n\n    if (engine) {\n        return engine;\n    }\n\n    throw new Error(\"No audio engine.\");\n}\n\n/**\n * Creates a new audio bus.\n * @param name - The name of the audio bus.\n * @param options - The options to use when creating the audio bus.\n * @param engine - The audio engine.\n * @returns A promise that resolves with the created audio bus.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateAudioBusAsync(name: string, options: Partial<IAudioBusOptions> = {}, engine: Nullable<AudioEngineV2> = null): Promise<AudioBus> {\n    engine = _GetAudioEngine(engine);\n    return engine.createBusAsync(name, options);\n}\n\n/**\n * Creates a new main audio bus.\n * @param name - The name of the main audio bus.\n * @param options - The options to use when creating the main audio bus.\n * @param engine - The audio engine.\n * @returns A promise that resolves with the created main audio bus.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateMainAudioBusAsync(name: string, options: Partial<IMainAudioBusOptions> = {}, engine: Nullable<AudioEngineV2> = null): Promise<MainAudioBus> {\n    engine = _GetAudioEngine(engine);\n    return engine.createMainBusAsync(name, options);\n}\n\n/**\n * Creates a new microphone sound source.\n * @param name - The name of the sound.\n * @param options - The options for the sound source.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created sound source.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateMicrophoneSoundSourceAsync(name: string, options: Partial<ISoundSourceOptions> = {}, engine: Nullable<AudioEngineV2> = null): Promise<AbstractSoundSource> {\n    engine = _GetAudioEngine(engine);\n    return engine.createMicrophoneSoundSourceAsync(name, options);\n}\n\n/**\n * Creates a new static sound.\n * @param name - The name of the sound.\n * @param source - The source of the sound.\n * @param options - The options for the static sound.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created static sound.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateSoundAsync(\n    name: string,\n    source: ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[],\n    options: Partial<IStaticSoundOptions> = {},\n    engine: Nullable<AudioEngineV2> = null\n): Promise<StaticSound> {\n    engine = _GetAudioEngine(engine);\n    return engine.createSoundAsync(name, source, options);\n}\n\n/**\n * Creates a new static sound buffer.\n * @param source - The source of the sound buffer.\n * @param options - The options for the static sound buffer.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created static sound buffer.\n */\nexport async function CreateSoundBufferAsync(\n    source: ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[],\n    options: Partial<IStaticSoundBufferOptions> = {},\n    engine: Nullable<AudioEngineV2> = null\n): Promise<StaticSoundBuffer> {\n    engine = _GetAudioEngine(engine);\n    return await engine.createSoundBufferAsync(source, options);\n}\n\n/**\n * Creates a new sound source.\n * @param name - The name of the sound.\n * @param source - The source of the sound.\n * @param options - The options for the sound source.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created sound source.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateSoundSourceAsync(\n    name: string,\n    source: AudioNode,\n    options: Partial<ISoundSourceOptions> = {},\n    engine: Nullable<AudioEngineV2> = null\n): Promise<AbstractSoundSource> {\n    engine = _GetAudioEngine(engine);\n    return engine.createSoundSourceAsync(name, source, options);\n}\n\n/**\n * Creates a new streaming sound.\n * @param name - The name of the sound.\n * @param source - The source of the sound.\n * @param options - The options for the streaming sound.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created streaming sound.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateStreamingSoundAsync(\n    name: string,\n    source: HTMLMediaElement | string | string[],\n    options: Partial<IStreamingSoundOptions> = {},\n    engine: Nullable<AudioEngineV2> = null\n): Promise<StreamingSound> {\n    engine = _GetAudioEngine(engine);\n    return engine.createStreamingSoundAsync(name, source, options);\n}\n", "import { Quaternion, Vector3 } from \"../../../Maths/math.vector\";\nimport type { Node } from \"../../../node\";\nimport type { Nullable } from \"../../../types\";\nimport type { SpatialAudioAttachmentType } from \"../../spatialAudioAttachmentType\";\n\nexport const _SpatialAudioListenerDefaults = {\n    position: Vector3.Zero(),\n    rotation: Vector3.Zero(),\n    rotationQuaternion: new Quaternion(),\n} as const;\n\n/**\n * Options for spatial audio.\n */\nexport interface ISpatialAudioListenerOptions {\n    /**\n     * Whether to automatically update the position and rotation of the listener. Defaults to `true`.\n     */\n    listenerAutoUpdate: boolean;\n    /**\n     * Set to `true` to enable the listener. Defaults to `false`.\n     */\n    listenerEnabled: boolean;\n    /**\n     * The minimum update time in seconds of the listener if it is attached to a mesh, scene or transform node. Defaults to `0`.\n     * - The listener's position and rotation will not update faster than this time, but they may update slower depending on the frame rate.\n     */\n    listenerMinUpdateTime: number;\n    /**\n     * The listener position. Defaults to (0, 0, 0).\n     */\n    listenerPosition: Vector3;\n    /**\n     * The listener rotation, as Euler angles. Defaults to (0, 0, 0).\n     */\n    listenerRotation: Vector3;\n    /**\n     * The listener rotation, as a quaternion. Defaults to (0, 0, 0, 1).\n     */\n    listenerRotationQuaternion: Quaternion;\n}\n\n/**\n * @param options The spatial audio listener options to check.\n * @returns `true` if spatial audio listener options are defined, otherwise `false`.\n */\nexport function _HasSpatialAudioListenerOptions(options: Partial<ISpatialAudioListenerOptions>): boolean {\n    return (\n        options.listenerEnabled ||\n        options.listenerMinUpdateTime !== undefined ||\n        options.listenerPosition !== undefined ||\n        options.listenerRotation !== undefined ||\n        options.listenerRotationQuaternion !== undefined\n    );\n}\n\n/**\n * Abstract class representing the spatial audio `listener` property on an audio engine.\n *\n * @see {@link AudioEngineV2.listener}\n */\nexport abstract class AbstractSpatialAudioListener {\n    /**\n     * Whether the listener is attached to a camera, mesh or transform node.\n     */\n    public abstract isAttached: boolean;\n\n    /**\n     * The minimum update time in seconds of the listener if it is attached to a mesh, scene or transform node. Defaults to `0`.\n     * - The listener's position and rotation will not update faster than this time, but they may update slower depending on the frame rate.\n     */\n    public abstract minUpdateTime: number;\n\n    /**\n     * The listener position. Defaults to (0, 0, 0).\n     */\n    public abstract position: Vector3;\n\n    /**\n     * The listener rotation, as Euler angles. Defaults to (0, 0, 0).\n     */\n    public abstract rotation: Vector3;\n\n    /**\n     * The listener rotation, as a quaternion. Defaults to (0, 0, 0, 1).\n     */\n    public abstract rotationQuaternion: Quaternion;\n\n    /**\n     * Attaches to a scene node.\n     *\n     * Detaches automatically before attaching to the given scene node.\n     * If `sceneNode` is `null` it is the same as calling `detach()`.\n     *\n     * @param sceneNode The scene node to attach to, or `null` to detach.\n     * @param useBoundingBox Whether to use the bounding box of the node for positioning. Defaults to `false`.\n     * @param attachmentType Whether to attach to the node's position and/or rotation. Defaults to `PositionAndRotation`.\n     */\n    public abstract attach(sceneNode: Nullable<Node>, useBoundingBox?: boolean, attachmentType?: SpatialAudioAttachmentType): void;\n\n    /**\n     * Detaches from the scene node if attached.\n     */\n    public abstract detach(): void;\n\n    /**\n     * Updates the position and rotation of the associated audio engine object in the audio rendering graph.\n     *\n     * This is called automatically by default and only needs to be called manually if automatic updates are disabled.\n     */\n    public abstract update(): void;\n}\n", "import type { Node } from \"../../../node\";\nimport type { Nullable } from \"../../../types\";\nimport { SpatialAudioAttachmentType } from \"../../spatialAudioAttachmentType\";\nimport { _SpatialAudioAttacherComponent } from \"../components/spatialAudioAttacherComponent\";\nimport type { ISpatialAudioListenerOptions } from \"./abstractSpatialAudioListener\";\nimport { _SpatialAudioListenerDefaults, AbstractSpatialAudioListener } from \"./abstractSpatialAudioListener\";\n\n/** @internal */\nexport abstract class _SpatialAudioListener extends AbstractSpatialAudioListener {\n    protected _attacherComponent: Nullable<_SpatialAudioAttacherComponent> = null;\n\n    protected constructor() {\n        super();\n\n        this._attacherComponent = new _SpatialAudioAttacherComponent(this);\n    }\n\n    /** @internal */\n    public get isAttached(): boolean {\n        return this._attacherComponent !== null && this._attacherComponent.isAttached;\n    }\n\n    /**\n     * Attaches to a scene node.\n     *\n     * Detaches automatically before attaching to the given scene node.\n     * If `sceneNode` is `null` it is the same as calling `detach()`.\n     *\n     * @param sceneNode The scene node to attach to, or `null` to detach.\n     * @param useBoundingBox Whether to use the bounding box of the node for positioning. Defaults to `false`.\n     * @param attachmentType Whether to attach to the node's position and/or rotation. Defaults to `PositionAndRotation`.\n     */\n    public attach(sceneNode: Nullable<Node>, useBoundingBox: boolean = false, attachmentType: SpatialAudioAttachmentType = SpatialAudioAttachmentType.PositionAndRotation): void {\n        if (!this._attacherComponent) {\n            this._attacherComponent = new _SpatialAudioAttacherComponent(this);\n        }\n        this._attacherComponent.attach(sceneNode, useBoundingBox, attachmentType);\n    }\n\n    /**\n     * Detaches from the scene node if attached.\n     */\n    public detach(): void {\n        this._attacherComponent?.detach();\n    }\n\n    /** @internal */\n    public dispose(): void {\n        this._attacherComponent?.dispose();\n        this._attacherComponent = null;\n    }\n\n    /** @internal */\n    public setOptions(options: Partial<ISpatialAudioListenerOptions>): void {\n        if (options.listenerMinUpdateTime !== undefined) {\n            this.minUpdateTime = options.listenerMinUpdateTime;\n        }\n\n        if (options.listenerPosition) {\n            this.position = options.listenerPosition.clone();\n        }\n\n        if (options.listenerRotationQuaternion) {\n            this.rotationQuaternion = options.listenerRotationQuaternion.clone();\n        } else if (options.listenerRotation) {\n            this.rotation = options.listenerRotation.clone();\n        } else {\n            this.rotationQuaternion = _SpatialAudioListenerDefaults.rotationQuaternion.clone();\n        }\n\n        this.update();\n    }\n\n    public abstract _updatePosition(): void;\n    public abstract _updateRotation(): void;\n}\n", "import { Matrix, Quaternion, Vector3 } from \"../../../Maths/math.vector\";\nimport { _SpatialAudioListener } from \"../../abstractAudio/subProperties/spatialAudioListener\";\nimport { _SpatialWebAudioUpdaterComponent } from \"../components/spatialWebAudioUpdaterComponent\";\nimport { _WebAudioParameterComponent } from \"../components/webAudioParameterComponent\";\nimport type { _WebAudioEngine } from \"../webAudioEngine\";\n\nconst TmpMatrix = Matrix.Zero();\nconst TmpQuaternion = new Quaternion();\nconst TmpVector1 = Vector3.Zero();\nconst TmpVector2 = Vector3.Zero();\n\n/** @internal */\nexport function _CreateSpatialAudioListener(engine: _WebAudioEngine, autoUpdate: boolean, minUpdateTime: number): _SpatialAudioListener {\n    const listener = engine._audioContext.listener;\n    if (\n        listener.forwardX &&\n        listener.forwardY &&\n        listener.forwardZ &&\n        listener.positionX &&\n        listener.positionY &&\n        listener.positionZ &&\n        listener.upX &&\n        listener.upY &&\n        listener.upZ\n    ) {\n        return new _SpatialWebAudioListener(engine, autoUpdate, minUpdateTime);\n    } else {\n        return new _SpatialWebAudioListenerFallback(engine, autoUpdate, minUpdateTime);\n    }\n}\n\nabstract class _AbstractSpatialWebAudioListener extends _SpatialAudioListener {\n    protected readonly _listener: AudioListener;\n\n    protected _lastPosition: Vector3 = Vector3.Zero();\n    protected _lastRotation: Vector3 = Vector3.Zero();\n    protected _lastRotationQuaternion: Quaternion = new Quaternion();\n    protected _updaterComponent: _SpatialWebAudioUpdaterComponent;\n\n    /** @internal */\n    public readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public readonly position: Vector3 = Vector3.Zero();\n    /** @internal */\n    public readonly rotation: Vector3 = Vector3.Zero();\n    /** @internal */\n    public readonly rotationQuaternion: Quaternion = new Quaternion();\n\n    /** @internal */\n    public constructor(engine: _WebAudioEngine, autoUpdate: boolean, minUpdateTime: number) {\n        super();\n\n        this._listener = engine._audioContext.listener;\n        this.engine = engine;\n\n        this._updaterComponent = new _SpatialWebAudioUpdaterComponent(this, autoUpdate, minUpdateTime);\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._updaterComponent.dispose();\n        this._updaterComponent = null!;\n    }\n\n    /** @internal */\n    public get minUpdateTime(): number {\n        return this._updaterComponent.minUpdateTime;\n    }\n\n    /** @internal */\n    public set minUpdateTime(value: number) {\n        this._updaterComponent.minUpdateTime = value;\n    }\n\n    /** @internal */\n    public update(): void {\n        if (this.isAttached) {\n            this._attacherComponent?.update();\n        } else {\n            this._updatePosition();\n            this._updateRotation();\n        }\n    }\n\n    public _updatePosition(): void {\n        if (this._lastPosition.equalsWithEpsilon(this.position)) {\n            return;\n        }\n\n        this._setWebAudioPosition(this.position);\n\n        this._lastPosition.copyFrom(this.position);\n    }\n\n    public _updateRotation(): void {\n        if (!this._lastRotationQuaternion.equalsWithEpsilon(this.rotationQuaternion)) {\n            TmpQuaternion.copyFrom(this.rotationQuaternion);\n            this._lastRotationQuaternion.copyFrom(this.rotationQuaternion);\n        } else if (!this._lastRotation.equalsWithEpsilon(this.rotation)) {\n            Quaternion.FromEulerAnglesToRef(this.rotation.x, this.rotation.y, this.rotation.z, TmpQuaternion);\n            this._lastRotation.copyFrom(this.rotation);\n        } else {\n            return;\n        }\n\n        Matrix.FromQuaternionToRef(TmpQuaternion, TmpMatrix);\n\n        // NB: The WebAudio API is right-handed.\n        Vector3.TransformNormalToRef(Vector3.RightHandedForwardReadOnly, TmpMatrix, TmpVector1);\n        Vector3.TransformNormalToRef(Vector3.Up(), TmpMatrix, TmpVector2);\n\n        this._setWebAudioOrientation(TmpVector1, TmpVector2);\n    }\n\n    protected abstract _setWebAudioPosition(position: Vector3): void;\n    protected abstract _setWebAudioOrientation(forward: Vector3, up: Vector3): void;\n}\n\n/**\n * Full-featured spatial audio listener for the Web Audio API.\n *\n * Used in browsers that support the `forwardX/Y/Z`, `positionX/Y/Z`, and `upX/Y/Z` properties on the AudioContext listener.\n *\n * NB: Firefox falls back to using this implementation.\n *\n * @see _SpatialWebAudioListenerFallback for the implementation used if only `setPosition` and `setOrientation` are available.\n *\n * NB: This sub property is not backed by a sub node and all properties are set directly on the audio context listener.\n *\n * @internal\n */\nclass _SpatialWebAudioListener extends _AbstractSpatialWebAudioListener {\n    private _forwardX: _WebAudioParameterComponent;\n    private _forwardY: _WebAudioParameterComponent;\n    private _forwardZ: _WebAudioParameterComponent;\n    private _positionX: _WebAudioParameterComponent;\n    private _positionY: _WebAudioParameterComponent;\n    private _positionZ: _WebAudioParameterComponent;\n    private _upX: _WebAudioParameterComponent;\n    private _upY: _WebAudioParameterComponent;\n    private _upZ: _WebAudioParameterComponent;\n\n    public constructor(engine: _WebAudioEngine, autoUpdate: boolean, minUpdateTime: number) {\n        super(engine, autoUpdate, minUpdateTime);\n\n        const listener = engine._audioContext.listener;\n        this._forwardX = new _WebAudioParameterComponent(engine, listener.forwardX);\n        this._forwardY = new _WebAudioParameterComponent(engine, listener.forwardY);\n        this._forwardZ = new _WebAudioParameterComponent(engine, listener.forwardZ);\n        this._positionX = new _WebAudioParameterComponent(engine, listener.positionX);\n        this._positionY = new _WebAudioParameterComponent(engine, listener.positionY);\n        this._positionZ = new _WebAudioParameterComponent(engine, listener.positionZ);\n        this._upX = new _WebAudioParameterComponent(engine, listener.upX);\n        this._upY = new _WebAudioParameterComponent(engine, listener.upY);\n        this._upZ = new _WebAudioParameterComponent(engine, listener.upZ);\n    }\n\n    protected override _setWebAudioPosition(position: Vector3): void {\n        // If attached and there is a ramp in progress, we assume another update is coming soon that we can wait for.\n        // We don't do this for unattached nodes because there may not be another update coming.\n        if (this.isAttached && (this._positionX.isRamping || this._positionY.isRamping || this._positionZ.isRamping)) {\n            return;\n        }\n\n        this._positionX.targetValue = position.x;\n        this._positionY.targetValue = position.y;\n        this._positionZ.targetValue = position.z;\n    }\n\n    protected override _setWebAudioOrientation(forward: Vector3, up: Vector3): void {\n        // If attached and there is a ramp in progress, we assume another update is coming soon that we can wait for.\n        // We don't do this for unattached nodes because there may not be another update coming.\n        if (\n            this.isAttached &&\n            (this._forwardX.isRamping || this._forwardY.isRamping || this._forwardZ.isRamping || this._upX.isRamping || this._upY.isRamping || this._upZ.isRamping)\n        ) {\n            return;\n        }\n\n        this._forwardX.targetValue = forward.x;\n        this._forwardY.targetValue = forward.y;\n        this._forwardZ.targetValue = forward.z;\n\n        this._upX.targetValue = up.x;\n        this._upY.targetValue = up.y;\n        this._upZ.targetValue = up.z;\n    }\n}\n\n/**\n * Fallback spatial audio listener for the Web Audio API.\n *\n * Used in browsers that do not support the `forwardX/Y/Z`, `positionX/Y/Z`, and `upX/Y/Z` properties on the\n * AudioContext listener.\n *\n * @see _SpatialWebAudioListener for the implementation used if the `forwardX/Y/Z`, `positionX/Y/Z`, and `upX/Y/Z`\n * properties are available.\n *\n * NB: This sub property is not backed by a sub node and all properties are set directly on the audio context listener.\n *\n * @internal\n */\nclass _SpatialWebAudioListenerFallback extends _AbstractSpatialWebAudioListener {\n    protected override _setWebAudioPosition(position: Vector3): void {\n        this._listener.setPosition(position.x, position.y, position.z);\n    }\n\n    protected override _setWebAudioOrientation(forward: Vector3, up: Vector3): void {\n        this._listener.setOrientation(forward.x, forward.y, forward.z, up.x, up.y, up.z);\n    }\n}\n", "import { AudioNodeType, AbstractAudioNode } from \"./abstractAudioNode\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\n\n/**\n * Abstract class for the main audio output node.\n *\n * A main audio output is the last audio node in the audio graph before the audio is sent to the speakers.\n *\n * @see {@link AudioEngineV2.mainOut}\n * @internal\n */\nexport abstract class _MainAudioOut extends AbstractAudioNode {\n    protected constructor(engine: AudioEngineV2) {\n        super(engine, AudioNodeType.HAS_INPUTS);\n    }\n}\n", "import type { Nullable } from \"../../types\";\nimport { _MainAudioOut } from \"../abstractAudio/mainAudioOut\";\nimport type { IAudioParameterRampOptions } from \"../audioParameter\";\nimport { _WebAudioParameterComponent } from \"./components/webAudioParameterComponent\";\nimport type { _WebAudioEngine } from \"./webAudioEngine\";\nimport type { IWebAudioInNode } from \"./webAudioNode\";\n\n/** @internal */\nexport class _WebAudioMainOut extends _MainAudioOut implements IWebAudioInNode {\n    private _gainNode: GainNode;\n    private _volume: _WebAudioParameterComponent;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public constructor(engine: _WebAudioEngine) {\n        super(engine);\n\n        this._setGainNode(new GainNode(engine._audioContext));\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._volume.dispose();\n        this._gainNode.disconnect();\n        this._destinationNode.disconnect();\n    }\n\n    /** @internal */\n    public get _inNode(): GainNode {\n        return this._gainNode;\n    }\n\n    public set _inNode(value: GainNode) {\n        if (this._gainNode === value) {\n            return;\n        }\n\n        this._setGainNode(value);\n    }\n\n    /** @internal */\n    public get volume(): number {\n        return this._volume.targetValue;\n    }\n\n    /** @internal */\n    public set volume(value: number) {\n        this._volume.targetValue = value;\n    }\n\n    private get _destinationNode(): AudioNode {\n        return this.engine._audioDestination;\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioMainOut\";\n    }\n\n    /** @internal */\n    public setVolume(value: number, options: Nullable<Partial<IAudioParameterRampOptions>> = null): void {\n        this._volume.setTargetValue(value, options);\n    }\n\n    private _setGainNode(gainNode: GainNode): void {\n        if (this._gainNode === gainNode) {\n            return;\n        }\n\n        this._gainNode?.disconnect();\n        gainNode.connect(this._destinationNode);\n\n        this._volume = new _WebAudioParameterComponent(this.engine, gainNode.gain);\n\n        this._gainNode = gainNode;\n    }\n}\n", "import type { Nullable } from \"../../types\";\nimport { EngineStore } from \"../../Engines/engineStore\";\nimport type { _WebAudioEngine } from \"./webAudioEngine\";\n\n/**\n * Adds a UI button that starts the audio engine's underlying audio context when the user presses it.\n * @internal\n */\nexport class _WebAudioUnmuteUI {\n    private _button: Nullable<HTMLButtonElement> = null;\n    private _enabled: boolean = true;\n    private _engine: _WebAudioEngine;\n    private _style: Nullable<HTMLStyleElement> = null;\n\n    /** @internal */\n    public constructor(engine: _WebAudioEngine, parentElement?: HTMLElement) {\n        this._engine = engine;\n        const parent = parentElement || EngineStore.LastCreatedEngine?.getInputElement()?.parentElement || document.body;\n        const top = (parent?.offsetTop || 0) + 20;\n\n        this._style = document.createElement(\"style\");\n        this._style.appendChild(\n            document.createTextNode(\n                `.babylonUnmute{position:absolute;top:${top}px;margin-left:20px;height:40px;width:60px;background-color:rgba(51,51,51,0.7);background-image:url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");background-size:80%;background-repeat:no-repeat;background-position:center;background-position-y:4px;border:none;outline:none;transition:transform 0.125s ease-out;cursor:pointer;z-index:9999;}.babylonUnmute:hover{transform:scale(1.05)}`\n            )\n        );\n        document.head.appendChild(this._style);\n\n        this._button = document.createElement(\"button\");\n        this._button.className = \"babylonUnmute\";\n        this._button.id = \"babylonUnmuteButton\";\n\n        this._button.addEventListener(\"click\", () => {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._engine.unlockAsync();\n        });\n\n        parent.appendChild(this._button);\n\n        this._engine.stateChangedObservable.add(this._onStateChanged);\n    }\n\n    /** @internal */\n    public dispose(): void {\n        this._button?.remove();\n        this._button = null;\n\n        this._style?.remove();\n        this._style = null;\n\n        this._engine.stateChangedObservable.removeCallback(this._onStateChanged);\n    }\n\n    /** @internal */\n    public get enabled(): boolean {\n        return this._enabled;\n    }\n\n    public set enabled(value: boolean) {\n        this._enabled = value;\n        if (value) {\n            if (this._engine.state !== \"running\") {\n                this._show();\n            }\n        } else {\n            this._hide();\n        }\n    }\n\n    private _show(): void {\n        if (!this._button || !this._enabled) {\n            return;\n        }\n\n        this._button.style.display = \"block\";\n    }\n\n    private _hide(): void {\n        if (!this._button) {\n            return;\n        }\n\n        this._button.style.display = \"none\";\n    }\n\n    private _onStateChanged = () => {\n        if (!this._button) {\n            return;\n        }\n\n        if (this._engine.state === \"running\") {\n            this._hide();\n        } else {\n            this._show();\n        }\n    };\n}\n", "import { Observable } from \"../../Misc/observable\";\nimport type { Nullable } from \"../../types\";\nimport type { AbstractNamedAudioNode } from \"../abstractAudio/abstractAudioNode\";\nimport type { AbstractSound } from \"../abstractAudio/abstractSound\";\nimport type { AbstractSoundSource, ISoundSourceOptions } from \"../abstractAudio/abstractSoundSource\";\nimport type { AudioBus, IAudioBusOptions } from \"../abstractAudio/audioBus\";\nimport type { AudioEngineV2State, IAudioEngineV2Options } from \"../abstractAudio/audioEngineV2\";\nimport { AudioEngineV2 } from \"../abstractAudio/audioEngineV2\";\nimport type { IMainAudioBusOptions, MainAudioBus } from \"../abstractAudio/mainAudioBus\";\nimport type { IStaticSoundOptions, StaticSound } from \"../abstractAudio/staticSound\";\nimport type { IStaticSoundBufferOptions, StaticSoundBuffer } from \"../abstractAudio/staticSoundBuffer\";\nimport type { IStreamingSoundOptions, StreamingSound } from \"../abstractAudio/streamingSound\";\nimport type { AbstractSpatialAudioListener } from \"../abstractAudio/subProperties/abstractSpatialAudioListener\";\nimport { _HasSpatialAudioListenerOptions } from \"../abstractAudio/subProperties/abstractSpatialAudioListener\";\nimport type { _SpatialAudioListener } from \"../abstractAudio/subProperties/spatialAudioListener\";\nimport type { IAudioParameterRampOptions } from \"../audioParameter\";\nimport { _CreateSpatialAudioListener } from \"./subProperties/spatialWebAudioListener\";\nimport { _WebAudioMainOut } from \"./webAudioMainOut\";\nimport { _WebAudioUnmuteUI } from \"./webAudioUnmuteUI\";\n\n/**\n * Options for creating a v2 audio engine that uses the WebAudio API.\n */\nexport interface IWebAudioEngineOptions extends IAudioEngineV2Options {\n    /**\n     * The audio context to be used by the engine.\n     */\n    audioContext: AudioContext;\n    /**\n     * The default UI's parent element. Defaults to the last created graphics engine's canvas if it exists; otherwise the HTML document's body.\n     */\n    defaultUIParentElement?: HTMLElement;\n    /**\n     * Set to `true` to disable the default UI. Defaults to `false`.\n     */\n    disableDefaultUI?: boolean;\n    /**\n     * Set to `true` to automatically resume the audio context when the user interacts with the page. Defaults to `true`.\n     */\n    resumeOnInteraction: boolean;\n    /**\n     * Set to `true` to automatically resume the audio context when the browser pauses audio playback. Defaults to `true`.\n     */\n    resumeOnPause: boolean;\n    /**\n     * The interval in milliseconds to try resuming audio playback when `resumeOnPause` is `true`. Defaults to `1000`.\n     */\n    resumeOnPauseRetryInterval: number;\n}\n\n/**\n * Creates a new v2 audio engine that uses the WebAudio API.\n * @param options - The options for creating the audio engine.\n * @returns A promise that resolves with the created audio engine.\n */\nexport async function CreateAudioEngineAsync(options: Partial<IWebAudioEngineOptions> = {}): Promise<AudioEngineV2> {\n    const engine = new _WebAudioEngine(options);\n    await engine._initAsync(options);\n    return engine;\n}\n\nconst FormatMimeTypes: { [key: string]: string } = {\n    aac: \"audio/aac\",\n    ac3: \"audio/ac3\",\n    flac: \"audio/flac\",\n    m4a: \"audio/mp4\",\n    mp3: 'audio/mpeg; codecs=\"mp3\"',\n    mp4: \"audio/mp4\",\n    ogg: 'audio/ogg; codecs=\"vorbis\"',\n    wav: \"audio/wav\",\n    webm: 'audio/webm; codecs=\"vorbis\"',\n};\n\n/** @internal */\nexport class _WebAudioEngine extends AudioEngineV2 {\n    private _audioContextStarted = false;\n    private _destinationNode: Nullable<AudioNode> = null;\n    private _invalidFormats = new Set<string>();\n    private _isUpdating = false;\n    private _listener: Nullable<_SpatialAudioListener> = null;\n    private readonly _listenerAutoUpdate: boolean = true;\n    private readonly _listenerMinUpdateTime: number = 0;\n    private _mainOut: _WebAudioMainOut;\n    private _pauseCalled = false;\n    private _resumeOnInteraction = true;\n    private _resumeOnPause = true;\n    private _resumeOnPauseRetryInterval = 1000;\n    private _resumeOnPauseTimerId: any = null;\n    private _resumePromise: Nullable<Promise<void>> = null;\n    private _silentHtmlAudio: Nullable<HTMLAudioElement> = null;\n    private _unmuteUI: Nullable<_WebAudioUnmuteUI> = null;\n    private _updateObservable: Nullable<Observable<void>> = null;\n    private readonly _validFormats = new Set<string>();\n    private _volume = 1;\n\n    /** @internal */\n    public readonly _audioContext: AudioContext;\n\n    /** @internal */\n    public readonly _isUsingOfflineAudioContext: boolean = false;\n\n    /** @internal */\n    public readonly isReadyPromise: Promise<void> = new Promise((resolve) => {\n        this._resolveIsReadyPromise = resolve;\n    });\n\n    /** @internal */\n    public stateChangedObservable: Observable<string> = new Observable();\n\n    /** @internal */\n    public userGestureObservable: Observable<void> = new Observable();\n\n    /** @internal */\n    public constructor(options: Partial<IWebAudioEngineOptions> = {}) {\n        super(options);\n\n        if (typeof options.listenerAutoUpdate === \"boolean\") {\n            this._listenerAutoUpdate = options.listenerAutoUpdate;\n        }\n\n        if (typeof options.listenerMinUpdateTime === \"number\") {\n            this._listenerMinUpdateTime = options.listenerMinUpdateTime;\n        }\n\n        this._volume = options.volume ?? 1;\n\n        if (options.audioContext) {\n            this._isUsingOfflineAudioContext = options.audioContext instanceof OfflineAudioContext;\n            this._audioContext = options.audioContext;\n        } else {\n            this._audioContext = new AudioContext();\n        }\n\n        if (!options.disableDefaultUI) {\n            this._unmuteUI = new _WebAudioUnmuteUI(this, options.defaultUIParentElement);\n        }\n    }\n\n    /** @internal */\n    public async _initAsync(options: Partial<IWebAudioEngineOptions>): Promise<void> {\n        this._resumeOnInteraction = typeof options.resumeOnInteraction === \"boolean\" ? options.resumeOnInteraction : true;\n        this._resumeOnPause = typeof options.resumeOnPause === \"boolean\" ? options.resumeOnPause : true;\n        this._resumeOnPauseRetryInterval = options.resumeOnPauseRetryInterval ?? 1000;\n\n        document.addEventListener(\"click\", this._onUserGestureAsync);\n\n        await this._initAudioContextAsync();\n\n        if (_HasSpatialAudioListenerOptions(options)) {\n            this._listener = _CreateSpatialAudioListener(this, this._listenerAutoUpdate, this._listenerMinUpdateTime);\n            this._listener.setOptions(options);\n        }\n\n        this._resolveIsReadyPromise();\n    }\n\n    /** @internal */\n    public get currentTime(): number {\n        return this._audioContext.currentTime ?? 0;\n    }\n\n    /** @internal */\n    public get _inNode(): AudioNode {\n        return this._audioContext.destination;\n    }\n\n    /** @internal */\n    public get mainOut(): _WebAudioMainOut {\n        return this._mainOut;\n    }\n\n    /** @internal */\n    public get listener(): AbstractSpatialAudioListener {\n        return this._listener ?? (this._listener = _CreateSpatialAudioListener(this, this._listenerAutoUpdate, this._listenerMinUpdateTime));\n    }\n\n    /** @internal */\n    public get state(): AudioEngineV2State {\n        // Always return \"running\" for OfflineAudioContext so sound `play` calls work while the context is suspended.\n        return this._isUsingOfflineAudioContext ? \"running\" : this._audioContext.state;\n    }\n\n    /** @internal */\n    public get volume(): number {\n        return this._volume;\n    }\n\n    /** @internal */\n    public set volume(value: number) {\n        if (this._volume === value) {\n            return;\n        }\n\n        this._volume = value;\n\n        if (this._mainOut) {\n            this._mainOut.volume = value;\n        }\n    }\n\n    /**\n     * This property should only be used by the legacy audio engine.\n     * @internal\n     * */\n    public get _audioDestination(): AudioNode {\n        return this._destinationNode ? this._destinationNode : (this._destinationNode = this._audioContext.destination);\n    }\n\n    public set _audioDestination(value: Nullable<AudioNode>) {\n        this._destinationNode = value;\n    }\n\n    /**\n     * This property should only be used by the legacy audio engine.\n     * @internal\n     */\n    public get _unmuteUIEnabled(): boolean {\n        return this._unmuteUI ? this._unmuteUI.enabled : false;\n    }\n\n    public set _unmuteUIEnabled(value: boolean) {\n        if (this._unmuteUI) {\n            this._unmuteUI.enabled = value;\n        }\n    }\n\n    /** @internal */\n    public async createBusAsync(name: string, options: Partial<IAudioBusOptions> = {}): Promise<AudioBus> {\n        const module = await import(\"./webAudioBus\");\n\n        const bus = new module._WebAudioBus(name, this, options);\n        await bus._initAsync(options);\n\n        return bus;\n    }\n\n    /** @internal */\n    public async createMainBusAsync(name: string, options: Partial<IMainAudioBusOptions> = {}): Promise<MainAudioBus> {\n        const module = await import(\"./webAudioMainBus\");\n\n        const bus = new module._WebAudioMainBus(name, this);\n        await bus._initAsync(options);\n\n        return bus;\n    }\n\n    /** @internal */\n    public async createMicrophoneSoundSourceAsync(name: string, options?: Partial<ISoundSourceOptions>): Promise<AbstractSoundSource> {\n        let mediaStream: MediaStream;\n\n        try {\n            mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });\n        } catch (e) {\n            throw new Error(\"Unable to access microphone: \" + e);\n        }\n\n        return await this.createSoundSourceAsync(name, new MediaStreamAudioSourceNode(this._audioContext, { mediaStream }), {\n            outBusAutoDefault: false,\n            ...options,\n        });\n    }\n\n    /** @internal */\n    public async createSoundAsync(\n        name: string,\n        source: ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[],\n        options: Partial<IStaticSoundOptions> = {}\n    ): Promise<StaticSound> {\n        const module = await import(\"./webAudioStaticSound\");\n\n        const sound = new module._WebAudioStaticSound(name, this, options);\n        await sound._initAsync(source, options);\n\n        return sound;\n    }\n\n    /** @internal */\n    public async createSoundBufferAsync(\n        source: ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[],\n        options: Partial<IStaticSoundBufferOptions> = {}\n    ): Promise<StaticSoundBuffer> {\n        const module = await import(\"./webAudioStaticSound\");\n\n        const soundBuffer = new module._WebAudioStaticSoundBuffer(this);\n        await soundBuffer._initAsync(source, options);\n\n        return soundBuffer;\n    }\n\n    /** @internal */\n    public async createSoundSourceAsync(name: string, source: AudioNode, options: Partial<ISoundSourceOptions> = {}): Promise<AbstractSoundSource> {\n        const module = await import(\"./webAudioSoundSource\");\n\n        const soundSource = new module._WebAudioSoundSource(name, source, this, options);\n        await soundSource._initAsync(options);\n\n        return soundSource;\n    }\n\n    /** @internal */\n    public async createStreamingSoundAsync(name: string, source: HTMLMediaElement | string | string[], options: Partial<IStreamingSoundOptions> = {}): Promise<StreamingSound> {\n        const module = await import(\"./webAudioStreamingSound\");\n\n        const sound = new module._WebAudioStreamingSound(name, this, options);\n        await sound._initAsync(source, options);\n\n        return sound;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._listener?.dispose();\n        this._listener = null;\n\n        // Note that OfflineAudioContext does not have a `close` method.\n        if (this._audioContext.state !== \"closed\" && !this._isUsingOfflineAudioContext) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._audioContext.close();\n        }\n\n        document.removeEventListener(\"click\", this._onUserGestureAsync);\n        this._audioContext.removeEventListener(\"statechange\", this._onAudioContextStateChange);\n\n        this._silentHtmlAudio?.remove();\n\n        this._updateObservable?.clear();\n        this._updateObservable = null;\n\n        this._unmuteUI?.dispose();\n        this._unmuteUI = null;\n\n        this.stateChangedObservable.clear();\n    }\n\n    /** @internal */\n    public flagInvalidFormat(format: string): void {\n        this._invalidFormats.add(format);\n    }\n\n    /** @internal */\n    public isFormatValid(format: string): boolean {\n        if (this._validFormats.has(format)) {\n            return true;\n        }\n\n        if (this._invalidFormats.has(format)) {\n            return false;\n        }\n\n        const mimeType = FormatMimeTypes[format];\n        if (mimeType === undefined) {\n            return false;\n        }\n\n        const audio = new Audio();\n        if (audio.canPlayType(mimeType) === \"\") {\n            this._invalidFormats.add(format);\n            return false;\n        }\n\n        this._validFormats.add(format);\n\n        return true;\n    }\n\n    /** @internal */\n    public override async pauseAsync(): Promise<void> {\n        await this._audioContext.suspend();\n\n        this._pauseCalled = true;\n    }\n\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    public override resumeAsync(): Promise<void> {\n        this._pauseCalled = false;\n\n        if (this._resumePromise) {\n            return this._resumePromise;\n        }\n\n        this._resumePromise = this._audioContext.resume();\n\n        this.stateChangedObservable.notifyObservers(this.state);\n\n        return this._resumePromise;\n    }\n\n    /** @internal */\n    public setVolume(value: number, options: Nullable<Partial<IAudioParameterRampOptions>> = null): void {\n        if (this._mainOut) {\n            this._mainOut.setVolume(value, options);\n        } else {\n            throw new Error(\"Main output not initialized yet.\");\n        }\n    }\n\n    /** @internal */\n    public override _addMainBus(mainBus: MainAudioBus): void {\n        super._addMainBus(mainBus);\n    }\n\n    /** @internal */\n    public override _removeMainBus(mainBus: MainAudioBus): void {\n        super._removeMainBus(mainBus);\n    }\n\n    /** @internal */\n    public override _addNode(node: AbstractNamedAudioNode): void {\n        super._addNode(node);\n    }\n\n    /** @internal */\n    public override _removeNode(node: AbstractNamedAudioNode): void {\n        super._removeNode(node);\n    }\n\n    /** @internal */\n    public override _addSound(sound: AbstractSound): void {\n        super._addSound(sound);\n    }\n\n    /** @internal */\n    public override _removeSound(sound: AbstractSound): void {\n        super._removeSound(sound);\n    }\n\n    /** @internal */\n    public _addUpdateObserver(callback: () => void): void {\n        if (!this._updateObservable) {\n            this._updateObservable = new Observable<void>();\n        }\n\n        this._updateObservable.add(callback);\n        this._startUpdating();\n    }\n\n    public _removeUpdateObserver(callback: () => void): void {\n        if (this._updateObservable) {\n            this._updateObservable.removeCallback(callback);\n        }\n    }\n\n    private _initAudioContextAsync: () => Promise<void> = async () => {\n        this._audioContext.addEventListener(\"statechange\", this._onAudioContextStateChange);\n\n        this._mainOut = new _WebAudioMainOut(this);\n        this._mainOut.volume = this._volume;\n\n        await this.createMainBusAsync(\"default\");\n    };\n\n    private _onAudioContextStateChange = () => {\n        if (this.state === \"running\") {\n            clearInterval(this._resumeOnPauseTimerId);\n            this._audioContextStarted = true;\n            this._resumePromise = null;\n        }\n        if (this.state === \"suspended\" || this.state === \"interrupted\") {\n            if (this._audioContextStarted && this._resumeOnPause && !this._pauseCalled) {\n                clearInterval(this._resumeOnPauseTimerId);\n\n                this._resumeOnPauseTimerId = setInterval(() => {\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                    this.resumeAsync();\n                }, this._resumeOnPauseRetryInterval);\n            }\n        }\n\n        this.stateChangedObservable.notifyObservers(this.state);\n    };\n\n    private _onUserGestureAsync: () => void = async () => {\n        if (this._resumeOnInteraction) {\n            await this._audioContext.resume();\n        }\n\n        // On iOS the ringer switch must be turned on for WebAudio to play.\n        // This gets WebAudio to play with the ringer switch turned off by playing an HTMLAudioElement.\n        if (!this._silentHtmlAudio) {\n            this._silentHtmlAudio = document.createElement(\"audio\");\n\n            const audio = this._silentHtmlAudio;\n            audio.controls = false;\n            audio.preload = \"auto\";\n            audio.loop = true;\n\n            // Wave data for 0.0001 seconds of silence.\n            audio.src = \"data:audio/wav;base64,UklGRjAAAABXQVZFZm10IBAAAAABAAEAgLsAAAB3AQACABAAZGF0YQwAAAAAAAEA/v8CAP//AQA=\";\n\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            audio.play();\n        }\n\n        this.userGestureObservable.notifyObservers();\n    };\n\n    private _resolveIsReadyPromise: () => void;\n\n    private _startUpdating = () => {\n        if (this._isUpdating) {\n            return;\n        }\n\n        this._isUpdating = true;\n\n        if (this.state === \"running\") {\n            this._update();\n        } else {\n            const callback = () => {\n                if (this.state === \"running\") {\n                    this._update();\n                    this.stateChangedObservable.removeCallback(callback);\n                }\n            };\n\n            this.stateChangedObservable.add(callback);\n        }\n    };\n\n    private _update = (): void => {\n        if (this._updateObservable?.hasObservers()) {\n            this._updateObservable.notifyObservers();\n            requestAnimationFrame(this._update);\n        } else {\n            this._isUpdating = false;\n        }\n    };\n}\n", "import { _WebAudioEngine } from \"../AudioV2/webAudio/webAudioEngine\";\r\nimport type { _WebAudioMainBus } from \"../AudioV2/webAudio/webAudioMainBus\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Analyser } from \"./analyser\";\r\nimport type { IAudioEngine } from \"./Interfaces/IAudioEngine\";\r\n\r\n// Sets the default audio engine to Babylon.js\r\nAbstractEngine.AudioEngineFactory = (\r\n    hostElement: Nullable<HTMLElement>,\r\n    audioContext: Nullable<AudioContext>,\r\n    audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode>\r\n) => {\r\n    return new AudioEngine(hostElement, audioContext, audioDestination);\r\n};\r\n\r\n/**\r\n * This represents the default audio engine used in babylon.\r\n * It is responsible to play, synchronize and analyse sounds throughout the  application.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n */\r\nexport class AudioEngine implements IAudioEngine {\r\n    private _masterGain: GainNode;\r\n    private _tryToRun = false;\r\n    private _useCustomUnlockedButton: boolean = false;\r\n\r\n    /**\r\n     * Gets whether the current host supports Web Audio and thus could create AudioContexts.\r\n     */\r\n    public canUseWebAudio: boolean = true;\r\n\r\n    /**\r\n     * The master gain node defines the global audio volume of your audio engine.\r\n     */\r\n    public get masterGain(): GainNode {\r\n        return this._masterGain;\r\n    }\r\n\r\n    public set masterGain(value: GainNode) {\r\n        this._masterGain = this._v2.mainOut._inNode = value;\r\n    }\r\n\r\n    /**\r\n     * Defines if Babylon should emit a warning if WebAudio is not supported.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public WarnedWebAudioUnsupported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether or not mp3 are supported by your browser.\r\n     */\r\n    public isMP3supported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether or not ogg are supported by your browser.\r\n     */\r\n    public isOGGsupported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether audio has been unlocked on the device.\r\n     * Some Browsers have strong restrictions about Audio and won't autoplay unless\r\n     * a user interaction has happened.\r\n     */\r\n    public unlocked: boolean = false;\r\n\r\n    /**\r\n     * Defines if the audio engine relies on a custom unlocked button.\r\n     * In this case, the embedded button will not be displayed.\r\n     */\r\n    public get useCustomUnlockedButton(): boolean {\r\n        return this._useCustomUnlockedButton;\r\n    }\r\n\r\n    public set useCustomUnlockedButton(value: boolean) {\r\n        this._useCustomUnlockedButton = value;\r\n        this._v2._unmuteUIEnabled = !value;\r\n    }\r\n\r\n    /**\r\n     * Event raised when audio has been unlocked on the browser.\r\n     */\r\n    public onAudioUnlockedObservable = new Observable<IAudioEngine>();\r\n\r\n    /**\r\n     * Event raised when audio has been locked on the browser.\r\n     */\r\n    public onAudioLockedObservable = new Observable<IAudioEngine>();\r\n\r\n    /** @internal */\r\n    public _v2: _WebAudioEngine;\r\n\r\n    /**\r\n     * Gets the current AudioContext if available.\r\n     */\r\n    public get audioContext(): Nullable<AudioContext> {\r\n        if (this._v2.state === \"running\") {\r\n            // Do not wait for the promise to unlock.\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._triggerRunningStateAsync();\r\n        }\r\n        return this._v2._audioContext;\r\n    }\r\n\r\n    private _connectedAnalyser: Nullable<Analyser>;\r\n\r\n    /**\r\n     * Instantiates a new audio engine.\r\n     *\r\n     * @param hostElement defines the host element where to display the mute icon if necessary\r\n     * @param audioContext defines the audio context to be used by the audio engine\r\n     * @param audioDestination defines the audio destination node to be used by audio engine\r\n     */\r\n    constructor(\r\n        hostElement: Nullable<HTMLElement> = null,\r\n        audioContext: Nullable<AudioContext> = null,\r\n        audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode> = null\r\n    ) {\r\n        const v2 = new _WebAudioEngine({\r\n            audioContext: audioContext ? audioContext : undefined,\r\n            defaultUIParentElement: hostElement?.parentElement ? hostElement.parentElement : undefined,\r\n        });\r\n\r\n        // Historically the unmute button is disabled until a sound tries to play and can't, which results in a call\r\n        // to `AudioEngine.lock()`, which is where the unmute button is enabled if no custom UI is requested.\r\n        v2._unmuteUIEnabled = false;\r\n\r\n        this._masterGain = new GainNode(v2._audioContext);\r\n        v2._audioDestination = audioDestination;\r\n\r\n        v2.stateChangedObservable.add((state) => {\r\n            if (state === \"running\") {\r\n                this.unlocked = true;\r\n                this.onAudioUnlockedObservable.notifyObservers(this);\r\n            } else {\r\n                this.unlocked = false;\r\n                this.onAudioLockedObservable.notifyObservers(this);\r\n            }\r\n        });\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n        v2._initAsync({ resumeOnInteraction: false }).then(() => {\r\n            const mainBusOutNode = (v2.defaultMainBus as _WebAudioMainBus)._outNode;\r\n            if (mainBusOutNode) {\r\n                mainBusOutNode.disconnect(v2.mainOut._inNode);\r\n                mainBusOutNode.connect(this._masterGain);\r\n            }\r\n\r\n            v2.mainOut._inNode = this._masterGain;\r\n            v2.stateChangedObservable.notifyObservers(v2.state);\r\n        });\r\n\r\n        this.isMP3supported = v2.isFormatValid(\"mp3\");\r\n        this.isOGGsupported = v2.isFormatValid(\"ogg\");\r\n\r\n        this._v2 = v2;\r\n    }\r\n\r\n    /**\r\n     * Flags the audio engine in Locked state.\r\n     * This happens due to new browser policies preventing audio to autoplay.\r\n     */\r\n    public lock() {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._v2._audioContext.suspend();\r\n\r\n        if (!this._useCustomUnlockedButton) {\r\n            this._v2._unmuteUIEnabled = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unlocks the audio engine once a user action has been done on the dom.\r\n     * This is helpful to resume play once browser policies have been satisfied.\r\n     */\r\n    public unlock() {\r\n        if (this._v2._audioContext?.state === \"running\") {\r\n            if (!this.unlocked) {\r\n                // Notify users that the audio stack is unlocked/unmuted\r\n                this.unlocked = true;\r\n                this.onAudioUnlockedObservable.notifyObservers(this);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._triggerRunningStateAsync();\r\n    }\r\n\r\n    /** @internal */\r\n    public _resumeAudioContextOnStateChange(): void {\r\n        this._v2._audioContext?.addEventListener(\r\n            \"statechange\",\r\n            () => {\r\n                if (this.unlocked && this._v2._audioContext?.state !== \"running\") {\r\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                    this._resumeAudioContextAsync();\r\n                }\r\n            },\r\n            {\r\n                once: true,\r\n                passive: true,\r\n                signal: AbortSignal.timeout(3000),\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _resumeAudioContextAsync(): Promise<void> {\r\n        if (this._v2._isUsingOfflineAudioContext) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this._v2._audioContext.state === \"suspended\" && !this._useCustomUnlockedButton) {\r\n            this._v2._unmuteUIEnabled = true;\r\n        }\r\n\r\n        return this._v2._audioContext.resume();\r\n    }\r\n\r\n    /**\r\n     * Destroy and release the resources associated with the audio context.\r\n     */\r\n    public dispose(): void {\r\n        this._v2.dispose();\r\n\r\n        this.onAudioUnlockedObservable.clear();\r\n        this.onAudioLockedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Gets the global volume sets on the master gain.\r\n     * @returns the global volume if set or -1 otherwise\r\n     */\r\n    public getGlobalVolume(): number {\r\n        return this.masterGain.gain.value;\r\n    }\r\n\r\n    /**\r\n     * Sets the global volume of your experience (sets on the master gain).\r\n     * @param newVolume Defines the new global volume of the application\r\n     */\r\n    public setGlobalVolume(newVolume: number): void {\r\n        this.masterGain.gain.value = newVolume;\r\n    }\r\n\r\n    /**\r\n     * Connect the audio engine to an audio analyser allowing some amazing\r\n     * synchronization between the sounds/music and your visualization (VuMeter for instance).\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser\r\n     * @param analyser The analyser to connect to the engine\r\n     */\r\n    public connectToAnalyser(analyser: Analyser): void {\r\n        if (this._connectedAnalyser) {\r\n            this._connectedAnalyser.stopDebugCanvas();\r\n        }\r\n\r\n        this._connectedAnalyser = analyser;\r\n        this.masterGain.disconnect();\r\n        this._connectedAnalyser.connectAudioNodes(this.masterGain, this._v2._audioContext.destination);\r\n    }\r\n\r\n    private async _triggerRunningStateAsync() {\r\n        if (this._tryToRun) {\r\n            void this._v2._audioContext.resume();\r\n            return;\r\n        }\r\n        this._tryToRun = true;\r\n\r\n        await this._resumeAudioContextAsync();\r\n\r\n        this._tryToRun = false;\r\n        this.unlocked = true;\r\n\r\n        this.onAudioUnlockedObservable.notifyObservers(this);\r\n    }\r\n}\r\n", "import { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\n\r\n/**\r\n * Nothing specific to WebGPU in this class, but the spec is not final yet so let's remove it later on\r\n * if it is not needed\r\n * @internal\r\n **/\r\nexport class WebGPUExternalTexture extends ExternalTexture {\r\n    public constructor(video: HTMLVideoElement) {\r\n        super(video);\r\n    }\r\n}\r\n", "import { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { Constants } from \"../../constants\";\r\n\r\nimport \"../../AbstractEngine/abstractEngine.alpha\";\r\nimport { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Sets the current alpha mode\r\n         * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)\r\n         * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\r\n         * @param targetIndex defines the index of the target to set the alpha mode for (default is 0)\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\r\n         */\r\n        setAlphaMode(mode: number, noDepthWriteChange?: boolean, targetIndex?: number): void;\r\n    }\r\n}\r\n\r\nThinWebGPUEngine.prototype.setAlphaMode = function (mode: number, noDepthWriteChange: boolean = false, targetIndex: number = 0): void {\r\n    const alphaBlend = this._alphaState._alphaBlend[targetIndex];\r\n\r\n    if (this._alphaMode[targetIndex] === mode && ((mode === Constants.ALPHA_DISABLE && !alphaBlend) || (mode !== Constants.ALPHA_DISABLE && alphaBlend))) {\r\n        if (!noDepthWriteChange) {\r\n            // Make sure we still have the correct depth mask according to the alpha mode (a transparent material could have forced writting to the depth buffer, for instance)\r\n            const depthMask = mode === Constants.ALPHA_DISABLE;\r\n            if (this.depthCullingState.depthMask !== depthMask) {\r\n                this.setDepthWrite(depthMask);\r\n                this._cacheRenderPipeline.setDepthWriteEnabled(depthMask);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n\r\n    const alphaBlendDisabled = mode === Constants.ALPHA_DISABLE;\r\n\r\n    this._alphaState.setAlphaBlend(!alphaBlendDisabled, targetIndex);\r\n    this._alphaState.setAlphaMode(mode, targetIndex);\r\n\r\n    if (!noDepthWriteChange) {\r\n        this.setDepthWrite(alphaBlendDisabled);\r\n        this._cacheRenderPipeline.setDepthWriteEnabled(alphaBlendDisabled);\r\n    }\r\n    this._alphaMode[targetIndex] = mode;\r\n    this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState._alphaBlend, this._alphaState._numTargetEnabled);\r\n    this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\r\n};\r\n\r\nThinWebGPUEngine.prototype.setAlphaEquation = function (equation: number, targetIndex: number = 0): void {\r\n    AbstractEngine.prototype.setAlphaEquation.call(this, equation, targetIndex);\r\n\r\n    this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\r\n};\r\n", "import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IWebRequest } from \"../../../Misc/interfaces/iWebRequest\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\n\r\nimport type { Scene } from \"../../../scene\";\r\nimport { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         */\r\n        updateRawTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            useSRGBBuffer: boolean\r\n        ): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture\r\n         * @param data defines the array of data to use to create each face\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_BYTE)\r\n         * @param generateMipMaps  defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compression used (null by default)\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTexture(\r\n            data: Nullable<ArrayBufferView[]>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param level defines which level of the texture to update\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>, level: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_BYTE)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[] | Promise<ArrayBufferView[]>>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_BYTE)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[] | Promise<ArrayBufferView[]>>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            samplingMode: number,\r\n            invertY: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture2DArray(\r\n            texture: InternalTexture,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            textureType: number\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinWebGPUEngine.prototype.createRawTexture = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n    creationFlags: number = 0,\r\n    useSRGBBuffer: boolean = false\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n    texture._creationFlags = creationFlags;\r\n    texture._useSRGBBuffer = useSRGBBuffer;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type, useSRGBBuffer);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinWebGPUEngine.prototype.updateRawTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n    useSRGBBuffer: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = ConvertRGBtoRGBATextureData(bufferView, texture.width, texture.height, type);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nThinWebGPUEngine.prototype.createRawCubeTexture = function (\r\n    data: Nullable<ArrayBufferView[]>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n\r\n    if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    texture.isCube = true;\r\n    texture._originalFormat = format;\r\n    texture.format = format === Constants.TEXTUREFORMAT_RGB ? Constants.TEXTUREFORMAT_RGBA : format;\r\n    texture.type = type;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.width = size;\r\n    texture.height = size;\r\n    texture.samplingMode = samplingMode;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n\r\n    if (format === Constants.TEXTUREFORMAT_RGB) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        gpuTextureWrapper._originalFormatIsRGB = true;\r\n    }\r\n\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    }\r\n\r\n    texture.isReady = true;\r\n\r\n    return texture;\r\n};\r\n\r\nThinWebGPUEngine.prototype.updateRawCubeTexture = function (\r\n    texture: InternalTexture,\r\n    bufferView: ArrayBufferView[],\r\n    _format: number,\r\n    type: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null\r\n): void {\r\n    texture._bufferViewArray = bufferView;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n    const needConversion = gpuTextureWrapper._originalFormatIsRGB;\r\n\r\n    const faces = [0, 2, 4, 1, 3, 5];\r\n\r\n    const data = [];\r\n    for (let i = 0; i < bufferView.length; ++i) {\r\n        let faceData = bufferView[faces[i]];\r\n        if (needConversion) {\r\n            faceData = ConvertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\r\n        }\r\n        data.push(new Uint8Array(faceData.buffer, faceData.byteOffset, faceData.byteLength));\r\n    }\r\n\r\n    this._textureHelper.updateCubeTextures(data, gpuTextureWrapper.underlyingResource!, texture.width, texture.height, gpuTextureWrapper.format, invertY, false, 0, 0);\r\n    if (texture.generateMipMaps) {\r\n        this._generateMipmaps(texture, this._uploadEncoder);\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nThinWebGPUEngine.prototype.createRawCubeTextureFromUrl = function (\r\n    url: string,\r\n    scene: Nullable<Scene>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[] | Promise<ArrayBufferView[]>>,\r\n    mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    invertY: boolean = false\r\n): InternalTexture {\r\n    const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene?.addPendingData(texture);\r\n    texture.url = url;\r\n    texture.isReady = false;\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene?.removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    const internalCallbackAsync = async (data: any) => {\r\n        const faceDataArraysResult = callback(data);\r\n        if (!faceDataArraysResult) {\r\n            return;\r\n        }\r\n\r\n        const faceDataArrays: any = faceDataArraysResult instanceof Promise ? await faceDataArraysResult : faceDataArraysResult;\r\n        const width = texture.width;\r\n\r\n        if (mipmapGenerator) {\r\n            const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n            const mipData = mipmapGenerator(faceDataArrays);\r\n            const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n            const faces = [0, 1, 2, 3, 4, 5];\r\n            for (let level = 0; level < mipData.length; level++) {\r\n                const mipSize = width >> level;\r\n                const allFaces = [];\r\n                for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faces[faceIndex]];\r\n                    if (needConversion) {\r\n                        mipFaceData = ConvertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    allFaces.push(new Uint8Array(mipFaceData.buffer, mipFaceData.byteOffset, mipFaceData.byteLength));\r\n                }\r\n                this._textureHelper.updateCubeTextures(allFaces, gpuTextureWrapper.underlyingResource!, mipSize, mipSize, gpuTextureWrapper.format, invertY, false, 0, 0);\r\n            }\r\n        } else {\r\n            this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        scene?.removePendingData(texture);\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(\r\n        url,\r\n        (data) => {\r\n            // eslint-disable-next-line github/no-then\r\n            internalCallbackAsync(data).catch((err) => {\r\n                onerror(undefined, err);\r\n            });\r\n        },\r\n        undefined,\r\n        scene?.offlineProvider,\r\n        true,\r\n        onerror\r\n    );\r\n\r\n    return texture;\r\n};\r\n\r\nThinWebGPUEngine.prototype.createRawTexture3D = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    depth: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n    creationFlags: number = 0\r\n): InternalTexture {\r\n    const source = InternalTextureSource.Raw3D;\r\n    const texture = new InternalTexture(this, source);\r\n\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.baseDepth = depth;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.depth = depth;\r\n    texture.format = format;\r\n    texture.type = textureType;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.is3D = true;\r\n    texture._creationFlags = creationFlags;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\r\n\r\n    this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinWebGPUEngine.prototype.updateRawTexture3D = function (\r\n    texture: InternalTexture,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n): void {\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.format = format;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = ConvertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nThinWebGPUEngine.prototype.createRawTexture2DArray = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    depth: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n    creationFlags: number = 0\r\n): InternalTexture {\r\n    const source = InternalTextureSource.Raw2DArray;\r\n    const texture = new InternalTexture(this, source);\r\n\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.baseDepth = depth;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.depth = depth;\r\n    texture.format = format;\r\n    texture.type = textureType;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.is2DArray = true;\r\n    texture._creationFlags = creationFlags;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags);\r\n\r\n    this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinWebGPUEngine.prototype.updateRawTexture2DArray = function (\r\n    texture: InternalTexture,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n): void {\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.format = format;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = ConvertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction ConvertRGBtoRGBATextureData(rgbData: any, width: number, height: number, textureType: number): ArrayBufferView {\r\n    // Create new RGBA data container.\r\n    let rgbaData: any;\r\n    let val1 = 1;\r\n    if (textureType === Constants.TEXTURETYPE_FLOAT) {\r\n        rgbaData = new Float32Array(width * height * 4);\r\n    } else if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n        rgbaData = new Uint16Array(width * height * 4);\r\n        val1 = 15360; // 15360 is the encoding of 1 in half float\r\n    } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_INTEGER) {\r\n        rgbaData = new Uint32Array(width * height * 4);\r\n    } else {\r\n        rgbaData = new Uint8Array(width * height * 4);\r\n    }\r\n\r\n    // Convert each pixel.\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            const index = (y * width + x) * 3;\r\n            const newIndex = (y * width + x) * 4;\r\n\r\n            // Map Old Value to new value.\r\n            rgbaData[newIndex + 0] = rgbData[index + 0];\r\n            rgbaData[newIndex + 1] = rgbData[index + 1];\r\n            rgbaData[newIndex + 2] = rgbData[index + 2];\r\n\r\n            // Add fully opaque alpha channel.\r\n            rgbaData[newIndex + 3] = val1;\r\n        }\r\n    }\r\n\r\n    return rgbaData;\r\n}\r\n", "import { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /** @internal */\r\n        _readTexturePixels(\r\n            texture: InternalTexture,\r\n            width: number,\r\n            height: number,\r\n            faceIndex?: number,\r\n            level?: number,\r\n            buffer?: Nullable<ArrayBufferView>,\r\n            flushRenderer?: boolean,\r\n            noDataConversion?: boolean,\r\n            x?: number,\r\n            y?: number\r\n        ): Promise<ArrayBufferView>;\r\n\r\n        /** @internal */\r\n        _readTexturePixelsSync(\r\n            texture: InternalTexture,\r\n            width: number,\r\n            height: number,\r\n            faceIndex?: number,\r\n            level?: number,\r\n            buffer?: Nullable<ArrayBufferView>,\r\n            flushRenderer?: boolean,\r\n            noDataConversion?: boolean,\r\n            x?: number,\r\n            y?: number\r\n        ): ArrayBufferView;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/promise-function-async\r\nThinWebGPUEngine.prototype._readTexturePixels = function (\r\n    texture: InternalTexture,\r\n    width: number,\r\n    height: number,\r\n    faceIndex = -1,\r\n    level = 0,\r\n    buffer: Nullable<ArrayBufferView> = null,\r\n    flushRenderer = true,\r\n    noDataConversion = false,\r\n    x = 0,\r\n    y = 0\r\n): Promise<ArrayBufferView> {\r\n    const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n    if (flushRenderer) {\r\n        this.flushFramebuffer();\r\n    }\r\n\r\n    return this._textureHelper.readPixels(gpuTextureWrapper.underlyingResource!, x, y, width, height, gpuTextureWrapper.format, faceIndex, level, buffer, noDataConversion);\r\n};\r\n\r\nThinWebGPUEngine.prototype._readTexturePixelsSync = function (): ArrayBufferView {\r\n    // eslint-disable-next-line no-throw-literal\r\n    throw \"_readTexturePixelsSync is unsupported in WebGPU!\";\r\n};\r\n", "import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { DepthTextureCreationOptions } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport { WebGPUTextureHelper } from \"../webgpuTextureHelper\";\r\n\r\nimport type { Scene } from \"../../../scene\";\r\nimport { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * @internal\r\n         */\r\n        _setCubeMapTextureParams(texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void;\r\n\r\n        /**\r\n         * Creates a depth stencil cube texture.\r\n         * This is only available in WebGL 2.\r\n         * @param size The size of face edge in the cube texture.\r\n         * @param options The options defining the cube texture.\r\n         * @returns The cube texture\r\n         */\r\n        _createDepthStencilCubeTexture(size: number, options: DepthTextureCreationOptions): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n         * @param loaderOptions options to be passed to the loader\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         * @param buffer defines the data buffer to load instead of loading the rootUrl\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean | undefined,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            loaderOptions: any,\r\n            useSRGBBuffer: boolean,\r\n            buffer: Nullable<ArrayBufferView>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        createCubeTextureBase(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void>,\r\n            imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            useSRGBBuffer: boolean,\r\n            buffer: Nullable<ArrayBufferView>\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        _partialLoadFile(\r\n            url: string,\r\n            index: number,\r\n            loadedFiles: ArrayBuffer[],\r\n            onfinish: (files: ArrayBuffer[]) => void,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadFiles(scene: Nullable<Scene>, onfinish: (images: ArrayBuffer[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void>): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadImgs(\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            files: string[],\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _partialLoadImg(\r\n            url: string,\r\n            index: number,\r\n            loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /**\r\n         * Force the mipmap generation for the given render target texture\r\n         * @param texture defines the render target texture to use\r\n         * @param unbind defines whether or not to unbind the texture after generation. Defaults to true.\r\n         */\r\n        generateMipMapsForCubemap(texture: InternalTexture, unbind?: boolean): void;\r\n    }\r\n}\r\n\r\nThinWebGPUEngine.prototype._createDepthStencilCubeTexture = function (size: number, options: DepthTextureCreationOptions): InternalTexture {\r\n    const internalTexture = new InternalTexture(this, options.generateStencil ? InternalTextureSource.DepthStencil : InternalTextureSource.Depth);\r\n\r\n    internalTexture.isCube = true;\r\n    internalTexture.label = options.label;\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        samples: 1,\r\n        depthTextureFormat: options.generateStencil ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n        ...options,\r\n    };\r\n\r\n    internalTexture.format = internalOptions.depthTextureFormat;\r\n\r\n    this._setupDepthStencilTexture(internalTexture, size, internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(internalTexture);\r\n\r\n    // Now that the hardware texture is created, we can retrieve the GPU format and set the right type to the internal texture\r\n    const gpuTextureWrapper = internalTexture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n    internalTexture.type = WebGPUTextureHelper.GetTextureTypeFromFormat(gpuTextureWrapper.format);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nThinWebGPUEngine.prototype.createCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    loaderOptions?: any,\r\n    useSRGBBuffer = false,\r\n    buffer: Nullable<ArrayBufferView> = null\r\n): InternalTexture {\r\n    return this.createCubeTextureBase(\r\n        rootUrl,\r\n        scene,\r\n        files,\r\n        !!noMipmap,\r\n        onLoad,\r\n        onError,\r\n        format,\r\n        forcedExtension,\r\n        createPolynomials,\r\n        lodScale,\r\n        lodOffset,\r\n        fallback,\r\n        null,\r\n        (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n            const imageBitmaps = imgs as ImageBitmap[]; // we will always get an ImageBitmap array in WebGPU\r\n            const width = imageBitmaps[0].width;\r\n            const height = width;\r\n\r\n            this._setCubeMapTextureParams(texture, !noMipmap);\r\n            texture.format = format ?? -1;\r\n\r\n            const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n\r\n            this._textureHelper.updateCubeTextures(imageBitmaps, gpuTextureWrapper.underlyingResource!, width, height, gpuTextureWrapper.format, false, false, 0, 0);\r\n\r\n            if (!noMipmap) {\r\n                this._generateMipmaps(texture, this._uploadEncoder);\r\n            }\r\n\r\n            texture.isReady = true;\r\n\r\n            texture.onLoadedObservable.notifyObservers(texture);\r\n            texture.onLoadedObservable.clear();\r\n\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        },\r\n        !!useSRGBBuffer,\r\n        buffer\r\n    );\r\n};\r\n\r\nThinWebGPUEngine.prototype._setCubeMapTextureParams = function (texture: InternalTexture, loadMipmap: boolean, maxLevel?: number) {\r\n    texture.samplingMode = loadMipmap ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n    texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    if (maxLevel) {\r\n        texture._maxLodLevel = maxLevel;\r\n    }\r\n};\r\n\r\nThinWebGPUEngine.prototype.generateMipMapsForCubemap = function (texture: InternalTexture) {\r\n    if (texture.generateMipMaps) {\r\n        const gpuTexture = texture._hardwareTexture?.underlyingResource;\r\n\r\n        if (!gpuTexture) {\r\n            this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n        }\r\n\r\n        this._generateMipmaps(texture);\r\n    }\r\n};\r\n", "import type { TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport { WebGPUPerfCounter } from \"./webgpuPerfCounter\";\r\nimport type { ThinWebGPUEngine } from \"../thinWebGPUEngine\";\r\n\r\n/**\r\n * Specialized class used to store a render target of a WebGPU engine\r\n */\r\nexport class WebGPURenderTargetWrapper extends RenderTargetWrapper {\r\n    /** @internal */\r\n    public _defaultAttachments: number[];\r\n\r\n    /**\r\n     * Gets the GPU time spent rendering this render target in the last frame (in nanoseconds).\r\n     * You have to enable the \"timestamp-query\" extension in the engine constructor options and set engine.enableGPUTimingMeasurements = true.\r\n     */\r\n    public readonly gpuTimeInFrame?: WebGPUPerfCounter;\r\n\r\n    /**\r\n     * Initializes the render target wrapper\r\n     * @param isMulti true if the wrapper is a multi render target\r\n     * @param isCube true if the wrapper should render to a cube texture\r\n     * @param size size of the render target (width/height/layers)\r\n     * @param engine engine used to create the render target\r\n     * @param label defines the label to use for the wrapper (for debugging purpose only)\r\n     */\r\n    constructor(isMulti: boolean, isCube: boolean, size: TextureSize, engine: ThinWebGPUEngine, label?: string) {\r\n        super(isMulti, isCube, size, engine, label);\r\n\r\n        if (engine.enableGPUTimingMeasurements) {\r\n            this.gpuTimeInFrame = new WebGPUPerfCounter();\r\n        }\r\n    }\r\n}\r\n", "import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { RenderTargetCreationOptions, DepthTextureCreationOptions, TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\nimport { WebGPURenderTargetWrapper } from \"../webgpuRenderTargetWrapper\";\r\nimport { GetTypeForDepthTexture, HasStencilAspect } from \"core/Materials/Textures/textureHelper.functions\";\r\n\r\nimport \"../../AbstractEngine/abstractEngine.texture\";\r\nimport { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Creates a new render target texture\r\n         * @param size defines the size of the texture\r\n         * @param options defines the options used to create the texture\r\n         * @returns a new render target wrapper ready to render texture\r\n         */\r\n        createRenderTargetTexture(size: TextureSize, options: boolean | RenderTargetCreationOptions): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Updates the sample count of a render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multisample-render-targets\r\n         * @param rtWrapper defines the render target wrapper to update\r\n         * @param samples defines the sample count to set\r\n         * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n         */\r\n        updateRenderTargetTextureSampleCount(rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number;\r\n\r\n        /** @internal */\r\n        _createDepthStencilTexture(size: TextureSize, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture;\r\n\r\n        /** @internal */\r\n        _createHardwareRenderTargetWrapper(isMulti: boolean, isCube: boolean, size: TextureSize): RenderTargetWrapper;\r\n\r\n        /** @internal */\r\n        _setupDepthStencilTexture(internalTexture: InternalTexture, size: TextureSize, bilinearFiltering: boolean, comparisonFunction: number, samples?: number): void;\r\n    }\r\n}\r\n\r\nThinWebGPUEngine.prototype._createHardwareRenderTargetWrapper = function (isMulti: boolean, isCube: boolean, size: TextureSize): WebGPURenderTargetWrapper {\r\n    const rtWrapper = new WebGPURenderTargetWrapper(isMulti, isCube, size, this);\r\n    this._renderTargetWrapperCache.push(rtWrapper);\r\n    return rtWrapper;\r\n};\r\n\r\nThinWebGPUEngine.prototype.createRenderTargetTexture = function (size: TextureSize, options: boolean | RenderTargetCreationOptions): WebGPURenderTargetWrapper {\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size) as WebGPURenderTargetWrapper;\r\n\r\n    const fullOptions: RenderTargetCreationOptions = {};\r\n\r\n    if (options !== undefined && typeof options === \"object\") {\r\n        fullOptions.generateMipMaps = options.generateMipMaps;\r\n        fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\r\n        fullOptions.samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n        fullOptions.creationFlags = options.creationFlags ?? 0;\r\n        fullOptions.noColorAttachment = !!options.noColorAttachment;\r\n        fullOptions.colorAttachment = options.colorAttachment;\r\n        fullOptions.samples = options.samples;\r\n        fullOptions.label = options.label;\r\n        fullOptions.format = options.format;\r\n        fullOptions.type = options.type;\r\n    } else {\r\n        fullOptions.generateMipMaps = options;\r\n        fullOptions.generateDepthBuffer = true;\r\n        fullOptions.generateStencilBuffer = false;\r\n        fullOptions.samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n        fullOptions.creationFlags = 0;\r\n        fullOptions.noColorAttachment = false;\r\n    }\r\n\r\n    const texture =\r\n        fullOptions.colorAttachment || (fullOptions.noColorAttachment ? null : this._createInternalTexture(size, fullOptions, true, InternalTextureSource.RenderTarget));\r\n\r\n    rtWrapper.label = fullOptions.label ?? \"RenderTargetWrapper\";\r\n    rtWrapper._samples = fullOptions.colorAttachment?.samples ?? fullOptions.samples ?? 1;\r\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\r\n\r\n    rtWrapper.setTextures(texture);\r\n\r\n    if (rtWrapper._generateDepthBuffer || rtWrapper._generateStencilBuffer) {\r\n        rtWrapper.createDepthStencilTexture(\r\n            0,\r\n            false, // force false as filtering is not supported for depth textures\r\n            rtWrapper._generateStencilBuffer,\r\n            rtWrapper.samples,\r\n            fullOptions.generateStencilBuffer ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n            fullOptions.label ? fullOptions.label + \"-DepthStencil\" : undefined\r\n        );\r\n    }\r\n\r\n    if (texture && !fullOptions.colorAttachment) {\r\n        if (options !== undefined && typeof options === \"object\" && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n            texture.generateMipMaps = true;\r\n        }\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture, undefined, undefined, undefined, fullOptions.creationFlags);\r\n\r\n        if (options !== undefined && typeof options === \"object\" && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n            texture.generateMipMaps = false;\r\n        }\r\n    }\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nThinWebGPUEngine.prototype._createDepthStencilTexture = function (size: TextureSize, options: DepthTextureCreationOptions, wrapper: WebGPURenderTargetWrapper): InternalTexture {\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        samples: 1,\r\n        depthTextureFormat: options.generateStencil ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n        ...options,\r\n    };\r\n\r\n    const hasStencil = HasStencilAspect(internalOptions.depthTextureFormat);\r\n\r\n    wrapper._depthStencilTextureWithStencil = hasStencil;\r\n\r\n    const internalTexture = new InternalTexture(this, hasStencil ? InternalTextureSource.DepthStencil : InternalTextureSource.Depth);\r\n\r\n    internalTexture.label = options.label;\r\n\r\n    internalTexture.format = internalOptions.depthTextureFormat;\r\n    internalTexture.type = GetTypeForDepthTexture(internalTexture.format);\r\n\r\n    this._setupDepthStencilTexture(internalTexture, size, internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(internalTexture);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nThinWebGPUEngine.prototype._setupDepthStencilTexture = function (\r\n    internalTexture: InternalTexture,\r\n    size: TextureSize,\r\n    bilinearFiltering: boolean,\r\n    comparisonFunction: number,\r\n    samples = 1\r\n): void {\r\n    const width = (<{ width: number; height: number; layers?: number }>size).width ?? <number>size;\r\n    const height = (<{ width: number; height: number; layers?: number }>size).height ?? <number>size;\r\n    const layers = (<{ width: number; height: number; depth?: number; layers?: number }>size).layers || 0;\r\n    const depth = (<{ width: number; height: number; depth?: number; layers?: number }>size).depth || 0;\r\n\r\n    internalTexture.baseWidth = width;\r\n    internalTexture.baseHeight = height;\r\n    internalTexture.width = width;\r\n    internalTexture.height = height;\r\n    internalTexture.is2DArray = layers > 0;\r\n    internalTexture.is3D = depth > 0;\r\n    internalTexture.depth = layers || depth;\r\n    internalTexture.isReady = true;\r\n    internalTexture.samples = samples;\r\n    internalTexture.generateMipMaps = false;\r\n    internalTexture.samplingMode = bilinearFiltering ? Constants.TEXTURE_BILINEAR_SAMPLINGMODE : Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n    internalTexture.type = Constants.TEXTURETYPE_FLOAT; // the right type will be set later\r\n    internalTexture._comparisonFunction = comparisonFunction;\r\n    internalTexture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    internalTexture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n};\r\n\r\nThinWebGPUEngine.prototype.updateRenderTargetTextureSampleCount = function (rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number {\r\n    if (!rtWrapper || !rtWrapper.texture || rtWrapper.samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    this._textureHelper.createMSAATexture(rtWrapper.texture, samples);\r\n\r\n    if (rtWrapper._depthStencilTexture) {\r\n        this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\r\n        rtWrapper._depthStencilTexture.samples = samples;\r\n    }\r\n\r\n    rtWrapper._samples = samples;\r\n    rtWrapper.texture.samples = samples;\r\n\r\n    return samples;\r\n};\r\n", "import type { Nullable } from \"../../../types\";\r\nimport type { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Sets a depth stencil texture from a render target to the according uniform.\r\n         * @param channel The texture channel\r\n         * @param uniform The uniform to set\r\n         * @param texture The render target texture containing the depth stencil texture to apply\r\n         * @param name The texture name\r\n         */\r\n        setDepthStencilTexture(channel: number, uniform: Nullable<WebGLUniformLocation>, texture: Nullable<RenderTargetTexture>, name?: string): void;\r\n    }\r\n}\r\n\r\nThinWebGPUEngine.prototype.setDepthStencilTexture = function (\r\n    channel: number,\r\n    uniform: Nullable<WebGLUniformLocation>,\r\n    texture: Nullable<RenderTargetTexture>,\r\n    name?: string\r\n): void {\r\n    if (!texture || !texture.depthStencilTexture) {\r\n        this._setTexture(channel, null, undefined, undefined, name);\r\n    } else {\r\n        this._setTexture(channel, texture, false, true, name);\r\n    }\r\n};\r\n", "import { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { RenderTargetCreationOptions } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Creates a new render target cube wrapper\r\n         * @param size defines the size of the texture\r\n         * @param options defines the options used to create the texture\r\n         * @returns a new render target cube wrapper\r\n         */\r\n        createRenderTargetCubeTexture(size: number, options?: RenderTargetCreationOptions): RenderTargetWrapper;\r\n    }\r\n}\r\n\r\nThinWebGPUEngine.prototype.createRenderTargetCubeTexture = function (size: number, options?: RenderTargetCreationOptions): RenderTargetWrapper {\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);\r\n\r\n    const fullOptions = {\r\n        generateMipMaps: true,\r\n        generateDepthBuffer: true,\r\n        generateStencilBuffer: false,\r\n        type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: Constants.TEXTUREFORMAT_RGBA,\r\n        samples: 1,\r\n        ...options,\r\n    };\r\n    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;\r\n\r\n    rtWrapper.label = fullOptions.label ?? \"RenderTargetWrapper\";\r\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer;\r\n\r\n    const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\r\n\r\n    texture.width = size;\r\n    texture.height = size;\r\n    texture.depth = 0;\r\n    texture.isReady = true;\r\n    texture.isCube = true;\r\n    texture.samples = fullOptions.samples;\r\n    texture.generateMipMaps = fullOptions.generateMipMaps;\r\n    texture.samplingMode = fullOptions.samplingMode;\r\n    texture.type = fullOptions.type;\r\n    texture.format = fullOptions.format;\r\n\r\n    this._internalTexturesCache.push(texture);\r\n    rtWrapper.setTextures(texture);\r\n\r\n    if (rtWrapper._generateDepthBuffer || rtWrapper._generateStencilBuffer) {\r\n        rtWrapper.createDepthStencilTexture(\r\n            0,\r\n            fullOptions.samplingMode === undefined ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_BILINEAR_SAMPLINGMODE ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_TRILINEAR_SAMPLINGMODE ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST,\r\n            rtWrapper._generateStencilBuffer,\r\n            rtWrapper.samples\r\n        );\r\n    }\r\n\r\n    if (options && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n        texture.generateMipMaps = true;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n\r\n    if (options && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n        texture.generateMipMaps = false;\r\n    }\r\n\r\n    return rtWrapper;\r\n};\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n// \"Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed.\"\r\n// https://en.wikipedia.org/wiki/Coroutine\r\n\r\n// In this implementation, coroutines are typically created via generator functions (function* with yield statements).\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\r\n\r\n// In this implementation, the generator function (possibly parameterized) is referred to as a coroutine factory, and the returned iterator is referred to as the coroutine.\r\n// Technically yielding generator functions are not required - anything that implements the contract of Coroutine<T> can be run as a coroutine.\r\n\r\n// The coroutine is started with the first call to next on the iterator, it is suspended with yield statements, and it is resumed with additional calls to next on the iterator.\r\n// To create an object satisfying the Coroutine<T> contract with a generator function, it must not yield values, but rather only void via a plain \"yield;\" statement.\r\n// Coroutines can call other coroutines via:\r\n// 1. yield* someOtherCoroutine(); // If the called coroutine does not return a value\r\n// 2. const result = yield* someOtherCoroutine(); // If the called coroutine returns a value\r\n\r\n// Coroutines are run with the runCoroutine function, which takes a Coroutine<T>, a CoroutineScheduler<T>, and a success and error callback.\r\n// A scheduler is responsible for scheduling the next step of a coroutine, either synchronously or asynchronously.\r\n\r\n/**\r\n * A Coroutine<T> is the intersection of:\r\n * 1. An Iterator that yields void, returns a T, and is not passed values with calls to next.\r\n * 2. An IterableIterator of void (since it only yields void).\r\n */\r\ntype CoroutineBase<TStep, TReturn> = Iterator<TStep, TReturn, void> & IterableIterator<TStep>;\r\n/** @internal */\r\nexport type Coroutine<T> = CoroutineBase<void, T>;\r\n/** @internal */\r\nexport type AsyncCoroutine<T> = CoroutineBase<void | Promise<void>, T>;\r\n\r\n// A CoroutineStep<T> represents a single step of a coroutine, and is an IteratorResult as returned from Coroutine<T>.next().\r\n/** @internal */\r\nexport type CoroutineStep<T> = IteratorResult<void, T>;\r\n\r\n// A CoroutineScheduler<T> is responsible for scheduling the call to Coroutine<T>.next and invokes the success or error callback after next is called.\r\n/** @internal */\r\nexport type CoroutineScheduler<T> = (coroutine: AsyncCoroutine<T>, onStep: (stepResult: CoroutineStep<T>) => void, onError: (stepError: any) => void) => void;\r\n\r\n// The inline scheduler simply steps the coroutine synchronously. This is useful for running a coroutine synchronously, and also as a helper function for other schedulers.\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function inlineScheduler<T>(coroutine: AsyncCoroutine<T>, onStep: (stepResult: CoroutineStep<T>) => void, onError: (stepError: any) => void) {\r\n    try {\r\n        const step = coroutine.next();\r\n\r\n        if (step.done) {\r\n            onStep(step);\r\n        } else if (!step.value) {\r\n            // NOTE: The properties of step have been narrowed, but the type of step itself is not narrowed, so the cast below is the most type safe way to deal with this without instantiating a new object to hold the values.\r\n            onStep(step as { done: typeof step.done; value: typeof step.value });\r\n        } else {\r\n            // eslint-disable-next-line github/no-then\r\n            step.value.then(() => {\r\n                step.value = undefined;\r\n                onStep(step as { done: typeof step.done; value: typeof step.value });\r\n            }, onError);\r\n        }\r\n    } catch (error) {\r\n        onError(error);\r\n    }\r\n}\r\n\r\n// The yielding scheduler steps the coroutine synchronously until the specified time interval has elapsed, then yields control so other operations can be performed.\r\n// A single instance of a yielding scheduler could be shared across multiple coroutines to yield when their collective work exceeds the threshold.\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function createYieldingScheduler<T>(yieldAfterMS = 25) {\r\n    let startTime: number | undefined;\r\n    return (coroutine: AsyncCoroutine<T>, onStep: (stepResult: CoroutineStep<T>) => void, onError: (stepError: any) => void) => {\r\n        const currentTime = performance.now();\r\n\r\n        if (startTime === undefined || currentTime - startTime > yieldAfterMS) {\r\n            // If this is the first coroutine step, or if the time interval has elapsed, record a new start time, and schedule the coroutine step to happen later, effectively yielding control of the execution context.\r\n            startTime = currentTime;\r\n            setTimeout(() => {\r\n                inlineScheduler(coroutine, onStep, onError);\r\n            }, 0);\r\n        } else {\r\n            // Otherwise it is not time to yield yet, so step the coroutine synchronously.\r\n            inlineScheduler(coroutine, onStep, onError);\r\n        }\r\n    };\r\n}\r\n\r\n// Runs the specified coroutine with the specified scheduler. The success or error callback will be invoked when the coroutine finishes.\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function runCoroutine<T>(\r\n    coroutine: AsyncCoroutine<T>,\r\n    scheduler: CoroutineScheduler<T>,\r\n    onSuccess: (result: T) => void,\r\n    onError: (error: any) => void,\r\n    abortSignal?: AbortSignal\r\n) {\r\n    const resume = () => {\r\n        let reschedule: boolean | undefined;\r\n\r\n        const onStep = (stepResult: CoroutineStep<T>) => {\r\n            if (stepResult.done) {\r\n                // If the coroutine is done, report success.\r\n                onSuccess(stepResult.value);\r\n            } else {\r\n                // If the coroutine is not done, resume the coroutine (via the scheduler).\r\n                if (reschedule === undefined) {\r\n                    // If reschedule is undefined at this point, then the coroutine must have stepped synchronously, so just flag another loop iteration.\r\n                    reschedule = true;\r\n                } else {\r\n                    // If reschedule is defined at this point, then the coroutine must have stepped asynchronously, so call resume to restart the step loop.\r\n                    resume();\r\n                }\r\n            }\r\n        };\r\n\r\n        do {\r\n            reschedule = undefined;\r\n\r\n            if (!abortSignal || !abortSignal.aborted) {\r\n                scheduler(coroutine, onStep, onError);\r\n            } else {\r\n                onError(new Error(\"Aborted\"));\r\n            }\r\n\r\n            if (reschedule === undefined) {\r\n                // If reschedule is undefined at this point, then the coroutine must have stepped asynchronously, so stop looping and let the coroutine be resumed later.\r\n                reschedule = false;\r\n            }\r\n        } while (reschedule);\r\n    };\r\n\r\n    resume();\r\n}\r\n\r\n// Runs the specified coroutine synchronously.\r\n/**\r\n * @internal\r\n */\r\nexport function runCoroutineSync<T>(coroutine: Coroutine<T>, abortSignal?: AbortSignal): T {\r\n    // Run the coroutine with the inline scheduler, storing the returned value, or re-throwing the error (since the error callback will be called synchronously by the inline scheduler).\r\n    let result: T | undefined;\r\n    runCoroutine(\r\n        coroutine,\r\n        inlineScheduler,\r\n        (r: T) => (result = r),\r\n        (e: any) => {\r\n            throw e;\r\n        },\r\n        abortSignal\r\n    );\r\n\r\n    // Synchronously return the result of the coroutine.\r\n    return result!;\r\n}\r\n\r\n// Runs the specified coroutine asynchronously with the specified scheduler.\r\n/**\r\n * @internal\r\n */\r\nexport async function runCoroutineAsync<T>(coroutine: AsyncCoroutine<T>, scheduler: CoroutineScheduler<T>, abortSignal?: AbortSignal): Promise<T> {\r\n    // Run the coroutine with a yielding scheduler, resolving or rejecting the result promise when the coroutine finishes.\r\n    return await new Promise((resolve, reject) => {\r\n        runCoroutine(coroutine, scheduler, resolve, reject, abortSignal);\r\n    });\r\n}\r\n\r\n/**\r\n * Given a function that returns a Coroutine<T>, produce a function with the same parameters that returns a T.\r\n * The returned function runs the coroutine synchronously.\r\n * @param coroutineFactory A function that returns a Coroutine<T>.\r\n * @param abortSignal\r\n * @returns A function that runs the coroutine synchronously.\r\n * @internal\r\n */\r\nexport function makeSyncFunction<TParams extends unknown[], TReturn>(\r\n    coroutineFactory: (...params: TParams) => Coroutine<TReturn>,\r\n    abortSignal?: AbortSignal\r\n): (...params: TParams) => TReturn {\r\n    return (...params: TParams) => {\r\n        // Run the coroutine synchronously.\r\n        return runCoroutineSync(coroutineFactory(...params), abortSignal);\r\n    };\r\n}\r\n\r\n/**\r\n * Given a function that returns a Coroutine<T>, product a function with the same parameters that returns a Promise<T>.\r\n * The returned function runs the coroutine asynchronously, yield control of the execution context occasionally to enable a more responsive experience.\r\n * @param coroutineFactory A function that returns a Coroutine<T>.\r\n * @param scheduler\r\n * @param abortSignal\r\n * @returns A function that runs the coroutine asynchronously.\r\n * @internal\r\n */\r\nexport function makeAsyncFunction<TParams extends unknown[], TReturn>(\r\n    coroutineFactory: (...params: TParams) => AsyncCoroutine<TReturn>,\r\n    scheduler: CoroutineScheduler<TReturn>,\r\n    abortSignal?: AbortSignal\r\n): (...params: TParams) => Promise<TReturn> {\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n    return (...params: TParams) => {\r\n        // Run the coroutine asynchronously.\r\n        return runCoroutineAsync(coroutineFactory(...params), scheduler, abortSignal);\r\n    };\r\n}\r\n", "/* eslint-disable jsdoc/require-returns-check */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable, FloatArray, IndicesArray, DeepImmutable } from \"../types\";\r\nimport type { Matrix, Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3, Vector4, TmpVectors } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { nativeOverride } from \"../Misc/decorators\";\r\nimport type { Coroutine } from \"../Misc/coroutine\";\r\nimport { makeSyncFunction, runCoroutineSync } from \"../Misc/coroutine\";\r\nimport type { ICreateCapsuleOptions } from \"./Builders/capsuleBuilder\";\r\nimport { RuntimeError, ErrorCodes } from \"../Misc/error\";\r\n\r\nimport type { Geometry } from \"../Meshes/geometry\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { SubMesh } from \"./subMesh\";\r\n\r\n/**\r\n * Define an interface for all classes that will get and set the data on vertices\r\n */\r\nexport interface IGetSetVerticesData {\r\n    /**\r\n     * Gets a boolean indicating if specific vertex data is present\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns true is data kind is present\r\n     */\r\n    isVerticesDataPresent(kind: string): boolean;\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the indices array or an empty array if the mesh has no geometry\r\n     */\r\n    getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray>;\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    setVerticesData(kind: string, data: FloatArray, updatable: boolean, stride?: number): void;\r\n    /**\r\n     * Update a specific associated vertex buffer\r\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\r\n     */\r\n    updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): void;\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    setIndices(indices: IndicesArray, totalVertices: Nullable<number>, updatable?: boolean): void;\r\n}\r\n\r\n/** Class used to attach material info to sub section of a vertex data class */\r\nexport class VertexDataMaterialInfo {\r\n    /** Defines the material index to use */\r\n    public materialIndex: number;\r\n    /** Defines vertex index start*/\r\n    public verticesStart: number;\r\n    /** Defines vertices count */\r\n    public verticesCount: number;\r\n    /** Defines index start */\r\n    public indexStart: number;\r\n    /** Defines indices count */\r\n    public indexCount: number;\r\n}\r\n\r\n/**\r\n * Interface used to define a object like a vertex data structure\r\n */\r\nexport interface IVertexDataLike {\r\n    /**\r\n     * An array of the x, y, z position of each vertex  [...., x, y, z, .....]\r\n     */\r\n    positions: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    normals?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z, w tangent vector of each vertex  [...., x, y, z, w, .....]\r\n     */\r\n    tangents?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    uvs?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    uvs2?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    uvs3?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    uvs4?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    uvs5?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    uvs6?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]\r\n     */\r\n    colors?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).\r\n     */\r\n    matricesIndices?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of weights defining the weight of each indexed matrix in the final computation\r\n     */\r\n    matricesWeights?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible indices\r\n     */\r\n    matricesIndicesExtra?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible weights when the number of indices is extended\r\n     */\r\n    matricesWeightsExtra?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]\r\n     */\r\n    indices?: Nullable<IndicesArray>;\r\n}\r\n\r\n/**\r\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\r\n */\r\nexport class VertexData implements IVertexDataLike {\r\n    /**\r\n     * Mesh side orientation : usually the external or front surface\r\n     */\r\n    public static readonly FRONTSIDE = 0;\r\n    /**\r\n     * Mesh side orientation : usually the internal or back surface\r\n     */\r\n    public static readonly BACKSIDE = 1;\r\n    /**\r\n     * Mesh side orientation : both internal and external or front and back surfaces\r\n     */\r\n    public static readonly DOUBLESIDE = 2;\r\n    /**\r\n     * Mesh side orientation : by default, `FRONTSIDE`\r\n     */\r\n    public static readonly DEFAULTSIDE = 0;\r\n\r\n    private static _UniqueIdGenerator = 0;\r\n\r\n    /**\r\n     * An array of the x, y, z position of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public positions: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public normals: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z, w tangent vector of each vertex  [...., x, y, z, w, .....]\r\n     */\r\n    public tangents: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs2: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs3: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs4: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs5: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs6: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]\r\n     */\r\n    public colors: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).\r\n     */\r\n    public matricesIndices: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of weights defining the weight of each indexed matrix in the final computation\r\n     */\r\n    public matricesWeights: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible indices\r\n     */\r\n    public matricesIndicesExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible weights when the number of indices is extended\r\n     */\r\n    public matricesWeightsExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]\r\n     */\r\n    public indices: Nullable<IndicesArray>;\r\n\r\n    /**\r\n     * An array defining material association for sub sections of the vertex data\r\n     */\r\n    public materialInfos: Nullable<Array<VertexDataMaterialInfo>>;\r\n\r\n    /**\r\n     * Gets the unique ID of this vertex Data\r\n     */\r\n    public uniqueId = 0;\r\n\r\n    /**\r\n     * Metadata used to store contextual values\r\n     */\r\n    public metadata: any = {};\r\n\r\n    /**\r\n     * Gets or sets a value indicating that the mesh must be flagged with hasVertexAlpha = true\r\n     */\r\n    public hasVertexAlpha: boolean;\r\n\r\n    /**\r\n     * Creates a new VertexData\r\n     */\r\n    public constructor() {\r\n        this.uniqueId = VertexData._UniqueIdGenerator;\r\n        VertexData._UniqueIdGenerator++;\r\n    }\r\n\r\n    /**\r\n     * Uses the passed data array to set the set the values for the specified kind of data\r\n     * @param data a linear array of floating numbers\r\n     * @param kind the type of data that is being set, eg positions, colors etc\r\n     */\r\n    public set(data: FloatArray, kind: string) {\r\n        if (!data.length) {\r\n            Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);\r\n        }\r\n\r\n        switch (kind) {\r\n            case VertexBuffer.PositionKind:\r\n                this.positions = data;\r\n                break;\r\n            case VertexBuffer.NormalKind:\r\n                this.normals = data;\r\n                break;\r\n            case VertexBuffer.TangentKind:\r\n                this.tangents = data;\r\n                break;\r\n            case VertexBuffer.UVKind:\r\n                this.uvs = data;\r\n                break;\r\n            case VertexBuffer.UV2Kind:\r\n                this.uvs2 = data;\r\n                break;\r\n            case VertexBuffer.UV3Kind:\r\n                this.uvs3 = data;\r\n                break;\r\n            case VertexBuffer.UV4Kind:\r\n                this.uvs4 = data;\r\n                break;\r\n            case VertexBuffer.UV5Kind:\r\n                this.uvs5 = data;\r\n                break;\r\n            case VertexBuffer.UV6Kind:\r\n                this.uvs6 = data;\r\n                break;\r\n            case VertexBuffer.ColorKind:\r\n                this.colors = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesKind:\r\n                this.matricesIndices = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsKind:\r\n                this.matricesWeights = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesExtraKind:\r\n                this.matricesIndicesExtra = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsExtraKind:\r\n                this.matricesWeightsExtra = data;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Mesh.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param mesh the mesh the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns the VertexData\r\n     */\r\n    public applyToMesh(mesh: Mesh, updatable?: boolean): VertexData {\r\n        this._applyTo(mesh, updatable, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Geometry.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param geometry the geometry the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns VertexData\r\n     */\r\n    public applyToGeometry(geometry: Geometry, updatable?: boolean): VertexData {\r\n        this._applyTo(geometry, updatable, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated mesh\r\n     * @param mesh the mesh to be updated\r\n     * @returns VertexData\r\n     */\r\n    public updateMesh(mesh: Mesh): VertexData {\r\n        this._update(mesh);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated geometry\r\n     * @param geometry the geometry to be updated\r\n     * @returns VertexData.\r\n     */\r\n    public updateGeometry(geometry: Geometry): VertexData {\r\n        this._update(geometry);\r\n        return this;\r\n    }\r\n\r\n    private readonly _applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public *_applyToCoroutine(meshOrGeometry: IGetSetVerticesData, updatable: boolean = false, isAsync: boolean): Coroutine<VertexData> {\r\n        if (this.positions) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.colors) {\r\n            const stride = this.positions && this.colors.length === this.positions.length ? 3 : 4;\r\n            meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable, stride);\r\n            if (this.hasVertexAlpha && (meshOrGeometry as any).hasVertexAlpha !== undefined) {\r\n                (meshOrGeometry as any).hasVertexAlpha = true;\r\n            }\r\n\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        } else {\r\n            meshOrGeometry.setIndices([], null);\r\n        }\r\n\r\n        if ((meshOrGeometry as Mesh).subMeshes && this.materialInfos && this.materialInfos.length > 1) {\r\n            const mesh = meshOrGeometry as Mesh;\r\n            mesh.subMeshes = [];\r\n            for (const matInfo of this.materialInfos) {\r\n                new SubMesh(matInfo.materialIndex, matInfo.verticesStart, matInfo.verticesCount, matInfo.indexStart, matInfo.indexCount, mesh);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _update(meshOrGeometry: IGetSetVerticesData, updateExtends?: boolean, makeItUnique?: boolean): VertexData {\r\n        if (this.positions) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    @nativeOverride.filter((...[coordinates]: Parameters<typeof VertexData._TransformVector3Coordinates>) => !Array.isArray(coordinates))\r\n    private static _TransformVector3Coordinates(coordinates: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = coordinates.length) {\r\n        const coordinate = TmpVectors.Vector3[0];\r\n        const transformedCoordinate = TmpVectors.Vector3[1];\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            Vector3.FromArrayToRef(coordinates, index, coordinate);\r\n            Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);\r\n            coordinates[index] = transformedCoordinate.x;\r\n            coordinates[index + 1] = transformedCoordinate.y;\r\n            coordinates[index + 2] = transformedCoordinate.z;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[normals]: Parameters<typeof VertexData._TransformVector3Normals>) => !Array.isArray(normals))\r\n    private static _TransformVector3Normals(normals: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = normals.length) {\r\n        const normal = TmpVectors.Vector3[0];\r\n        const transformedNormal = TmpVectors.Vector3[1];\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            Vector3.FromArrayToRef(normals, index, normal);\r\n            Vector3.TransformNormalToRef(normal, transformation, transformedNormal);\r\n            normals[index] = transformedNormal.x;\r\n            normals[index + 1] = transformedNormal.y;\r\n            normals[index + 2] = transformedNormal.z;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[normals]: Parameters<typeof VertexData._TransformVector4Normals>) => !Array.isArray(normals))\r\n    private static _TransformVector4Normals(normals: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = normals.length) {\r\n        const normal = TmpVectors.Vector4[0];\r\n        const transformedNormal = TmpVectors.Vector4[1];\r\n        for (let index = offset; index < offset + length; index += 4) {\r\n            Vector4.FromArrayToRef(normals, index, normal);\r\n            Vector4.TransformNormalToRef(normal, transformation, transformedNormal);\r\n            normals[index] = transformedNormal.x;\r\n            normals[index + 1] = transformedNormal.y;\r\n            normals[index + 2] = transformedNormal.z;\r\n            normals[index + 3] = transformedNormal.w;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[indices]: Parameters<typeof VertexData._FlipFaces>) => !Array.isArray(indices))\r\n    private static _FlipFaces(indices: IndicesArray, offset = 0, length = indices.length) {\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            const tmp = indices[index + 1];\r\n            indices[index + 1] = indices[index + 2];\r\n            indices[index + 2] = tmp;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transforms each position and each normal of the vertexData according to the passed Matrix\r\n     * @param matrix the transforming matrix\r\n     * @returns the VertexData\r\n     */\r\n    public transform(matrix: Matrix): VertexData {\r\n        const flip = matrix.determinant() < 0;\r\n        if (this.positions) {\r\n            VertexData._TransformVector3Coordinates(this.positions, matrix);\r\n        }\r\n\r\n        if (this.normals) {\r\n            VertexData._TransformVector3Normals(this.normals, matrix);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            VertexData._TransformVector4Normals(this.tangents, matrix);\r\n        }\r\n\r\n        if (flip && this.indices) {\r\n            VertexData._FlipFaces(this.indices);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Generates an array of vertex data where each vertex data only has one material info\r\n     * @returns An array of VertexData\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public splitBasedOnMaterialID() {\r\n        if (!this.materialInfos || this.materialInfos.length < 2) {\r\n            return [this];\r\n        }\r\n\r\n        const result: VertexData[] = [];\r\n        for (const materialInfo of this.materialInfos) {\r\n            const vertexData = new VertexData();\r\n\r\n            if (this.positions) {\r\n                vertexData.positions = this.positions.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);\r\n            }\r\n\r\n            if (this.normals) {\r\n                vertexData.normals = this.normals.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);\r\n            }\r\n\r\n            if (this.tangents) {\r\n                vertexData.tangents = this.tangents.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.colors) {\r\n                vertexData.colors = this.colors.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.uvs) {\r\n                vertexData.uvs = this.uvs.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs2) {\r\n                vertexData.uvs2 = this.uvs2.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs3) {\r\n                vertexData.uvs3 = this.uvs3.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs4) {\r\n                vertexData.uvs4 = this.uvs4.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs5) {\r\n                vertexData.uvs5 = this.uvs5.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs6) {\r\n                vertexData.uvs6 = this.uvs6.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.matricesIndices) {\r\n                vertexData.matricesIndices = this.matricesIndices.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.matricesIndicesExtra) {\r\n                vertexData.matricesIndicesExtra = this.matricesIndicesExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.matricesWeights) {\r\n                vertexData.matricesWeights = this.matricesWeights.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.matricesWeightsExtra) {\r\n                vertexData.matricesWeightsExtra = this.matricesWeightsExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.indices) {\r\n                vertexData.indices = [];\r\n                for (let index = materialInfo.indexStart; index < materialInfo.indexStart + materialInfo.indexCount; index++) {\r\n                    vertexData.indices.push(this.indices[index] - materialInfo.verticesStart);\r\n                }\r\n            }\r\n\r\n            const newMaterialInfo = new VertexDataMaterialInfo();\r\n            newMaterialInfo.indexStart = 0;\r\n            newMaterialInfo.indexCount = vertexData.indices ? vertexData.indices.length : 0;\r\n            newMaterialInfo.materialIndex = materialInfo.materialIndex;\r\n            newMaterialInfo.verticesStart = 0;\r\n            newMaterialInfo.verticesCount = (vertexData.positions ? vertexData.positions.length : 0) / 3;\r\n            vertexData.materialInfos = [newMaterialInfo];\r\n\r\n            result.push(vertexData);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Merges the passed VertexData into the current one\r\n     * @param others the VertexData to be merged into the current one\r\n     * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\r\n     * @param forceCloneIndices defines a boolean indicating if indices are forced to be cloned\r\n     * @param mergeMaterialIds defines a boolean indicating if we need to merge the material infos\r\n     * @param enableCompletion defines a boolean indicating if the vertex data should be completed to be compatible\r\n     * @returns the modified VertexData\r\n     */\r\n    public merge(others: VertexData | VertexData[], use32BitsIndices = false, forceCloneIndices = false, mergeMaterialIds = false, enableCompletion = false) {\r\n        const vertexDatas: { vertexData: VertexData; transform?: Matrix }[] = Array.isArray(others)\r\n            ? others.map((other) => {\r\n                  return { vertexData: other };\r\n              })\r\n            : [{ vertexData: others }];\r\n        return runCoroutineSync(this._mergeCoroutine(undefined, vertexDatas, use32BitsIndices, false, forceCloneIndices, mergeMaterialIds, enableCompletion));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public *_mergeCoroutine(\r\n        transform: Matrix | undefined,\r\n        vertexDatas: { vertexData: VertexData; transform?: Matrix }[],\r\n        use32BitsIndices = false,\r\n        isAsync: boolean,\r\n        forceCloneIndices: boolean,\r\n        mergeMaterialIds = false,\r\n        enableCompletion = false\r\n    ): Coroutine<VertexData> {\r\n        this._validate();\r\n\r\n        let others = vertexDatas.map((vertexData) => vertexData.vertexData);\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        let root: VertexData = this;\r\n\r\n        if (enableCompletion) {\r\n            // First let's make sure we have the max set of attributes on the main vertex data\r\n            for (const other of others) {\r\n                if (!other) {\r\n                    continue;\r\n                }\r\n\r\n                other._validate();\r\n\r\n                if (!this.normals && other.normals) {\r\n                    this.normals = new Float32Array(this.positions!.length);\r\n                }\r\n\r\n                if (!this.tangents && other.tangents) {\r\n                    this.tangents = new Float32Array((this.positions!.length / 3) * 4);\r\n                }\r\n\r\n                if (!this.uvs && other.uvs) {\r\n                    this.uvs = new Float32Array((this.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (!this.uvs2 && other.uvs2) {\r\n                    this.uvs2 = new Float32Array((this.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (!this.uvs3 && other.uvs3) {\r\n                    this.uvs3 = new Float32Array((this.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (!this.uvs4 && other.uvs4) {\r\n                    this.uvs4 = new Float32Array((this.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (!this.uvs5 && other.uvs5) {\r\n                    this.uvs5 = new Float32Array((this.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (!this.uvs6 && other.uvs6) {\r\n                    this.uvs6 = new Float32Array((this.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (!this.colors && other.colors) {\r\n                    this.colors = new Float32Array((this.positions!.length / 3) * 4);\r\n                    this.colors.fill(1); // Set to white by default\r\n                }\r\n\r\n                if (!this.matricesIndices && other.matricesIndices) {\r\n                    this.matricesIndices = new Float32Array((this.positions!.length / 3) * 4);\r\n                }\r\n\r\n                if (!this.matricesWeights && other.matricesWeights) {\r\n                    this.matricesWeights = new Float32Array((this.positions!.length / 3) * 4);\r\n                }\r\n\r\n                if (!this.matricesIndicesExtra && other.matricesIndicesExtra) {\r\n                    this.matricesIndicesExtra = new Float32Array((this.positions!.length / 3) * 4);\r\n                }\r\n\r\n                if (!this.matricesWeightsExtra && other.matricesWeightsExtra) {\r\n                    this.matricesWeightsExtra = new Float32Array((this.positions!.length / 3) * 4);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const other of others) {\r\n            if (!other) {\r\n                continue;\r\n            }\r\n\r\n            if (!enableCompletion) {\r\n                other._validate();\r\n                if (\r\n                    !this.normals !== !other.normals ||\r\n                    !this.tangents !== !other.tangents ||\r\n                    !this.uvs !== !other.uvs ||\r\n                    !this.uvs2 !== !other.uvs2 ||\r\n                    !this.uvs3 !== !other.uvs3 ||\r\n                    !this.uvs4 !== !other.uvs4 ||\r\n                    !this.uvs5 !== !other.uvs5 ||\r\n                    !this.uvs6 !== !other.uvs6 ||\r\n                    !this.colors !== !other.colors ||\r\n                    !this.matricesIndices !== !other.matricesIndices ||\r\n                    !this.matricesWeights !== !other.matricesWeights ||\r\n                    !this.matricesIndicesExtra !== !other.matricesIndicesExtra ||\r\n                    !this.matricesWeightsExtra !== !other.matricesWeightsExtra\r\n                ) {\r\n                    throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\r\n                }\r\n            } else {\r\n                // Align the others with main set of attributes\r\n                if (this.normals && !other.normals) {\r\n                    other.normals = new Float32Array(other.positions!.length);\r\n                }\r\n\r\n                if (this.tangents && !other.tangents) {\r\n                    other.tangents = new Float32Array((other.positions!.length / 3) * 4);\r\n                }\r\n\r\n                if (this.uvs && !other.uvs) {\r\n                    other.uvs = new Float32Array((other.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (this.uvs2 && !other.uvs2) {\r\n                    other.uvs2 = new Float32Array((other.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (this.uvs3 && !other.uvs3) {\r\n                    other.uvs3 = new Float32Array((other.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (this.uvs4 && !other.uvs4) {\r\n                    other.uvs4 = new Float32Array((other.positions!.length / 3) * 2);\r\n                }\r\n                if (this.uvs5 && !other.uvs5) {\r\n                    other.uvs5 = new Float32Array((other.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (this.uvs6 && !other.uvs6) {\r\n                    other.uvs6 = new Float32Array((other.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (this.colors && !other.colors) {\r\n                    other.colors = new Float32Array((other.positions!.length / 3) * 4);\r\n                    other.colors.fill(1); // Set to white by default\r\n                }\r\n\r\n                if (this.matricesIndices && !other.matricesIndices) {\r\n                    other.matricesIndices = new Float32Array((other.positions!.length / 3) * 4);\r\n                }\r\n                if (this.matricesWeights && !other.matricesWeights) {\r\n                    other.matricesWeights = new Float32Array((other.positions!.length / 3) * 4);\r\n                }\r\n\r\n                if (this.matricesIndicesExtra && !other.matricesIndicesExtra) {\r\n                    other.matricesIndicesExtra = new Float32Array((other.positions!.length / 3) * 4);\r\n                }\r\n\r\n                if (this.matricesWeightsExtra && !other.matricesWeightsExtra) {\r\n                    other.matricesWeightsExtra = new Float32Array((other.positions!.length / 3) * 4);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (mergeMaterialIds) {\r\n            // Merge material infos\r\n            let materialIndex = 0;\r\n            let indexOffset = 0;\r\n            let vertexOffset = 0;\r\n            const materialInfos: VertexDataMaterialInfo[] = [];\r\n            let currentMaterialInfo: Nullable<VertexDataMaterialInfo> = null;\r\n            const vertexDataList: { vertexData: VertexData; transform?: Matrix }[] = [];\r\n\r\n            // We need to split vertexData with more than one materialInfo\r\n            for (const split of this.splitBasedOnMaterialID()) {\r\n                vertexDataList.push({ vertexData: split, transform: transform });\r\n            }\r\n\r\n            for (const data of vertexDatas) {\r\n                if (!data.vertexData) {\r\n                    continue;\r\n                }\r\n                for (const split of data.vertexData.splitBasedOnMaterialID()) {\r\n                    vertexDataList.push({ vertexData: split, transform: data.transform });\r\n                }\r\n            }\r\n\r\n            // Sort by material IDs\r\n            vertexDataList.sort((a, b) => {\r\n                const matInfoA = a.vertexData.materialInfos ? a.vertexData.materialInfos[0].materialIndex : 0;\r\n                const matInfoB = b.vertexData.materialInfos ? b.vertexData.materialInfos[0].materialIndex : 0;\r\n\r\n                if (matInfoA > matInfoB) {\r\n                    return 1;\r\n                }\r\n\r\n                if (matInfoA === matInfoB) {\r\n                    return 0;\r\n                }\r\n\r\n                return -1;\r\n            });\r\n\r\n            // Build the new material info\r\n            for (const vertexDataSource of vertexDataList) {\r\n                const vertexData = vertexDataSource.vertexData;\r\n                if (vertexData.materialInfos) {\r\n                    materialIndex = vertexData.materialInfos[0].materialIndex;\r\n                } else {\r\n                    materialIndex = 0;\r\n                }\r\n                if (currentMaterialInfo && currentMaterialInfo.materialIndex === materialIndex) {\r\n                    currentMaterialInfo.indexCount += vertexData.indices!.length;\r\n                    currentMaterialInfo.verticesCount += vertexData.positions!.length / 3;\r\n                } else {\r\n                    const materialInfo = new VertexDataMaterialInfo();\r\n                    materialInfo.materialIndex = materialIndex;\r\n                    materialInfo.indexStart = indexOffset;\r\n                    materialInfo.indexCount = vertexData.indices!.length;\r\n                    materialInfo.verticesStart = vertexOffset;\r\n                    materialInfo.verticesCount = vertexData.positions!.length / 3;\r\n\r\n                    materialInfos.push(materialInfo);\r\n                    currentMaterialInfo = materialInfo;\r\n                }\r\n                indexOffset += vertexData.indices!.length;\r\n                vertexOffset += vertexData.positions!.length / 3;\r\n            }\r\n            // Extract sorted values\r\n            const first = vertexDataList.splice(0, 1)[0];\r\n            root = first.vertexData;\r\n            transform = first.transform;\r\n            others = vertexDataList.map((v) => v.vertexData);\r\n            vertexDatas = vertexDataList;\r\n\r\n            this.materialInfos = materialInfos;\r\n        }\r\n\r\n        // Merge geometries\r\n        const totalIndices = others.reduce((indexSum, vertexData) => indexSum + (vertexData.indices?.length ?? 0), root.indices?.length ?? 0);\r\n        const sliceIndices = forceCloneIndices || others.some((vertexData) => vertexData.indices === root.indices);\r\n        let indices = sliceIndices ? root.indices?.slice() : root.indices;\r\n        if (totalIndices > 0) {\r\n            let indicesOffset = indices?.length ?? 0;\r\n\r\n            if (!indices) {\r\n                indices = new Array<number>(totalIndices);\r\n            }\r\n\r\n            if (indices.length !== totalIndices) {\r\n                if (Array.isArray(indices)) {\r\n                    indices.length = totalIndices;\r\n                } else {\r\n                    const temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);\r\n                    temp.set(indices);\r\n                    indices = temp;\r\n                }\r\n\r\n                if (transform && transform.determinant() < 0) {\r\n                    VertexData._FlipFaces(indices, 0, indicesOffset);\r\n                }\r\n            }\r\n\r\n            let positionsOffset = root.positions ? root.positions.length / 3 : 0;\r\n            for (const { vertexData: other, transform } of vertexDatas) {\r\n                if (other.indices) {\r\n                    for (let index = 0; index < other.indices.length; index++) {\r\n                        indices[indicesOffset + index] = other.indices[index] + positionsOffset;\r\n                    }\r\n\r\n                    if (transform && transform.determinant() < 0) {\r\n                        VertexData._FlipFaces(indices, indicesOffset, other.indices.length);\r\n                    }\r\n\r\n                    // The call to _validate already checked for positions\r\n                    positionsOffset += other.positions!.length / 3;\r\n                    indicesOffset += other.indices.length;\r\n\r\n                    if (isAsync) {\r\n                        yield;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.indices = indices!;\r\n\r\n        this.positions = VertexData._MergeElement(\r\n            VertexBuffer.PositionKind,\r\n            root.positions,\r\n            transform,\r\n            vertexDatas.map((other) => [other.vertexData.positions, other.transform])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        if (root.normals) {\r\n            this.normals = VertexData._MergeElement(\r\n                VertexBuffer.NormalKind,\r\n                root.normals,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.normals, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.tangents) {\r\n            this.tangents = VertexData._MergeElement(\r\n                VertexBuffer.TangentKind,\r\n                root.tangents,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.tangents, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs) {\r\n            this.uvs = VertexData._MergeElement(\r\n                VertexBuffer.UVKind,\r\n                root.uvs,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs2) {\r\n            this.uvs2 = VertexData._MergeElement(\r\n                VertexBuffer.UV2Kind,\r\n                root.uvs2,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs2, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs3) {\r\n            this.uvs3 = VertexData._MergeElement(\r\n                VertexBuffer.UV3Kind,\r\n                root.uvs3,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs3, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs4) {\r\n            this.uvs4 = VertexData._MergeElement(\r\n                VertexBuffer.UV4Kind,\r\n                root.uvs4,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs4, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs5) {\r\n            this.uvs5 = VertexData._MergeElement(\r\n                VertexBuffer.UV5Kind,\r\n                root.uvs5,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs5, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs6) {\r\n            this.uvs6 = VertexData._MergeElement(\r\n                VertexBuffer.UV6Kind,\r\n                root.uvs6,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs6, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.colors) {\r\n            this.colors = VertexData._MergeElement(\r\n                VertexBuffer.ColorKind,\r\n                root.colors,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.colors, other.transform])\r\n            );\r\n            if (root.hasVertexAlpha !== undefined || vertexDatas.some((other) => other.vertexData.hasVertexAlpha !== undefined)) {\r\n                this.hasVertexAlpha = root.hasVertexAlpha || vertexDatas.some((other) => other.vertexData.hasVertexAlpha);\r\n            }\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesIndices) {\r\n            this.matricesIndices = VertexData._MergeElement(\r\n                VertexBuffer.MatricesIndicesKind,\r\n                root.matricesIndices,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesIndices, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesWeights) {\r\n            this.matricesWeights = VertexData._MergeElement(\r\n                VertexBuffer.MatricesWeightsKind,\r\n                root.matricesWeights,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesWeights, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesIndicesExtra) {\r\n            this.matricesIndicesExtra = VertexData._MergeElement(\r\n                VertexBuffer.MatricesIndicesExtraKind,\r\n                root.matricesIndicesExtra,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesIndicesExtra, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesWeightsExtra) {\r\n            this.matricesWeightsExtra = VertexData._MergeElement(\r\n                VertexBuffer.MatricesWeightsExtraKind,\r\n                root.matricesWeightsExtra,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesWeightsExtra, other.transform])\r\n            );\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private static _MergeElement(\r\n        kind: string,\r\n        source: Nullable<FloatArray>,\r\n        transform: Matrix | undefined,\r\n        others: readonly (readonly [element: Nullable<FloatArray>, transform?: Matrix])[]\r\n    ): Nullable<FloatArray> {\r\n        const nonNullOthers = others.filter((other): other is [element: FloatArray, transform?: Matrix] => other[0] !== null && other[0] !== undefined);\r\n\r\n        // If there is no source to copy and no other non-null sources then skip this element.\r\n        if (!source && nonNullOthers.length == 0) {\r\n            return source;\r\n        }\r\n\r\n        if (!source) {\r\n            return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));\r\n        }\r\n\r\n        const len = nonNullOthers.reduce((sumLen, elements) => sumLen + elements[0].length, source.length);\r\n\r\n        const transformRange =\r\n            kind === VertexBuffer.PositionKind\r\n                ? VertexData._TransformVector3Coordinates\r\n                : kind === VertexBuffer.NormalKind\r\n                  ? VertexData._TransformVector3Normals\r\n                  : kind === VertexBuffer.TangentKind\r\n                    ? VertexData._TransformVector4Normals\r\n                    : () => {};\r\n\r\n        if (source instanceof Float32Array) {\r\n            // use non-loop method when the source is Float32Array\r\n            const ret32 = new Float32Array(len);\r\n            ret32.set(source);\r\n            transform && transformRange(ret32, transform, 0, source.length);\r\n\r\n            let offset = source.length;\r\n            for (const [vertexData, transform] of nonNullOthers) {\r\n                ret32.set(vertexData, offset);\r\n                transform && transformRange(ret32, transform, offset, vertexData.length);\r\n                offset += vertexData.length;\r\n            }\r\n            return ret32;\r\n        } else {\r\n            // don't use concat as it is super slow, just loop for other cases\r\n            const ret = new Array<number>(len);\r\n            for (let i = 0; i < source.length; i++) {\r\n                ret[i] = source[i];\r\n            }\r\n            transform && transformRange(ret, transform, 0, source.length);\r\n\r\n            let offset = source.length;\r\n            for (const [vertexData, transform] of nonNullOthers) {\r\n                for (let i = 0; i < vertexData.length; i++) {\r\n                    ret[offset + i] = vertexData[i];\r\n                }\r\n                transform && transformRange(ret, transform, offset, vertexData.length);\r\n                offset += vertexData.length;\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    private _validate(): void {\r\n        if (!this.positions) {\r\n            throw new RuntimeError(\"Positions are required\", ErrorCodes.MeshInvalidPositionsError);\r\n        }\r\n\r\n        const getElementCount = (kind: string, values: FloatArray) => {\r\n            const stride = VertexBuffer.DeduceStride(kind);\r\n            if (values.length % stride !== 0) {\r\n                throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\r\n            }\r\n\r\n            return values.length / stride;\r\n        };\r\n\r\n        const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\r\n\r\n        const validateElementCount = (kind: string, values: FloatArray) => {\r\n            const elementCount = getElementCount(kind, values);\r\n            if (elementCount !== positionsElementCount) {\r\n                throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\r\n            }\r\n        };\r\n\r\n        if (this.normals) {\r\n            validateElementCount(VertexBuffer.NormalKind, this.normals);\r\n        }\r\n        if (this.tangents) {\r\n            validateElementCount(VertexBuffer.TangentKind, this.tangents);\r\n        }\r\n        if (this.uvs) {\r\n            validateElementCount(VertexBuffer.UVKind, this.uvs);\r\n        }\r\n        if (this.uvs2) {\r\n            validateElementCount(VertexBuffer.UV2Kind, this.uvs2);\r\n        }\r\n        if (this.uvs3) {\r\n            validateElementCount(VertexBuffer.UV3Kind, this.uvs3);\r\n        }\r\n        if (this.uvs4) {\r\n            validateElementCount(VertexBuffer.UV4Kind, this.uvs4);\r\n        }\r\n        if (this.uvs5) {\r\n            validateElementCount(VertexBuffer.UV5Kind, this.uvs5);\r\n        }\r\n        if (this.uvs6) {\r\n            validateElementCount(VertexBuffer.UV6Kind, this.uvs6);\r\n        }\r\n        if (this.colors) {\r\n            validateElementCount(VertexBuffer.ColorKind, this.colors);\r\n        }\r\n        if (this.matricesIndices) {\r\n            validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);\r\n        }\r\n        if (this.matricesWeights) {\r\n            validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);\r\n        }\r\n        if (this.matricesIndicesExtra) {\r\n            validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);\r\n        }\r\n        if (this.matricesWeightsExtra) {\r\n            validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current vertex data\r\n     * @returns a copy of the current data\r\n     */\r\n    public clone() {\r\n        const serializationObject = this.serialize();\r\n        return VertexData.Parse(serializationObject);\r\n    }\r\n\r\n    /**\r\n     * Serializes the VertexData\r\n     * @returns a serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        if (this.positions) {\r\n            serializationObject.positions = Array.from(this.positions);\r\n        }\r\n\r\n        if (this.normals) {\r\n            serializationObject.normals = Array.from(this.normals);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            serializationObject.tangents = Array.from(this.tangents);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            serializationObject.uvs = Array.from(this.uvs);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            serializationObject.uvs2 = Array.from(this.uvs2);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            serializationObject.uvs3 = Array.from(this.uvs3);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            serializationObject.uvs4 = Array.from(this.uvs4);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            serializationObject.uvs5 = Array.from(this.uvs5);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            serializationObject.uvs6 = Array.from(this.uvs6);\r\n        }\r\n\r\n        if (this.colors) {\r\n            serializationObject.colors = Array.from(this.colors);\r\n            serializationObject.hasVertexAlpha = this.hasVertexAlpha;\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            serializationObject.matricesIndices = Array.from(this.matricesIndices);\r\n            serializationObject.matricesIndicesExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            serializationObject.matricesWeights = Array.from(this.matricesWeights);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            serializationObject.matricesIndicesExtra = Array.from(this.matricesIndicesExtra);\r\n            serializationObject.matricesIndicesExtraExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            serializationObject.matricesWeightsExtra = Array.from(this.matricesWeightsExtra);\r\n        }\r\n\r\n        serializationObject.indices = this.indices ? Array.from(this.indices as number[]) : [];\r\n\r\n        if (this.materialInfos) {\r\n            serializationObject.materialInfos = [];\r\n            for (const materialInfo of this.materialInfos) {\r\n                const materialInfoSerializationObject = {\r\n                    indexStart: materialInfo.indexStart,\r\n                    indexCount: materialInfo.indexCount,\r\n                    materialIndex: materialInfo.materialIndex,\r\n                    verticesStart: materialInfo.verticesStart,\r\n                    verticesCount: materialInfo.verticesCount,\r\n                };\r\n                serializationObject.materialInfos.push(materialInfoSerializationObject);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Extracts the vertexData from a mesh\r\n     * @param mesh the mesh from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Extracts the vertexData from the geometry\r\n     * @param geometry the geometry from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when the geometry is shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromGeometry(geometry: Geometry, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    private static _ExtractFrom(meshOrGeometry: IGetSetVerticesData, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        const result = new VertexData();\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            const geometry = (meshOrGeometry as Mesh).geometry || (meshOrGeometry as Geometry);\r\n            const vertexBuffer = geometry.getVertexBuffer(VertexBuffer.ColorKind)!;\r\n            const colors = geometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy)!;\r\n            if (vertexBuffer.getSize() === 3) {\r\n                const newColors = new Float32Array((colors.length * 4) / 3);\r\n                for (let i = 0, j = 0; i < colors.length; i += 3, j += 4) {\r\n                    newColors[j] = colors[i];\r\n                    newColors[j + 1] = colors[i + 1];\r\n                    newColors[j + 2] = colors[i + 2];\r\n                    newColors[j + 3] = 1;\r\n                }\r\n                result.colors = newColors;\r\n            } else if (vertexBuffer.getSize() === 4) {\r\n                result.colors = colors;\r\n            } else {\r\n                throw new Error(`Unexpected number of color components: ${vertexBuffer.getSize()}`);\r\n            }\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\r\n            result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\r\n            result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ribbon\r\n     * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n     * * pathArray array of paths, each of which an array of successive Vector3\r\n     * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n     * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n     * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n     * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n     * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n     * @returns the VertexData of the ribbon\r\n     * @deprecated use CreateRibbonVertexData instead\r\n     */\r\n    public static CreateRibbon(options: {\r\n        pathArray: Vector3[][];\r\n        closeArray?: boolean;\r\n        closePath?: boolean;\r\n        offset?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        invertUV?: boolean;\r\n        uvs?: Vector2[];\r\n        colors?: Color4[];\r\n    }): VertexData {\r\n        throw _WarnImport(\"ribbonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n     * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n     * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n     * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the box\r\n     * @deprecated Please use CreateBoxVertexData from the BoxBuilder file instead\r\n     */\r\n    public static CreateBox(options: {\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"boxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * faceTiles sets the pattern, tile size and number of tiles for a face\r\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param options.pattern\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.depth\r\n     * @param options.tileSize\r\n     * @param options.tileWidth\r\n     * @param options.tileHeight\r\n     * @param options.alignHorizontal\r\n     * @param options.alignVertical\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.sideOrientation\r\n     * @returns the VertexData of the box\r\n     * @deprecated Please use CreateTiledBoxVertexData instead\r\n     */\r\n    public static CreateTiledBox(options: {\r\n        pattern?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n    }): VertexData {\r\n        throw _WarnImport(\"tiledBoxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled plane\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * pattern a limited pattern arrangement depending on the number\r\n     * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n     * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n     * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the tiled plane\r\n     * @deprecated use CreateTiledPlaneVertexData instead\r\n     */\r\n    public static CreateTiledPlane(options: {\r\n        pattern?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"tiledPlaneBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * segments sets the number of horizontal strips optional, default 32\r\n     * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n     * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n     * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n     * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n     * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n     * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the ellipsoid\r\n     * @deprecated use CreateSphereVertexData instead\r\n     */\r\n    public static CreateSphere(options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"sphereBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a cylinder, cone or prism\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * height sets the height (y direction) of the cylinder, optional, default 2\r\n     * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n     * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n     * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n     * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n     * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n     * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the cylinder, cone or prism\r\n     * @deprecated please use CreateCylinderVertexData instead\r\n     */\r\n    public static CreateCylinder(options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"cylinderBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a torus\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * diameter the diameter of the torus, optional default 1\r\n     * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the torus\r\n     * @deprecated use CreateTorusVertexData instead\r\n     */\r\n    public static CreateTorus(options: {\r\n        diameter?: number;\r\n        thickness?: number;\r\n        tessellation?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"torusBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the LineSystem\r\n     * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n     *  - lines an array of lines, each line being an array of successive Vector3\r\n     *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n     * @returns the VertexData of the LineSystem\r\n     * @deprecated use CreateLineSystemVertexData instead\r\n     */\r\n    public static CreateLineSystem(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n        throw _WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Create the VertexData for a DashedLines\r\n     * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n     *  - points an array successive Vector3\r\n     *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n     *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n     *  - dashNb the intended total number of dashes, optional, default 200\r\n     * @returns the VertexData for the DashedLines\r\n     * @deprecated use CreateDashedLinesVertexData instead\r\n     */\r\n    public static CreateDashedLines(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n        throw _WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ground\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     *  - width the width (x direction) of the ground, optional, default 1\r\n     *  - height the height (z direction) of the ground, optional, default 1\r\n     *  - subdivisions the number of subdivisions per side, optional, default 1\r\n     * @returns the VertexData of the Ground\r\n     * @deprecated Please use CreateGroundVertexData instead\r\n     */\r\n    public static CreateGround(options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     * * xmin the ground minimum X coordinate, optional, default -1\r\n     * * zmin the ground minimum Z coordinate, optional, default -1\r\n     * * xmax the ground maximum X coordinate, optional, default 1\r\n     * * zmax the ground maximum Z coordinate, optional, default 1\r\n     * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n     * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n     * @returns the VertexData of the TiledGround\r\n     * @deprecated use CreateTiledGroundVertexData instead\r\n     */\r\n    public static CreateTiledGround(options: {\r\n        xmin: number;\r\n        zmin: number;\r\n        xmax: number;\r\n        zmax: number;\r\n        subdivisions?: { w: number; h: number };\r\n        precision?: { w: number; h: number };\r\n    }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Ground designed from a heightmap\r\n     * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\r\n     * * width the width (x direction) of the ground\r\n     * * height the height (z direction) of the ground\r\n     * * subdivisions the number of subdivisions per side\r\n     * * minHeight the minimum altitude on the ground, optional, default 0\r\n     * * maxHeight the maximum altitude on the ground, optional default 1\r\n     * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n     * * buffer the array holding the image color data\r\n     * * bufferWidth the width of image\r\n     * * bufferHeight the height of image\r\n     * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * @returns the VertexData of the Ground designed from a heightmap\r\n     * @deprecated use CreateGroundFromHeightMapVertexData instead\r\n     */\r\n    public static CreateGroundFromHeightMap(options: {\r\n        width: number;\r\n        height: number;\r\n        subdivisions: number;\r\n        minHeight: number;\r\n        maxHeight: number;\r\n        colorFilter: Color3;\r\n        buffer: Uint8Array;\r\n        bufferWidth: number;\r\n        bufferHeight: number;\r\n        alphaFilter: number;\r\n    }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Plane\r\n     * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n     * * size sets the width and height of the plane to the value of size, optional default 1\r\n     * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n     * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the box\r\n     * @deprecated use CreatePlaneVertexData instead\r\n     */\r\n    public static CreatePlane(options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n        throw _WarnImport(\"planeBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Disc or regular Polygon\r\n     * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n     * * radius the radius of the disc, optional default 0.5\r\n     * * tessellation the number of polygon sides, optional, default 64\r\n     * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the box\r\n     * @deprecated use CreateDiscVertexData instead\r\n     */\r\n    public static CreateDisc(options: { radius?: number; tessellation?: number; arc?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n        throw _WarnImport(\"discBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n     * All parameters are provided by CreatePolygon as needed\r\n     * @param polygon a mesh built from polygonTriangulation.build()\r\n     * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n     * @returns the VertexData of the Polygon\r\n     * @deprecated use CreatePolygonVertexData instead\r\n     */\r\n    public static CreatePolygon(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrap?: boolean): VertexData {\r\n        throw _WarnImport(\"polygonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the IcoSphere\r\n     * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n     * * radius the radius of the IcoSphere, optional default 1\r\n     * * radiusX allows stretching in the x direction, optional, default radius\r\n     * * radiusY allows stretching in the y direction, optional, default radius\r\n     * * radiusZ allows stretching in the z direction, optional, default radius\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the IcoSphere\r\n     * @deprecated use CreateIcoSphereVertexData instead\r\n     */\r\n    public static CreateIcoSphere(options: {\r\n        radius?: number;\r\n        radiusX?: number;\r\n        radiusY?: number;\r\n        radiusZ?: number;\r\n        flat?: boolean;\r\n        subdivisions?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"icoSphereBuilder\");\r\n    }\r\n\r\n    // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\r\n    /**\r\n     * Creates the VertexData for a Polyhedron\r\n     * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n     * * type provided types are:\r\n     *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n     *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n     * * size the size of the IcoSphere, optional default 1\r\n     * * sizeX allows stretching in the x direction, optional, default size\r\n     * * sizeY allows stretching in the y direction, optional, default size\r\n     * * sizeZ allows stretching in the z direction, optional, default size\r\n     * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the Polyhedron\r\n     * @deprecated use CreatePolyhedronVertexData instead\r\n     */\r\n    public static CreatePolyhedron(options: {\r\n        type?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        custom?: any;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        flat?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"polyhedronBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n     * @param options an object used to set the following optional parameters for the capsule, required but can be empty\r\n     * @returns the VertexData of the Capsule\r\n     * @deprecated Please use CreateCapsuleVertexData from the capsuleBuilder file instead\r\n     */\r\n    public static CreateCapsule(\r\n        options: ICreateCapsuleOptions = {\r\n            orientation: Vector3.Up(),\r\n            subdivisions: 2,\r\n            tessellation: 16,\r\n            height: 1,\r\n            radius: 0.25,\r\n            capSubdivisions: 6,\r\n        }\r\n    ): VertexData {\r\n        throw _WarnImport(\"capsuleBuilder\");\r\n    }\r\n\r\n    // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n    /**\r\n     * Creates the VertexData for a TorusKnot\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n     * * radius the radius of the torus knot, optional, default 2\r\n     * * tube the thickness of the tube, optional, default 0.5\r\n     * * radialSegments the number of sides on each tube segments, optional, default 32\r\n     * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n     * * p the number of windings around the z axis, optional,  default 2\r\n     * * q the number of windings around the x axis, optional,  default 3\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the Torus Knot\r\n     * @deprecated use CreateTorusKnotVertexData instead\r\n     */\r\n    public static CreateTorusKnot(options: {\r\n        radius?: number;\r\n        tube?: number;\r\n        radialSegments?: number;\r\n        tubularSegments?: number;\r\n        p?: number;\r\n        q?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"torusKnotBuilder\");\r\n    }\r\n\r\n    // Tools\r\n\r\n    /**\r\n     * Compute normals for given positions and indices\r\n     * @param positions an array of vertex positions, [...., x, y, z, ......]\r\n     * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\r\n     * @param normals an array of vertex normals, [...., x, y, z, ......]\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, optional\r\n     * * facetNormals : optional array of facet normals (vector3)\r\n     * * facetPositions : optional array of facet positions (vector3)\r\n     * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\r\n     * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\r\n     * * bInfo : optional bounding info, required for facetPartitioning computation\r\n     * * bbSize : optional bounding box size data, required for facetPartitioning computation\r\n     * * subDiv : optional partitioning data about subdivisions on  each axis (int), required for facetPartitioning computation\r\n     * * useRightHandedSystem: optional boolean to for right handed system computation\r\n     * * depthSort : optional boolean to enable the facet depth sort computation\r\n     * * distanceTo : optional Vector3 to compute the facet depth from this location\r\n     * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\r\n     */\r\n    public static ComputeNormals(\r\n        positions: any,\r\n        indices: any,\r\n        normals: any,\r\n        options?: {\r\n            facetNormals?: any;\r\n            facetPositions?: any;\r\n            facetPartitioning?: any;\r\n            ratio?: number;\r\n            bInfo?: any;\r\n            bbSize?: Vector3;\r\n            subDiv?: any;\r\n            useRightHandedSystem?: boolean;\r\n            depthSort?: boolean;\r\n            distanceTo?: Vector3;\r\n            depthSortedFacets?: any;\r\n        }\r\n    ): void {\r\n        // temporary scalar variables\r\n        let index = 0; // facet index\r\n        let p1p2x = 0.0; // p1p2 vector x coordinate\r\n        let p1p2y = 0.0; // p1p2 vector y coordinate\r\n        let p1p2z = 0.0; // p1p2 vector z coordinate\r\n        let p3p2x = 0.0; // p3p2 vector x coordinate\r\n        let p3p2y = 0.0; // p3p2 vector y coordinate\r\n        let p3p2z = 0.0; // p3p2 vector z coordinate\r\n        let faceNormalx = 0.0; // facet normal x coordinate\r\n        let faceNormaly = 0.0; // facet normal y coordinate\r\n        let faceNormalz = 0.0; // facet normal z coordinate\r\n        let length = 0.0; // facet normal length before normalization\r\n        let v1x = 0; // vector1 x index in the positions array\r\n        let v1y = 0; // vector1 y index in the positions array\r\n        let v1z = 0; // vector1 z index in the positions array\r\n        let v2x = 0; // vector2 x index in the positions array\r\n        let v2y = 0; // vector2 y index in the positions array\r\n        let v2z = 0; // vector2 z index in the positions array\r\n        let v3x = 0; // vector3 x index in the positions array\r\n        let v3y = 0; // vector3 y index in the positions array\r\n        let v3z = 0; // vector3 z index in the positions array\r\n        let computeFacetNormals = false;\r\n        let computeFacetPositions = false;\r\n        let computeFacetPartitioning = false;\r\n        let computeDepthSort = false;\r\n        let faceNormalSign = 1;\r\n        let ratio = 0;\r\n        let distanceTo: Nullable<Vector3> = null;\r\n        if (options) {\r\n            computeFacetNormals = options.facetNormals ? true : false;\r\n            computeFacetPositions = options.facetPositions ? true : false;\r\n            computeFacetPartitioning = options.facetPartitioning ? true : false;\r\n            faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;\r\n            ratio = options.ratio || 0;\r\n            computeDepthSort = options.depthSort ? true : false;\r\n            distanceTo = <Vector3>options.distanceTo;\r\n            if (computeDepthSort) {\r\n                if (distanceTo === undefined) {\r\n                    distanceTo = Vector3.Zero();\r\n                }\r\n            }\r\n        }\r\n\r\n        // facetPartitioning reinit if needed\r\n        let xSubRatio = 0;\r\n        let ySubRatio = 0;\r\n        let zSubRatio = 0;\r\n        let subSq = 0;\r\n        if (computeFacetPartitioning && options && options.bbSize) {\r\n            //let bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;\r\n            //bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;\r\n            xSubRatio = (options.subDiv.X * ratio) / options.bbSize.x;\r\n            ySubRatio = (options.subDiv.Y * ratio) / options.bbSize.y;\r\n            zSubRatio = (options.subDiv.Z * ratio) / options.bbSize.z;\r\n            subSq = options.subDiv.max * options.subDiv.max;\r\n            options.facetPartitioning.length = 0;\r\n        }\r\n\r\n        // reset the normals\r\n        for (index = 0; index < positions.length; index++) {\r\n            normals[index] = 0.0;\r\n        }\r\n\r\n        // Loop : 1 indice triplet = 1 facet\r\n        const nbFaces = (indices.length / 3) | 0;\r\n        for (index = 0; index < nbFaces; index++) {\r\n            // get the indexes of the coordinates of each vertex of the facet\r\n            v1x = indices[index * 3] * 3;\r\n            v1y = v1x + 1;\r\n            v1z = v1x + 2;\r\n            v2x = indices[index * 3 + 1] * 3;\r\n            v2y = v2x + 1;\r\n            v2z = v2x + 2;\r\n            v3x = indices[index * 3 + 2] * 3;\r\n            v3y = v3x + 1;\r\n            v3z = v3x + 2;\r\n\r\n            p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\r\n            p1p2y = positions[v1y] - positions[v2y];\r\n            p1p2z = positions[v1z] - positions[v2z];\r\n\r\n            p3p2x = positions[v3x] - positions[v2x];\r\n            p3p2y = positions[v3y] - positions[v2y];\r\n            p3p2z = positions[v3z] - positions[v2z];\r\n\r\n            // compute the face normal with the cross product\r\n            faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\r\n            faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\r\n            faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\r\n            // normalize this normal and store it in the array facetData\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = length === 0 ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            if (computeFacetNormals && options) {\r\n                options.facetNormals[index].x = faceNormalx;\r\n                options.facetNormals[index].y = faceNormaly;\r\n                options.facetNormals[index].z = faceNormalz;\r\n            }\r\n\r\n            if (computeFacetPositions && options) {\r\n                // compute and the facet barycenter coordinates in the array facetPositions\r\n                options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\r\n                options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\r\n                options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\r\n            }\r\n\r\n            if (computeFacetPartitioning && options) {\r\n                // store the facet indexes in arrays in the main facetPartitioning array :\r\n                // compute each facet vertex (+ facet barycenter) index in the partiniong array\r\n                const ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n\r\n                const blockIdxV1 = b1x + options.subDiv.max * b1y + subSq * b1z;\r\n                const blockIdxV2 = b2x + options.subDiv.max * b2y + subSq * b2z;\r\n                const blockIdxV3 = b3x + options.subDiv.max * b3y + subSq * b3z;\r\n                const blockIdxV4 = ox + options.subDiv.max * oy + subSq * oz;\r\n\r\n                options.facetPartitioning[blockIdxV4] = options.facetPartitioning[blockIdxV4] ? options.facetPartitioning[blockIdxV4] : [];\r\n                options.facetPartitioning[blockIdxV1] = options.facetPartitioning[blockIdxV1] ? options.facetPartitioning[blockIdxV1] : [];\r\n                options.facetPartitioning[blockIdxV2] = options.facetPartitioning[blockIdxV2] ? options.facetPartitioning[blockIdxV2] : [];\r\n                options.facetPartitioning[blockIdxV3] = options.facetPartitioning[blockIdxV3] ? options.facetPartitioning[blockIdxV3] : [];\r\n\r\n                // push each facet index in each block containing the vertex\r\n                options.facetPartitioning[blockIdxV1].push(index);\r\n                if (blockIdxV2 != blockIdxV1) {\r\n                    options.facetPartitioning[blockIdxV2].push(index);\r\n                }\r\n                if (!(blockIdxV3 == blockIdxV2 || blockIdxV3 == blockIdxV1)) {\r\n                    options.facetPartitioning[blockIdxV3].push(index);\r\n                }\r\n                if (!(blockIdxV4 == blockIdxV1 || blockIdxV4 == blockIdxV2 || blockIdxV4 == blockIdxV3)) {\r\n                    options.facetPartitioning[blockIdxV4].push(index);\r\n                }\r\n            }\r\n\r\n            if (computeDepthSort && options && options.facetPositions) {\r\n                const dsf = options.depthSortedFacets[index];\r\n                dsf.ind = index * 3;\r\n                dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo!);\r\n            }\r\n\r\n            // compute the normals anyway\r\n            normals[v1x] += faceNormalx; // accumulate all the normals per face\r\n            normals[v1y] += faceNormaly;\r\n            normals[v1z] += faceNormalz;\r\n            normals[v2x] += faceNormalx;\r\n            normals[v2y] += faceNormaly;\r\n            normals[v2z] += faceNormalz;\r\n            normals[v3x] += faceNormalx;\r\n            normals[v3y] += faceNormaly;\r\n            normals[v3z] += faceNormalz;\r\n        }\r\n        // last normalization of each normal\r\n        for (index = 0; index < normals.length / 3; index++) {\r\n            faceNormalx = normals[index * 3];\r\n            faceNormaly = normals[index * 3 + 1];\r\n            faceNormalz = normals[index * 3 + 2];\r\n\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = length === 0 ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            normals[index * 3] = faceNormalx;\r\n            normals[index * 3 + 1] = faceNormaly;\r\n            normals[index * 3 + 2] = faceNormalz;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ComputeSides(\r\n        sideOrientation: number,\r\n        positions: FloatArray,\r\n        indices: FloatArray | IndicesArray,\r\n        normals: FloatArray,\r\n        uvs: FloatArray,\r\n        frontUVs?: Vector4,\r\n        backUVs?: Vector4\r\n    ) {\r\n        const li: number = indices.length;\r\n        const ln: number = normals.length;\r\n        let i: number;\r\n        let n: number;\r\n        sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n        switch (sideOrientation) {\r\n            case VertexData.FRONTSIDE:\r\n                // nothing changed\r\n                break;\r\n\r\n            case VertexData.BACKSIDE:\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    const tmp = indices[i];\r\n                    indices[i] = indices[i + 2];\r\n                    indices[i + 2] = tmp;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[n] = -normals[n];\r\n                }\r\n                break;\r\n\r\n            case VertexData.DOUBLESIDE: {\r\n                // positions\r\n                const lp: number = positions.length;\r\n                const l: number = lp / 3;\r\n                for (let p = 0; p < lp; p++) {\r\n                    positions[lp + p] = positions[p];\r\n                }\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    indices[i + li] = indices[i + 2] + l;\r\n                    indices[i + 1 + li] = indices[i + 1] + l;\r\n                    indices[i + 2 + li] = indices[i] + l;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[ln + n] = -normals[n];\r\n                }\r\n\r\n                // uvs\r\n                const lu: number = uvs.length;\r\n                let u: number = 0;\r\n                for (u = 0; u < lu; u++) {\r\n                    uvs[u + lu] = uvs[u];\r\n                }\r\n                frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                u = 0;\r\n                for (i = 0; i < lu / 2; i++) {\r\n                    uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\r\n                    uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\r\n                    uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\r\n                    uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\r\n                    u += 2;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a VertexData from serialized data\r\n     * @param parsedVertexData the parsed data from an imported file\r\n     * @returns a VertexData\r\n     */\r\n    public static Parse(parsedVertexData: any) {\r\n        const vertexData = new VertexData();\r\n\r\n        // positions\r\n        const positions = parsedVertexData.positions;\r\n        if (positions) {\r\n            vertexData.set(positions, VertexBuffer.PositionKind);\r\n        }\r\n\r\n        // normals\r\n        const normals = parsedVertexData.normals;\r\n        if (normals) {\r\n            vertexData.set(normals, VertexBuffer.NormalKind);\r\n        }\r\n\r\n        // tangents\r\n        const tangents = parsedVertexData.tangents;\r\n        if (tangents) {\r\n            vertexData.set(tangents, VertexBuffer.TangentKind);\r\n        }\r\n\r\n        // uvs\r\n        const uvs = parsedVertexData.uvs;\r\n        if (uvs) {\r\n            vertexData.set(uvs, VertexBuffer.UVKind);\r\n        }\r\n\r\n        // uv2s\r\n        const uvs2 = parsedVertexData.uvs2;\r\n        if (uvs2) {\r\n            vertexData.set(uvs2, VertexBuffer.UV2Kind);\r\n        }\r\n\r\n        // uv3s\r\n        const uvs3 = parsedVertexData.uvs3;\r\n        if (uvs3) {\r\n            vertexData.set(uvs3, VertexBuffer.UV3Kind);\r\n        }\r\n\r\n        // uv4s\r\n        const uvs4 = parsedVertexData.uvs4;\r\n        if (uvs4) {\r\n            vertexData.set(uvs4, VertexBuffer.UV4Kind);\r\n        }\r\n\r\n        // uv5s\r\n        const uvs5 = parsedVertexData.uvs5;\r\n        if (uvs5) {\r\n            vertexData.set(uvs5, VertexBuffer.UV5Kind);\r\n        }\r\n\r\n        // uv6s\r\n        const uvs6 = parsedVertexData.uvs6;\r\n        if (uvs6) {\r\n            vertexData.set(uvs6, VertexBuffer.UV6Kind);\r\n        }\r\n\r\n        // colors\r\n        const colors = parsedVertexData.colors;\r\n        if (colors) {\r\n            vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\r\n            if (parsedVertexData.hasVertexAlpha !== undefined) {\r\n                vertexData.hasVertexAlpha = parsedVertexData.hasVertexAlpha;\r\n            }\r\n        }\r\n\r\n        // matricesIndices\r\n        const matricesIndices = parsedVertexData.matricesIndices;\r\n        if (matricesIndices) {\r\n            vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\r\n        }\r\n\r\n        // matricesWeights\r\n        const matricesWeights = parsedVertexData.matricesWeights;\r\n        if (matricesWeights) {\r\n            vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\r\n        }\r\n\r\n        // indices\r\n        const indices = parsedVertexData.indices;\r\n        if (indices) {\r\n            vertexData.indices = indices;\r\n        }\r\n\r\n        // MaterialInfos\r\n        const materialInfos = parsedVertexData.materialInfos;\r\n        if (materialInfos) {\r\n            vertexData.materialInfos = [];\r\n            for (const materialInfoFromJSON of materialInfos) {\r\n                const materialInfo = new VertexDataMaterialInfo();\r\n                materialInfo.indexCount = materialInfoFromJSON.indexCount;\r\n                materialInfo.indexStart = materialInfoFromJSON.indexStart;\r\n                materialInfo.verticesCount = materialInfoFromJSON.verticesCount;\r\n                materialInfo.verticesStart = materialInfoFromJSON.verticesStart;\r\n                materialInfo.materialIndex = materialInfoFromJSON.materialIndex;\r\n                vertexData.materialInfos.push(materialInfo);\r\n            }\r\n        }\r\n\r\n        return vertexData;\r\n    }\r\n\r\n    /**\r\n     * Applies VertexData created from the imported parameters to the geometry\r\n     * @param parsedVertexData the parsed data from an imported file\r\n     * @param geometry the geometry to apply the VertexData to\r\n     */\r\n    public static ImportVertexData(parsedVertexData: any, geometry: Geometry) {\r\n        const vertexData = VertexData.Parse(parsedVertexData);\r\n\r\n        geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\r\n    }\r\n}\r\n", "import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { serialize, serializeAsVector3, serializeAsQuaternion } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { Observable } from \"../Misc/observable\";\r\n\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Space } from \"../Maths/math.axis\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\n\r\n/**\r\n * A TransformNode is an object that is not rendered but can be used as a center of transformation. This can decrease memory usage and increase rendering speed compared to using an empty mesh as a parent and is less complicated than using a pivot matrix.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/parent_pivot/transform_node\r\n */\r\nexport class TransformNode extends Node {\r\n    // Statics\r\n    /**\r\n     * Object will not rotate to face the camera\r\n     */\r\n    public static BILLBOARDMODE_NONE = 0;\r\n    /**\r\n     * Object will rotate to face the camera but only on the x axis\r\n     */\r\n    public static BILLBOARDMODE_X = 1;\r\n    /**\r\n     * Object will rotate to face the camera but only on the y axis\r\n     */\r\n    public static BILLBOARDMODE_Y = 2;\r\n    /**\r\n     * Object will rotate to face the camera but only on the z axis\r\n     */\r\n    public static BILLBOARDMODE_Z = 4;\r\n    /**\r\n     * Object will rotate to face the camera\r\n     */\r\n    public static BILLBOARDMODE_ALL = 7;\r\n    /**\r\n     * Object will rotate to face the camera's position instead of orientation\r\n     */\r\n    public static BILLBOARDMODE_USE_POSITION = 128;\r\n    /**\r\n     * Child transform with Billboard flags should or should not apply parent rotation (default if off)\r\n     */\r\n    public static BillboardUseParentOrientation: boolean = false;\r\n\r\n    private static _TmpRotation = Quaternion.Zero();\r\n    private static _TmpScaling = Vector3.Zero();\r\n    private static _TmpTranslation = Vector3.Zero();\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private static _TmpRHRestore = Matrix.Scaling(1, 1, -1);\r\n\r\n    private _forward = new Vector3(0, 0, 1);\r\n    private _up = new Vector3(0, 1, 0);\r\n    private _right = new Vector3(1, 0, 0);\r\n\r\n    // Properties\r\n    @serializeAsVector3(\"position\")\r\n    private _position = Vector3.Zero();\r\n\r\n    @serializeAsVector3(\"rotation\")\r\n    private _rotation = Vector3.Zero();\r\n\r\n    @serializeAsQuaternion(\"rotationQuaternion\")\r\n    private _rotationQuaternion: Nullable<Quaternion> = null;\r\n\r\n    @serializeAsVector3(\"scaling\")\r\n    protected _scaling = Vector3.One();\r\n    private _transformToBoneReferal: Nullable<TransformNode> = null;\r\n    private _currentParentWhenAttachingToBone: Nullable<Node>;\r\n    private _isAbsoluteSynced = false;\r\n\r\n    @serialize(\"billboardMode\")\r\n    private _billboardMode = TransformNode.BILLBOARDMODE_NONE;\r\n\r\n    /**\r\n     * Gets or sets the billboard mode. Default is 0.\r\n     *\r\n     * | Value | Type | Description |\r\n     * | --- | --- | --- |\r\n     * | 0 | BILLBOARDMODE_NONE |  |\r\n     * | 1 | BILLBOARDMODE_X |  |\r\n     * | 2 | BILLBOARDMODE_Y |  |\r\n     * | 4 | BILLBOARDMODE_Z |  |\r\n     * | 7 | BILLBOARDMODE_ALL |  |\r\n     *\r\n     */\r\n    public get billboardMode() {\r\n        return this._billboardMode;\r\n    }\r\n\r\n    public set billboardMode(value: number) {\r\n        if (this._billboardMode === value) {\r\n            return;\r\n        }\r\n        this._billboardMode = value;\r\n        this._cache.useBillboardPosition = (this._billboardMode & TransformNode.BILLBOARDMODE_USE_POSITION) !== 0;\r\n    }\r\n\r\n    /**\r\n     * Multiplication factor on scale x/y/z when computing the world matrix. Eg. for a 1x1x1 cube setting this to 2 will make it a 2x2x2 cube\r\n     */\r\n    @serialize()\r\n    public scalingDeterminant = 1;\r\n\r\n    @serialize(\"infiniteDistance\")\r\n    private _infiniteDistance = false;\r\n\r\n    /**\r\n     * Gets or sets the distance of the object to max, often used by skybox\r\n     */\r\n    public get infiniteDistance() {\r\n        return this._infiniteDistance;\r\n    }\r\n\r\n    public set infiniteDistance(value: boolean) {\r\n        if (this._infiniteDistance === value) {\r\n            return;\r\n        }\r\n\r\n        this._infiniteDistance = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that non uniform scaling (when at least one component is different from others) should be ignored.\r\n     * By default the system will update normals to compensate\r\n     */\r\n    @serialize()\r\n    public ignoreNonUniformScaling = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that even if rotationQuaternion is defined, you can keep updating rotation property and Babylon.js will just mix both\r\n     */\r\n    @serialize()\r\n    public reIntegrateRotationIntoRotationQuaternion = false;\r\n\r\n    // Cache\r\n    /** @internal */\r\n    public _poseMatrix: Nullable<Matrix> = null;\r\n    /** @internal */\r\n    public _localMatrix = Matrix.Zero();\r\n\r\n    private _usePivotMatrix = false;\r\n    private _absolutePosition = Vector3.Zero();\r\n    private _absoluteScaling = Vector3.Zero();\r\n    private _absoluteRotationQuaternion = Quaternion.Identity();\r\n    private _pivotMatrix = Matrix.Identity();\r\n    private _pivotMatrixInverse: Matrix;\r\n    /** @internal */\r\n    public _postMultiplyPivotMatrix = false;\r\n\r\n    protected _isWorldMatrixFrozen = false;\r\n\r\n    /** @internal */\r\n    public _indexInSceneTransformNodesArray = -1;\r\n\r\n    /**\r\n     * An event triggered after the world matrix is updated\r\n     */\r\n    public onAfterWorldMatrixUpdateObservable = new Observable<TransformNode>();\r\n\r\n    constructor(name: string, scene: Nullable<Scene> = null, isPure = true) {\r\n        super(name, scene, false);\r\n\r\n        if (isPure) {\r\n            this.getScene().addTransformNode(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"TransformNode\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"TransformNode\";\r\n    }\r\n\r\n    /**\r\n     * Gets or set the node position (default is (0.0, 0.0, 0.0))\r\n     */\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this._position = newPosition;\r\n        this._markAsDirtyInternal();\r\n    }\r\n\r\n    /**\r\n     * return true if a pivot has been set\r\n     * @returns true if a pivot matrix is used\r\n     */\r\n    public isUsingPivotMatrix(): boolean {\r\n        return this._usePivotMatrix;\r\n    }\r\n\r\n    /**\r\n     * @returns true if pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect.\r\n     */\r\n    public isUsingPostMultiplyPivotMatrix(): boolean {\r\n        return this._postMultiplyPivotMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the rotation property : a Vector3 defining the rotation value in radians around each local axis X, Y, Z  (default is (0.0, 0.0, 0.0)).\r\n     * If rotation quaternion is set, this Vector3 will be ignored and copy from the quaternion\r\n     */\r\n    public get rotation(): Vector3 {\r\n        return this._rotation;\r\n    }\r\n\r\n    public set rotation(newRotation: Vector3) {\r\n        this._rotation = newRotation;\r\n        this._rotationQuaternion = null;\r\n        this._markAsDirtyInternal();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the scaling property : a Vector3 defining the node scaling along each local axis X, Y, Z (default is (1.0, 1.0, 1.0)).\r\n     */\r\n    public get scaling(): Vector3 {\r\n        return this._scaling;\r\n    }\r\n\r\n    public set scaling(newScaling: Vector3) {\r\n        this._scaling = newScaling;\r\n        this._markAsDirtyInternal();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the rotation Quaternion property : this a Quaternion object defining the node rotation by using a unit quaternion (undefined by default, but can be null).\r\n     * If set, only the rotationQuaternion is then used to compute the node rotation (ie. node.rotation will be ignored)\r\n     */\r\n    public get rotationQuaternion(): Nullable<Quaternion> {\r\n        return this._rotationQuaternion;\r\n    }\r\n\r\n    public set rotationQuaternion(quaternion: Nullable<Quaternion>) {\r\n        this._rotationQuaternion = quaternion;\r\n        //reset the rotation vector.\r\n        if (quaternion) {\r\n            this._rotation.setAll(0.0);\r\n        }\r\n        this._markAsDirtyInternal();\r\n    }\r\n\r\n    /**\r\n     * Allow user to specify custom mechanism for mark as dirty\r\n     */\r\n    public customMarkAsDirty: () => void;\r\n\r\n    private _markAsDirtyInternal(): void {\r\n        if (this._isDirty) {\r\n            return;\r\n        }\r\n        this._isDirty = true;\r\n\r\n        if (this.customMarkAsDirty) {\r\n            this.customMarkAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The forward direction of that transform in world space.\r\n     */\r\n    public get forward(): Vector3 {\r\n        Vector3.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1.0 : 1.0, this.getWorldMatrix(), this._forward);\r\n        return this._forward.normalize();\r\n    }\r\n\r\n    /**\r\n     * The up direction of that transform in world space.\r\n     */\r\n    public get up(): Vector3 {\r\n        Vector3.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up);\r\n        return this._up.normalize();\r\n    }\r\n\r\n    /**\r\n     * The right direction of that transform in world space.\r\n     */\r\n    public get right(): Vector3 {\r\n        Vector3.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1.0 : 1.0, 0, 0, this.getWorldMatrix(), this._right);\r\n        return this._right.normalize();\r\n    }\r\n\r\n    /**\r\n     * Copies the parameter passed Matrix into the mesh Pose matrix.\r\n     * @param matrix the matrix to copy the pose from\r\n     * @returns this TransformNode.\r\n     */\r\n    public updatePoseMatrix(matrix: Matrix): TransformNode {\r\n        if (!this._poseMatrix) {\r\n            this._poseMatrix = matrix.clone();\r\n            return this;\r\n        }\r\n        this._poseMatrix.copyFrom(matrix);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh Pose matrix.\r\n     * @returns the pose matrix\r\n     */\r\n    public getPoseMatrix(): Matrix {\r\n        if (!this._poseMatrix) {\r\n            this._poseMatrix = Matrix.Identity();\r\n        }\r\n        return this._poseMatrix;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _isSynchronized(): boolean {\r\n        const cache = this._cache;\r\n\r\n        if (this._billboardMode !== cache.billboardMode || this._billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\r\n            return false;\r\n        }\r\n\r\n        if (cache.pivotMatrixUpdated) {\r\n            return false;\r\n        }\r\n\r\n        if (this._infiniteDistance) {\r\n            return false;\r\n        }\r\n\r\n        if (this._position._isDirty) {\r\n            return false;\r\n        }\r\n\r\n        if (this._scaling._isDirty) {\r\n            return false;\r\n        }\r\n\r\n        if ((this._rotationQuaternion && this._rotationQuaternion._isDirty) || this._rotation._isDirty) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _initCache() {\r\n        super._initCache();\r\n\r\n        const cache = this._cache;\r\n        cache.localMatrixUpdated = false;\r\n        cache.billboardMode = -1;\r\n        cache.infiniteDistance = false;\r\n        cache.useBillboardPosition = false;\r\n    }\r\n\r\n    /**\r\n     * Returns the current mesh absolute position.\r\n     * Returns a Vector3.\r\n     */\r\n    public get absolutePosition(): Vector3 {\r\n        return this.getAbsolutePosition();\r\n    }\r\n\r\n    /**\r\n     * Returns the current mesh absolute scaling.\r\n     * Returns a Vector3.\r\n     */\r\n    public get absoluteScaling(): Vector3 {\r\n        this._syncAbsoluteScalingAndRotation();\r\n        return this._absoluteScaling;\r\n    }\r\n\r\n    /**\r\n     * Returns the current mesh absolute rotation.\r\n     * Returns a Quaternion.\r\n     */\r\n    public get absoluteRotationQuaternion(): Quaternion {\r\n        this._syncAbsoluteScalingAndRotation();\r\n        return this._absoluteRotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Sets a new matrix to apply before all other transformation\r\n     * @param matrix defines the transform matrix\r\n     * @returns the current TransformNode\r\n     */\r\n    public setPreTransformMatrix(matrix: Matrix): TransformNode {\r\n        return this.setPivotMatrix(matrix, false);\r\n    }\r\n\r\n    /**\r\n     * Sets a new pivot matrix to the current node\r\n     * @param matrix defines the new pivot matrix to use\r\n     * @param postMultiplyPivotMatrix defines if the pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect\r\n     * @returns the current TransformNode\r\n     */\r\n    public setPivotMatrix(matrix: DeepImmutable<Matrix>, postMultiplyPivotMatrix = true): TransformNode {\r\n        this._pivotMatrix.copyFrom(matrix);\r\n        this._usePivotMatrix = !this._pivotMatrix.isIdentity();\r\n\r\n        this._cache.pivotMatrixUpdated = true;\r\n        this._postMultiplyPivotMatrix = postMultiplyPivotMatrix;\r\n\r\n        if (this._postMultiplyPivotMatrix) {\r\n            if (!this._pivotMatrixInverse) {\r\n                this._pivotMatrixInverse = Matrix.Invert(this._pivotMatrix);\r\n            } else {\r\n                this._pivotMatrix.invertToRef(this._pivotMatrixInverse);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh pivot matrix.\r\n     * Default : Identity.\r\n     * @returns the matrix\r\n     */\r\n    public getPivotMatrix(): Matrix {\r\n        return this._pivotMatrix;\r\n    }\r\n\r\n    /**\r\n     * Instantiate (when possible) or clone that node with its hierarchy\r\n     * @param newParent defines the new parent to use for the instance (or clone)\r\n     * @param options defines options to configure how copy is done\r\n     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\r\n     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\r\n     * @returns an instance (or a clone) of the current node with its hierarchy\r\n     */\r\n    public instantiateHierarchy(\r\n        newParent: Nullable<TransformNode> = null,\r\n        options?: { doNotInstantiate: boolean | ((node: TransformNode) => boolean) },\r\n        onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void\r\n    ): Nullable<TransformNode> {\r\n        const clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true);\r\n\r\n        if (clone) {\r\n            if (onNewNodeCreated) {\r\n                onNewNodeCreated(this, clone);\r\n            }\r\n        }\r\n\r\n        for (const child of this.getChildTransformNodes(true)) {\r\n            child.instantiateHierarchy(clone, options, onNewNodeCreated);\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Prevents the World matrix to be computed any longer.\r\n     * Please note that the \"moral\" contract is that the world matrix is not going to be updated anymore. It is up to the developer to force updates.\r\n     * You trade flexibility for performance. If you want to update it, you have to unfreeze it first.\r\n     * @param newWorldMatrix defines an optional matrix to use as world matrix\r\n     * @param decompose defines whether to decompose the given newWorldMatrix or directly assign\r\n     * @returns the TransformNode.\r\n     */\r\n    public freezeWorldMatrix(newWorldMatrix: Nullable<Matrix> = null, decompose = false): TransformNode {\r\n        if (newWorldMatrix) {\r\n            if (decompose) {\r\n                this._rotation.setAll(0);\r\n                this._rotationQuaternion = this._rotationQuaternion || Quaternion.Identity();\r\n                newWorldMatrix.decompose(this._scaling, this._rotationQuaternion, this._position);\r\n                this.computeWorldMatrix(true);\r\n            } else {\r\n                this._worldMatrix = newWorldMatrix;\r\n                this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);\r\n                this._afterComputeWorldMatrix();\r\n            }\r\n        } else {\r\n            this._isWorldMatrixFrozen = false; // no guarantee world is not already frozen, switch off temporarily\r\n            this.computeWorldMatrix(true);\r\n        }\r\n        this._isDirty = false;\r\n        this._isWorldMatrixFrozen = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Allows back the World matrix computation.\r\n     * @returns the TransformNode.\r\n     */\r\n    public unfreezeWorldMatrix() {\r\n        this._isWorldMatrixFrozen = false;\r\n        this.computeWorldMatrix(true);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * True if the World matrix has been frozen.\r\n     */\r\n    public get isWorldMatrixFrozen(): boolean {\r\n        return this._isWorldMatrixFrozen;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh absolute position in the World.\r\n     * @returns a Vector3.\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        this.computeWorldMatrix();\r\n        return this._absolutePosition;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh absolute position in the World from a Vector3 or an Array(3).\r\n     * @param absolutePosition the absolute position to set\r\n     * @returns the TransformNode.\r\n     */\r\n    public setAbsolutePosition(absolutePosition: Vector3): TransformNode {\r\n        if (!absolutePosition) {\r\n            return this;\r\n        }\r\n        let absolutePositionX;\r\n        let absolutePositionY;\r\n        let absolutePositionZ;\r\n        if (absolutePosition.x === undefined) {\r\n            if (arguments.length < 3) {\r\n                return this;\r\n            }\r\n            absolutePositionX = arguments[0];\r\n            absolutePositionY = arguments[1];\r\n            absolutePositionZ = arguments[2];\r\n        } else {\r\n            absolutePositionX = absolutePosition.x;\r\n            absolutePositionY = absolutePosition.y;\r\n            absolutePositionZ = absolutePosition.z;\r\n        }\r\n        if (this.parent) {\r\n            const invertParentWorldMatrix = TmpVectors.Matrix[0];\r\n            this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);\r\n            Vector3.TransformCoordinatesFromFloatsToRef(absolutePositionX, absolutePositionY, absolutePositionZ, invertParentWorldMatrix, this.position);\r\n        } else {\r\n            this.position.x = absolutePositionX;\r\n            this.position.y = absolutePositionY;\r\n            this.position.z = absolutePositionZ;\r\n        }\r\n\r\n        this._absolutePosition.copyFrom(absolutePosition);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh position in its local space.\r\n     * @param vector3 the position to set in localspace\r\n     * @returns the TransformNode.\r\n     */\r\n    public setPositionWithLocalVector(vector3: Vector3): TransformNode {\r\n        this.computeWorldMatrix();\r\n        this.position = Vector3.TransformNormal(vector3, this._localMatrix);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh position in the local space from the current World matrix values.\r\n     * @returns a new Vector3.\r\n     */\r\n    public getPositionExpressedInLocalSpace(): Vector3 {\r\n        this.computeWorldMatrix();\r\n        const invLocalWorldMatrix = TmpVectors.Matrix[0];\r\n        this._localMatrix.invertToRef(invLocalWorldMatrix);\r\n        return Vector3.TransformNormal(this.position, invLocalWorldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Translates the mesh along the passed Vector3 in its local space.\r\n     * @param vector3 the distance to translate in localspace\r\n     * @returns the TransformNode.\r\n     */\r\n    public locallyTranslate(vector3: Vector3): TransformNode {\r\n        this.computeWorldMatrix(true);\r\n        this.position = Vector3.TransformCoordinates(vector3, this._localMatrix);\r\n        return this;\r\n    }\r\n\r\n    private static _LookAtVectorCache = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Orients a mesh towards a target point. Mesh must be drawn facing user.\r\n     * @param targetPoint the position (must be in same space as current mesh) to look at\r\n     * @param yawCor optional yaw (y-axis) correction in radians\r\n     * @param pitchCor optional pitch (x-axis) correction in radians\r\n     * @param rollCor optional roll (z-axis) correction in radians\r\n     * @param space the chosen space of the target\r\n     * @returns the TransformNode.\r\n     */\r\n    public lookAt(targetPoint: Vector3, yawCor: number = 0, pitchCor: number = 0, rollCor: number = 0, space: Space = Space.LOCAL): TransformNode {\r\n        const dv = TransformNode._LookAtVectorCache;\r\n        const pos = space === Space.LOCAL ? this.position : this.getAbsolutePosition();\r\n        targetPoint.subtractToRef(pos, dv);\r\n        this.setDirection(dv, yawCor, pitchCor, rollCor);\r\n\r\n        // Correct for parent's rotation offset\r\n        if (space === Space.WORLD && this.parent) {\r\n            if (this.rotationQuaternion) {\r\n                // Get local rotation matrix of the looking object\r\n                const rotationMatrix = TmpVectors.Matrix[0];\r\n                this.rotationQuaternion.toRotationMatrix(rotationMatrix);\r\n\r\n                // Offset rotation by parent's inverted rotation matrix to correct in world space\r\n                const parentRotationMatrix = TmpVectors.Matrix[1];\r\n                this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);\r\n                parentRotationMatrix.invert();\r\n                rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);\r\n                this.rotationQuaternion.fromRotationMatrix(rotationMatrix);\r\n            } else {\r\n                // Get local rotation matrix of the looking object\r\n                const quaternionRotation = TmpVectors.Quaternion[0];\r\n                Quaternion.FromEulerVectorToRef(this.rotation, quaternionRotation);\r\n                const rotationMatrix = TmpVectors.Matrix[0];\r\n                quaternionRotation.toRotationMatrix(rotationMatrix);\r\n\r\n                // Offset rotation by parent's inverted rotation matrix to correct in world space\r\n                const parentRotationMatrix = TmpVectors.Matrix[1];\r\n                this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);\r\n                parentRotationMatrix.invert();\r\n                rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);\r\n                quaternionRotation.fromRotationMatrix(rotationMatrix);\r\n                quaternionRotation.toEulerAnglesToRef(this.rotation);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.\r\n     * This Vector3 is expressed in the World space.\r\n     * @param localAxis axis to rotate\r\n     * @returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.\r\n     */\r\n    public getDirection(localAxis: Vector3): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getDirectionToRef(localAxis, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the Vector3 \"result\" as the rotated Vector3 \"localAxis\" in the same rotation than the mesh.\r\n     * localAxis is expressed in the mesh local space.\r\n     * result is computed in the World space from the mesh World matrix.\r\n     * @param localAxis axis to rotate\r\n     * @param result the resulting transformnode\r\n     * @returns this TransformNode.\r\n     */\r\n    public getDirectionToRef(localAxis: Vector3, result: Vector3): TransformNode {\r\n        Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets this transform node rotation to the given local axis.\r\n     * @param localAxis the axis in local space\r\n     * @param yawCor optional yaw (y-axis) correction in radians\r\n     * @param pitchCor optional pitch (x-axis) correction in radians\r\n     * @param rollCor optional roll (z-axis) correction in radians\r\n     * @returns this TransformNode\r\n     */\r\n    public setDirection(localAxis: Vector3, yawCor: number = 0, pitchCor: number = 0, rollCor: number = 0): TransformNode {\r\n        const yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;\r\n        const len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);\r\n        const pitch = -Math.atan2(localAxis.y, len);\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);\r\n        } else {\r\n            this.rotation.x = pitch + pitchCor;\r\n            this.rotation.y = yaw + yawCor;\r\n            this.rotation.z = rollCor;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a new pivot point to the current node\r\n     * @param point defines the new pivot point to use\r\n     * @param space defines if the point is in world or local space (local by default)\r\n     * @returns the current TransformNode\r\n     */\r\n    public setPivotPoint(point: Vector3, space: Space = Space.LOCAL): TransformNode {\r\n        if (this.getScene().getRenderId() == 0) {\r\n            this.computeWorldMatrix(true);\r\n        }\r\n\r\n        const wm = this.getWorldMatrix();\r\n\r\n        if (space == Space.WORLD) {\r\n            const tmat = TmpVectors.Matrix[0];\r\n            wm.invertToRef(tmat);\r\n            point = Vector3.TransformCoordinates(point, tmat);\r\n        }\r\n\r\n        return this.setPivotMatrix(Matrix.Translation(-point.x, -point.y, -point.z), true);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the mesh pivot point coordinates in the local space.\r\n     * @returns the pivot point\r\n     */\r\n    public getPivotPoint(): Vector3 {\r\n        const point = Vector3.Zero();\r\n        this.getPivotPointToRef(point);\r\n        return point;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Vector3 \"result\" with the coordinates of the mesh pivot point in the local space.\r\n     * @param result the vector3 to store the result\r\n     * @returns this TransformNode.\r\n     */\r\n    public getPivotPointToRef(result: Vector3): TransformNode {\r\n        result.x = -this._pivotMatrix.m[12];\r\n        result.y = -this._pivotMatrix.m[13];\r\n        result.z = -this._pivotMatrix.m[14];\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the mesh pivot point World coordinates.\r\n     * @returns a new Vector3 set with the mesh pivot point World coordinates.\r\n     */\r\n    public getAbsolutePivotPoint(): Vector3 {\r\n        const point = Vector3.Zero();\r\n        this.getAbsolutePivotPointToRef(point);\r\n        return point;\r\n    }\r\n\r\n    /**\r\n     * Sets the Vector3 \"result\" coordinates with the mesh pivot point World coordinates.\r\n     * @param result vector3 to store the result\r\n     * @returns this TransformNode.\r\n     */\r\n    public getAbsolutePivotPointToRef(result: Vector3): TransformNode {\r\n        this.getPivotPointToRef(result);\r\n        Vector3.TransformCoordinatesToRef(result, this.getWorldMatrix(), result);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Flag the transform node as dirty (Forcing it to update everything)\r\n     * @param property if set to \"rotation\" the objects rotationQuaternion will be set to null\r\n     * @returns this  node\r\n     */\r\n    public override markAsDirty(property?: string): Node {\r\n        if (this._isDirty) {\r\n            return this;\r\n        }\r\n\r\n        // We need to explicitly update the children\r\n        // as the scene.evaluateActiveMeshes will not poll the transform nodes\r\n        if (this._children) {\r\n            for (const child of this._children) {\r\n                child.markAsDirty(property);\r\n            }\r\n        }\r\n        return super.markAsDirty(property);\r\n    }\r\n\r\n    /**\r\n     * Defines the passed node as the parent of the current node.\r\n     * The node will remain exactly where it is and its position / rotation will be updated accordingly.\r\n     * If you don't want to preserve the current rotation / position, assign the parent through parent accessor.\r\n     * Note that if the mesh has a pivot matrix / point defined it will be applied after the parent was updated.\r\n     * In that case the node will not remain in the same space as it is, as the pivot will be applied.\r\n     * To avoid this, you can set updatePivot to true and the pivot will be updated to identity\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/parent_pivot/parent\r\n     * @param node the node ot set as the parent\r\n     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\r\n     * @param updatePivot if true, update the pivot matrix to keep the node in the same space as before\r\n     * @returns this TransformNode.\r\n     */\r\n    public setParent(node: Nullable<Node>, preserveScalingSign: boolean = false, updatePivot = false): TransformNode {\r\n        if (!node && !this.parent) {\r\n            return this;\r\n        }\r\n\r\n        const quatRotation = TmpVectors.Quaternion[0];\r\n        const position = TmpVectors.Vector3[0];\r\n        const scale = TmpVectors.Vector3[1];\r\n        const invParentMatrix = TmpVectors.Matrix[1];\r\n        Matrix.IdentityToRef(invParentMatrix);\r\n        const composedMatrix = TmpVectors.Matrix[0];\r\n        this.computeWorldMatrix(true);\r\n\r\n        let currentRotation = this.rotationQuaternion;\r\n        if (!currentRotation) {\r\n            currentRotation = TransformNode._TmpRotation;\r\n            Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, currentRotation);\r\n        }\r\n\r\n        // current global transformation without pivot\r\n        Matrix.ComposeToRef(this.scaling, currentRotation, this.position, composedMatrix);\r\n        if (this.parent) {\r\n            composedMatrix.multiplyToRef(this.parent.computeWorldMatrix(true), composedMatrix);\r\n        }\r\n\r\n        // is a node was set, calculate the difference between this and the node\r\n        if (node) {\r\n            node.computeWorldMatrix(true).invertToRef(invParentMatrix);\r\n            composedMatrix.multiplyToRef(invParentMatrix, composedMatrix);\r\n        }\r\n        composedMatrix.decompose(scale, quatRotation, position, preserveScalingSign ? this : undefined);\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.copyFrom(quatRotation);\r\n        } else {\r\n            quatRotation.toEulerAnglesToRef(this.rotation);\r\n        }\r\n\r\n        this.scaling.copyFrom(scale);\r\n        this.position.copyFrom(position);\r\n\r\n        this.parent = node;\r\n\r\n        if (updatePivot) {\r\n            this.setPivotMatrix(Matrix.Identity());\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds the passed mesh as a child to the current mesh.\r\n     * The node will remain exactly where it is and its position / rotation will be updated accordingly.\r\n     * This method is equivalent to calling setParent().\r\n     * @param mesh defines the child mesh\r\n     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\r\n     * @returns the current mesh\r\n     */\r\n    public addChild(mesh: TransformNode, preserveScalingSign: boolean = false): this {\r\n        mesh.setParent(this, preserveScalingSign);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the passed mesh from the current mesh children list\r\n     * @param mesh defines the child mesh\r\n     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\r\n     * @returns the current mesh\r\n     */\r\n    public removeChild(mesh: TransformNode, preserveScalingSign: boolean = false): this {\r\n        if (mesh.parent !== this) {\r\n            return this;\r\n        }\r\n        mesh.setParent(null, preserveScalingSign);\r\n        return this;\r\n    }\r\n\r\n    private _nonUniformScaling = false;\r\n    /**\r\n     * True if the scaling property of this object is non uniform eg. (1,2,1)\r\n     */\r\n    public get nonUniformScaling(): boolean {\r\n        return this._nonUniformScaling;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateNonUniformScalingState(value: boolean): boolean {\r\n        if (this._nonUniformScaling === value) {\r\n            return false;\r\n        }\r\n\r\n        this._nonUniformScaling = value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Attach the current TransformNode to another TransformNode associated with a bone\r\n     * @param bone Bone affecting the TransformNode\r\n     * @param affectedTransformNode TransformNode associated with the bone\r\n     * @returns this object\r\n     */\r\n    public attachToBone(bone: Bone, affectedTransformNode: TransformNode): TransformNode {\r\n        this._currentParentWhenAttachingToBone = this.parent;\r\n        this._transformToBoneReferal = affectedTransformNode;\r\n        this.parent = bone;\r\n\r\n        bone.getSkeleton().prepare(true); // make sure bone.getFinalMatrix() is up to date\r\n\r\n        if (bone.getFinalMatrix().determinant() < 0) {\r\n            this.scalingDeterminant *= -1;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Detach the transform node if its associated with a bone\r\n     * @param resetToPreviousParent Indicates if the parent that was in effect when attachToBone was called should be set back or if we should set parent to null instead (defaults to the latter)\r\n     * @returns this object\r\n     */\r\n    public detachFromBone(resetToPreviousParent = false): TransformNode {\r\n        if (!this.parent) {\r\n            if (resetToPreviousParent) {\r\n                this.parent = this._currentParentWhenAttachingToBone;\r\n            }\r\n            return this;\r\n        }\r\n\r\n        if (this.parent.getWorldMatrix().determinant() < 0) {\r\n            this.scalingDeterminant *= -1;\r\n        }\r\n        this._transformToBoneReferal = null;\r\n        if (resetToPreviousParent) {\r\n            this.parent = this._currentParentWhenAttachingToBone;\r\n        } else {\r\n            this.parent = null;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    private static _RotationAxisCache = new Quaternion();\r\n    /**\r\n     * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.\r\n     * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.\r\n     * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.\r\n     * The passed axis is also normalized.\r\n     * @param axis the axis to rotate around\r\n     * @param amount the amount to rotate in radians\r\n     * @param space Space to rotate in (Default: local)\r\n     * @returns the TransformNode.\r\n     */\r\n    public rotate(axis: Vector3, amount: number, space?: Space): TransformNode {\r\n        axis.normalize();\r\n        if (!this.rotationQuaternion) {\r\n            this.rotationQuaternion = this.rotation.toQuaternion();\r\n            this.rotation.setAll(0);\r\n        }\r\n        let rotationQuaternion: Quaternion;\r\n        if (!space || (space as any) === Space.LOCAL) {\r\n            rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);\r\n            this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);\r\n        } else {\r\n            if (this.parent) {\r\n                const parentWorldMatrix = this.parent.getWorldMatrix();\r\n                const invertParentWorldMatrix = TmpVectors.Matrix[0];\r\n                parentWorldMatrix.invertToRef(invertParentWorldMatrix);\r\n                axis = Vector3.TransformNormal(axis, invertParentWorldMatrix);\r\n\r\n                if (parentWorldMatrix.determinant() < 0) {\r\n                    amount *= -1;\r\n                }\r\n            }\r\n            rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);\r\n            rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.\r\n     * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.\r\n     * The passed axis is also normalized. .\r\n     * Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm\r\n     * @param point the point to rotate around\r\n     * @param axis the axis to rotate around\r\n     * @param amount the amount to rotate in radians\r\n     * @returns the TransformNode\r\n     */\r\n    public rotateAround(point: Vector3, axis: Vector3, amount: number): TransformNode {\r\n        axis.normalize();\r\n        if (!this.rotationQuaternion) {\r\n            this.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\r\n            this.rotation.setAll(0);\r\n        }\r\n\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n        const finalScale = TmpVectors.Vector3[1];\r\n        const finalTranslation = TmpVectors.Vector3[2];\r\n\r\n        const finalRotation = TmpVectors.Quaternion[0];\r\n\r\n        const translationMatrix = TmpVectors.Matrix[0]; // T\r\n        const translationMatrixInv = TmpVectors.Matrix[1]; // T'\r\n        const rotationMatrix = TmpVectors.Matrix[2]; // R\r\n        const finalMatrix = TmpVectors.Matrix[3]; // T' x R x T\r\n\r\n        point.subtractToRef(this.position, tmpVector);\r\n        Matrix.TranslationToRef(tmpVector.x, tmpVector.y, tmpVector.z, translationMatrix); // T\r\n        Matrix.TranslationToRef(-tmpVector.x, -tmpVector.y, -tmpVector.z, translationMatrixInv); // T'\r\n        Matrix.RotationAxisToRef(axis, amount, rotationMatrix); // R\r\n\r\n        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\r\n        finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x T\r\n\r\n        finalMatrix.decompose(finalScale, finalRotation, finalTranslation);\r\n\r\n        this.position.addInPlace(finalTranslation);\r\n        finalRotation.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Translates the mesh along the axis vector for the passed distance in the given space.\r\n     * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.\r\n     * @param axis the axis to translate in\r\n     * @param distance the distance to translate\r\n     * @param space Space to rotate in (Default: local)\r\n     * @returns the TransformNode.\r\n     */\r\n    public translate(axis: Vector3, distance: number, space?: Space): TransformNode {\r\n        const displacementVector = axis.scale(distance);\r\n        if (!space || (space as any) === Space.LOCAL) {\r\n            const tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);\r\n            this.setPositionWithLocalVector(tempV3);\r\n        } else {\r\n            this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a rotation step to the mesh current rotation.\r\n     * x, y, z are Euler angles expressed in radians.\r\n     * This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.\r\n     * This means this rotation is made in the mesh local space only.\r\n     * It's useful to set a custom rotation order different from the BJS standard one YXZ.\r\n     * Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.\r\n     * ```javascript\r\n     * mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);\r\n     * ```\r\n     * Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.\r\n     * Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.\r\n     * @param x Rotation to add\r\n     * @param y Rotation to add\r\n     * @param z Rotation to add\r\n     * @returns the TransformNode.\r\n     */\r\n    public addRotation(x: number, y: number, z: number): TransformNode {\r\n        let rotationQuaternion;\r\n        if (this.rotationQuaternion) {\r\n            rotationQuaternion = this.rotationQuaternion;\r\n        } else {\r\n            rotationQuaternion = TmpVectors.Quaternion[1];\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);\r\n        }\r\n        const accumulation = TmpVectors.Quaternion[0];\r\n        Quaternion.RotationYawPitchRollToRef(y, x, z, accumulation);\r\n        rotationQuaternion.multiplyInPlace(accumulation);\r\n        if (!this.rotationQuaternion) {\r\n            rotationQuaternion.toEulerAnglesToRef(this.rotation);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _getEffectiveParent(): Nullable<Node> {\r\n        return this.parent;\r\n    }\r\n\r\n    /**\r\n     * Returns whether the transform node world matrix computation needs the camera information to be computed.\r\n     * This is the case when the node is a billboard or has an infinite distance for instance.\r\n     * @returns true if the world matrix computation needs the camera information to be computed\r\n     */\r\n    public isWorldMatrixCameraDependent(): boolean {\r\n        return (this._infiniteDistance && !this.parent) || this._billboardMode !== TransformNode.BILLBOARDMODE_NONE;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\r\n     * @param camera defines the camera used if different from the scene active camera (This is used with modes like Billboard or infinite distance)\r\n     * @returns the world matrix\r\n     */\r\n    public override computeWorldMatrix(force: boolean = false, camera: Nullable<Camera> = null): Matrix {\r\n        if (this._isWorldMatrixFrozen && !this._isDirty) {\r\n            return this._worldMatrix;\r\n        }\r\n\r\n        const currentRenderId = this.getScene().getRenderId();\r\n        if (!this._isDirty && !force && (this._currentRenderId === currentRenderId || this.isSynchronized())) {\r\n            this._currentRenderId = currentRenderId;\r\n            return this._worldMatrix;\r\n        }\r\n\r\n        camera = camera || this.getScene().activeCamera;\r\n\r\n        this._updateCache();\r\n        const cache = this._cache;\r\n        cache.pivotMatrixUpdated = false;\r\n        cache.billboardMode = this.billboardMode;\r\n        cache.infiniteDistance = this.infiniteDistance;\r\n        cache.parent = this._parentNode;\r\n\r\n        this._currentRenderId = currentRenderId;\r\n        this._childUpdateId += 1;\r\n        this._isDirty = false;\r\n        this._position._isDirty = false;\r\n        this._rotation._isDirty = false;\r\n        this._scaling._isDirty = false;\r\n        const parent = this._getEffectiveParent();\r\n\r\n        // Scaling\r\n        const scaling: Vector3 = TransformNode._TmpScaling;\r\n        let translation: Vector3 = this._position;\r\n\r\n        // Translation\r\n        if (this._infiniteDistance) {\r\n            if (!this.parent && camera) {\r\n                const cameraWorldMatrix = camera.getWorldMatrix();\r\n                const cameraGlobalPosition = new Vector3(cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);\r\n\r\n                translation = TransformNode._TmpTranslation;\r\n                translation.copyFromFloats(this._position.x + cameraGlobalPosition.x, this._position.y + cameraGlobalPosition.y, this._position.z + cameraGlobalPosition.z);\r\n            }\r\n        }\r\n\r\n        // Scaling\r\n        scaling.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);\r\n\r\n        // Rotation\r\n        let rotation: Quaternion;\r\n        if (this._rotationQuaternion) {\r\n            this._rotationQuaternion._isDirty = false;\r\n            rotation = this._rotationQuaternion;\r\n            if (this.reIntegrateRotationIntoRotationQuaternion) {\r\n                const len = this.rotation.lengthSquared();\r\n                if (len) {\r\n                    this._rotationQuaternion.multiplyInPlace(Quaternion.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z));\r\n                    this._rotation.copyFromFloats(0, 0, 0);\r\n                }\r\n            }\r\n        } else {\r\n            rotation = TransformNode._TmpRotation;\r\n            Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, rotation);\r\n        }\r\n\r\n        // Compose\r\n        if (this._usePivotMatrix) {\r\n            const scaleMatrix = TmpVectors.Matrix[1];\r\n            Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, scaleMatrix);\r\n\r\n            // Rotation\r\n            const rotationMatrix = TmpVectors.Matrix[0];\r\n            rotation.toRotationMatrix(rotationMatrix);\r\n\r\n            // Composing transformations\r\n            this._pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);\r\n            TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, this._localMatrix);\r\n\r\n            // Post multiply inverse of pivotMatrix\r\n            if (this._postMultiplyPivotMatrix) {\r\n                this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix);\r\n            }\r\n\r\n            this._localMatrix.addTranslationFromFloats(translation.x, translation.y, translation.z);\r\n        } else {\r\n            Matrix.ComposeToRef(scaling, rotation, translation, this._localMatrix);\r\n        }\r\n\r\n        // Parent\r\n        if (parent && parent.getWorldMatrix) {\r\n            if (force) {\r\n                parent.computeWorldMatrix(force);\r\n            }\r\n            if (this.billboardMode) {\r\n                if (this._transformToBoneReferal) {\r\n                    const bone = this.parent as Bone;\r\n                    bone.getSkeleton().prepare();\r\n                    bone.getFinalMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), TmpVectors.Matrix[7]);\r\n                } else {\r\n                    TmpVectors.Matrix[7].copyFrom(parent.getWorldMatrix());\r\n                }\r\n\r\n                // Extract scaling and translation from parent\r\n                const translation = TmpVectors.Vector3[5];\r\n                const scale = TmpVectors.Vector3[6];\r\n                const orientation = TmpVectors.Quaternion[0];\r\n                TmpVectors.Matrix[7].decompose(scale, orientation, translation);\r\n                Matrix.ScalingToRef(scale.x, scale.y, scale.z, TmpVectors.Matrix[7]);\r\n                TmpVectors.Matrix[7].setTranslation(translation);\r\n\r\n                if (TransformNode.BillboardUseParentOrientation) {\r\n                    // set localMatrix translation to be transformed against parent's orientation.\r\n                    this._position.applyRotationQuaternionToRef(orientation, translation);\r\n                    this._localMatrix.setTranslation(translation);\r\n                }\r\n\r\n                this._localMatrix.multiplyToRef(TmpVectors.Matrix[7], this._worldMatrix);\r\n            } else {\r\n                if (this._transformToBoneReferal) {\r\n                    const bone = this.parent as Bone;\r\n                    bone.getSkeleton().prepare();\r\n                    this._localMatrix.multiplyToRef(bone.getFinalMatrix(), TmpVectors.Matrix[6]);\r\n                    TmpVectors.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix);\r\n                } else {\r\n                    this._localMatrix.multiplyToRef(parent.getWorldMatrix(), this._worldMatrix);\r\n                }\r\n            }\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._worldMatrix.copyFrom(this._localMatrix);\r\n        }\r\n\r\n        if (camera && this.billboardMode) {\r\n            // Billboarding based on camera orientation (testing PG:http://www.babylonjs-playground.com/#UJEIL#13)\r\n            if (!cache.useBillboardPosition) {\r\n                const storedTranslation = TmpVectors.Vector3[0];\r\n                this._worldMatrix.getTranslationToRef(storedTranslation); // Save translation\r\n\r\n                // Get camera view matrix\r\n                TmpVectors.Matrix[1].copyFrom(camera.getViewMatrix());\r\n\r\n                const isRH = this.getScene().useRightHandedSystem;\r\n\r\n                if (isRH) {\r\n                    // This operation is necessary to cancel out the scaling component of the matrix without decomposing it.\r\n                    // It's a trick to extract only the rotation part.\r\n                    TmpVectors.Matrix[1].multiplyToRef(TransformNode._TmpRHRestore, TmpVectors.Matrix[1]);\r\n                }\r\n\r\n                // This will cancel the camera rotation\r\n                TmpVectors.Matrix[1].setTranslationFromFloats(0, 0, 0);\r\n                TmpVectors.Matrix[1].invertToRef(TmpVectors.Matrix[0]);\r\n\r\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {\r\n                    TmpVectors.Matrix[0].decompose(undefined, TmpVectors.Quaternion[0], undefined);\r\n                    const eulerAngles = TmpVectors.Vector3[1];\r\n                    TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);\r\n\r\n                    if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {\r\n                        eulerAngles.x = 0;\r\n                    }\r\n\r\n                    if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {\r\n                        eulerAngles.y = 0;\r\n                    }\r\n\r\n                    if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {\r\n                        eulerAngles.z = 0;\r\n                    }\r\n\r\n                    if (isRH) {\r\n                        eulerAngles.y += Math.PI; // Yaw correction\r\n                    }\r\n\r\n                    Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);\r\n                }\r\n                this._worldMatrix.setTranslationFromFloats(0, 0, 0);\r\n                this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);\r\n\r\n                // Restore translation\r\n                this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);\r\n            }\r\n            // Billboarding based on camera position\r\n            else {\r\n                const storedTranslation = TmpVectors.Vector3[0];\r\n                // Save translation\r\n                this._worldMatrix.getTranslationToRef(storedTranslation);\r\n\r\n                // Compute camera position in local space\r\n                const cameraPosition = camera.globalPosition;\r\n                this._worldMatrix.invertToRef(TmpVectors.Matrix[1]);\r\n                const camInObjSpace = TmpVectors.Vector3[1];\r\n                Vector3.TransformCoordinatesToRef(cameraPosition, TmpVectors.Matrix[1], camInObjSpace);\r\n                camInObjSpace.normalize();\r\n\r\n                // Find the lookAt info in local space\r\n                const yaw = -Math.atan2(camInObjSpace.z, camInObjSpace.x) + Math.PI / 2;\r\n                const len = Math.sqrt(camInObjSpace.x * camInObjSpace.x + camInObjSpace.z * camInObjSpace.z);\r\n                const pitch = -Math.atan2(camInObjSpace.y, len);\r\n                Quaternion.RotationYawPitchRollToRef(yaw, pitch, 0, TmpVectors.Quaternion[0]);\r\n\r\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {\r\n                    const eulerAngles = TmpVectors.Vector3[1];\r\n                    TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);\r\n\r\n                    if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {\r\n                        eulerAngles.x = 0;\r\n                    }\r\n\r\n                    if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {\r\n                        eulerAngles.y = 0;\r\n                    }\r\n\r\n                    if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {\r\n                        eulerAngles.z = 0;\r\n                    }\r\n\r\n                    Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);\r\n                } else {\r\n                    Matrix.FromQuaternionToRef(TmpVectors.Quaternion[0], TmpVectors.Matrix[0]);\r\n                }\r\n\r\n                // Cancel translation\r\n                this._worldMatrix.setTranslationFromFloats(0, 0, 0);\r\n\r\n                // Rotate according to lookat (diff from local to lookat)\r\n                this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);\r\n\r\n                // Restore translation\r\n                this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);\r\n            }\r\n        }\r\n\r\n        // Normal matrix\r\n        if (!this.ignoreNonUniformScaling) {\r\n            if (this._scaling.isNonUniformWithinEpsilon(0.000001)) {\r\n                this._updateNonUniformScalingState(true);\r\n            } else if (parent && (<TransformNode>parent)._nonUniformScaling) {\r\n                this._updateNonUniformScalingState((<TransformNode>parent)._nonUniformScaling);\r\n            } else {\r\n                this._updateNonUniformScalingState(false);\r\n            }\r\n        } else {\r\n            this._updateNonUniformScalingState(false);\r\n        }\r\n\r\n        this._afterComputeWorldMatrix();\r\n\r\n        // Absolute position\r\n        this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);\r\n        this._isAbsoluteSynced = false;\r\n\r\n        // Callbacks\r\n        this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);\r\n\r\n        if (!this._poseMatrix) {\r\n            this._poseMatrix = Matrix.Invert(this._worldMatrix);\r\n        }\r\n\r\n        // Cache the determinant\r\n        this._worldMatrixDeterminantIsDirty = true;\r\n\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Resets this nodeTransform's local matrix to Matrix.Identity().\r\n     * @param independentOfChildren indicates if all child nodeTransform's world-space transform should be preserved.\r\n     */\r\n    public resetLocalMatrix(independentOfChildren: boolean = true): void {\r\n        this.computeWorldMatrix();\r\n        if (independentOfChildren) {\r\n            const children = this.getChildren();\r\n            for (let i = 0; i < children.length; ++i) {\r\n                const child = children[i] as TransformNode;\r\n                if (child) {\r\n                    child.computeWorldMatrix();\r\n                    const bakedMatrix = TmpVectors.Matrix[0];\r\n                    child._localMatrix.multiplyToRef(this._localMatrix, bakedMatrix);\r\n                    const tmpRotationQuaternion = TmpVectors.Quaternion[0];\r\n                    bakedMatrix.decompose(child.scaling, tmpRotationQuaternion, child.position);\r\n                    if (child.rotationQuaternion) {\r\n                        child.rotationQuaternion.copyFrom(tmpRotationQuaternion);\r\n                    } else {\r\n                        tmpRotationQuaternion.toEulerAnglesToRef(child.rotation);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.scaling.copyFromFloats(1, 1, 1);\r\n        this.position.copyFromFloats(0, 0, 0);\r\n        this.rotation.copyFromFloats(0, 0, 0);\r\n\r\n        //only if quaternion is already set\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = Quaternion.Identity();\r\n        }\r\n        this._worldMatrix = Matrix.Identity();\r\n    }\r\n\r\n    protected _afterComputeWorldMatrix(): void {}\r\n\r\n    /**\r\n     * If you'd like to be called back after the mesh position, rotation or scaling has been updated.\r\n     * @param func callback function to add\r\n     *\r\n     * @returns the TransformNode.\r\n     */\r\n    public registerAfterWorldMatrixUpdate(func: (mesh: TransformNode) => void): TransformNode {\r\n        this.onAfterWorldMatrixUpdateObservable.add(func);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a registered callback function.\r\n     * @param func callback function to remove\r\n     * @returns the TransformNode.\r\n     */\r\n    public unregisterAfterWorldMatrixUpdate(func: (mesh: TransformNode) => void): TransformNode {\r\n        this.onAfterWorldMatrixUpdateObservable.removeCallback(func);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the position of the current mesh in camera space\r\n     * @param camera defines the camera to use\r\n     * @returns a position\r\n     */\r\n    public getPositionInCameraSpace(camera: Nullable<Camera> = null): Vector3 {\r\n        if (!camera) {\r\n            camera = <Camera>this.getScene().activeCamera;\r\n        }\r\n\r\n        return Vector3.TransformCoordinates(this.getAbsolutePosition(), camera.getViewMatrix());\r\n    }\r\n\r\n    /**\r\n     * Returns the distance from the mesh to the active camera\r\n     * @param camera defines the camera to use\r\n     * @returns the distance\r\n     */\r\n    public getDistanceToCamera(camera: Nullable<Camera> = null): number {\r\n        if (!camera) {\r\n            camera = <Camera>this.getScene().activeCamera;\r\n        }\r\n        return this.getAbsolutePosition().subtract(camera.globalPosition).length();\r\n    }\r\n\r\n    /**\r\n     * Clone the current transform node\r\n     * @param name Name of the new clone\r\n     * @param newParent New parent for the clone\r\n     * @param doNotCloneChildren Do not clone children hierarchy\r\n     * @returns the new transform node\r\n     */\r\n    public override clone(name: string, newParent: Nullable<Node>, doNotCloneChildren?: boolean): Nullable<TransformNode> {\r\n        const result = SerializationHelper.Clone(() => new TransformNode(name, this.getScene()), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            const directDescendants = this.getDescendants(true);\r\n            for (let index = 0; index < directDescendants.length; index++) {\r\n                const child = directDescendants[index];\r\n\r\n                if ((<any>child).clone) {\r\n                    (<any>child).clone(name + \".\" + child.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Serializes the objects information.\r\n     * @param currentSerializationObject defines the object to serialize in\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(currentSerializationObject?: any): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, currentSerializationObject);\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            this.parent._serializeAsParent(serializationObject);\r\n        }\r\n\r\n        serializationObject.localMatrix = this.getPivotMatrix().asArray();\r\n\r\n        serializationObject.isEnabled = this.isEnabled();\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Returns a new TransformNode object parsed from the source provided.\r\n     * @param parsedTransformNode is the source.\r\n     * @param scene the scene the object belongs to\r\n     * @param rootUrl is a string, it's the root URL to prefix the `delayLoadingFile` property with\r\n     * @returns a new TransformNode object parsed from the source provided.\r\n     */\r\n    public static Parse(parsedTransformNode: any, scene: Scene, rootUrl: string): TransformNode {\r\n        const transformNode = SerializationHelper.Parse(() => new TransformNode(parsedTransformNode.name, scene), parsedTransformNode, scene, rootUrl);\r\n\r\n        if (parsedTransformNode.localMatrix) {\r\n            transformNode.setPreTransformMatrix(Matrix.FromArray(parsedTransformNode.localMatrix));\r\n        } else if (parsedTransformNode.pivotMatrix) {\r\n            transformNode.setPivotMatrix(Matrix.FromArray(parsedTransformNode.pivotMatrix));\r\n        }\r\n\r\n        transformNode.setEnabled(parsedTransformNode.isEnabled);\r\n\r\n        transformNode._waitingParsedUniqueId = parsedTransformNode.uniqueId;\r\n\r\n        // Parent\r\n        if (parsedTransformNode.parentId !== undefined) {\r\n            transformNode._waitingParentId = parsedTransformNode.parentId;\r\n        }\r\n\r\n        if (parsedTransformNode.parentInstanceIndex !== undefined) {\r\n            transformNode._waitingParentInstanceIndex = parsedTransformNode.parentInstanceIndex;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedTransformNode.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedTransformNode.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedTransformNode.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    transformNode.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(transformNode, parsedTransformNode, scene);\r\n        }\r\n\r\n        if (parsedTransformNode.autoAnimate) {\r\n            scene.beginAnimation(\r\n                transformNode,\r\n                parsedTransformNode.autoAnimateFrom,\r\n                parsedTransformNode.autoAnimateTo,\r\n                parsedTransformNode.autoAnimateLoop,\r\n                parsedTransformNode.autoAnimateSpeed || 1.0\r\n            );\r\n        }\r\n\r\n        return transformNode;\r\n    }\r\n\r\n    /**\r\n     * Get all child-transformNodes of this node\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @returns an array of TransformNode\r\n     */\r\n    public getChildTransformNodes(directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): TransformNode[] {\r\n        const results: Array<TransformNode> = [];\r\n        this._getDescendants(results, directDescendantsOnly, (node: Node) => {\r\n            return (!predicate || predicate(node)) && node instanceof TransformNode;\r\n        });\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this transform node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        // Remove from scene\r\n        this.getScene().removeTransformNode(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.transformNodes.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.transformNodes.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        this.onAfterWorldMatrixUpdateObservable.clear();\r\n\r\n        if (doNotRecurse) {\r\n            const transformNodes = this.getChildTransformNodes(true);\r\n            for (const transformNode of transformNodes) {\r\n                transformNode.parent = null;\r\n                transformNode.computeWorldMatrix(true);\r\n            }\r\n        }\r\n\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)\r\n     * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false\r\n     * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false\r\n     * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling\r\n     * @returns the current mesh\r\n     */\r\n    public normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate?: Nullable<(node: AbstractMesh) => boolean>): TransformNode {\r\n        let storedRotation: Nullable<Vector3> = null;\r\n        let storedRotationQuaternion: Nullable<Quaternion> = null;\r\n\r\n        if (ignoreRotation) {\r\n            if (this.rotationQuaternion) {\r\n                storedRotationQuaternion = this.rotationQuaternion.clone();\r\n                this.rotationQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            } else if (this.rotation) {\r\n                storedRotation = this.rotation.clone();\r\n                this.rotation.copyFromFloats(0, 0, 0);\r\n            }\r\n        }\r\n\r\n        const boundingVectors = this.getHierarchyBoundingVectors(includeDescendants, predicate);\r\n        const sizeVec = boundingVectors.max.subtract(boundingVectors.min);\r\n        const maxDimension = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);\r\n\r\n        if (maxDimension === 0) {\r\n            return this;\r\n        }\r\n\r\n        const scale = 1 / maxDimension;\r\n\r\n        this.scaling.scaleInPlace(scale);\r\n\r\n        if (ignoreRotation) {\r\n            if (this.rotationQuaternion && storedRotationQuaternion) {\r\n                this.rotationQuaternion.copyFrom(storedRotationQuaternion);\r\n            } else if (this.rotation && storedRotation) {\r\n                this.rotation.copyFrom(storedRotation);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _syncAbsoluteScalingAndRotation(): void {\r\n        if (!this._isAbsoluteSynced) {\r\n            this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion);\r\n            this._isAbsoluteSynced = true;\r\n        }\r\n    }\r\n}\r\n", "import type { Collider } from \"./collider\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\n\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _MeshCollisionData {\r\n    public _checkCollisions = false;\r\n    public _collisionMask = -1;\r\n    public _collisionGroup = -1;\r\n    public _surroundingMeshes: Nullable<AbstractMesh[]> = null;\r\n    public _collider: Nullable<Collider> = null;\r\n    public _oldPositionForCollisions = new Vector3(0, 0, 0);\r\n    public _diffPositionForCollisions = new Vector3(0, 0, 0);\r\n    public _onCollideObserver: Nullable<Observer<AbstractMesh>>;\r\n    public _onCollisionPositionChangeObserver: Nullable<Observer<Vector3>>;\r\n    public _collisionResponse = true;\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport type { Nullable, FloatArray, IndicesArray, DeepImmutable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { ScenePerformancePriority } from \"../scene\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { IGetSetVerticesData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { ICullable } from \"../Culling/boundingInfo\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport type { MorphTargetManager } from \"../Morph/morphTargetManager\";\r\nimport type { IBakedVertexAnimationManager } from \"../BakedVertexAnimation/bakedVertexAnimationManager\";\r\nimport type { IEdgesRenderer } from \"../Rendering/edgesRenderer\";\r\nimport type { SolidParticle } from \"../Particles/solidParticle\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { AbstractActionManager } from \"../Actions/abstractActionManager\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport { _MeshCollisionData } from \"../Collisions/meshCollisionData\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { extractMinAndMax } from \"../Maths/math.functions\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Ray } from \"../Culling/ray\";\r\nimport type { Collider } from \"../Collisions/collider\";\r\nimport type { TrianglePickingPredicate } from \"../Culling/ray\";\r\nimport type { RenderingGroup } from \"../Rendering/renderingGroup\";\r\nimport type { IEdgesRendererOptions } from \"../Rendering/edgesRenderer\";\r\nimport type { MorphTarget } from \"../Morph/morphTarget\";\r\nimport type { Geometry } from \"./geometry\";\r\nimport { nativeOverride } from \"../Misc/decorators\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\nfunction ApplyMorph(data: FloatArray, kind: string, morphTargetManager: MorphTargetManager): void {\r\n    let getTargetData: Nullable<(target: MorphTarget) => Nullable<FloatArray>> = null;\r\n    switch (kind) {\r\n        case VertexBuffer.PositionKind:\r\n            getTargetData = (target) => target.getPositions();\r\n            break;\r\n        case VertexBuffer.NormalKind:\r\n            getTargetData = (target) => target.getNormals();\r\n            break;\r\n        case VertexBuffer.TangentKind:\r\n            getTargetData = (target) => target.getTangents();\r\n            break;\r\n        case VertexBuffer.UVKind:\r\n            getTargetData = (target) => target.getUVs();\r\n            break;\r\n        case VertexBuffer.UV2Kind:\r\n            getTargetData = (target) => target.getUV2s();\r\n            break;\r\n        case VertexBuffer.ColorKind:\r\n            getTargetData = (target) => target.getColors();\r\n            break;\r\n        default:\r\n            return;\r\n    }\r\n\r\n    for (let index = 0; index < data.length; index++) {\r\n        let value = data[index];\r\n        for (let targetCount = 0; targetCount < morphTargetManager.numTargets; targetCount++) {\r\n            const target = morphTargetManager.getTarget(targetCount);\r\n            const influence = target.influence;\r\n            if (influence !== 0) {\r\n                const targetData = getTargetData(target);\r\n                if (targetData) {\r\n                    value += (targetData[index] - data[index]) * influence;\r\n                }\r\n            }\r\n        }\r\n        data[index] = value;\r\n    }\r\n}\r\n\r\nfunction ApplySkeleton(\r\n    data: FloatArray,\r\n    kind: string,\r\n    skeletonMatrices: Float32Array,\r\n    matricesIndicesData: FloatArray,\r\n    matricesWeightsData: FloatArray,\r\n    matricesIndicesExtraData: Nullable<FloatArray>,\r\n    matricesWeightsExtraData: Nullable<FloatArray>\r\n): void {\r\n    const tempVector = TmpVectors.Vector3[0];\r\n    const finalMatrix = TmpVectors.Matrix[0];\r\n    const tempMatrix = TmpVectors.Matrix[1];\r\n\r\n    const transformFromFloatsToRef = kind === VertexBuffer.NormalKind ? Vector3.TransformNormalFromFloatsToRef : Vector3.TransformCoordinatesFromFloatsToRef;\r\n\r\n    for (let index = 0, matWeightIdx = 0; index < data.length; index += 3, matWeightIdx += 4) {\r\n        finalMatrix.reset();\r\n\r\n        let inf: number;\r\n        let weight: number;\r\n        for (inf = 0; inf < 4; inf++) {\r\n            weight = matricesWeightsData[matWeightIdx + inf];\r\n            if (weight > 0) {\r\n                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\r\n                finalMatrix.addToSelf(tempMatrix);\r\n            }\r\n        }\r\n        if (matricesIndicesExtraData && matricesWeightsExtraData) {\r\n            for (inf = 0; inf < 4; inf++) {\r\n                weight = matricesWeightsExtraData[matWeightIdx + inf];\r\n                if (weight > 0) {\r\n                    Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\r\n                    finalMatrix.addToSelf(tempMatrix);\r\n                }\r\n            }\r\n        }\r\n\r\n        transformFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);\r\n        tempVector.toArray(data, index);\r\n    }\r\n}\r\n\r\n/**\r\n * Opaque cache when computing data about a mesh\r\n */\r\nexport interface IMeshDataCache {\r\n    /** @internal */\r\n    _outputData?: Float32Array;\r\n\r\n    /** @internal */\r\n    _vertexData?: { [kind: string]: Float32Array };\r\n}\r\n\r\n/**\r\n * Options when computing data about a mesh\r\n */\r\nexport interface IMeshDataOptions {\r\n    /** Apply skeleton when computing the bounding info. Defaults to false. */\r\n    applySkeleton?: boolean;\r\n\r\n    /** Apply morph when computing the bounding info. Defaults to false. */\r\n    applyMorph?: boolean;\r\n\r\n    /** Update the cached positions stored as a Vector3 array. Defaults to true. */\r\n    updatePositionsArray?: boolean;\r\n\r\n    /**\r\n     * Cache to avoid redundant allocations and computations when computing the bounding info multiple times. Pass in\r\n     * an initial empty object and continue with subsequent calls using the same object. Caching is disabled by default.\r\n     */\r\n    cache?: IMeshDataCache;\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nclass _FacetDataStorage {\r\n    // facetData private properties\r\n    public facetPositions: Vector3[]; // facet local positions\r\n    public facetNormals: Vector3[]; // facet local normals\r\n    public facetPartitioning: number[][]; // partitioning array of facet index arrays\r\n    public facetNb: number = 0; // facet number\r\n    public partitioningSubdivisions: number = 10; // number of subdivisions per axis in the partitioning space\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public partitioningBBoxRatio: number = 1.01; // the partitioning array space is by default 1% bigger than the bounding box\r\n    public facetDataEnabled: boolean = false; // is the facet data feature enabled on this mesh ?\r\n    public facetParameters: any = {}; // keep a reference to the object parameters to avoid memory re-allocation\r\n    public bbSize: Vector3 = Vector3.Zero(); // bbox size approximated for facet data\r\n    public subDiv = {\r\n        // actual number of subdivisions per axis for ComputeNormals()\r\n        max: 1,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        X: 1,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        Y: 1,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        Z: 1,\r\n    };\r\n\r\n    public facetDepthSort: boolean = false; // is the facet depth sort to be computed\r\n    public facetDepthSortEnabled: boolean = false; // is the facet depth sort initialized\r\n    public depthSortedIndices: IndicesArray; // copy of the indices array to store them once sorted\r\n    public depthSortedFacets: { ind: number; sqDistance: number }[]; // array of depth sorted facets\r\n    public facetDepthSortFunction: (f1: { ind: number; sqDistance: number }, f2: { ind: number; sqDistance: number }) => number; // facet depth sort function\r\n    public facetDepthSortFrom: Vector3; // location where to depth sort from\r\n    public facetDepthSortOrigin: Vector3; // same as facetDepthSortFrom but expressed in the mesh local space\r\n\r\n    public invertedMatrix: Matrix; // Inverted world matrix.\r\n}\r\n\r\n/**\r\n * @internal\r\n **/\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nclass _InternalAbstractMeshDataInfo {\r\n    public _hasVertexAlpha = false;\r\n    public _useVertexColors = true;\r\n    public _numBoneInfluencers = 4;\r\n    public _applyFog = true;\r\n    public _receiveShadows = false;\r\n    public _facetData = new _FacetDataStorage();\r\n    public _visibility = 1.0;\r\n    public _skeleton: Nullable<Skeleton> = null;\r\n    public _layerMask: number = 0x0fffffff;\r\n    public _computeBonesUsingShaders = true;\r\n    public _isActive = false;\r\n    public _onlyForInstances = false;\r\n    public _isActiveIntermediate = false;\r\n    public _onlyForInstancesIntermediate = false;\r\n    public _actAsRegularMesh = false;\r\n    public _currentLOD: Map<Camera, [Nullable<AbstractMesh>, number]> = new Map();\r\n    public _collisionRetryCount: number = 3;\r\n    public _morphTargetManager: Nullable<MorphTargetManager> = null;\r\n    public _renderingGroupId = 0;\r\n    public _bakedVertexAnimationManager: Nullable<IBakedVertexAnimationManager> = null;\r\n    public _material: Nullable<Material> = null;\r\n    public _materialForRenderPass: Array<Material | undefined>; // map a render pass id (index in the array) to a Material\r\n    public _positions: Nullable<Vector3[]> = null;\r\n    public _pointerOverDisableMeshTesting: boolean = false;\r\n    // Collisions\r\n    public _meshCollisionData = new _MeshCollisionData();\r\n    public _enableDistantPicking = false;\r\n    /** @internal\r\n     * Bounding info that is unnafected by the addition of thin instances\r\n     */\r\n    public _rawBoundingInfo: Nullable<BoundingInfo> = null;\r\n    /** @internal\r\n     * This value will indicate us that at some point, the mesh was specifically used with the opposite winding order\r\n     * We use that as a clue to force the material to sideOrientation = null\r\n     */\r\n    public _sideOrientationHint = false;\r\n    /**\r\n     * Used in frame graph mode only, to know which meshes to update when in frozen mode\r\n     */\r\n    public _wasActiveLastFrame = false;\r\n}\r\n\r\n/**\r\n * Class used to store all common mesh properties\r\n */\r\nexport abstract class AbstractMesh extends TransformNode implements IDisposable, ICullable, IGetSetVerticesData {\r\n    /** No occlusion */\r\n    public static OCCLUSION_TYPE_NONE = 0;\r\n    /** Occlusion set to optimistic */\r\n    public static OCCLUSION_TYPE_OPTIMISTIC = 1;\r\n    /** Occlusion set to strict */\r\n    public static OCCLUSION_TYPE_STRICT = 2;\r\n    /** Use an accurate occlusion algorithm */\r\n    public static OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;\r\n    /** Use a conservative occlusion algorithm */\r\n    public static OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;\r\n\r\n    /** Default culling strategy : this is an exclusion test and it's the more accurate.\r\n     *  Test order :\r\n     *  Is the bounding sphere outside the frustum ?\r\n     *  If not, are the bounding box vertices outside the frustum ?\r\n     *  It not, then the cullable object is in the frustum.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_STANDARD = Constants.MESHES_CULLINGSTRATEGY_STANDARD;\r\n    /** Culling strategy : Bounding Sphere Only.\r\n     *  This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.\r\n     *  It's also less accurate than the standard because some not visible objects can still be selected.\r\n     *  Test : is the bounding sphere outside the frustum ?\r\n     *  If not, then the cullable object is in the frustum.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\r\n    /** Culling strategy : Optimistic Inclusion.\r\n     *  This in an inclusion test first, then the standard exclusion test.\r\n     *  This can be faster when a cullable object is expected to be almost always in the camera frustum.\r\n     *  This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.\r\n     *  Anyway, it's as accurate as the standard strategy.\r\n     *  Test :\r\n     *  Is the cullable object bounding sphere center in the frustum ?\r\n     *  If not, apply the default culling strategy.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION;\r\n    /** Culling strategy : Optimistic Inclusion then Bounding Sphere Only.\r\n     *  This in an inclusion test first, then the bounding sphere only exclusion test.\r\n     *  This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.\r\n     *  This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.\r\n     *  It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.\r\n     *  Test :\r\n     *  Is the cullable object bounding sphere center in the frustum ?\r\n     *  If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n\r\n    /**\r\n     * No billboard\r\n     */\r\n    public static override get BILLBOARDMODE_NONE(): number {\r\n        return TransformNode.BILLBOARDMODE_NONE;\r\n    }\r\n\r\n    /** Billboard on X axis */\r\n    public static override get BILLBOARDMODE_X(): number {\r\n        return TransformNode.BILLBOARDMODE_X;\r\n    }\r\n\r\n    /** Billboard on Y axis */\r\n    public static override get BILLBOARDMODE_Y(): number {\r\n        return TransformNode.BILLBOARDMODE_Y;\r\n    }\r\n\r\n    /** Billboard on Z axis */\r\n    public static override get BILLBOARDMODE_Z(): number {\r\n        return TransformNode.BILLBOARDMODE_Z;\r\n    }\r\n\r\n    /** Billboard on all axes */\r\n    public static override get BILLBOARDMODE_ALL(): number {\r\n        return TransformNode.BILLBOARDMODE_ALL;\r\n    }\r\n\r\n    /** Billboard on using position instead of orientation */\r\n    public static override get BILLBOARDMODE_USE_POSITION(): number {\r\n        return TransformNode.BILLBOARDMODE_USE_POSITION;\r\n    }\r\n\r\n    // Internal data\r\n    /** @internal */\r\n    public _internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();\r\n\r\n    /** @internal */\r\n    public _waitingMaterialId: Nullable<string> = null;\r\n\r\n    /** @internal */\r\n    public _waitingMorphTargetManagerId: Nullable<number> = null;\r\n\r\n    /**\r\n     * The culling strategy to use to check whether the mesh must be rendered or not.\r\n     * This value can be changed at any time and will be used on the next render mesh selection.\r\n     * The possible values are :\r\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\r\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * Please read each static variable documentation to get details about the culling process.\r\n     * */\r\n    public cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\r\n\r\n    /**\r\n     * Gets the number of facets in the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#what-is-a-mesh-facet\r\n     */\r\n    public get facetNb(): number {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetNb;\r\n    }\r\n    /**\r\n     * Gets or set the number (integer) of subdivisions per axis in the partitioning space\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#tweaking-the-partitioning\r\n     */\r\n    public get partitioningSubdivisions(): number {\r\n        return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;\r\n    }\r\n    public set partitioningSubdivisions(nb: number) {\r\n        this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;\r\n    }\r\n    /**\r\n     * The ratio (float) to apply to the bounding box size to set to the partitioning space.\r\n     * Ex : 1.01 (default) the partitioning space is 1% bigger than the bounding box\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#tweaking-the-partitioning\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get partitioningBBoxRatio(): number {\r\n        return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public set partitioningBBoxRatio(ratio: number) {\r\n        this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.\r\n     * Works only for updatable meshes.\r\n     * Doesn't work with multi-materials\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#facet-depth-sort\r\n     */\r\n    public get mustDepthSortFacets(): boolean {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;\r\n    }\r\n    public set mustDepthSortFacets(sort: boolean) {\r\n        this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;\r\n    }\r\n\r\n    /**\r\n     * The location (Vector3) where the facet depth sort must be computed from.\r\n     * By default, the active camera position.\r\n     * Used only when facet depth sort is enabled\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#facet-depth-sort\r\n     */\r\n    public get facetDepthSortFrom(): Vector3 {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;\r\n    }\r\n    public set facetDepthSortFrom(location: Vector3) {\r\n        this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location;\r\n    }\r\n\r\n    /** number of collision detection tries. Change this value if not all collisions are detected and handled properly */\r\n    public get collisionRetryCount(): number {\r\n        return this._internalAbstractMeshDataInfo._collisionRetryCount;\r\n    }\r\n    public set collisionRetryCount(retryCount: number) {\r\n        this._internalAbstractMeshDataInfo._collisionRetryCount = retryCount;\r\n    }\r\n    /**\r\n     * gets a boolean indicating if facetData is enabled\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#what-is-a-mesh-facet\r\n     */\r\n    public get isFacetDataEnabled(): boolean {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the morph target manager\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\r\n     */\r\n    public get morphTargetManager(): Nullable<MorphTargetManager> {\r\n        return this._internalAbstractMeshDataInfo._morphTargetManager;\r\n    }\r\n\r\n    public set morphTargetManager(value: Nullable<MorphTargetManager>) {\r\n        if (this._internalAbstractMeshDataInfo._morphTargetManager === value) {\r\n            return;\r\n        }\r\n        this._internalAbstractMeshDataInfo._morphTargetManager = value;\r\n        this._syncGeometryWithMorphTargetManager();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the baked vertex animation manager\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/baked_texture_animations\r\n     */\r\n    public get bakedVertexAnimationManager(): Nullable<IBakedVertexAnimationManager> {\r\n        return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;\r\n    }\r\n\r\n    public set bakedVertexAnimationManager(value: Nullable<IBakedVertexAnimationManager>) {\r\n        if (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager === value) {\r\n            return;\r\n        }\r\n        this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /** @internal */\r\n    public _syncGeometryWithMorphTargetManager(): void {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _updateNonUniformScalingState(value: boolean): boolean {\r\n        if (!super._updateNonUniformScalingState(value)) {\r\n            return false;\r\n        }\r\n        this._markSubMeshesAsMiscDirty();\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public get rawBoundingInfo(): Nullable<BoundingInfo> {\r\n        return this._internalAbstractMeshDataInfo._rawBoundingInfo;\r\n    }\r\n    public set rawBoundingInfo(boundingInfo: Nullable<BoundingInfo>) {\r\n        this._internalAbstractMeshDataInfo._rawBoundingInfo = boundingInfo;\r\n    }\r\n\r\n    // Events\r\n\r\n    /**\r\n     * An event triggered when this mesh collides with another one\r\n     */\r\n    public onCollideObservable = new Observable<AbstractMesh>();\r\n\r\n    /** Set a function to call when this mesh collides with another one */\r\n    public set onCollide(callback: (collidedMesh?: AbstractMesh) => void) {\r\n        if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver) {\r\n            this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver);\r\n        }\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the collision's position changes\r\n     */\r\n    public onCollisionPositionChangeObservable = new Observable<Vector3>();\r\n\r\n    /** Set a function to call when the collision's position changes */\r\n    public set onCollisionPositionChange(callback: () => void) {\r\n        if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver) {\r\n            this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver);\r\n        }\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when material is changed\r\n     */\r\n    public onMaterialChangedObservable = new Observable<AbstractMesh>();\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets or sets the orientation for POV movement & rotation\r\n     */\r\n    public definedFacingForward = true;\r\n\r\n    /** @internal */\r\n    public _occlusionQuery: Nullable<WebGLQuery | number> = null;\r\n\r\n    /** @internal */\r\n    public _renderingGroup: Nullable<RenderingGroup> = null;\r\n\r\n    /**\r\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\r\n     */\r\n    public get visibility(): number {\r\n        return this._internalAbstractMeshDataInfo._visibility;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\r\n     */\r\n    public set visibility(value: number) {\r\n        if (this._internalAbstractMeshDataInfo._visibility === value) {\r\n            return;\r\n        }\r\n\r\n        const oldValue = this._internalAbstractMeshDataInfo._visibility;\r\n\r\n        this._internalAbstractMeshDataInfo._visibility = value;\r\n\r\n        if ((oldValue === 1 && value !== 1) || (oldValue !== 1 && value === 1)) {\r\n            this._markSubMeshesAsDirty((defines) => {\r\n                defines.markAsMiscDirty();\r\n                defines.markAsPrePassDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the alpha index used to sort transparent meshes\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering#alpha-index\r\n     */\r\n    public alphaIndex = Number.MAX_VALUE;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true\r\n     */\r\n    public isPickable = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be near picked (touched by the XR controller or hands). Default is false\r\n     */\r\n    public isNearPickable = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be grabbed. Default is false.\r\n     * Setting this to true, while using the XR near interaction feature, will trigger a pointer event when the mesh is grabbed.\r\n     * Grabbing means that the controller is using the squeeze or main trigger button to grab the mesh.\r\n     * This is different from nearPickable which only triggers the event when the mesh is touched by the controller\r\n     */\r\n    public isNearGrabbable = false;\r\n\r\n    /** Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default) */\r\n    public showSubMeshesBoundingBox = false;\r\n\r\n    /** Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\r\n     */\r\n    public isBlocker = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)\r\n     */\r\n    public enablePointerMoveEvents = false;\r\n\r\n    /**\r\n     * Gets or sets the property which disables the test that is checking that the mesh under the pointer is the same than the previous time we tested for it (default: false).\r\n     * Set this property to true if you want thin instances picking to be reported accurately when moving over the mesh.\r\n     * Note that setting this property to true will incur some performance penalties when dealing with pointer events for this mesh so use it sparingly.\r\n     */\r\n    public get pointerOverDisableMeshTesting() {\r\n        return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting;\r\n    }\r\n\r\n    public set pointerOverDisableMeshTesting(disable: boolean) {\r\n        this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting = disable;\r\n    }\r\n\r\n    /**\r\n     * Specifies the rendering group id for this mesh (0 by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering#rendering-groups\r\n     */\r\n    public get renderingGroupId() {\r\n        return this._internalAbstractMeshDataInfo._renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        this._internalAbstractMeshDataInfo._renderingGroupId = value;\r\n    }\r\n\r\n    /** Gets or sets current material */\r\n    public get material(): Nullable<Material> {\r\n        return this._internalAbstractMeshDataInfo._material;\r\n    }\r\n    public set material(value: Nullable<Material>) {\r\n        this._setMaterial(value);\r\n    }\r\n\r\n    /** @internal */\r\n    protected _setMaterial(value: Nullable<Material>) {\r\n        if (this._internalAbstractMeshDataInfo._material === value) {\r\n            return;\r\n        }\r\n\r\n        // remove from material mesh map id needed\r\n        if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {\r\n            this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = undefined;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._material = value;\r\n\r\n        if (value && value.meshMap) {\r\n            value.meshMap[this.uniqueId] = this;\r\n        }\r\n\r\n        if (this.onMaterialChangedObservable.hasObservers()) {\r\n            this.onMaterialChangedObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        this.resetDrawCache(undefined, value == null);\r\n        this._unBindEffect();\r\n    }\r\n\r\n    /**\r\n     * Gets the material used to render the mesh in a specific render pass\r\n     * @param renderPassId render pass id\r\n     * @returns material used for the render pass. If no specific material is used for this render pass, undefined is returned (meaning mesh.material is used for this pass)\r\n     */\r\n    public getMaterialForRenderPass(renderPassId: number): Material | undefined {\r\n        return this._internalAbstractMeshDataInfo._materialForRenderPass?.[renderPassId];\r\n    }\r\n\r\n    /**\r\n     * Sets the material to be used to render the mesh in a specific render pass\r\n     * @param renderPassId render pass id\r\n     * @param material material to use for this render pass. If undefined is passed, no specific material will be used for this render pass but the regular material will be used instead (mesh.material)\r\n     */\r\n    public setMaterialForRenderPass(renderPassId: number, material?: Material): void {\r\n        this.resetDrawCache(renderPassId);\r\n        if (!this._internalAbstractMeshDataInfo._materialForRenderPass) {\r\n            this._internalAbstractMeshDataInfo._materialForRenderPass = [];\r\n        }\r\n        const currentMaterial = this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId];\r\n        if (currentMaterial?.meshMap?.[this.uniqueId]) {\r\n            currentMaterial.meshMap[this.uniqueId] = undefined;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId] = material;\r\n        if (material && material.meshMap) {\r\n            material.meshMap[this.uniqueId] = this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this mesh can receive realtime shadows\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._internalAbstractMeshDataInfo._receiveShadows;\r\n    }\r\n    public set receiveShadows(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._receiveShadows === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._receiveShadows = value;\r\n        this._markSubMeshesAsLightDirty();\r\n    }\r\n\r\n    /** Defines color to use when rendering outline */\r\n    public outlineColor = Color3.Red();\r\n    /** Define width to use when rendering outline */\r\n    public outlineWidth = 0.02;\r\n\r\n    /** Defines color to use when rendering overlay */\r\n    public overlayColor = Color3.Red();\r\n    /** Defines alpha to use when rendering overlay */\r\n    public overlayAlpha = 0.5;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this mesh needs to use vertex alpha data to render.\r\n     * This property is misnamed and should be `useVertexAlpha`. Note that the mesh will be rendered\r\n     * with alpha blending when this flag is set even if vertex alpha data is missing from the geometry.\r\n     */\r\n    public get hasVertexAlpha(): boolean {\r\n        return this._internalAbstractMeshDataInfo._hasVertexAlpha;\r\n    }\r\n    public set hasVertexAlpha(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._hasVertexAlpha = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n        this._markSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) */\r\n    public get useVertexColors(): boolean {\r\n        return this._internalAbstractMeshDataInfo._useVertexColors;\r\n    }\r\n    public set useVertexColors(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._useVertexColors === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._useVertexColors = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that bone animations must be computed by the GPU (true by default)\r\n     */\r\n    public get computeBonesUsingShaders(): boolean {\r\n        return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\r\n    }\r\n    public set computeBonesUsingShaders(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /** Gets or sets the number of allowed bone influences per vertex (4 by default) */\r\n    public get numBoneInfluencers(): number {\r\n        return this._internalAbstractMeshDataInfo._numBoneInfluencers;\r\n    }\r\n    public set numBoneInfluencers(value: number) {\r\n        if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._numBoneInfluencers = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) */\r\n    public get applyFog(): boolean {\r\n        return this._internalAbstractMeshDataInfo._applyFog;\r\n    }\r\n    public set applyFog(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._applyFog === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._applyFog = value;\r\n        this._markSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /** When enabled, decompose picking matrices for better precision with large values for mesh position and scling */\r\n    public get enableDistantPicking(): boolean {\r\n        return this._internalAbstractMeshDataInfo._enableDistantPicking;\r\n    }\r\n    public set enableDistantPicking(value: boolean) {\r\n        this._internalAbstractMeshDataInfo._enableDistantPicking = value;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default) */\r\n    public useOctreeForRenderingSelection = true;\r\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default) */\r\n    public useOctreeForPicking = true;\r\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default) */\r\n    public useOctreeForCollisions = true;\r\n    /**\r\n     * Gets or sets the current layer mask (default is 0x0FFFFFFF)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/layerMasksAndMultiCam\r\n     */\r\n    public get layerMask(): number {\r\n        return this._internalAbstractMeshDataInfo._layerMask;\r\n    }\r\n\r\n    public set layerMask(value: number) {\r\n        if (value === this._internalAbstractMeshDataInfo._layerMask) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._layerMask = value;\r\n        this._resyncLightSources();\r\n    }\r\n\r\n    /**\r\n     * True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)\r\n     */\r\n    public alwaysSelectAsActiveMesh = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the bounding info does not need to be kept in sync (for performance reason)\r\n     */\r\n    public doNotSyncBoundingInfo = false;\r\n\r\n    /**\r\n     * Gets or sets the current action manager\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions\r\n     */\r\n    public actionManager: Nullable<AbstractActionManager> = null;\r\n\r\n    /**\r\n     * Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\r\n     */\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n    /**\r\n     * Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\r\n     */\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Gets or sets a collision mask used to mask collisions (default is -1).\r\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a collision response flag (default is true).\r\n     * when collisionResponse is false, events are still triggered but colliding entity has no response\r\n     * This helps creating trigger volume when user wants collision feedback events but not position/velocity\r\n     * to respond to the collision.\r\n     */\r\n    public get collisionResponse(): boolean {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;\r\n    }\r\n\r\n    public set collisionResponse(response: boolean) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = response;\r\n    }\r\n    /**\r\n     * Gets or sets the current collision group mask (-1 by default).\r\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\r\n     */\r\n    public get collisionGroup(): number {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;\r\n    }\r\n\r\n    public set collisionGroup(mask: number) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets current surrounding meshes (null by default).\r\n     *\r\n     * By default collision detection is tested against every mesh in the scene.\r\n     * It is possible to set surroundingMeshes to a defined list of meshes and then only these specified\r\n     * meshes will be tested for the collision.\r\n     *\r\n     * Note: if set to an empty array no collision will happen when this mesh is moved.\r\n     */\r\n    public get surroundingMeshes(): Nullable<AbstractMesh[]> {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;\r\n    }\r\n\r\n    public set surroundingMeshes(meshes: Nullable<AbstractMesh[]>) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = meshes;\r\n    }\r\n\r\n    // Edges\r\n    /**\r\n     * Defines edge width used when edgesRenderer is enabled\r\n     * @see https://www.babylonjs-playground.com/#10OJSG#13\r\n     */\r\n    public edgesWidth = 1;\r\n    /**\r\n     * Defines edge color used when edgesRenderer is enabled\r\n     * @see https://www.babylonjs-playground.com/#10OJSG#13\r\n     */\r\n    public edgesColor = new Color4(1, 0, 0, 1);\r\n    /** @internal */\r\n    public _edgesRenderer: Nullable<IEdgesRenderer> = null;\r\n\r\n    /** @internal */\r\n    public _masterMesh: Nullable<AbstractMesh> = null;\r\n    protected _boundingInfo: Nullable<BoundingInfo> = null;\r\n    protected _boundingInfoIsDirty = true;\r\n    /** @internal */\r\n    public _renderId = 0;\r\n\r\n    /**\r\n     * Gets or sets the list of subMeshes\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/multiMaterials\r\n     */\r\n    public subMeshes: SubMesh[];\r\n\r\n    /** @internal */\r\n    public _intersectionsInProgress = new Array<AbstractMesh>();\r\n\r\n    /** @internal */\r\n    public _unIndexed = false;\r\n\r\n    /** @internal */\r\n    public _lightSources = new Array<Light>();\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._lightSources;\r\n    }\r\n\r\n    /** @internal */\r\n    public abstract get _positions(): Nullable<Vector3[]>;\r\n\r\n    // Loading properties\r\n    /** @internal */\r\n    public _waitingData: {\r\n        lods: Nullable<any>;\r\n        actions: Nullable<any>;\r\n        freezeWorldMatrix: Nullable<boolean>;\r\n    } = {\r\n        lods: null,\r\n        actions: null,\r\n        freezeWorldMatrix: null,\r\n    };\r\n\r\n    /** @internal */\r\n    public _bonesTransformMatrices: Nullable<Float32Array> = null;\r\n\r\n    /** @internal */\r\n    public _transformMatrixTexture: Nullable<RawTexture> = null;\r\n\r\n    /**\r\n     * Gets or sets a skeleton to apply skinning transformations\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n     */\r\n    public set skeleton(value: Nullable<Skeleton>) {\r\n        const skeleton = this._internalAbstractMeshDataInfo._skeleton;\r\n        if (skeleton && skeleton.needInitialSkinMatrix) {\r\n            skeleton._unregisterMeshWithPoseMatrix(this);\r\n        }\r\n\r\n        if (value && value.needInitialSkinMatrix) {\r\n            value._registerMeshWithPoseMatrix(this);\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._skeleton = value;\r\n\r\n        if (!this._internalAbstractMeshDataInfo._skeleton) {\r\n            this._bonesTransformMatrices = null;\r\n        }\r\n\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._internalAbstractMeshDataInfo._skeleton;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the mesh is rebuilt.\r\n     */\r\n    public onRebuildObservable = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * The current mesh uniform buffer.\r\n     * @internal Internal use only.\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    // Constructor\r\n\r\n    /**\r\n     * Creates a new AbstractMesh\r\n     * @param name defines the name of the mesh\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(name: string, scene: Nullable<Scene> = null) {\r\n        super(name, scene, false);\r\n\r\n        scene = this.getScene();\r\n\r\n        scene.addMesh(this);\r\n\r\n        this._resyncLightSources();\r\n\r\n        // Mesh Uniform Buffer.\r\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name, !this.getScene().getEngine().isWebGPU);\r\n        this._buildUniformLayout();\r\n\r\n        switch (scene.performancePriority) {\r\n            case ScenePerformancePriority.Aggressive:\r\n                this.doNotSyncBoundingInfo = true;\r\n            // eslint-disable-next-line no-fallthrough\r\n            case ScenePerformancePriority.Intermediate:\r\n                this.alwaysSelectAsActiveMesh = true;\r\n                this.isPickable = false;\r\n                break;\r\n        }\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"world\", 16);\r\n        this._uniformBuffer.addUniform(\"visibility\", 1);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Transfer the mesh values to its UBO.\r\n     * @param world The world matrix associated with the mesh\r\n     */\r\n    public transferToEffect(world: Matrix): void {\r\n        const ubo = this._uniformBuffer;\r\n\r\n        ubo.updateMatrix(\"world\", world);\r\n        ubo.updateFloat(\"visibility\", this._internalAbstractMeshDataInfo._visibility);\r\n\r\n        ubo.update();\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh uniform buffer.\r\n     * @returns the uniform buffer of the mesh.\r\n     */\r\n    public getMeshUniformBuffer(): UniformBuffer {\r\n        return this._uniformBuffer;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"AbstractMesh\"\r\n     * @returns \"AbstractMesh\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"AbstractMesh\";\r\n    }\r\n\r\n    /**\r\n     * Gets a string representation of the current mesh\r\n     * @param fullDetails defines a boolean indicating if full details must be included\r\n     * @returns a string representation of the current mesh\r\n     */\r\n    public override toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name + \", isInstance: \" + (this.getClassName() === \"InstancedMesh\" ? \"YES\" : \"NO\");\r\n        ret += \", # of submeshes: \" + (this.subMeshes ? this.subMeshes.length : 0);\r\n\r\n        const skeleton = this._internalAbstractMeshDataInfo._skeleton;\r\n        if (skeleton) {\r\n            ret += \", skeleton: \" + skeleton.name;\r\n        }\r\n        if (fullDetails) {\r\n            ret += \", billboard mode: \" + [\"NONE\", \"X\", \"Y\", null, \"Z\", null, null, \"ALL\"][this.billboardMode];\r\n            ret += \", freeze wrld mat: \" + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? \"YES\" : \"NO\");\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected override _getEffectiveParent(): Nullable<Node> {\r\n        if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\r\n            return this._masterMesh;\r\n        }\r\n\r\n        return super._getEffectiveParent();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _getActionManagerForTrigger(trigger?: number, initialCall = true): Nullable<AbstractActionManager> {\r\n        if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {\r\n            if (trigger) {\r\n                if (this.actionManager.hasSpecificTrigger(trigger)) {\r\n                    return this.actionManager;\r\n                }\r\n            } else {\r\n                return this.actionManager;\r\n            }\r\n        }\r\n\r\n        if (!this.parent) {\r\n            return null;\r\n        }\r\n\r\n        return this.parent._getActionManagerForTrigger(trigger, false);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _rebuild(dispose = false): void {\r\n        this.onRebuildObservable.notifyObservers(this);\r\n\r\n        if (this._occlusionQuery !== null) {\r\n            this._occlusionQuery = null;\r\n        }\r\n\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        for (const subMesh of this.subMeshes) {\r\n            subMesh._rebuild();\r\n        }\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    /** @internal */\r\n    public _resyncLightSources(): void {\r\n        this._lightSources.length = 0;\r\n\r\n        for (const light of this.getScene().lights) {\r\n            if (!light.isEnabled()) {\r\n                continue;\r\n            }\r\n\r\n            if (light.canAffectMesh(this)) {\r\n                this._lightSources.push(light);\r\n            }\r\n        }\r\n\r\n        this._markSubMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _resyncLightSource(light: Light): void {\r\n        const isIn = light.isEnabled() && light.canAffectMesh(this);\r\n\r\n        const index = this._lightSources.indexOf(light);\r\n        let removed = false;\r\n        if (index === -1) {\r\n            if (!isIn) {\r\n                return;\r\n            }\r\n            this._lightSources.push(light);\r\n        } else {\r\n            if (isIn) {\r\n                return;\r\n            }\r\n            removed = true;\r\n            this._lightSources.splice(index, 1);\r\n        }\r\n\r\n        this._markSubMeshesAsLightDirty(removed);\r\n    }\r\n\r\n    /** @internal */\r\n    public _unBindEffect() {\r\n        for (const subMesh of this.subMeshes) {\r\n            subMesh.setEffect(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _removeLightSource(light: Light, dispose: boolean): void {\r\n        const index = this._lightSources.indexOf(light);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n        this._lightSources.splice(index, 1);\r\n\r\n        this._markSubMeshesAsLightDirty(dispose);\r\n    }\r\n\r\n    private _markSubMeshesAsDirty(func: (defines: MaterialDefines) => void) {\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        for (const subMesh of this.subMeshes) {\r\n            for (let i = 0; i < subMesh._drawWrappers.length; ++i) {\r\n                const drawWrapper = subMesh._drawWrappers[i];\r\n                if (!drawWrapper || !drawWrapper.defines || !(drawWrapper.defines as MaterialDefines).markAllAsDirty) {\r\n                    continue;\r\n                }\r\n                func(drawWrapper.defines as MaterialDefines);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _markSubMeshesAsLightDirty(dispose: boolean = false) {\r\n        this._markSubMeshesAsDirty((defines) => defines.markAsLightDirty(dispose));\r\n    }\r\n\r\n    /** @internal */\r\n    public _markSubMeshesAsAttributesDirty() {\r\n        this._markSubMeshesAsDirty((defines) => defines.markAsAttributesDirty());\r\n    }\r\n\r\n    /** @internal */\r\n    public _markSubMeshesAsMiscDirty() {\r\n        this._markSubMeshesAsDirty((defines) => defines.markAsMiscDirty());\r\n    }\r\n\r\n    /**\r\n     * Flag the AbstractMesh as dirty (Forcing it to update everything)\r\n     * @param property if set to \"rotation\" the objects rotationQuaternion will be set to null\r\n     * @returns this AbstractMesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public override markAsDirty(property?: string): AbstractMesh {\r\n        this._currentRenderId = Number.MAX_VALUE;\r\n        super.markAsDirty(property);\r\n        this._isDirty = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache for all submeshes of this abstract mesh\r\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\r\n     * @param immediate If true, the effect will be released immediately, otherwise it will be released at the next frame\r\n     */\r\n    public resetDrawCache(passId?: number, immediate = false): void {\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        for (const subMesh of this.subMeshes) {\r\n            subMesh.resetDrawCache(passId, immediate);\r\n        }\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Returns true if the mesh is blocked. Implemented by child classes\r\n     */\r\n    public get isBlocked(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh itself by default. Implemented by child classes\r\n     * @param camera defines the camera to use to pick the right LOD level\r\n     * @returns the currentAbstractMesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getLOD(camera: Camera): Nullable<AbstractMesh> {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * The mesh's internal Geometry object. Implemented by child classes.\r\n     */\r\n    public abstract get geometry(): Nullable<Geometry>;\r\n\r\n    /**\r\n     * Returns 0 by default. Implemented by child classes\r\n     * @returns an integer\r\n     */\r\n    public getTotalVertices(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the number of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns null by default. Implemented by child classes\r\n     * @returns null\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the array of the requested vertex data kind. Implemented by child classes\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns null\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getVerticesData(kind: string): Nullable<FloatArray> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Copies the requested vertex data kind into the given vertex data map. Float data is constructed if the map doesn't have the data.\r\n     * @param kind defines the vertex data kind to use\r\n     * @param vertexData defines the map that stores the resulting data\r\n     */\r\n    public abstract copyVerticesData(kind: string, vertexData: { [kind: string]: Float32Array }): void;\r\n\r\n    /**\r\n     * Returns the mesh VertexBuffer object from the requested `kind`\r\n     * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.NormalKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\r\n     * @returns a FloatArray or null if the mesh has no vertex buffer for this kind.\r\n     */\r\n    public abstract getVertexBuffer(kind: string, bypassInstanceData?: boolean): Nullable<VertexBuffer>;\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * @param kind defines vertex data kind:\r\n     * * VertexBuffer.PositionKind\r\n     * * VertexBuffer.UVKind\r\n     * * VertexBuffer.UV2Kind\r\n     * * VertexBuffer.UV3Kind\r\n     * * VertexBuffer.UV4Kind\r\n     * * VertexBuffer.UV5Kind\r\n     * * VertexBuffer.UV6Kind\r\n     * * VertexBuffer.ColorKind\r\n     * * VertexBuffer.MatricesIndicesKind\r\n     * * VertexBuffer.MatricesIndicesExtraKind\r\n     * * VertexBuffer.MatricesWeightsKind\r\n     * * VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updatable defines if the data must be flagged as updatable (or static)\r\n     * @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind\r\n     * @returns the current mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * @param kind defines vertex data kind:\r\n     * * VertexBuffer.PositionKind\r\n     * * VertexBuffer.UVKind\r\n     * * VertexBuffer.UV2Kind\r\n     * * VertexBuffer.UV3Kind\r\n     * * VertexBuffer.UV4Kind\r\n     * * VertexBuffer.UV5Kind\r\n     * * VertexBuffer.UV6Kind\r\n     * * VertexBuffer.ColorKind\r\n     * * VertexBuffer.MatricesIndicesKind\r\n     * * VertexBuffer.MatricesIndicesExtraKind\r\n     * * VertexBuffer.MatricesWeightsKind\r\n     * * VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed\r\n     * @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh\r\n     * @returns the current mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices,\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)\r\n     * @param totalVertices Defines the total number of vertices\r\n     * @returns the current mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number>): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if specific vertex data is present\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns true is data kind is present\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined.\r\n     * Note that it returns a shallow bounding of the mesh (i.e. it does not include children).\r\n     * However, if the mesh contains thin instances, it will be expanded to include them. If you want the \"raw\" bounding data instead, then use `getRawBoundingInfo()`.\r\n     * To get the full bounding of all children, call `getHierarchyBoundingVectors` instead.\r\n     * @returns a BoundingInfo\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        if (this._masterMesh) {\r\n            return this._masterMesh.getBoundingInfo();\r\n        }\r\n\r\n        if (this._boundingInfoIsDirty) {\r\n            this._boundingInfoIsDirty = false;\r\n            // this._boundingInfo is being created if undefined\r\n            this._updateBoundingInfo();\r\n        }\r\n        // cannot be null.\r\n        return this._boundingInfo!;\r\n    }\r\n\r\n    /**\r\n     * Returns the bounding info unnafected by instance data.\r\n     * @returns the bounding info of the mesh unaffected by instance data.\r\n     */\r\n    public getRawBoundingInfo() {\r\n        return this.rawBoundingInfo ?? this.getBoundingInfo();\r\n    }\r\n\r\n    /**\r\n     * Overwrite the current bounding info\r\n     * @param boundingInfo defines the new bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public setBoundingInfo(boundingInfo: BoundingInfo): AbstractMesh {\r\n        this._boundingInfo = boundingInfo;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns true if there is already a bounding info\r\n     */\r\n    public get hasBoundingInfo(): boolean {\r\n        return this._boundingInfo !== null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new bounding info for the mesh\r\n     * @param minimum min vector of the bounding box/sphere\r\n     * @param maximum max vector of the bounding box/sphere\r\n     * @param worldMatrix defines the new world matrix\r\n     * @returns the new bounding info\r\n     */\r\n    public buildBoundingInfo(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this._boundingInfo = new BoundingInfo(minimum, maximum, worldMatrix);\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)\r\n     * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false\r\n     * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false\r\n     * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling\r\n     * @returns the current mesh\r\n     */\r\n    public override normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate?: Nullable<(node: AbstractMesh) => boolean>): AbstractMesh {\r\n        return <AbstractMesh>super.normalizeToUnitCube(includeDescendants, ignoreRotation, predicate);\r\n    }\r\n\r\n    /** Gets a boolean indicating if this mesh has skinning data and an attached skeleton */\r\n    public get useBones(): boolean {\r\n        return <boolean>(\r\n            (this.skeleton &&\r\n                this.getScene().skeletonsEnabled &&\r\n                this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) &&\r\n                this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind))\r\n        );\r\n    }\r\n\r\n    /** @internal */\r\n    public _preActivate(): void {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _preActivateForIntermediateRendering(renderId: number): void {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        this._renderId = renderId;\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _postActivate(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /** @internal */\r\n    public _freeze() {\r\n        // Do nothing\r\n    }\r\n\r\n    /** @internal */\r\n    public _unFreeze() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Gets the current world matrix\r\n     * @returns a Matrix\r\n     */\r\n    public override getWorldMatrix(): Matrix {\r\n        if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {\r\n            return this._masterMesh.getWorldMatrix();\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    /** @internal */\r\n    public override _getWorldMatrixDeterminant(): number {\r\n        if (this._masterMesh) {\r\n            return this._masterMesh._getWorldMatrixDeterminant();\r\n        }\r\n\r\n        return super._getWorldMatrixDeterminant();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this mesh is an instance or a regular mesh\r\n     */\r\n    public get isAnInstance(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this mesh has instances\r\n     */\r\n    public get hasInstances(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this mesh has thin instances\r\n     */\r\n    public get hasThinInstances(): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ================================== Point of View Movement =================================\r\n\r\n    /**\r\n     * Perform relative position change from the point of view of behind the front of the mesh.\r\n     * This is performed taking into account the meshes current rotation, so you do not have to care.\r\n     * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.\r\n     * @param amountRight defines the distance on the right axis\r\n     * @param amountUp defines the distance on the up axis\r\n     * @param amountForward defines the distance on the forward axis\r\n     * @returns the current mesh\r\n     */\r\n    public movePOV(amountRight: number, amountUp: number, amountForward: number): AbstractMesh {\r\n        this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Calculate relative position change from the point of view of behind the front of the mesh.\r\n     * This is performed taking into account the meshes current rotation, so you do not have to care.\r\n     * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.\r\n     * @param amountRight defines the distance on the right axis\r\n     * @param amountUp defines the distance on the up axis\r\n     * @param amountForward defines the distance on the forward axis\r\n     * @returns the new displacement vector\r\n     */\r\n    public calcMovePOV(amountRight: number, amountUp: number, amountForward: number): Vector3 {\r\n        const rotMatrix = new Matrix();\r\n        const rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\r\n        rotQuaternion.toRotationMatrix(rotMatrix);\r\n\r\n        const translationDelta = Vector3.Zero();\r\n        const defForwardMult = this.definedFacingForward ? -1 : 1;\r\n        Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);\r\n        return translationDelta;\r\n    }\r\n    // ================================== Point of View Rotation =================================\r\n    /**\r\n     * Perform relative rotation change from the point of view of behind the front of the mesh.\r\n     * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.\r\n     * @param flipBack defines the flip\r\n     * @param twirlClockwise defines the twirl\r\n     * @param tiltRight defines the tilt\r\n     * @returns the current mesh\r\n     */\r\n    public rotatePOV(flipBack: number, twirlClockwise: number, tiltRight: number): AbstractMesh {\r\n        this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Calculate relative rotation change from the point of view of behind the front of the mesh.\r\n     * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.\r\n     * @param flipBack defines the flip\r\n     * @param twirlClockwise defines the twirl\r\n     * @param tiltRight defines the tilt\r\n     * @returns the new rotation vector\r\n     */\r\n    public calcRotatePOV(flipBack: number, twirlClockwise: number, tiltRight: number): Vector3 {\r\n        const defForwardMult = this.definedFacingForward ? 1 : -1;\r\n        return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param options defines a set of options for computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public abstract refreshBoundingInfo(options: IMeshDataOptions): AbstractMesh;\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeletonOrOptions defines whether to apply the skeleton before computing the bounding info or a set of options\r\n     * @param applyMorph defines whether to apply the morph target before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public abstract refreshBoundingInfo(applySkeletonOrOptions: boolean | IMeshDataOptions, applyMorph: boolean): AbstractMesh;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _refreshBoundingInfo(data: Nullable<FloatArray>, bias: Nullable<Vector2>): void {\r\n        if (data) {\r\n            const extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);\r\n            if (this._boundingInfo) {\r\n                this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n            } else {\r\n                this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n            }\r\n        }\r\n\r\n        if (this.subMeshes) {\r\n            for (let index = 0; index < this.subMeshes.length; index++) {\r\n                this.subMeshes[index].refreshBoundingInfo(data);\r\n            }\r\n        }\r\n\r\n        this._updateBoundingInfo();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _refreshBoundingInfoDirect(extend: { minimum: Vector3; maximum: Vector3 }): void {\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n        } else {\r\n            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n        }\r\n\r\n        if (this.subMeshes) {\r\n            for (let index = 0; index < this.subMeshes.length; index++) {\r\n                this.subMeshes[index].refreshBoundingInfo(null);\r\n            }\r\n        }\r\n\r\n        this._updateBoundingInfo();\r\n    }\r\n\r\n    // This function is only here so we can apply the nativeOverride decorator.\r\n    @nativeOverride.filter(\r\n        (...[data, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData]: Parameters<typeof AbstractMesh._ApplySkeleton>) =>\r\n            !Array.isArray(data) &&\r\n            !Array.isArray(matricesIndicesData) &&\r\n            !Array.isArray(matricesWeightsData) &&\r\n            !Array.isArray(matricesIndicesExtraData) &&\r\n            !Array.isArray(matricesWeightsExtraData)\r\n    )\r\n    private static _ApplySkeleton(\r\n        data: FloatArray,\r\n        kind: string,\r\n        skeletonMatrices: Float32Array,\r\n        matricesIndicesData: FloatArray,\r\n        matricesWeightsData: FloatArray,\r\n        matricesIndicesExtraData: Nullable<FloatArray>,\r\n        matricesWeightsExtraData: Nullable<FloatArray>\r\n    ): void {\r\n        ApplySkeleton(data, kind, skeletonMatrices, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getData(options: IMeshDataOptions, data: Nullable<FloatArray>, kind: string = VertexBuffer.PositionKind): Nullable<FloatArray> {\r\n        const cache = options.cache;\r\n\r\n        const getVertexData = (kind: string): Nullable<FloatArray> => {\r\n            if (cache) {\r\n                const vertexData = (cache._vertexData ||= {});\r\n                if (!vertexData[kind]) {\r\n                    this.copyVerticesData(kind, vertexData);\r\n                }\r\n                return vertexData[kind];\r\n            }\r\n\r\n            return this.getVerticesData(kind);\r\n        };\r\n\r\n        data ||= getVertexData(kind);\r\n        if (!data) {\r\n            return null;\r\n        }\r\n\r\n        if (cache) {\r\n            if (cache._outputData) {\r\n                cache._outputData.set(data);\r\n            } else {\r\n                cache._outputData = new Float32Array(data);\r\n            }\r\n\r\n            data = cache._outputData;\r\n        } else if ((options.applyMorph && this.morphTargetManager) || (options.applySkeleton && this.skeleton)) {\r\n            data = data.slice();\r\n        }\r\n\r\n        if (options.applyMorph && this.morphTargetManager) {\r\n            ApplyMorph(data, kind, this.morphTargetManager);\r\n        }\r\n\r\n        if (options.applySkeleton && this.skeleton) {\r\n            const matricesIndicesData = getVertexData(VertexBuffer.MatricesIndicesKind);\r\n            const matricesWeightsData = getVertexData(VertexBuffer.MatricesWeightsKind);\r\n            if (matricesWeightsData && matricesIndicesData) {\r\n                const needExtras = this.numBoneInfluencers > 4;\r\n                const matricesIndicesExtraData = needExtras ? getVertexData(VertexBuffer.MatricesIndicesExtraKind) : null;\r\n                const matricesWeightsExtraData = needExtras ? getVertexData(VertexBuffer.MatricesWeightsExtraKind) : null;\r\n                const skeletonMatrices = this.skeleton.getTransformMatrices(this);\r\n                AbstractMesh._ApplySkeleton(data, kind, skeletonMatrices, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData);\r\n            }\r\n        }\r\n\r\n        if (options.updatePositionsArray !== false && kind === VertexBuffer.PositionKind) {\r\n            const positions = this._internalAbstractMeshDataInfo._positions || [];\r\n            const previousLength = positions.length;\r\n            positions.length = data.length / 3;\r\n            if (previousLength < positions.length) {\r\n                for (let positionIndex = previousLength; positionIndex < positions.length; positionIndex++) {\r\n                    positions[positionIndex] = new Vector3();\r\n                }\r\n            }\r\n\r\n            for (let positionIndex = 0, dataIndex = 0; positionIndex < positions.length; positionIndex++, dataIndex += 3) {\r\n                positions[positionIndex].copyFromFloats(data[dataIndex], data[dataIndex + 1], data[dataIndex + 2]);\r\n            }\r\n\r\n            this._internalAbstractMeshDataInfo._positions = positions;\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Get the normals vertex data and optionally apply skeleton and morphing.\r\n     * @param applySkeleton defines whether to apply the skeleton\r\n     * @param applyMorph  defines whether to apply the morph target\r\n     * @returns the normals data\r\n     */\r\n    public getNormalsData(applySkeleton = false, applyMorph = false): Nullable<FloatArray> {\r\n        return this._getData({ applySkeleton, applyMorph, updatePositionsArray: false }, null, VertexBuffer.NormalKind);\r\n    }\r\n\r\n    /**\r\n     * Get the position vertex data and optionally apply skeleton and morphing.\r\n     * @param applySkeleton defines whether to apply the skeleton\r\n     * @param applyMorph  defines whether to apply the morph target\r\n     * @param data defines the position data to apply the skeleton and morph to\r\n     * @returns the position data\r\n     */\r\n    public getPositionData(applySkeleton: boolean = false, applyMorph: boolean = false, data: Nullable<FloatArray> = null): Nullable<FloatArray> {\r\n        return this._getData({ applySkeleton, applyMorph, updatePositionsArray: false }, data, VertexBuffer.PositionKind);\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateBoundingInfo(): AbstractMesh {\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.update(this.worldMatrixFromCache);\r\n        } else {\r\n            this._boundingInfo = new BoundingInfo(Vector3.Zero(), Vector3.Zero(), this.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateSubMeshesBoundingInfo(matrix: DeepImmutable<Matrix>): AbstractMesh {\r\n        if (!this.subMeshes) {\r\n            return this;\r\n        }\r\n        const count = this.subMeshes.length;\r\n        for (let subIndex = 0; subIndex < count; subIndex++) {\r\n            const subMesh = this.subMeshes[subIndex];\r\n            if (count > 1 || !subMesh.IsGlobal) {\r\n                subMesh.updateBoundingInfo(matrix);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    protected override _afterComputeWorldMatrix(): void {\r\n        if (this.doNotSyncBoundingInfo) {\r\n            return;\r\n        }\r\n        // Bounding info\r\n        this._boundingInfoIsDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\r\n     * A mesh is in the frustum if its bounding box intersects the frustum\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @returns true if the mesh is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        return this.getBoundingInfo().isInFrustum(frustumPlanes, this.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.\r\n     * A mesh is completely in the frustum if its bounding box it completely inside the frustum.\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @returns true if the mesh is completely in the frustum planes\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Plane[]): boolean {\r\n        return this.getBoundingInfo().isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * True if the mesh intersects another mesh or a SolidParticle object\r\n     * @param mesh defines a target mesh or SolidParticle to test\r\n     * @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)\r\n     * @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsMesh(mesh: AbstractMesh | SolidParticle, precise: boolean = false, includeDescendants?: boolean): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n        const otherBoundingInfo = mesh.getBoundingInfo();\r\n\r\n        if (boundingInfo.intersects(otherBoundingInfo, precise)) {\r\n            return true;\r\n        }\r\n\r\n        if (includeDescendants) {\r\n            for (const child of this.getChildMeshes()) {\r\n                if (child.intersectsMesh(mesh, precise, true)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the passed point (Vector3) is inside the mesh bounding box\r\n     * @param point defines the point to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsPoint(point: Vector3): boolean {\r\n        return this.getBoundingInfo().intersectsPoint(point);\r\n    }\r\n\r\n    // Collisions\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this mesh can be used in the collision engine\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;\r\n    }\r\n\r\n    public set checkCollisions(collisionEnabled: boolean) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = collisionEnabled;\r\n    }\r\n\r\n    /**\r\n     * Gets Collider object used to compute collisions (not physics)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\r\n     */\r\n    public get collider(): Nullable<Collider> {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collider;\r\n    }\r\n\r\n    /**\r\n     * Move the mesh using collision engine\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\r\n     * @param displacement defines the requested displacement vector\r\n     * @param slideOnCollide If true, the mesh will slide along a collider's surface.  If false, it will stop moving at the first collision. (true by default)\r\n     * @returns the current mesh\r\n     */\r\n    public moveWithCollisions(displacement: Vector3, slideOnCollide: boolean = true): AbstractMesh {\r\n        const globalPosition = this.getAbsolutePosition();\r\n\r\n        globalPosition.addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n\r\n        if (!this._internalAbstractMeshDataInfo._meshCollisionData._collider) {\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid;\r\n\r\n        coordinator.getNewPosition(\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,\r\n            displacement,\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._collider,\r\n            this.collisionRetryCount,\r\n            this,\r\n            this._onCollisionPositionChange,\r\n            this.uniqueId,\r\n            slideOnCollide\r\n        );\r\n        return this;\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        newPosition.subtractToRef(\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions\r\n        );\r\n\r\n        if (this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > AbstractEngine.CollisionsEpsilon) {\r\n            this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);\r\n        }\r\n\r\n        if (collidedMesh) {\r\n            this.onCollideObservable.notifyObservers(collidedMesh);\r\n        }\r\n\r\n        this.onCollisionPositionChangeObservable.notifyObservers(this.position);\r\n    };\r\n\r\n    // Collisions\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideForSubMesh(subMesh: SubMesh, transformMatrix: Matrix, collider: Collider): AbstractMesh {\r\n        this._generatePointsArray();\r\n\r\n        if (!this._positions) {\r\n            return this;\r\n        }\r\n\r\n        // Transformation\r\n        if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix!.equals(transformMatrix)) {\r\n            subMesh._lastColliderTransformMatrix = transformMatrix.clone();\r\n            subMesh._lastColliderWorldVertices = [];\r\n            subMesh._trianglePlanes = [];\r\n            const start = subMesh.verticesStart;\r\n            const end = subMesh.verticesStart + subMesh.verticesCount;\r\n            for (let i = start; i < end; i++) {\r\n                subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));\r\n            }\r\n        }\r\n\r\n        // Collide\r\n        collider._collide(\r\n            subMesh._trianglePlanes,\r\n            subMesh._lastColliderWorldVertices,\r\n            <IndicesArray>this.getIndices(),\r\n            subMesh.indexStart,\r\n            subMesh.indexStart + subMesh.indexCount,\r\n            subMesh.verticesStart,\r\n            !!subMesh.getMaterial(),\r\n            this,\r\n            this._shouldConvertRHS(),\r\n            subMesh.getMaterial()?.fillMode === Constants.MATERIAL_TriangleStripDrawMode\r\n        );\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _processCollisionsForSubMeshes(collider: Collider, transformMatrix: Matrix): AbstractMesh {\r\n        const subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);\r\n        const len = subMeshes.length;\r\n\r\n        for (let index = 0; index < len; index++) {\r\n            const subMesh = subMeshes.data[index];\r\n\r\n            // Bounding test\r\n            if (len > 1 && !subMesh._checkCollision(collider)) {\r\n                continue;\r\n            }\r\n\r\n            this._collideForSubMesh(subMesh, transformMatrix, collider);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldConvertRHS() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): AbstractMesh {\r\n        // Bounding box test\r\n        if (!this.getBoundingInfo()._checkCollision(collider)) {\r\n            return this;\r\n        }\r\n\r\n        // Transformation matrix\r\n        const collisionsScalingMatrix = TmpVectors.Matrix[0];\r\n        const collisionsTransformMatrix = TmpVectors.Matrix[1];\r\n        Matrix.ScalingToRef(1.0 / collider._radius.x, 1.0 / collider._radius.y, 1.0 / collider._radius.z, collisionsScalingMatrix);\r\n        this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);\r\n        this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);\r\n        return this;\r\n    }\r\n\r\n    // Picking\r\n    /** @internal */\r\n    public _generatePointsArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the passed Ray intersects with the mesh. A mesh triangle can be picked both from its front and back sides,\r\n     * irrespective of orientation.\r\n     * @param ray defines the ray to use. It should be in the mesh's LOCAL coordinate space.\r\n     * @param fastCheck defines if fast mode (but less precise) must be used (false by default)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n     * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns the picking info\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     */\r\n    public intersects(\r\n        ray: Ray,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate,\r\n        onlyBoundingInfo = false,\r\n        worldToUse?: Matrix,\r\n        skipBoundingInfo = false\r\n    ): PickingInfo {\r\n        const pickingInfo = new PickingInfo();\r\n        const className = this.getClassName();\r\n        const intersectionThreshold = className === \"InstancedLinesMesh\" || className === \"LinesMesh\" || className === \"GreasedLineMesh\" ? (this as any).intersectionThreshold : 0;\r\n        const boundingInfo = this.getBoundingInfo();\r\n        if (!this.subMeshes) {\r\n            return pickingInfo;\r\n        }\r\n        if (\r\n            !skipBoundingInfo &&\r\n            (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))\r\n        ) {\r\n            return pickingInfo;\r\n        }\r\n\r\n        if (onlyBoundingInfo) {\r\n            pickingInfo.hit = skipBoundingInfo ? false : true;\r\n            pickingInfo.pickedMesh = skipBoundingInfo ? null : this;\r\n            pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\r\n            pickingInfo.subMeshId = 0;\r\n            return pickingInfo;\r\n        }\r\n\r\n        if (!this._generatePointsArray()) {\r\n            return pickingInfo;\r\n        }\r\n\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        const subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);\r\n        const len: number = subMeshes.length;\r\n\r\n        // Check if all submeshes are using a material that don't allow picking (point/lines rendering)\r\n        // if no submesh can be picked that way, then fallback to BBox picking\r\n        let anySubmeshSupportIntersect = false;\r\n        for (let index = 0; index < len; index++) {\r\n            const subMesh = subMeshes.data[index];\r\n            const material = subMesh.getMaterial();\r\n            if (!material) {\r\n                continue;\r\n            }\r\n            if (\r\n                material.fillMode == Constants.MATERIAL_TriangleStripDrawMode ||\r\n                material.fillMode == Constants.MATERIAL_TriangleFillMode ||\r\n                material.fillMode == Constants.MATERIAL_WireFrameFillMode ||\r\n                material.fillMode == Constants.MATERIAL_PointFillMode ||\r\n                material.fillMode == Constants.MATERIAL_LineListDrawMode\r\n            ) {\r\n                anySubmeshSupportIntersect = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // no sub mesh support intersection, fallback to BBox that has already be done\r\n        if (!anySubmeshSupportIntersect) {\r\n            pickingInfo.hit = true;\r\n            pickingInfo.pickedMesh = this;\r\n            pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\r\n            pickingInfo.subMeshId = -1;\r\n            return pickingInfo;\r\n        }\r\n\r\n        // at least 1 submesh supports intersection, keep going\r\n        for (let index = 0; index < len; index++) {\r\n            const subMesh = subMeshes.data[index];\r\n\r\n            // Bounding test\r\n            if (len > 1 && !skipBoundingInfo && !subMesh.canIntersects(ray)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = subMesh.intersects(ray, <Vector3[]>this._positions, <IndicesArray>this.getIndices(), fastCheck, trianglePredicate);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.subMeshId = subMesh._id;\r\n                    intersectInfo._internalSubMeshId = index;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (intersectInfo) {\r\n            // Get picked point\r\n            const world = worldToUse ?? this.getWorldMatrix();\r\n            const worldOrigin = TmpVectors.Vector3[0];\r\n            const direction = TmpVectors.Vector3[1];\r\n            Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);\r\n            ray.direction.scaleToRef(intersectInfo.distance, direction);\r\n            const worldDirection = Vector3.TransformNormal(direction, world);\r\n            const pickedPoint = worldDirection.addInPlace(worldOrigin);\r\n\r\n            // Return result\r\n            pickingInfo.hit = true;\r\n            pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);\r\n            pickingInfo.pickedPoint = pickedPoint;\r\n            pickingInfo.pickedMesh = this;\r\n            pickingInfo.bu = intersectInfo.bu || 0;\r\n            pickingInfo.bv = intersectInfo.bv || 0;\r\n            pickingInfo.subMeshFaceId = intersectInfo.faceId;\r\n            pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo._internalSubMeshId].indexStart / (this.getClassName().indexOf(\"LinesMesh\") !== -1 ? 2 : 3);\r\n            pickingInfo.subMeshId = intersectInfo.subMeshId;\r\n            return pickingInfo;\r\n        }\r\n\r\n        return pickingInfo;\r\n    }\r\n\r\n    /**\r\n     * Clones the current mesh\r\n     * @param name defines the mesh name\r\n     * @param newParent defines the new mesh parent\r\n     * @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)\r\n     * @returns the new mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public override clone(name: string, newParent: Nullable<Node>, doNotCloneChildren?: boolean): Nullable<AbstractMesh> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes all the submeshes of the current mesh\r\n     * @param immediate should dispose the effects immediately or not\r\n     * @returns the current mesh\r\n     */\r\n    public releaseSubMeshes(immediate = false): AbstractMesh {\r\n        if (this.subMeshes) {\r\n            while (this.subMeshes.length) {\r\n                this.subMeshes[0].dispose(immediate);\r\n            }\r\n        } else {\r\n            this.subMeshes = [] as SubMesh[];\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this abstract mesh.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        let index: number;\r\n\r\n        const scene = this.getScene();\r\n\r\n        // mesh map release.\r\n        if (this._scene.useMaterialMeshMap) {\r\n            // remove from material mesh map id needed\r\n            if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {\r\n                this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = undefined;\r\n            }\r\n        }\r\n\r\n        // Smart Array Retainers.\r\n        scene.freeActiveMeshes();\r\n        scene.freeRenderingGroups();\r\n        if (scene.renderingManager.maintainStateBetweenFrames) {\r\n            scene.renderingManager.restoreDispachedFlags();\r\n        }\r\n\r\n        // Action manager\r\n        if (this.actionManager !== undefined && this.actionManager !== null) {\r\n            // If we are the only mesh using the action manager, dispose of the action manager too unless it has opted out from that behavior\r\n            if (this.actionManager.disposeWhenUnowned && !this._scene.meshes.some((m) => m !== this && m.actionManager === this.actionManager)) {\r\n                this.actionManager.dispose();\r\n            }\r\n            this.actionManager = null;\r\n        }\r\n\r\n        // Skeleton\r\n        this._internalAbstractMeshDataInfo._skeleton = null;\r\n\r\n        if (this._transformMatrixTexture) {\r\n            this._transformMatrixTexture.dispose();\r\n            this._transformMatrixTexture = null;\r\n        }\r\n\r\n        // Intersections in progress\r\n        for (index = 0; index < this._intersectionsInProgress.length; index++) {\r\n            const other = this._intersectionsInProgress[index];\r\n\r\n            const pos = other._intersectionsInProgress.indexOf(this);\r\n            other._intersectionsInProgress.splice(pos, 1);\r\n        }\r\n\r\n        this._intersectionsInProgress.length = 0;\r\n\r\n        // Lights\r\n        const lights = scene.lights;\r\n\r\n        for (const light of lights) {\r\n            let meshIndex = light.includedOnlyMeshes.indexOf(this);\r\n\r\n            if (meshIndex !== -1) {\r\n                light.includedOnlyMeshes.splice(meshIndex, 1);\r\n            }\r\n\r\n            meshIndex = light.excludedMeshes.indexOf(this);\r\n\r\n            if (meshIndex !== -1) {\r\n                light.excludedMeshes.splice(meshIndex, 1);\r\n            }\r\n\r\n            // Shadow generators\r\n            const generators = light.getShadowGenerators();\r\n            if (generators) {\r\n                const iterator = generators.values();\r\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                    const generator = key.value;\r\n                    const shadowMap = generator.getShadowMap();\r\n\r\n                    if (shadowMap && shadowMap.renderList) {\r\n                        meshIndex = shadowMap.renderList.indexOf(this);\r\n\r\n                        if (meshIndex !== -1) {\r\n                            shadowMap.renderList.splice(meshIndex, 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // SubMeshes\r\n        if (this.getClassName() !== \"InstancedMesh\" || this.getClassName() !== \"InstancedLinesMesh\") {\r\n            this.releaseSubMeshes(true);\r\n        }\r\n\r\n        // Query\r\n        const engine = scene.getEngine();\r\n        if (this._occlusionQuery !== null) {\r\n            this.isOcclusionQueryInProgress = false;\r\n            engine.deleteQuery(this._occlusionQuery);\r\n            this._occlusionQuery = null;\r\n        }\r\n\r\n        // Engine\r\n        engine.wipeCaches();\r\n\r\n        // Remove from scene\r\n        scene.removeMesh(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.meshes.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.meshes.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (disposeMaterialAndTextures) {\r\n            if (this.material) {\r\n                if (this.material.getClassName() === \"MultiMaterial\") {\r\n                    this.material.dispose(false, true, true);\r\n                } else {\r\n                    this.material.dispose(false, true);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!doNotRecurse) {\r\n            // Particles\r\n            for (index = 0; index < scene.particleSystems.length; index++) {\r\n                if (scene.particleSystems[index].emitter === this) {\r\n                    scene.particleSystems[index].dispose();\r\n                    index--;\r\n                }\r\n            }\r\n        }\r\n\r\n        // facet data\r\n        if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {\r\n            this.disableFacetData();\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        this.onAfterWorldMatrixUpdateObservable.clear();\r\n        this.onCollideObservable.clear();\r\n        this.onCollisionPositionChangeObservable.clear();\r\n        this.onRebuildObservable.clear();\r\n\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    // Facet data\r\n    /** @internal */\r\n    private _initFacetData(): AbstractMesh {\r\n        const data = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!data.facetNormals) {\r\n            data.facetNormals = [] as Vector3[];\r\n        }\r\n        if (!data.facetPositions) {\r\n            data.facetPositions = [] as Vector3[];\r\n        }\r\n        if (!data.facetPartitioning) {\r\n            data.facetPartitioning = new Array<number[]>();\r\n        }\r\n        data.facetNb = ((<IndicesArray>this.getIndices()).length / 3) | 0;\r\n        data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10; // default nb of partitioning subdivisions = 10\r\n        data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01; // default ratio 1.01 = the partitioning is 1% bigger than the bounding box\r\n        for (let f = 0; f < data.facetNb; f++) {\r\n            data.facetNormals[f] = Vector3.Zero();\r\n            data.facetPositions[f] = Vector3.Zero();\r\n        }\r\n        data.facetDataEnabled = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.\r\n     * This method can be called within the render loop.\r\n     * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public updateFacetData(): AbstractMesh {\r\n        const data = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!data.facetDataEnabled) {\r\n            this._initFacetData();\r\n        }\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n        const indices = this.getIndices();\r\n        const normals = this.getVerticesData(VertexBuffer.NormalKind);\r\n        const bInfo = this.getBoundingInfo();\r\n\r\n        if (data.facetDepthSort && !data.facetDepthSortEnabled) {\r\n            // init arrays, matrix and sort function on first call\r\n            data.facetDepthSortEnabled = true;\r\n            if (indices instanceof Uint16Array) {\r\n                data.depthSortedIndices = new Uint16Array(indices);\r\n            } else if (indices instanceof Uint32Array) {\r\n                data.depthSortedIndices = new Uint32Array(indices);\r\n            } else {\r\n                let needs32bits = false;\r\n                for (let i = 0; i < indices!.length; i++) {\r\n                    if (indices![i] > 65535) {\r\n                        needs32bits = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (needs32bits) {\r\n                    data.depthSortedIndices = new Uint32Array(indices!);\r\n                } else {\r\n                    data.depthSortedIndices = new Uint16Array(indices!);\r\n                }\r\n            }\r\n            data.facetDepthSortFunction = function (f1, f2) {\r\n                return f2.sqDistance - f1.sqDistance;\r\n            };\r\n            if (!data.facetDepthSortFrom) {\r\n                const camera = this.getScene().activeCamera;\r\n                data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();\r\n            }\r\n            data.depthSortedFacets = [];\r\n            for (let f = 0; f < data.facetNb; f++) {\r\n                const depthSortedFacet = { ind: f * 3, sqDistance: 0.0 };\r\n                data.depthSortedFacets.push(depthSortedFacet);\r\n            }\r\n            data.invertedMatrix = Matrix.Identity();\r\n            data.facetDepthSortOrigin = Vector3.Zero();\r\n        }\r\n\r\n        data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;\r\n        data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;\r\n        data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;\r\n        let bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;\r\n        bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;\r\n        data.subDiv.max = data.partitioningSubdivisions;\r\n        data.subDiv.X = Math.floor((data.subDiv.max * data.bbSize.x) / bbSizeMax); // adjust the number of subdivisions per axis\r\n        data.subDiv.Y = Math.floor((data.subDiv.max * data.bbSize.y) / bbSizeMax); // according to each bbox size per axis\r\n        data.subDiv.Z = Math.floor((data.subDiv.max * data.bbSize.z) / bbSizeMax);\r\n        data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X; // at least one subdivision\r\n        data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;\r\n        data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z;\r\n        // set the parameters for ComputeNormals()\r\n        data.facetParameters.facetNormals = this.getFacetLocalNormals();\r\n        data.facetParameters.facetPositions = this.getFacetLocalPositions();\r\n        data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();\r\n        data.facetParameters.bInfo = bInfo;\r\n        data.facetParameters.bbSize = data.bbSize;\r\n        data.facetParameters.subDiv = data.subDiv;\r\n        data.facetParameters.ratio = this.partitioningBBoxRatio;\r\n        data.facetParameters.depthSort = data.facetDepthSort;\r\n        if (data.facetDepthSort && data.facetDepthSortEnabled) {\r\n            this.computeWorldMatrix(true);\r\n            this._worldMatrix.invertToRef(data.invertedMatrix);\r\n            Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);\r\n            data.facetParameters.distanceTo = data.facetDepthSortOrigin;\r\n        }\r\n        data.facetParameters.depthSortedFacets = data.depthSortedFacets;\r\n        if (normals) {\r\n            VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);\r\n        }\r\n\r\n        if (data.facetDepthSort && data.facetDepthSortEnabled) {\r\n            data.depthSortedFacets.sort(data.facetDepthSortFunction);\r\n            const l = (data.depthSortedIndices.length / 3) | 0;\r\n            for (let f = 0; f < l; f++) {\r\n                const sind = data.depthSortedFacets[f].ind;\r\n                data.depthSortedIndices[f * 3] = indices![sind];\r\n                data.depthSortedIndices[f * 3 + 1] = indices![sind + 1];\r\n                data.depthSortedIndices[f * 3 + 2] = indices![sind + 2];\r\n            }\r\n            this.updateIndices(data.depthSortedIndices, undefined, true);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the facetLocalNormals array.\r\n     * The normals are expressed in the mesh local spac\r\n     * @returns an array of Vector3\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetLocalNormals(): Vector3[] {\r\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!facetData.facetNormals) {\r\n            this.updateFacetData();\r\n        }\r\n        return facetData.facetNormals;\r\n    }\r\n\r\n    /**\r\n     * Returns the facetLocalPositions array.\r\n     * The facet positions are expressed in the mesh local space\r\n     * @returns an array of Vector3\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetLocalPositions(): Vector3[] {\r\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!facetData.facetPositions) {\r\n            this.updateFacetData();\r\n        }\r\n        return facetData.facetPositions;\r\n    }\r\n\r\n    /**\r\n     * Returns the facetLocalPartitioning array\r\n     * @returns an array of array of numbers\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetLocalPartitioning(): number[][] {\r\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\r\n\r\n        if (!facetData.facetPartitioning) {\r\n            this.updateFacetData();\r\n        }\r\n        return facetData.facetPartitioning;\r\n    }\r\n\r\n    /**\r\n     * Returns the i-th facet position in the world system.\r\n     * This method allocates a new Vector3 per call\r\n     * @param i defines the facet index\r\n     * @returns a new Vector3\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetPosition(i: number): Vector3 {\r\n        const pos = Vector3.Zero();\r\n        this.getFacetPositionToRef(i, pos);\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Sets the reference Vector3 with the i-th facet position in the world system\r\n     * @param i defines the facet index\r\n     * @param ref defines the target vector\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetPositionToRef(i: number, ref: Vector3): AbstractMesh {\r\n        const localPos = this.getFacetLocalPositions()[i];\r\n        const world = this.getWorldMatrix();\r\n        Vector3.TransformCoordinatesToRef(localPos, world, ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the i-th facet normal in the world system.\r\n     * This method allocates a new Vector3 per call\r\n     * @param i defines the facet index\r\n     * @returns a new Vector3\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetNormal(i: number): Vector3 {\r\n        const norm = Vector3.Zero();\r\n        this.getFacetNormalToRef(i, norm);\r\n        return norm;\r\n    }\r\n\r\n    /**\r\n     * Sets the reference Vector3 with the i-th facet normal in the world system\r\n     * @param i defines the facet index\r\n     * @param ref defines the target vector\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetNormalToRef(i: number, ref: Vector3) {\r\n        const localNorm = this.getFacetLocalNormals()[i];\r\n        Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)\r\n     * @param x defines x coordinate\r\n     * @param y defines y coordinate\r\n     * @param z defines z coordinate\r\n     * @returns the array of facet indexes\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetsAtLocalCoordinates(x: number, y: number, z: number): Nullable<number[]> {\r\n        const bInfo = this.getBoundingInfo();\r\n        const data = this._internalAbstractMeshDataInfo._facetData;\r\n\r\n        const ox = Math.floor(((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio) / data.bbSize.x);\r\n        const oy = Math.floor(((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio) / data.bbSize.y);\r\n        const oz = Math.floor(((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio) / data.bbSize.z);\r\n        if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {\r\n            return null;\r\n        }\r\n        return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];\r\n    }\r\n\r\n    /**\r\n     * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found\r\n     * @param x defines x coordinate\r\n     * @param y defines y coordinate\r\n     * @param z defines z coordinate\r\n     * @param projected sets as the (x,y,z) world projection on the facet\r\n     * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\r\n     * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\r\n     * @returns the face index if found (or null instead)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getClosestFacetAtCoordinates(x: number, y: number, z: number, projected?: Vector3, checkFace: boolean = false, facing: boolean = true): Nullable<number> {\r\n        const world = this.getWorldMatrix();\r\n        const invMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(invMat);\r\n        const invVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect); // transform (x,y,z) to coordinates in the mesh local space\r\n        const closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);\r\n        if (projected) {\r\n            // transform the local computed projected vector to world coordinates\r\n            Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);\r\n        }\r\n        return closest;\r\n    }\r\n\r\n    /**\r\n     * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found\r\n     * @param x defines x coordinate\r\n     * @param y defines y coordinate\r\n     * @param z defines z coordinate\r\n     * @param projected sets as the (x,y,z) local projection on the facet\r\n     * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\r\n     * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\r\n     * @returns the face index if found (or null instead)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getClosestFacetAtLocalCoordinates(x: number, y: number, z: number, projected?: Vector3, checkFace: boolean = false, facing: boolean = true): Nullable<number> {\r\n        let closest = null;\r\n        let tmpx = 0.0;\r\n        let tmpy = 0.0;\r\n        let tmpz = 0.0;\r\n        let d = 0.0; // tmp dot facet normal * facet position\r\n        let t0 = 0.0;\r\n        let projx = 0.0;\r\n        let projy = 0.0;\r\n        let projz = 0.0;\r\n        // Get all the facets in the same partitioning block than (x, y, z)\r\n        const facetPositions = this.getFacetLocalPositions();\r\n        const facetNormals = this.getFacetLocalNormals();\r\n        const facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);\r\n        if (!facetsInBlock) {\r\n            return null;\r\n        }\r\n        // Get the closest facet to (x, y, z)\r\n        let shortest = Number.MAX_VALUE; // init distance vars\r\n        let tmpDistance = shortest;\r\n        let fib; // current facet in the block\r\n        let norm; // current facet normal\r\n        let p0; // current facet barycenter position\r\n        // loop on all the facets in the current partitioning block\r\n        for (let idx = 0; idx < facetsInBlock.length; idx++) {\r\n            fib = facetsInBlock[idx];\r\n            norm = facetNormals[fib];\r\n            p0 = facetPositions[fib];\r\n\r\n            d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;\r\n            if (!checkFace || (checkFace && facing && d >= 0.0) || (checkFace && !facing && d <= 0.0)) {\r\n                // compute (x,y,z) projection on the facet = (projx, projy, projz)\r\n                d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;\r\n                t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);\r\n                projx = x + norm.x * t0;\r\n                projy = y + norm.y * t0;\r\n                projz = z + norm.z * t0;\r\n\r\n                tmpx = projx - x;\r\n                tmpy = projy - y;\r\n                tmpz = projz - z;\r\n                tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz; // compute length between (x, y, z) and its projection on the facet\r\n                if (tmpDistance < shortest) {\r\n                    // just keep the closest facet to (x, y, z)\r\n                    shortest = tmpDistance;\r\n                    closest = fib;\r\n                    if (projected) {\r\n                        projected.x = projx;\r\n                        projected.y = projy;\r\n                        projected.z = projz;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return closest;\r\n    }\r\n\r\n    /**\r\n     * Returns the object \"parameter\" set with all the expected parameters for facetData computation by ComputeNormals()\r\n     * @returns the parameters\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetDataParameters(): any {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetParameters;\r\n    }\r\n\r\n    /**\r\n     * Disables the feature FacetData and frees the related memory\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public disableFacetData(): AbstractMesh {\r\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\r\n        if (facetData.facetDataEnabled) {\r\n            facetData.facetDataEnabled = false;\r\n            facetData.facetPositions = [] as Vector3[];\r\n            facetData.facetNormals = [] as Vector3[];\r\n            facetData.facetPartitioning = new Array<number[]>();\r\n            facetData.facetParameters = {};\r\n            facetData.depthSortedIndices = new Uint32Array(0);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the AbstractMesh indices array\r\n     * @param indices defines the data source\r\n     * @param offset defines the offset in the index buffer where to store the new data (can be null)\r\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n     * @returns the current mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly = false): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates new normals data for the mesh\r\n     * @param updatable defines if the normal vertex buffer must be flagged as updatable\r\n     * @returns the current mesh\r\n     */\r\n    public createNormals(updatable: boolean): AbstractMesh {\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n        const indices = this.getIndices();\r\n        let normals: FloatArray;\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            normals = <FloatArray>this.getVerticesData(VertexBuffer.NormalKind);\r\n        } else {\r\n            normals = [];\r\n        }\r\n\r\n        VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });\r\n        this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Optimize the indices order so that we keep the faces with similar indices together\r\n     * @returns the current mesh\r\n     */\r\n    public async optimizeIndicesAsync(): Promise<AbstractMesh> {\r\n        const indices = this.getIndices();\r\n\r\n        if (!indices) {\r\n            return this;\r\n        }\r\n\r\n        const { OptimizeIndices } = await import(\"./mesh.vertexData.functions\");\r\n\r\n        OptimizeIndices(indices);\r\n\r\n        this.setIndices(indices, this.getTotalVertices());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Align the mesh with a normal\r\n     * @param normal defines the normal to use\r\n     * @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)\r\n     * @returns the current mesh\r\n     */\r\n    public alignWithNormal(normal: Vector3, upDirection?: Vector3): AbstractMesh {\r\n        if (!upDirection) {\r\n            upDirection = Axis.Y;\r\n        }\r\n\r\n        const axisX = TmpVectors.Vector3[0];\r\n        const axisZ = TmpVectors.Vector3[1];\r\n        Vector3.CrossToRef(upDirection, normal, axisZ);\r\n        Vector3.CrossToRef(normal, axisZ, axisX);\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);\r\n        } else {\r\n            Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkOcclusionQuery(): boolean {\r\n        // Will be replaced by correct code if Occlusion queries are referenced\r\n        return false;\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Disables the mesh edge rendering mode\r\n     * @returns the currentAbstractMesh\r\n     */\r\n    disableEdgesRendering(): AbstractMesh {\r\n        throw _WarnImport(\"EdgesRenderer\");\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Enables the edge rendering mode on the mesh.\r\n     * This mode makes the mesh edges visible\r\n     * @param epsilon defines the maximal distance between two angles to detect a face\r\n     * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces\r\n     * @param options options to the edge renderer\r\n     * @returns the currentAbstractMesh\r\n     * @see https://www.babylonjs-playground.com/#19O9TU#0\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    enableEdgesRendering(epsilon?: number, checkVerticesInsteadOfIndices?: boolean, options?: IEdgesRendererOptions): AbstractMesh {\r\n        throw _WarnImport(\"EdgesRenderer\");\r\n    }\r\n\r\n    /**\r\n     * This function returns all of the particle systems in the scene that use the mesh as an emitter.\r\n     * @returns an array of particle systems in the scene that use the mesh as an emitter\r\n     */\r\n    public getConnectedParticleSystems(): IParticleSystem[] {\r\n        return this._scene.particleSystems.filter((particleSystem) => particleSystem.emitter === this);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.AbstractMesh\", AbstractMesh);\r\n", "import { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { AbstractEngine } from \"../abstractEngine\";\r\n\r\n/** @internal */\r\nexport type OcclusionQuery = WebGLQuery | number;\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _OcclusionDataStorage {\r\n    /** @internal */\r\n    public occlusionInternalRetryCounter = 0;\r\n\r\n    /** @internal */\r\n    public isOcclusionQueryInProgress = false;\r\n\r\n    /** @internal */\r\n    public isOccluded = false;\r\n\r\n    /** @internal */\r\n    public occlusionRetryCount = -1;\r\n\r\n    /** @internal */\r\n    public occlusionType = AbstractMesh.OCCLUSION_TYPE_NONE;\r\n\r\n    /** @internal */\r\n    public occlusionQueryAlgorithmType = AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE;\r\n\r\n    /** @internal */\r\n    public forceRenderingWhenOccluded = false;\r\n}\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Create a new webGL query (you must be sure that queries are supported by checking getCaps() function)\r\n         * @returns the new query\r\n         */\r\n        createQuery(): Nullable<OcclusionQuery>;\r\n        /**\r\n         * Delete and release a webGL query\r\n         * @param query defines the query to delete\r\n         * @returns the current engine\r\n         */\r\n        deleteQuery(query: OcclusionQuery): AbstractEngine /**\r\n         * Check if a given query has resolved and got its value\r\n         * @param query defines the query to check\r\n         * @returns true if the query got its value\r\n         */;\r\n        isQueryResultAvailable(query: OcclusionQuery): boolean;\r\n        /**\r\n         * Gets the value of a given query\r\n         * @param query defines the query to check\r\n         * @returns the value of the query\r\n         */\r\n        getQueryResult(query: OcclusionQuery): number;\r\n        /**\r\n         * Initiates an occlusion query\r\n         * @param algorithmType defines the algorithm to use\r\n         * @param query defines the query to use\r\n         * @returns the current engine\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         */\r\n        beginOcclusionQuery(algorithmType: number, query: OcclusionQuery): boolean;\r\n        /**\r\n         * Ends an occlusion query\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         * @param algorithmType defines the algorithm to use\r\n         * @returns the current engine\r\n         */\r\n        endOcclusionQuery(algorithmType: number): AbstractEngine;\r\n    }\r\n}\r\n\r\nAbstractEngine.prototype.createQuery = function (): Nullable<OcclusionQuery> {\r\n    return null;\r\n};\r\n\r\nAbstractEngine.prototype.deleteQuery = function (query: OcclusionQuery): AbstractEngine {\r\n    // Do nothing. Must be implemented by child classes\r\n    return this;\r\n};\r\n\r\nAbstractEngine.prototype.isQueryResultAvailable = function (query: OcclusionQuery): boolean {\r\n    // Do nothing. Must be implemented by child classes\r\n    return false;\r\n};\r\n\r\nAbstractEngine.prototype.getQueryResult = function (query: OcclusionQuery): number {\r\n    // Do nothing. Must be implemented by child classes\r\n    return 0;\r\n};\r\n\r\nAbstractEngine.prototype.beginOcclusionQuery = function (algorithmType: number, query: OcclusionQuery): boolean {\r\n    // Do nothing. Must be implemented by child classes\r\n    return false;\r\n};\r\n\r\nAbstractEngine.prototype.endOcclusionQuery = function (algorithmType: number): AbstractEngine {\r\n    // Do nothing. Must be implemented by child classes\r\n    return this;\r\n};\r\n\r\ndeclare module \"../../Meshes/abstractMesh\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Backing filed\r\n         * @internal\r\n         */\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        __occlusionDataStorage: _OcclusionDataStorage;\r\n\r\n        /**\r\n         * Access property\r\n         * @internal\r\n         */\r\n        _occlusionDataStorage: _OcclusionDataStorage;\r\n\r\n        /**\r\n         * This number indicates the number of allowed retries before stop the occlusion query, this is useful if the occlusion query is taking long time before to the query result is retrieved, the query result indicates if the object is visible within the scene or not and based on that Babylon.Js engine decides to show or hide the object.\r\n         * The default value is -1 which means don't break the query and wait till the result\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         */\r\n        occlusionRetryCount: number;\r\n\r\n        /**\r\n         * This property is responsible for starting the occlusion query within the Mesh or not, this property is also used to determine what should happen when the occlusionRetryCount is reached. It has supports 3 values:\r\n         * * OCCLUSION_TYPE_NONE (Default Value): this option means no occlusion query within the Mesh.\r\n         * * OCCLUSION_TYPE_OPTIMISTIC: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken show the mesh.\r\n         * * OCCLUSION_TYPE_STRICT: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken restore the last state of the mesh occlusion if the mesh was visible then show the mesh if was hidden then hide don't show.\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         */\r\n        occlusionType: number;\r\n\r\n        /**\r\n         * This property determines the type of occlusion query algorithm to run in WebGl, you can use:\r\n         * * AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE which is mapped to GL_ANY_SAMPLES_PASSED.\r\n         * * AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE (Default Value) which is mapped to GL_ANY_SAMPLES_PASSED_CONSERVATIVE which is a false positive algorithm that is faster than GL_ANY_SAMPLES_PASSED but less accurate.\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         */\r\n        occlusionQueryAlgorithmType: number;\r\n\r\n        /**\r\n         * Gets or sets whether the mesh is occluded or not, it is used also to set the initial state of the mesh to be occluded or not\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         */\r\n        isOccluded: boolean;\r\n\r\n        /**\r\n         * Flag to check the progress status of the query\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         */\r\n        isOcclusionQueryInProgress: boolean;\r\n\r\n        /**\r\n         * Flag to force rendering the mesh even if occluded\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         */\r\n        forceRenderingWhenOccluded: boolean;\r\n    }\r\n}\r\nObject.defineProperty(AbstractMesh.prototype, \"isOcclusionQueryInProgress\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._occlusionDataStorage.isOcclusionQueryInProgress;\r\n    },\r\n    set: function (this: AbstractMesh, value: boolean) {\r\n        this._occlusionDataStorage.isOcclusionQueryInProgress = value;\r\n    },\r\n    enumerable: false,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"_occlusionDataStorage\", {\r\n    get: function (this: AbstractMesh) {\r\n        if (!this.__occlusionDataStorage) {\r\n            this.__occlusionDataStorage = new _OcclusionDataStorage();\r\n        }\r\n        return this.__occlusionDataStorage;\r\n    },\r\n    enumerable: false,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"isOccluded\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._occlusionDataStorage.isOccluded;\r\n    },\r\n    set: function (this: AbstractMesh, value: boolean) {\r\n        this._occlusionDataStorage.isOccluded = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"occlusionQueryAlgorithmType\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._occlusionDataStorage.occlusionQueryAlgorithmType;\r\n    },\r\n    set: function (this: AbstractMesh, value: number) {\r\n        this._occlusionDataStorage.occlusionQueryAlgorithmType = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"occlusionType\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._occlusionDataStorage.occlusionType;\r\n    },\r\n    set: function (this: AbstractMesh, value: number) {\r\n        this._occlusionDataStorage.occlusionType = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"occlusionRetryCount\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._occlusionDataStorage.occlusionRetryCount;\r\n    },\r\n    set: function (this: AbstractMesh, value: number) {\r\n        this._occlusionDataStorage.occlusionRetryCount = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"forceRenderingWhenOccluded\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._occlusionDataStorage.forceRenderingWhenOccluded;\r\n    },\r\n    set: function (this: AbstractMesh, value: boolean) {\r\n        this._occlusionDataStorage.forceRenderingWhenOccluded = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n// We also need to update AbstractMesh as there is a portion of the code there\r\nAbstractMesh.prototype._checkOcclusionQuery = function () {\r\n    const dataStorage = this._occlusionDataStorage;\r\n\r\n    if (dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_NONE) {\r\n        dataStorage.isOccluded = false;\r\n        return false;\r\n    }\r\n\r\n    const engine = this.getEngine();\r\n\r\n    if (!engine.getCaps().supportOcclusionQuery) {\r\n        dataStorage.isOccluded = false;\r\n        return false;\r\n    }\r\n\r\n    if (!engine.isQueryResultAvailable) {\r\n        // Occlusion query where not referenced\r\n        dataStorage.isOccluded = false;\r\n        return false;\r\n    }\r\n\r\n    if (this.isOcclusionQueryInProgress && this._occlusionQuery !== null && this._occlusionQuery !== undefined) {\r\n        const isOcclusionQueryAvailable = engine.isQueryResultAvailable(this._occlusionQuery);\r\n        if (isOcclusionQueryAvailable) {\r\n            const occlusionQueryResult = engine.getQueryResult(this._occlusionQuery);\r\n\r\n            dataStorage.isOcclusionQueryInProgress = false;\r\n            dataStorage.occlusionInternalRetryCounter = 0;\r\n            dataStorage.isOccluded = occlusionQueryResult > 0 ? false : true;\r\n        } else {\r\n            dataStorage.occlusionInternalRetryCounter++;\r\n\r\n            if (dataStorage.occlusionRetryCount !== -1 && dataStorage.occlusionInternalRetryCounter > dataStorage.occlusionRetryCount) {\r\n                dataStorage.isOcclusionQueryInProgress = false;\r\n                dataStorage.occlusionInternalRetryCounter = 0;\r\n\r\n                // if optimistic set isOccluded to false regardless of the status of isOccluded. (Render in the current render loop)\r\n                // if strict continue the last state of the object.\r\n                dataStorage.isOccluded = dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;\r\n            } else {\r\n                return dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;\r\n            }\r\n        }\r\n    }\r\n\r\n    const scene = this.getScene();\r\n    if (scene.getBoundingBoxRenderer) {\r\n        const occlusionBoundingBoxRenderer = scene.getBoundingBoxRenderer();\r\n\r\n        if (this._occlusionQuery === null) {\r\n            this._occlusionQuery = engine.createQuery();\r\n        }\r\n\r\n        if (this._occlusionQuery && engine.beginOcclusionQuery(dataStorage.occlusionQueryAlgorithmType, this._occlusionQuery)) {\r\n            occlusionBoundingBoxRenderer.renderOcclusionBoundingBox(this);\r\n            engine.endOcclusionQuery(dataStorage.occlusionQueryAlgorithmType);\r\n            this._occlusionDataStorage.isOcclusionQueryInProgress = true;\r\n        }\r\n    }\r\n\r\n    return dataStorage.isOccluded;\r\n};\r\n", "import { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\nimport { WebGPURenderItemBeginOcclusionQuery, WebGPURenderItemEndOcclusionQuery } from \"../webgpuBundleList\";\r\n\r\nimport type { PerfCounter } from \"../../../Misc/perfCounter\";\r\nimport type { OcclusionQuery } from \"../../../Engines/AbstractEngine/abstractEngine.query\";\r\n\r\nimport \"../../../Engines/AbstractEngine/abstractEngine.query\";\r\n\r\nThinWebGPUEngine.prototype.getGPUFrameTimeCounter = function (): PerfCounter {\r\n    return this._timestampQuery.gpuFrameTimeCounter;\r\n};\r\n\r\nThinWebGPUEngine.prototype.captureGPUFrameTime = function (value: boolean) {\r\n    this._timestampQuery.enable = value && !!this._caps.timerQuery;\r\n};\r\n\r\nThinWebGPUEngine.prototype.createQuery = function (): OcclusionQuery {\r\n    return this._occlusionQuery.createQuery();\r\n};\r\n\r\nThinWebGPUEngine.prototype.deleteQuery = function (query: OcclusionQuery): ThinWebGPUEngine {\r\n    this._occlusionQuery.deleteQuery(query as number);\r\n\r\n    return this;\r\n};\r\n\r\nThinWebGPUEngine.prototype.isQueryResultAvailable = function (query: OcclusionQuery): boolean {\r\n    return this._occlusionQuery.isQueryResultAvailable(query as number);\r\n};\r\n\r\nThinWebGPUEngine.prototype.getQueryResult = function (query: OcclusionQuery): number {\r\n    return this._occlusionQuery.getQueryResult(query as number);\r\n};\r\n\r\nThinWebGPUEngine.prototype.beginOcclusionQuery = function (algorithmType: number, query: OcclusionQuery): boolean {\r\n    if (this.compatibilityMode) {\r\n        if (this._occlusionQuery.canBeginQuery(query as number)) {\r\n            this._currentRenderPass?.beginOcclusionQuery(query as number);\r\n            return true;\r\n        }\r\n    } else {\r\n        this._bundleList.addItem(new WebGPURenderItemBeginOcclusionQuery(query as number));\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nThinWebGPUEngine.prototype.endOcclusionQuery = function (): ThinWebGPUEngine {\r\n    if (this.compatibilityMode) {\r\n        this._currentRenderPass?.endOcclusionQuery();\r\n    } else {\r\n        this._bundleList.addItem(new WebGPURenderItemEndOcclusionQuery());\r\n    }\r\n    return this;\r\n};\r\n", "/* eslint-disable babylonjs/available */\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { ThinWebGPUEngine } from \"./thinWebGPUEngine\";\r\nimport type { Nullable, DataArray, IndicesArray, Immutable, FloatArray } from \"../types\";\r\nimport { Color4 } from \"../Maths/math\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { IEffectCreationOptions, IShaderPath } from \"../Materials/effect\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport type { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport { Constants } from \"./constants\";\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nimport * as WebGPUConstants from \"./WebGPU/webgpuConstants\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { IWebGPURenderPipelineStageDescriptor } from \"./WebGPU/webgpuPipelineContext\";\r\nimport { WebGPUPipelineContext } from \"./WebGPU/webgpuPipelineContext\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { IShaderProcessor } from \"./Processors/iShaderProcessor\";\r\nimport { WebGPUShaderProcessorGLSL } from \"./WebGPU/webgpuShaderProcessorsGLSL\";\r\nimport { WebGPUShaderProcessorWGSL } from \"./WebGPU/webgpuShaderProcessorsWGSL\";\r\nimport type { _IShaderProcessingContext } from \"./Processors/shaderProcessingOptions\";\r\nimport { WebGPUShaderProcessingContext } from \"./WebGPU/webgpuShaderProcessingContext\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { WebGPUTextureHelper } from \"./WebGPU/webgpuTextureHelper\";\r\nimport { WebGPUTextureManager } from \"./WebGPU/webgpuTextureManager\";\r\nimport { AbstractEngine } from \"./abstractEngine\";\r\nimport type { ISceneLike, AbstractEngineOptions } from \"./abstractEngine\";\r\nimport { WebGPUBufferManager } from \"./WebGPU/webgpuBufferManager\";\r\nimport type { IHardwareTextureWrapper } from \"../Materials/Textures/hardwareTextureWrapper\";\r\nimport { WebGPUHardwareTexture } from \"./WebGPU/webgpuHardwareTexture\";\r\nimport type { IColor4Like } from \"../Maths/math.like\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport { WebGPUCacheSampler } from \"./WebGPU/webgpuCacheSampler\";\r\nimport { WebGPUCacheRenderPipelineTree } from \"./WebGPU/webgpuCacheRenderPipelineTree\";\r\nimport { WebGPUStencilStateComposer } from \"./WebGPU/webgpuStencilStateComposer\";\r\nimport { WebGPUDepthCullingState } from \"./WebGPU/webgpuDepthCullingState\";\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { WebGPUMaterialContext } from \"./WebGPU/webgpuMaterialContext\";\r\nimport { WebGPUDrawContext } from \"./WebGPU/webgpuDrawContext\";\r\nimport { WebGPUCacheBindGroups } from \"./WebGPU/webgpuCacheBindGroups\";\r\nimport { WebGPUClearQuad } from \"./WebGPU/webgpuClearQuad\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\nimport { WebGPURenderItemBlendColor, WebGPURenderItemScissor, WebGPURenderItemStencilRef, WebGPURenderItemViewport, WebGPUBundleList } from \"./WebGPU/webgpuBundleList\";\r\nimport { WebGPUTimestampQuery } from \"./WebGPU/webgpuTimestampQuery\";\r\nimport type { ComputeEffect } from \"../Compute/computeEffect\";\r\nimport { WebGPUOcclusionQuery } from \"./WebGPU/webgpuOcclusionQuery\";\r\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner\";\r\nimport type { TwgslOptions } from \"./WebGPU/webgpuTintWASM\";\r\nimport { WebGPUTintWASM } from \"./WebGPU/webgpuTintWASM\";\r\nimport type { ExternalTexture } from \"../Materials/Textures/externalTexture\";\r\nimport { WebGPUShaderProcessor } from \"./WebGPU/webgpuShaderProcessor\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\nimport type { InternalTextureCreationOptions, TextureSize } from \"../Materials/Textures/textureCreationOptions\";\r\nimport { WebGPUSnapshotRendering } from \"./WebGPU/webgpuSnapshotRendering\";\r\nimport type { WebGPUDataBuffer } from \"../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { WebGPURenderTargetWrapper } from \"./WebGPU/webgpuRenderTargetWrapper\";\r\nimport { AlphaState } from \"../States/alphaCullingState\";\r\n\r\nimport \"../Buffers/buffer.align\";\r\n\r\nimport type { VideoTexture } from \"../Materials/Textures/videoTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { RenderTargetWrapper } from \"./renderTargetWrapper\";\r\nimport type { Scene } from \"../scene\";\r\n\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { PerformanceMonitor } from \"../Misc/performanceMonitor\";\r\nimport {\r\n    CreateImageBitmapFromSource,\r\n    ExitFullscreen,\r\n    ExitPointerlock,\r\n    GetFontOffset,\r\n    RequestFullscreen,\r\n    RequestPointerlock,\r\n    ResizeImageBitmap,\r\n    _CommonDispose,\r\n    _CommonInit,\r\n} from \"./engine.common\";\r\nimport { IsWrapper } from \"../Materials/drawWrapper.functions\";\r\nimport { PerfCounter } from \"../Misc/perfCounter\";\r\nimport \"./AbstractEngine/abstractEngine.loadingScreen\";\r\nimport \"./AbstractEngine/abstractEngine.dom\";\r\nimport \"./AbstractEngine/abstractEngine.states\";\r\nimport \"./AbstractEngine/abstractEngine.stencil\";\r\nimport \"./AbstractEngine/abstractEngine.renderPass\";\r\nimport \"../Audio/audioEngine\";\r\nimport { resetCachedPipeline } from \"../Materials/effect.functions\";\r\n\r\nimport { WebGPUExternalTexture } from \"./WebGPU/webgpuExternalTexture\";\r\nimport type { TextureSampler } from \"../Materials/Textures/textureSampler\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport \"./WebGPU/Extensions/engine.alpha\";\r\nimport \"./WebGPU/Extensions/engine.rawTexture\";\r\nimport \"./WebGPU/Extensions/engine.readTexture\";\r\nimport \"./WebGPU/Extensions/engine.cubeTexture\";\r\nimport \"./WebGPU/Extensions/engine.renderTarget\";\r\nimport \"./WebGPU/Extensions/engine.renderTargetTexture\";\r\nimport \"./WebGPU/Extensions/engine.renderTargetCube\";\r\nimport \"./WebGPU/Extensions/engine.query\";\r\n\r\nconst ViewDescriptorSwapChainAntialiasing: GPUTextureViewDescriptor = {\r\n    label: `TextureView_SwapChain_ResolveTarget`,\r\n    dimension: WebGPUConstants.TextureDimension.E2d,\r\n    format: undefined as any, // will be updated with the right value\r\n    mipLevelCount: 1,\r\n    arrayLayerCount: 1,\r\n};\r\n\r\nconst ViewDescriptorSwapChain: GPUTextureViewDescriptor = {\r\n    label: `TextureView_SwapChain`,\r\n    dimension: WebGPUConstants.TextureDimension.E2d,\r\n    format: undefined as any, // will be updated with the right value\r\n    mipLevelCount: 1,\r\n    arrayLayerCount: 1,\r\n};\r\nconst TempColor4 = new Color4();\r\n\r\n/** @internal */\r\ninterface IWebGPURenderPassWrapper {\r\n    renderPassDescriptor: Nullable<GPURenderPassDescriptor>;\r\n\r\n    colorAttachmentViewDescriptor: Nullable<GPUTextureViewDescriptor>;\r\n    depthAttachmentViewDescriptor: Nullable<GPUTextureViewDescriptor>;\r\n    colorAttachmentGPUTextures: (WebGPUHardwareTexture | null)[];\r\n    depthTextureFormat: GPUTextureFormat | undefined;\r\n}\r\n\r\n/**\r\n * Options to load the associated Glslang library\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface GlslangOptions {\r\n    /**\r\n     * Defines an existing instance of Glslang (useful in modules who do not access the global instance).\r\n     */\r\n    glslang?: any;\r\n    /**\r\n     * Defines the URL of the glslang JS File.\r\n     */\r\n    jsPath?: string;\r\n    /**\r\n     * Defines the URL of the glslang WASM File.\r\n     */\r\n    wasmPath?: string;\r\n}\r\n\r\n/**\r\n * Options to create the WebGPU engine\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface WebGPUEngineOptions extends AbstractEngineOptions, GPURequestAdapterOptions {\r\n    /**\r\n     * The featureLevel property of the GPURequestAdapterOptions interface\r\n     */\r\n    featureLevel?: string;\r\n\r\n    /**\r\n     * Defines the category of adapter to use.\r\n     * Is it the discrete or integrated device.\r\n     */\r\n    powerPreference?: GPUPowerPreference;\r\n\r\n    /**\r\n     * When set to true, indicates that only a fallback adapter may be returned when requesting an adapter.\r\n     * If the user agent does not support a fallback adapter, will cause requestAdapter() to resolve to null.\r\n     * Default: false\r\n     */\r\n    forceFallbackAdapter?: boolean;\r\n\r\n    /**\r\n     * Defines the device descriptor used to create a device once we have retrieved an appropriate adapter\r\n     */\r\n    deviceDescriptor?: GPUDeviceDescriptor;\r\n\r\n    /**\r\n     * When requesting the device, enable all the features supported by the adapter. Default: false\r\n     * Note that this setting is ignored if you explicitely set deviceDescriptor.requiredFeatures\r\n     */\r\n    enableAllFeatures?: boolean;\r\n\r\n    /**\r\n     * When requesting the device, set the required limits to the maximum possible values (the ones from adapter.limits). Default: false\r\n     * Note that this setting is ignored if you explicitely set deviceDescriptor.requiredLimits\r\n     */\r\n    setMaximumLimits?: boolean;\r\n\r\n    /**\r\n     * Defines the requested Swap Chain Format.\r\n     */\r\n    swapChainFormat?: GPUTextureFormat;\r\n\r\n    /**\r\n     * Defines whether we should generate debug markers in the gpu command lists (can be seen with PIX for eg). Default: false\r\n     */\r\n    enableGPUDebugMarkers?: boolean;\r\n\r\n    /**\r\n     * Options to load the associated Glslang library\r\n     */\r\n    glslangOptions?: GlslangOptions;\r\n\r\n    /**\r\n     * Options to load the associated Twgsl library\r\n     */\r\n    twgslOptions?: TwgslOptions;\r\n}\r\n\r\n/**\r\n * The web GPU engine class provides support for WebGPU version of babylon.js.\r\n * @since 5.0.0\r\n */\r\nexport class WebGPUEngine extends ThinWebGPUEngine {\r\n    // Default glslang options.\r\n    private static readonly _GlslangDefaultOptions: GlslangOptions = {\r\n        jsPath: `${Tools._DefaultCdnUrl}/glslang/glslang.js`,\r\n        wasmPath: `${Tools._DefaultCdnUrl}/glslang/glslang.wasm`,\r\n    };\r\n\r\n    private static _InstanceId = 0;\r\n\r\n    /** A unique id to identify this instance */\r\n    public readonly uniqueId = -1;\r\n\r\n    // Page Life cycle and constants\r\n    private readonly _uploadEncoderDescriptor = { label: \"upload\" };\r\n    private readonly _renderEncoderDescriptor = { label: \"render\" };\r\n    /** @internal */\r\n    public readonly _clearDepthValue = 1;\r\n    /** @internal */\r\n    public readonly _clearReverseDepthValue = 0;\r\n    /** @internal */\r\n    public _clearStencilValue = 0;\r\n    private readonly _defaultSampleCount = 4; // Only supported value for now.\r\n\r\n    // Engine Life Cycle\r\n    /** @internal */\r\n    public _options: WebGPUEngineOptions;\r\n    private _glslang: any = null;\r\n    private _tintWASM: Nullable<WebGPUTintWASM> = null;\r\n    private _glslangAndTintAreFullyLoaded = false;\r\n    private _adapter: GPUAdapter;\r\n    private _adapterSupportedExtensions: GPUFeatureName[];\r\n    private _adapterInfo: GPUAdapterInfo = {\r\n        vendor: \"\",\r\n        architecture: \"\",\r\n        device: \"\",\r\n        description: \"\",\r\n        subgroupMinSize: 0,\r\n        subgroupMaxSize: 0,\r\n        isFallbackAdapter: false,\r\n    };\r\n    private _adapterSupportedLimits: GPUSupportedLimits;\r\n    /** @internal */\r\n    public _device: GPUDevice;\r\n    private _deviceEnabledExtensions: GPUFeatureName[];\r\n    private _deviceLimits: GPUSupportedLimits;\r\n    private _context: GPUCanvasContext;\r\n    private _mainPassSampleCount: number;\r\n    private _glslangOptions?: GlslangOptions;\r\n    private _twgslOptions?: TwgslOptions;\r\n    /** @internal */\r\n    public _bufferManager: WebGPUBufferManager;\r\n    private _clearQuad: WebGPUClearQuad;\r\n    /** @internal */\r\n    public _cacheSampler: WebGPUCacheSampler;\r\n    private _cacheBindGroups: WebGPUCacheBindGroups;\r\n    private _emptyVertexBuffer: VertexBuffer;\r\n    /** @internal */\r\n    public _mrtAttachments: number[];\r\n    /** @internal */\r\n    public _compiledComputeEffects: { [key: string]: ComputeEffect } = {};\r\n    /** @internal */\r\n    public _counters: {\r\n        numEnableEffects: number;\r\n        numEnableDrawWrapper: number;\r\n        numBundleCreationNonCompatMode: number;\r\n        numBundleReuseNonCompatMode: number;\r\n    } = {\r\n        numEnableEffects: 0,\r\n        numEnableDrawWrapper: 0,\r\n        numBundleCreationNonCompatMode: 0,\r\n        numBundleReuseNonCompatMode: 0,\r\n    };\r\n    /**\r\n     * Counters from last frame\r\n     */\r\n    public readonly countersLastFrame: {\r\n        numEnableEffects: number;\r\n        numEnableDrawWrapper: number;\r\n        numBundleCreationNonCompatMode: number;\r\n        numBundleReuseNonCompatMode: number;\r\n    } = {\r\n        numEnableEffects: 0,\r\n        numEnableDrawWrapper: 0,\r\n        numBundleCreationNonCompatMode: 0,\r\n        numBundleReuseNonCompatMode: 0,\r\n    };\r\n    /**\r\n     * Max number of uncaptured error messages to log\r\n     */\r\n    public numMaxUncapturedErrors = 20;\r\n\r\n    /**\r\n     * Gets the list of created scenes\r\n     */\r\n    public override scenes: Scene[] = [];\r\n\r\n    /** @internal */\r\n    public override _virtualScenes = new Array<Scene>();\r\n\r\n    // Some of the internal state might change during the render pass.\r\n    // This happens mainly during clear for the state\r\n    // And when the frame starts to swap the target texture from the swap chain\r\n    private _mainTexture: GPUTexture;\r\n    private _depthTexture: GPUTexture;\r\n    private _mainTextureExtends: GPUExtent3D;\r\n    private _depthTextureFormat: GPUTextureFormat | undefined;\r\n    private _colorFormat: GPUTextureFormat | null;\r\n    /** @internal */\r\n    public _ubInvertY: WebGPUDataBuffer;\r\n    /** @internal */\r\n    public _ubDontInvertY: WebGPUDataBuffer;\r\n\r\n    private _commandBuffers: GPUCommandBuffer[] = [null as any, null as any];\r\n\r\n    // Frame Buffer Life Cycle (recreated for each render target pass)\r\n\r\n    private _mainRenderPassWrapper: IWebGPURenderPassWrapper = {\r\n        renderPassDescriptor: null,\r\n        colorAttachmentViewDescriptor: null,\r\n        depthAttachmentViewDescriptor: null,\r\n        colorAttachmentGPUTextures: [],\r\n        depthTextureFormat: undefined,\r\n    };\r\n    private _rttRenderPassWrapper: IWebGPURenderPassWrapper = {\r\n        renderPassDescriptor: null,\r\n        colorAttachmentViewDescriptor: null,\r\n        depthAttachmentViewDescriptor: null,\r\n        colorAttachmentGPUTextures: [],\r\n        depthTextureFormat: undefined,\r\n    };\r\n    /** @internal */\r\n    public _pendingDebugCommands: Array<[string, Nullable<string>, number?]> = [];\r\n\r\n    // DrawCall Life Cycle\r\n    // Effect is on the parent class\r\n    // protected _currentEffect: Nullable<Effect> = null;\r\n    private _defaultDrawContext: WebGPUDrawContext;\r\n    private _defaultMaterialContext: WebGPUMaterialContext;\r\n    /** @internal */\r\n    public override _currentDrawContext: WebGPUDrawContext;\r\n    /** @internal */\r\n    public override _currentMaterialContext: WebGPUMaterialContext;\r\n    private _currentVertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _currentOverrideVertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }> = null;\r\n    private _currentIndexBuffer: Nullable<DataBuffer> = null;\r\n    private _dummyIndexBuffer: WebGPUDataBuffer;\r\n    private _colorWriteLocal = true;\r\n    private _forceEnableEffect = false;\r\n\r\n    /**\r\n     * Gets or sets the snapshot rendering mode\r\n     */\r\n    public override get snapshotRenderingMode(): number {\r\n        return this._snapshotRendering.mode;\r\n    }\r\n\r\n    public override set snapshotRenderingMode(mode: number) {\r\n        this._snapshotRendering.mode = mode;\r\n    }\r\n\r\n    /**\r\n     * Creates a new snapshot at the next frame using the current snapshotRenderingMode\r\n     */\r\n    public snapshotRenderingReset(): void {\r\n        this._snapshotRendering.reset();\r\n    }\r\n\r\n    /**\r\n     * Enables or disables the snapshot rendering mode\r\n     * Note that the WebGL engine does not support snapshot rendering so setting the value won't have any effect for this engine\r\n     */\r\n    public override get snapshotRendering(): boolean {\r\n        return this._snapshotRendering.enabled;\r\n    }\r\n\r\n    public override set snapshotRendering(activate) {\r\n        this._snapshotRendering.enabled = activate;\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the samplers. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheSamplers(): boolean {\r\n        return this._cacheSampler ? this._cacheSampler.disabled : false;\r\n    }\r\n\r\n    public set disableCacheSamplers(disable: boolean) {\r\n        if (this._cacheSampler) {\r\n            this._cacheSampler.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the render pipelines. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheRenderPipelines(): boolean {\r\n        return this._cacheRenderPipeline ? this._cacheRenderPipeline.disabled : false;\r\n    }\r\n\r\n    public set disableCacheRenderPipelines(disable: boolean) {\r\n        if (this._cacheRenderPipeline) {\r\n            this._cacheRenderPipeline.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the bind groups. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheBindGroups(): boolean {\r\n        return this._cacheBindGroups ? this._cacheBindGroups.disabled : false;\r\n    }\r\n\r\n    public set disableCacheBindGroups(disable: boolean) {\r\n        if (this._cacheBindGroups) {\r\n            this._cacheBindGroups.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if all created effects are ready\r\n     * @returns true if all effects are ready\r\n     */\r\n    public areAllEffectsReady(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get Font size information\r\n     * @param font font name\r\n     * @returns an object containing ascent, height and descent\r\n     */\r\n    public override getFontOffset(font: string): { ascent: number; height: number; descent: number } {\r\n        return GetFontOffset(font);\r\n    }\r\n\r\n    /**\r\n     * Gets a Promise<boolean> indicating if the engine can be instantiated (ie. if a WebGPU context can be found)\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static get IsSupportedAsync(): Promise<boolean> {\r\n        return !navigator.gpu\r\n            ? Promise.resolve(false)\r\n            : navigator.gpu\r\n                  .requestAdapter()\r\n                  // eslint-disable-next-line github/no-then\r\n                  .then(\r\n                      (adapter: GPUAdapter | undefined) => !!adapter,\r\n                      () => false\r\n                  )\r\n                  // eslint-disable-next-line github/no-then\r\n                  .catch(() => false);\r\n    }\r\n\r\n    /**\r\n     * Not supported by WebGPU, you should call IsSupportedAsync instead!\r\n     */\r\n    public static get IsSupported(): boolean {\r\n        Logger.Warn(\"You must call IsSupportedAsync for WebGPU!\");\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine supports uniform buffers\r\n     */\r\n    public get supportsUniformBuffers(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** Gets the supported extensions by the WebGPU adapter */\r\n    public get supportedExtensions(): Immutable<GPUFeatureName[]> {\r\n        return this._adapterSupportedExtensions;\r\n    }\r\n\r\n    /** Gets the currently enabled extensions on the WebGPU device */\r\n    public get enabledExtensions(): Immutable<GPUFeatureName[]> {\r\n        return this._deviceEnabledExtensions;\r\n    }\r\n\r\n    /** Gets the supported limits by the WebGPU adapter */\r\n    public get supportedLimits(): GPUSupportedLimits {\r\n        return this._adapterSupportedLimits;\r\n    }\r\n\r\n    /** Gets the current limits of the WebGPU device */\r\n    public get currentLimits() {\r\n        return this._deviceLimits;\r\n    }\r\n\r\n    /**\r\n     * Returns a string describing the current engine\r\n     */\r\n    public override get description(): string {\r\n        const description = this.name + this.version;\r\n\r\n        return description;\r\n    }\r\n\r\n    /**\r\n     * Returns the version of the engine\r\n     */\r\n    public get version(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Gets an object containing information about the current engine context\r\n     * @returns an object containing the vendor, the renderer and the version of the current engine context\r\n     */\r\n    public getInfo() {\r\n        return {\r\n            vendor: this._adapterInfo.vendor || \"unknown vendor\",\r\n            renderer: this._adapterInfo.architecture || \"unknown renderer\",\r\n            version: this._adapterInfo.description || \"unknown version\",\r\n        };\r\n    }\r\n\r\n    /**\r\n     * (WebGPU only) True (default) to be in compatibility mode, meaning rendering all existing scenes without artifacts (same rendering than WebGL).\r\n     * Setting the property to false will improve performances but may not work in some scenes if some precautions are not taken.\r\n     * See https://doc.babylonjs.com/setup/support/webGPU/webGPUOptimization/webGPUNonCompatibilityMode for more details\r\n     */\r\n    public override get compatibilityMode() {\r\n        return this._compatibilityMode;\r\n    }\r\n\r\n    public override set compatibilityMode(mode: boolean) {\r\n        this._compatibilityMode = mode;\r\n    }\r\n\r\n    /** @internal */\r\n    public get currentSampleCount(): number {\r\n        return this._currentRenderTarget ? this._currentRenderTarget.samples : this._mainPassSampleCount;\r\n    }\r\n\r\n    /**\r\n     * Create a new instance of the gpu engine asynchronously\r\n     * @param canvas Defines the canvas to use to display the result\r\n     * @param options Defines the options passed to the engine to create the GPU context dependencies\r\n     * @returns a promise that resolves with the created engine\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public static CreateAsync(canvas: HTMLCanvasElement, options: WebGPUEngineOptions = {}): Promise<WebGPUEngine> {\r\n        const engine = new WebGPUEngine(canvas, options);\r\n\r\n        return new Promise((resolve) => {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            engine.initAsync(options.glslangOptions, options.twgslOptions).then(() => resolve(engine));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Indicates if the z range in NDC space is 0..1 (value: true) or -1..1 (value: false)\r\n     */\r\n    public override readonly isNDCHalfZRange: boolean = true;\r\n\r\n    /**\r\n     * Indicates that the origin of the texture/framebuffer space is the bottom left corner. If false, the origin is top left\r\n     */\r\n    public override readonly hasOriginBottomLeft: boolean = false;\r\n\r\n    /**\r\n     * Create a new instance of the gpu engine.\r\n     * @param canvas Defines the canvas to use to display the result\r\n     * @param options Defines the options passed to the engine to create the GPU context dependencies\r\n     */\r\n    public constructor(canvas: HTMLCanvasElement | OffscreenCanvas, options: WebGPUEngineOptions = {}) {\r\n        super(options.antialias ?? true, options);\r\n        this._name = \"WebGPU\";\r\n\r\n        this._drawCalls = new PerfCounter();\r\n\r\n        options.deviceDescriptor = options.deviceDescriptor || {};\r\n        options.enableGPUDebugMarkers = options.enableGPUDebugMarkers ?? false;\r\n\r\n        Logger.Log(`Babylon.js v${AbstractEngine.Version} - ${this.description} engine`);\r\n        if (!navigator.gpu) {\r\n            Logger.Error(\"WebGPU is not supported by your browser.\");\r\n            return;\r\n        }\r\n\r\n        options.swapChainFormat = options.swapChainFormat || navigator.gpu.getPreferredCanvasFormat();\r\n\r\n        this._isWebGPU = true;\r\n        this._shaderPlatformName = \"WEBGPU\";\r\n\r\n        this._renderingCanvas = canvas as HTMLCanvasElement;\r\n        this._options = options;\r\n\r\n        this._mainPassSampleCount = options.antialias ? this._defaultSampleCount : 1;\r\n\r\n        if (navigator && navigator.userAgent) {\r\n            this._setupMobileChecks();\r\n        }\r\n\r\n        this._sharedInit(this._renderingCanvas);\r\n\r\n        this._shaderProcessor = new WebGPUShaderProcessorGLSL();\r\n        this._shaderProcessorWGSL = new WebGPUShaderProcessorWGSL();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Initialization\r\n    //------------------------------------------------------------------------------\r\n    private _workingGlslangAndTintPromise: Nullable<Promise<void>> = null;\r\n\r\n    /**\r\n     * Load the glslang and tintWASM libraries and prepare them for use.\r\n     * @returns a promise that resolves when the engine is ready to use the glslang and tintWASM\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public prepareGlslangAndTintAsync(): Promise<void> {\r\n        if (!this._workingGlslangAndTintPromise) {\r\n            this._workingGlslangAndTintPromise = new Promise<void>((resolve) => {\r\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                this._initGlslangAsync(this._glslangOptions ?? this._options?.glslangOptions).then((glslang: any) => {\r\n                    this._glslang = glslang;\r\n                    this._tintWASM = new WebGPUTintWASM();\r\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                    this._tintWASM.initTwgsl(this._twgslOptions ?? this._options?.twgslOptions).then(() => {\r\n                        this._glslangAndTintAreFullyLoaded = true;\r\n                        resolve();\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        return this._workingGlslangAndTintPromise;\r\n    }\r\n\r\n    /**\r\n     * Initializes the WebGPU context and dependencies.\r\n     * @param glslangOptions Defines the GLSLang compiler options if necessary\r\n     * @param twgslOptions Defines the Twgsl compiler options if necessary\r\n     * @returns a promise notifying the readiness of the engine.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public initAsync(glslangOptions?: GlslangOptions, twgslOptions?: TwgslOptions): Promise<void> {\r\n        (this.uniqueId as number) = WebGPUEngine._InstanceId++;\r\n        this._glslangOptions = glslangOptions;\r\n        this._twgslOptions = twgslOptions;\r\n        return (\r\n            navigator\r\n                .gpu!.requestAdapter(this._options)\r\n                // eslint-disable-next-line github/no-then\r\n                .then(async (adapter: GPUAdapter | undefined) => {\r\n                    if (!adapter) {\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"Could not retrieve a WebGPU adapter (adapter is null).\";\r\n                    } else {\r\n                        this._adapter = adapter!;\r\n                        this._adapterSupportedExtensions = [];\r\n                        this._adapter.features?.forEach((feature) => {\r\n                            this._adapterSupportedExtensions.push(feature as WebGPUConstants.FeatureName);\r\n                        });\r\n                        this._adapterSupportedLimits = this._adapter.limits;\r\n                        this._adapterInfo = this._adapter.info;\r\n\r\n                        const deviceDescriptor = this._options.deviceDescriptor ?? {};\r\n                        const requiredFeatures = deviceDescriptor?.requiredFeatures ?? (this._options.enableAllFeatures ? this._adapterSupportedExtensions : undefined);\r\n\r\n                        if (requiredFeatures) {\r\n                            const requestedExtensions = requiredFeatures;\r\n                            const validExtensions: GPUFeatureName[] = [];\r\n\r\n                            for (const extension of requestedExtensions) {\r\n                                if (this._adapterSupportedExtensions.indexOf(extension) !== -1) {\r\n                                    validExtensions.push(extension);\r\n                                }\r\n                            }\r\n\r\n                            deviceDescriptor.requiredFeatures = validExtensions;\r\n                        }\r\n\r\n                        if (this._options.setMaximumLimits && !deviceDescriptor.requiredLimits) {\r\n                            deviceDescriptor.requiredLimits = {};\r\n                            for (const name in this._adapterSupportedLimits) {\r\n                                if (name === \"minSubgroupSize\" || name === \"maxSubgroupSize\") {\r\n                                    // Chrome exposes these limits in \"webgpu developer\" mode, but these can't be set on the device.\r\n                                    continue;\r\n                                }\r\n                                deviceDescriptor.requiredLimits[name] = this._adapterSupportedLimits[name];\r\n                            }\r\n                        }\r\n\r\n                        deviceDescriptor.label = `BabylonWebGPUDevice${this.uniqueId}`;\r\n\r\n                        return await this._adapter.requestDevice(deviceDescriptor);\r\n                    }\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .then((device: GPUDevice) => {\r\n                    this._device = device;\r\n                    this._deviceEnabledExtensions = [];\r\n                    this._device.features?.forEach((feature) => {\r\n                        this._deviceEnabledExtensions.push(feature as WebGPUConstants.FeatureName);\r\n                    });\r\n                    this._deviceLimits = device.limits;\r\n\r\n                    let numUncapturedErrors = -1;\r\n                    this._device.addEventListener(\"uncapturederror\", (event) => {\r\n                        if (++numUncapturedErrors < this.numMaxUncapturedErrors) {\r\n                            Logger.Warn(`WebGPU uncaptured error (${numUncapturedErrors + 1}): ${(<GPUUncapturedErrorEvent>event).error} - ${(<any>event).error.message}`);\r\n                        } else if (numUncapturedErrors++ === this.numMaxUncapturedErrors) {\r\n                            Logger.Warn(\r\n                                `WebGPU uncaptured error: too many warnings (${this.numMaxUncapturedErrors}), no more warnings will be reported to the console for this engine.`\r\n                            );\r\n                        }\r\n                    });\r\n\r\n                    if (!this._doNotHandleContextLost) {\r\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                        this._device.lost?.then((info) => {\r\n                            if (this._isDisposed) {\r\n                                return;\r\n                            }\r\n                            this._contextWasLost = true;\r\n                            Logger.Warn(\"WebGPU context lost. \" + info);\r\n                            this.onContextLostObservable.notifyObservers(this);\r\n                            // eslint-disable-next-line @typescript-eslint/no-misused-promises\r\n                            this._restoreEngineAfterContextLost(async () => {\r\n                                const snapshotRenderingMode = this.snapshotRenderingMode;\r\n                                const snapshotRendering = this.snapshotRendering;\r\n                                const disableCacheSamplers = this.disableCacheSamplers;\r\n                                const disableCacheRenderPipelines = this.disableCacheRenderPipelines;\r\n                                const disableCacheBindGroups = this.disableCacheBindGroups;\r\n                                const enableGPUTimingMeasurements = this.enableGPUTimingMeasurements;\r\n\r\n                                await this.initAsync(this._glslangOptions ?? this._options?.glslangOptions, this._twgslOptions ?? this._options?.twgslOptions);\r\n\r\n                                this.snapshotRenderingMode = snapshotRenderingMode;\r\n                                this.snapshotRendering = snapshotRendering;\r\n                                this.disableCacheSamplers = disableCacheSamplers;\r\n                                this.disableCacheRenderPipelines = disableCacheRenderPipelines;\r\n                                this.disableCacheBindGroups = disableCacheBindGroups;\r\n                                this.enableGPUTimingMeasurements = enableGPUTimingMeasurements;\r\n                                this._currentRenderPass = null;\r\n                            });\r\n                        });\r\n                    }\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .then(() => {\r\n                    this._initializeLimits();\r\n\r\n                    this._bufferManager = new WebGPUBufferManager(this, this._device);\r\n                    this._textureHelper = new WebGPUTextureManager(this, this._device, this._bufferManager, this._deviceEnabledExtensions);\r\n                    this._cacheSampler = new WebGPUCacheSampler(this._device);\r\n                    this._cacheBindGroups = new WebGPUCacheBindGroups(this._device, this._cacheSampler, this);\r\n                    this._timestampQuery = new WebGPUTimestampQuery(this, this._device, this._bufferManager);\r\n                    this._occlusionQuery = (this._device as any).createQuerySet ? new WebGPUOcclusionQuery(this, this._device, this._bufferManager) : (undefined as any);\r\n                    this._bundleList = new WebGPUBundleList(this._device);\r\n                    this._snapshotRendering = new WebGPUSnapshotRendering(this, this._snapshotRenderingMode, this._bundleList);\r\n\r\n                    this._ubInvertY = this._bufferManager.createBuffer(\r\n                        new Float32Array([-1, 0]),\r\n                        WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst,\r\n                        \"UBInvertY\"\r\n                    );\r\n                    this._ubDontInvertY = this._bufferManager.createBuffer(\r\n                        new Float32Array([1, 0]),\r\n                        WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst,\r\n                        \"UBDontInvertY\"\r\n                    );\r\n\r\n                    if (this.dbgVerboseLogsForFirstFrames) {\r\n                        if ((this as any)._count === undefined) {\r\n                            (this as any)._count = 0;\r\n                            Logger.Log([\"%c frame #\" + (this as any)._count + \" - begin\", \"background: #ffff00\"]);\r\n                        }\r\n                    }\r\n\r\n                    this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\r\n                    this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\r\n\r\n                    this._emptyVertexBuffer = new VertexBuffer(this, [0], \"\", {\r\n                        stride: 1,\r\n                        offset: 0,\r\n                        size: 1,\r\n                        label: \"EmptyVertexBuffer\",\r\n                    });\r\n\r\n                    this._dummyIndexBuffer = this._bufferManager.createBuffer(\r\n                        new Uint16Array([0, 0, 0, 0]),\r\n                        WebGPUConstants.BufferUsage.Storage | WebGPUConstants.BufferUsage.CopyDst,\r\n                        \"DummyIndices\"\r\n                    );\r\n\r\n                    this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, this._emptyVertexBuffer);\r\n\r\n                    this._depthCullingState = new WebGPUDepthCullingState(this._cacheRenderPipeline);\r\n                    this._stencilStateComposer = new WebGPUStencilStateComposer(this._cacheRenderPipeline);\r\n                    this._stencilStateComposer.stencilGlobal = this._stencilState;\r\n\r\n                    this._depthCullingState.depthTest = true;\r\n                    this._depthCullingState.depthFunc = Constants.LEQUAL;\r\n                    this._depthCullingState.depthMask = true;\r\n\r\n                    this._textureHelper.setCommandEncoder(this._uploadEncoder);\r\n\r\n                    this._clearQuad = new WebGPUClearQuad(this._device, this, this._emptyVertexBuffer);\r\n                    this._defaultDrawContext = this.createDrawContext()!;\r\n                    this._currentDrawContext = this._defaultDrawContext;\r\n                    this._defaultMaterialContext = this.createMaterialContext()!;\r\n                    this._currentMaterialContext = this._defaultMaterialContext;\r\n\r\n                    this._initializeContextAndSwapChain();\r\n                    this._initializeMainAttachments();\r\n                    this.resize();\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .catch((e: any) => {\r\n                    Logger.Error(\"A fatal error occurred during WebGPU creation/initialization.\");\r\n                    throw e;\r\n                })\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _initGlslangAsync(glslangOptions?: GlslangOptions): Promise<any> {\r\n        glslangOptions = glslangOptions || {};\r\n        glslangOptions = {\r\n            ...WebGPUEngine._GlslangDefaultOptions,\r\n            ...glslangOptions,\r\n        };\r\n\r\n        if (glslangOptions.glslang) {\r\n            return glslangOptions.glslang;\r\n        }\r\n\r\n        if ((self as any).glslang) {\r\n            return (self as any).glslang(glslangOptions.wasmPath);\r\n        }\r\n\r\n        if (glslangOptions.jsPath && glslangOptions.wasmPath) {\r\n            // eslint-disable-next-line github/no-then\r\n            return Tools.LoadBabylonScriptAsync(glslangOptions.jsPath).then(() => {\r\n                return (self as any).glslang(Tools.GetBabylonScriptURL(glslangOptions.wasmPath!));\r\n            });\r\n        }\r\n\r\n        throw new Error(\"glslang is not available\");\r\n    }\r\n\r\n    private _initializeLimits(): void {\r\n        // Init caps\r\n        const textureFormatsTier1 = this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureFormatsTier1) >= 0;\r\n\r\n        this._caps = {\r\n            maxTexturesImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage,\r\n            maxVertexTextureImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage,\r\n            maxCombinedTexturesImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage * 2,\r\n            maxTextureSize: this._deviceLimits.maxTextureDimension2D,\r\n            maxCubemapTextureSize: this._deviceLimits.maxTextureDimension2D,\r\n            maxRenderTextureSize: this._deviceLimits.maxTextureDimension2D,\r\n            maxVertexAttribs: this._deviceLimits.maxVertexAttributes,\r\n            maxDrawBuffers: 8,\r\n            maxVaryingVectors: this._deviceLimits.maxInterStageShaderVariables,\r\n            maxFragmentUniformVectors: Math.floor(this._deviceLimits.maxUniformBufferBindingSize / 4),\r\n            maxVertexUniformVectors: Math.floor(this._deviceLimits.maxUniformBufferBindingSize / 4),\r\n            shaderFloatPrecision: 23, // WGSL always uses IEEE-754 binary32 floats (which have 23 bits of significand)\r\n            standardDerivatives: true,\r\n            astc: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionASTC) >= 0 ? true : undefined) as any,\r\n            s3tc: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined) as any,\r\n            pvrtc: null,\r\n            etc1: null,\r\n            etc2: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionETC2) >= 0 ? true : undefined) as any,\r\n            bptc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined,\r\n            maxAnisotropy: 16, // Most implementations support maxAnisotropy values in range between 1 and 16, inclusive. The used value of maxAnisotropy will be clamped to the maximum value that the platform supports.\r\n            uintIndices: true,\r\n            fragmentDepthSupported: true,\r\n            highPrecisionShaderSupported: true,\r\n            colorBufferFloat: true,\r\n            blendFloat: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.Float32Blendable) >= 0,\r\n            supportFloatTexturesResolve: false, // See https://github.com/gpuweb/gpuweb/issues/3844\r\n            rg11b10ufColorRenderable: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.RG11B10UFloatRenderable) >= 0,\r\n            textureFloat: true,\r\n            textureFloatLinearFiltering: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.Float32Filterable) >= 0,\r\n            textureFloatRender: true,\r\n            textureHalfFloat: true,\r\n            textureHalfFloatLinearFiltering: true,\r\n            textureHalfFloatRender: true,\r\n            textureLOD: true,\r\n            texelFetch: true,\r\n            drawBuffersExtension: true,\r\n            depthTextureExtension: true,\r\n            vertexArrayObject: false,\r\n            instancedArrays: true,\r\n            timerQuery:\r\n                typeof BigUint64Array !== \"undefined\" && this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TimestampQuery) !== -1 ? (true as any) : undefined,\r\n            supportOcclusionQuery: typeof BigUint64Array !== \"undefined\",\r\n            canUseTimestampForTimerQuery: true,\r\n            multiview: false,\r\n            oculusMultiview: false,\r\n            parallelShaderCompile: undefined,\r\n            blendMinMax: true,\r\n            maxMSAASamples: 4, // the spec only supports values of 1 and 4\r\n            canUseGLInstanceID: true,\r\n            canUseGLVertexID: true,\r\n            supportComputeShaders: true,\r\n            supportSRGBBuffers: true,\r\n            supportTransformFeedbacks: false,\r\n            textureMaxLevel: true,\r\n            texture2DArrayMaxLayerCount: this._deviceLimits.maxTextureArrayLayers,\r\n            disableMorphTargetTexture: false,\r\n            textureNorm16: textureFormatsTier1,\r\n            blendParametersPerTarget: true,\r\n            dualSourceBlending: true,\r\n        };\r\n\r\n        this._features = {\r\n            forceBitmapOverHTMLImageElement: true,\r\n            supportRenderAndCopyToLodForFloatTextures: true,\r\n            supportDepthStencilTexture: true,\r\n            supportShadowSamplers: true,\r\n            uniformBufferHardCheckMatrix: false,\r\n            allowTexturePrefiltering: true,\r\n            trackUbosInFrame: true,\r\n            checkUbosContentBeforeUpload: true,\r\n            supportCSM: true,\r\n            basisNeedsPOT: false,\r\n            support3DTextures: true,\r\n            needTypeSuffixInShaderConstants: true,\r\n            supportMSAA: true,\r\n            supportSSAO2: true,\r\n            supportIBLShadows: true,\r\n            supportExtendedTextureFormats: true,\r\n            supportSwitchCaseInShader: true,\r\n            supportSyncTextureRead: false,\r\n            needsInvertingBitmap: false,\r\n            useUBOBindingCache: false,\r\n            needShaderCodeInlining: true,\r\n            needToAlwaysBindUniformBuffers: true,\r\n            supportRenderPasses: true,\r\n            supportSpriteInstancing: true,\r\n            forceVertexBufferStrideAndOffsetMultiple4Bytes: true,\r\n            _checkNonFloatVertexBuffersDontRecreatePipelineContext: true,\r\n            _collectUbosUpdatedInFrame: false,\r\n        };\r\n\r\n        this._alphaState = new AlphaState(this._caps.blendParametersPerTarget);\r\n    }\r\n\r\n    private _initializeContextAndSwapChain(): void {\r\n        if (!this._renderingCanvas) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"The rendering canvas has not been set!\";\r\n        }\r\n        this._context = this._renderingCanvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\r\n        this._configureContext();\r\n        this._colorFormat = this._options.swapChainFormat!;\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures = [new WebGPUHardwareTexture(this)];\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures[0]!.format = this._colorFormat;\r\n        this._setColorFormat(this._mainRenderPassWrapper);\r\n    }\r\n\r\n    // Set default values as WebGL with depth and stencil attachment for the broadest Compat.\r\n    private _initializeMainAttachments(): void {\r\n        if (!this._bufferManager) {\r\n            return;\r\n        }\r\n\r\n        this.flushFramebuffer();\r\n\r\n        this._mainTextureExtends = {\r\n            width: this.getRenderWidth(true),\r\n            height: this.getRenderHeight(true),\r\n            depthOrArrayLayers: 1,\r\n        };\r\n\r\n        const bufferDataUpdate = new Float32Array([this.getRenderHeight(true)]);\r\n\r\n        this._bufferManager.setSubData(this._ubInvertY, 4, bufferDataUpdate);\r\n        this._bufferManager.setSubData(this._ubDontInvertY, 4, bufferDataUpdate);\r\n\r\n        let mainColorAttachments: GPURenderPassColorAttachment[];\r\n\r\n        if (this._options.antialias) {\r\n            const mainTextureDescriptor: GPUTextureDescriptor = {\r\n                label: `Texture_MainColor_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}_antialiasing`,\r\n                size: this._mainTextureExtends,\r\n                mipLevelCount: 1,\r\n                sampleCount: this._mainPassSampleCount,\r\n                dimension: WebGPUConstants.TextureDimension.E2d,\r\n                format: this._options.swapChainFormat!,\r\n                usage: WebGPUConstants.TextureUsage.RenderAttachment,\r\n            };\r\n\r\n            if (this._mainTexture) {\r\n                this._textureHelper.releaseTexture(this._mainTexture);\r\n            }\r\n            this._mainTexture = this._device.createTexture(mainTextureDescriptor);\r\n            mainColorAttachments = [\r\n                {\r\n                    view: this._mainTexture.createView({\r\n                        label: \"TextureView_MainColor_antialiasing\",\r\n                        dimension: WebGPUConstants.TextureDimension.E2d,\r\n                        format: this._options.swapChainFormat!,\r\n                        mipLevelCount: 1,\r\n                        arrayLayerCount: 1,\r\n                    }),\r\n                    clearValue: new Color4(0, 0, 0, 1),\r\n                    loadOp: WebGPUConstants.LoadOp.Clear,\r\n                    storeOp: WebGPUConstants.StoreOp.Store, // don't use StoreOp.Discard, else using several cameras with different viewports or using scissors will fail because we call beginRenderPass / endPass several times for the same color attachment!\r\n                },\r\n            ];\r\n        } else {\r\n            mainColorAttachments = [\r\n                {\r\n                    view: undefined as any,\r\n                    clearValue: new Color4(0, 0, 0, 1),\r\n                    loadOp: WebGPUConstants.LoadOp.Clear,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ];\r\n        }\r\n\r\n        this._mainRenderPassWrapper.depthTextureFormat = this.isStencilEnable ? WebGPUConstants.TextureFormat.Depth24PlusStencil8 : WebGPUConstants.TextureFormat.Depth32Float;\r\n\r\n        this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n        this._setColorFormat(this._mainRenderPassWrapper);\r\n\r\n        const depthTextureDescriptor: GPUTextureDescriptor = {\r\n            label: `Texture_MainDepthStencil_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}`,\r\n            size: this._mainTextureExtends,\r\n            mipLevelCount: 1,\r\n            sampleCount: this._mainPassSampleCount,\r\n            dimension: WebGPUConstants.TextureDimension.E2d,\r\n            format: this._mainRenderPassWrapper.depthTextureFormat,\r\n            usage: WebGPUConstants.TextureUsage.RenderAttachment,\r\n        };\r\n\r\n        if (this._depthTexture) {\r\n            this._textureHelper.releaseTexture(this._depthTexture);\r\n        }\r\n        this._depthTexture = this._device.createTexture(depthTextureDescriptor);\r\n        const mainDepthAttachment: GPURenderPassDepthStencilAttachment = {\r\n            view: this._depthTexture.createView({\r\n                label: `TextureView_MainDepthStencil_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}`,\r\n                dimension: WebGPUConstants.TextureDimension.E2d,\r\n                format: this._depthTexture.format,\r\n                mipLevelCount: 1,\r\n                arrayLayerCount: 1,\r\n            }),\r\n\r\n            depthClearValue: this._clearDepthValue,\r\n            depthLoadOp: WebGPUConstants.LoadOp.Clear,\r\n            depthStoreOp: WebGPUConstants.StoreOp.Store,\r\n            stencilClearValue: this._clearStencilValue,\r\n            stencilLoadOp: !this.isStencilEnable ? undefined : WebGPUConstants.LoadOp.Clear,\r\n            stencilStoreOp: !this.isStencilEnable ? undefined : WebGPUConstants.StoreOp.Store,\r\n        };\r\n\r\n        this._mainRenderPassWrapper.renderPassDescriptor = {\r\n            label: \"MainRenderPass\",\r\n            colorAttachments: mainColorAttachments,\r\n            depthStencilAttachment: mainDepthAttachment,\r\n        };\r\n\r\n        this.beginFrame();\r\n        this._startMainRenderPass(true, null, true, false);\r\n        this._endCurrentRenderPass();\r\n        this.endFrame();\r\n        this._frameId--; // We don't want to count the frame as a real frame, because it was only used to initialize the depth texture\r\n    }\r\n\r\n    /**\r\n     * Shared initialization across engines types.\r\n     * @param canvas The canvas associated with this instance of the engine.\r\n     */\r\n    protected override _sharedInit(canvas: HTMLCanvasElement) {\r\n        super._sharedInit(canvas);\r\n\r\n        _CommonInit(this, canvas, this._creationOptions);\r\n    }\r\n\r\n    private _configureContext(): void {\r\n        this._context.configure({\r\n            device: this._device,\r\n            format: this._options.swapChainFormat!,\r\n            usage: WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.CopySrc,\r\n            alphaMode: this.premultipliedAlpha ? WebGPUConstants.CanvasAlphaMode.Premultiplied : WebGPUConstants.CanvasAlphaMode.Opaque,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Resize an image and returns the image data as an uint8array\r\n     * @param image image to resize\r\n     * @param bufferWidth destination buffer width\r\n     * @param bufferHeight destination buffer height\r\n     * @returns an uint8array containing RGBA values of bufferWidth * bufferHeight size\r\n     */\r\n    public override resizeImageBitmap(image: HTMLImageElement | ImageBitmap, bufferWidth: number, bufferHeight: number): Uint8Array {\r\n        return ResizeImageBitmap(this, image, bufferWidth, bufferHeight);\r\n    }\r\n\r\n    /**\r\n     * Engine abstraction for loading and creating an image bitmap from a given source string.\r\n     * @param imageSource source to load the image from.\r\n     * @param options An object that sets options for the image's extraction.\r\n     * @returns ImageBitmap\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public override async _createImageBitmapFromSource(imageSource: string, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        return await CreateImageBitmapFromSource(this, imageSource, options);\r\n    }\r\n\r\n    /**\r\n     * Toggle full screen mode\r\n     * @param requestPointerLock defines if a pointer lock should be requested from the user\r\n     */\r\n    public override switchFullscreen(requestPointerLock: boolean): void {\r\n        if (this.isFullscreen) {\r\n            this.exitFullscreen();\r\n        } else {\r\n            this.enterFullscreen(requestPointerLock);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enters full screen mode\r\n     * @param requestPointerLock defines if a pointer lock should be requested from the user\r\n     */\r\n    public override enterFullscreen(requestPointerLock: boolean): void {\r\n        if (!this.isFullscreen) {\r\n            this._pointerLockRequested = requestPointerLock;\r\n            if (this._renderingCanvas) {\r\n                RequestFullscreen(this._renderingCanvas);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exits full screen mode\r\n     */\r\n    public override exitFullscreen(): void {\r\n        if (this.isFullscreen) {\r\n            ExitFullscreen();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enters Pointerlock mode\r\n     */\r\n    public enterPointerlock(): void {\r\n        if (this._renderingCanvas) {\r\n            RequestPointerlock(this._renderingCanvas);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exits Pointerlock mode\r\n     */\r\n    public exitPointerlock(): void {\r\n        ExitPointerlock();\r\n    }\r\n\r\n    protected override _rebuildBuffers(): void {\r\n        super._rebuildBuffers();\r\n\r\n        for (const storageBuffer of this._storageBuffers) {\r\n            // The buffer can already be rebuilt by the call to _rebuildGeometries(), which recreates the storage buffers for the ComputeShaderParticleSystem\r\n            if ((storageBuffer.getBuffer() as WebGPUDataBuffer).engineId !== this.uniqueId) {\r\n                storageBuffer._rebuild();\r\n            }\r\n        }\r\n    }\r\n\r\n    protected override _restoreEngineAfterContextLost(initEngine: () => void) {\r\n        WebGPUCacheRenderPipelineTree.ResetCache();\r\n        WebGPUCacheBindGroups.ResetCache();\r\n\r\n        // Clear the draw wrappers and material contexts\r\n        const cleanScenes = (scenes: Scene[]) => {\r\n            for (const scene of scenes) {\r\n                for (const mesh of scene.meshes) {\r\n                    const subMeshes = mesh.subMeshes;\r\n                    if (!subMeshes) {\r\n                        continue;\r\n                    }\r\n                    for (const subMesh of subMeshes) {\r\n                        subMesh._drawWrappers = [];\r\n                    }\r\n                }\r\n\r\n                for (const material of scene.materials) {\r\n                    material._materialContext?.reset();\r\n                }\r\n            }\r\n        };\r\n\r\n        cleanScenes(this.scenes);\r\n        cleanScenes(this._virtualScenes);\r\n\r\n        // The leftOver uniform buffers are removed from the list because they will be recreated when we rebuild the effects\r\n        const uboList: UniformBuffer[] = [];\r\n        for (const uniformBuffer of this._uniformBuffers) {\r\n            if (uniformBuffer.name.indexOf(\"leftOver\") < 0) {\r\n                uboList.push(uniformBuffer);\r\n            }\r\n        }\r\n        this._uniformBuffers = uboList;\r\n\r\n        super._restoreEngineAfterContextLost(initEngine);\r\n    }\r\n\r\n    /**\r\n     * Force a specific size of the canvas\r\n     * @param width defines the new canvas' width\r\n     * @param height defines the new canvas' height\r\n     * @param forceSetSize true to force setting the sizes of the underlying canvas\r\n     * @returns true if the size was changed\r\n     */\r\n    public override setSize(width: number, height: number, forceSetSize = false): boolean {\r\n        if (!super.setSize(width, height, forceSetSize)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log([\"frame #\" + (this as any)._count + \" - setSize -\", width, height]);\r\n            }\r\n        }\r\n\r\n        this._initializeMainAttachments();\r\n\r\n        if (this.snapshotRendering) {\r\n            // reset snapshot rendering so that the next frame will record a new list of bundles\r\n            this.snapshotRenderingReset();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _shaderProcessorWGSL: Nullable<IShaderProcessor>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _getShaderProcessor(shaderLanguage: ShaderLanguage): Nullable<IShaderProcessor> {\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            return this._shaderProcessorWGSL;\r\n        }\r\n        return this._shaderProcessor;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getShaderProcessingContext(shaderLanguage: ShaderLanguage, pureMode: boolean): Nullable<_IShaderProcessingContext> {\r\n        return new WebGPUShaderProcessingContext(shaderLanguage, pureMode);\r\n    }\r\n\r\n    private _getCurrentRenderPass(): GPURenderPassEncoder {\r\n        if (this._currentRenderTarget && !this._currentRenderPass) {\r\n            // delayed creation of the render target pass, but we now need to create it as we are requested the render pass\r\n            this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);\r\n        } else if (!this._currentRenderPass) {\r\n            this._startMainRenderPass(false);\r\n        }\r\n\r\n        return this._currentRenderPass!;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getCurrentRenderPassWrapper() {\r\n        return this._currentRenderTarget ? this._rttRenderPassWrapper : this._mainRenderPassWrapper;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                          Static Pipeline WebGPU States\r\n    //------------------------------------------------------------------------------\r\n\r\n    /** @internal */\r\n    public applyStates() {\r\n        this._stencilStateComposer.apply();\r\n        this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState._alphaBlend, this._alphaState._numTargetEnabled);\r\n    }\r\n\r\n    /**\r\n     * Force the entire cache to be cleared\r\n     * You should not have to use this function unless your engine needs to share the WebGPU context with another engine\r\n     * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\r\n     */\r\n    public wipeCaches(bruteForce?: boolean): void {\r\n        if (this.preventCacheWipeBetweenFrames && !bruteForce) {\r\n            return;\r\n        }\r\n\r\n        //this._currentEffect = null; // can't reset _currentEffect, else some crashes can occur (for eg in ProceduralTexture which calls bindFrameBuffer (which calls wipeCaches) after having called enableEffect and before drawing into the texture)\r\n        // _forceEnableEffect = true assumes the role of _currentEffect = null\r\n        this._forceEnableEffect = true;\r\n        this._currentIndexBuffer = null;\r\n        this._currentOverrideVertexBuffers = null;\r\n        this._cacheRenderPipeline.setBuffers(null, null, null);\r\n\r\n        if (bruteForce) {\r\n            this._stencilStateComposer.reset();\r\n\r\n            this._depthCullingState.reset();\r\n            this._depthCullingState.depthFunc = Constants.LEQUAL;\r\n\r\n            this._alphaState.reset();\r\n            this._resetAlphaMode();\r\n            this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\r\n            this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState._alphaBlend, this._alphaState._numTargetEnabled);\r\n\r\n            this.setColorWrite(true);\r\n        }\r\n\r\n        this._cachedVertexBuffers = null;\r\n        this._cachedIndexBuffer = null;\r\n        this._cachedEffectForVertexBuffers = null;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable color writing\r\n     * @param enable defines the state to set\r\n     */\r\n    public override setColorWrite(enable: boolean): void {\r\n        this._colorWriteLocal = enable;\r\n        this._cacheRenderPipeline.setWriteMask(enable ? 0xf : 0);\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if color writing is enabled\r\n     * @returns the current color writing state\r\n     */\r\n    public override getColorWrite(): boolean {\r\n        return this._colorWriteLocal;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dynamic WebGPU States\r\n    //------------------------------------------------------------------------------\r\n\r\n    // index 0 is for main render pass, 1 for RTT render pass\r\n    private _viewportsCurrent: { x: number; y: number; w: number; h: number } = { x: 0, y: 0, w: 0, h: 0 };\r\n\r\n    private _mustUpdateViewport(): boolean {\r\n        const x = this._viewportCached.x,\r\n            y = this._viewportCached.y,\r\n            w = this._viewportCached.z,\r\n            h = this._viewportCached.w;\r\n\r\n        const update = this._viewportsCurrent.x !== x || this._viewportsCurrent.y !== y || this._viewportsCurrent.w !== w || this._viewportsCurrent.h !== h;\r\n\r\n        if (update) {\r\n            this._viewportsCurrent.x = this._viewportCached.x;\r\n            this._viewportsCurrent.y = this._viewportCached.y;\r\n            this._viewportsCurrent.w = this._viewportCached.z;\r\n            this._viewportsCurrent.h = this._viewportCached.w;\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyViewport(bundleList: Nullable<WebGPUBundleList>): void {\r\n        const x = Math.floor(this._viewportCached.x);\r\n        const w = Math.floor(this._viewportCached.z);\r\n        const h = Math.floor(this._viewportCached.w);\r\n\r\n        let y = Math.floor(this._viewportCached.y);\r\n\r\n        if (!this._currentRenderTarget) {\r\n            y = this.getRenderHeight(true) - y - h;\r\n        }\r\n\r\n        if (bundleList) {\r\n            bundleList.addItem(new WebGPURenderItemViewport(x, y, w, h));\r\n        } else {\r\n            this._getCurrentRenderPass().setViewport(x, y, w, h, 0, 1);\r\n        }\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log([\r\n                    \"frame #\" + (this as any)._count + \" - viewport applied - (\",\r\n                    this._viewportCached.x,\r\n                    this._viewportCached.y,\r\n                    this._viewportCached.z,\r\n                    this._viewportCached.w,\r\n                    \") current pass is main pass=\" + this._currentPassIsMainPass(),\r\n                ]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _viewport(x: number, y: number, width: number, height: number): void {\r\n        this._viewportCached.x = x;\r\n        this._viewportCached.y = y;\r\n        this._viewportCached.z = width;\r\n        this._viewportCached.w = height;\r\n    }\r\n\r\n    private _scissorsCurrent: { x: number; y: number; w: number; h: number } = { x: 0, y: 0, w: 0, h: 0 };\r\n    protected _scissorCached = { x: 0, y: 0, z: 0, w: 0 };\r\n\r\n    private _mustUpdateScissor(): boolean {\r\n        const x = this._scissorCached.x,\r\n            y = this._scissorCached.y,\r\n            w = this._scissorCached.z,\r\n            h = this._scissorCached.w;\r\n\r\n        const update = this._scissorsCurrent.x !== x || this._scissorsCurrent.y !== y || this._scissorsCurrent.w !== w || this._scissorsCurrent.h !== h;\r\n\r\n        if (update) {\r\n            this._scissorsCurrent.x = this._scissorCached.x;\r\n            this._scissorsCurrent.y = this._scissorCached.y;\r\n            this._scissorsCurrent.w = this._scissorCached.z;\r\n            this._scissorsCurrent.h = this._scissorCached.w;\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyScissor(bundleList: Nullable<WebGPUBundleList>): void {\r\n        const y = this._currentRenderTarget ? this._scissorCached.y : this.getRenderHeight() - this._scissorCached.w - this._scissorCached.y;\r\n\r\n        if (bundleList) {\r\n            bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, y, this._scissorCached.z, this._scissorCached.w));\r\n        } else {\r\n            this._getCurrentRenderPass().setScissorRect(this._scissorCached.x, y, this._scissorCached.z, this._scissorCached.w);\r\n        }\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log([\r\n                    \"frame #\" + (this as any)._count + \" - scissor applied - (\",\r\n                    this._scissorCached.x,\r\n                    this._scissorCached.y,\r\n                    this._scissorCached.z,\r\n                    this._scissorCached.w,\r\n                    \") current pass is main pass=\" + this._currentPassIsMainPass(),\r\n                ]);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _scissorIsActive() {\r\n        return this._scissorCached.x !== 0 || this._scissorCached.y !== 0 || this._scissorCached.z !== 0 || this._scissorCached.w !== 0;\r\n    }\r\n\r\n    public enableScissor(x: number, y: number, width: number, height: number): void {\r\n        this._scissorCached.x = x;\r\n        this._scissorCached.y = y;\r\n        this._scissorCached.z = width;\r\n        this._scissorCached.w = height;\r\n    }\r\n\r\n    public disableScissor() {\r\n        this._scissorCached.x = this._scissorCached.y = this._scissorCached.z = this._scissorCached.w = 0;\r\n        this._scissorsCurrent.x = this._scissorsCurrent.y = this._scissorsCurrent.w = this._scissorsCurrent.h = 0;\r\n    }\r\n\r\n    private _stencilRefsCurrent = -1;\r\n\r\n    private _mustUpdateStencilRef(): boolean {\r\n        const update = this._stencilStateComposer.funcRef !== this._stencilRefsCurrent;\r\n        if (update) {\r\n            this._stencilRefsCurrent = this._stencilStateComposer.funcRef;\r\n        }\r\n        return update;\r\n    }\r\n\r\n    private _applyStencilRef(bundleList: Nullable<WebGPUBundleList>): void {\r\n        if (bundleList) {\r\n            bundleList.addItem(new WebGPURenderItemStencilRef(this._stencilStateComposer.funcRef ?? 0));\r\n        } else {\r\n            this._getCurrentRenderPass().setStencilReference(this._stencilStateComposer.funcRef ?? 0);\r\n        }\r\n    }\r\n\r\n    private _blendColorsCurrent: Array<Nullable<number>> = [null, null, null, null];\r\n\r\n    private _mustUpdateBlendColor(): boolean {\r\n        const colorBlend = this._alphaState._blendConstants;\r\n\r\n        const update =\r\n            colorBlend[0] !== this._blendColorsCurrent[0] ||\r\n            colorBlend[1] !== this._blendColorsCurrent[1] ||\r\n            colorBlend[2] !== this._blendColorsCurrent[2] ||\r\n            colorBlend[3] !== this._blendColorsCurrent[3];\r\n\r\n        if (update) {\r\n            this._blendColorsCurrent[0] = colorBlend[0];\r\n            this._blendColorsCurrent[1] = colorBlend[1];\r\n            this._blendColorsCurrent[2] = colorBlend[2];\r\n            this._blendColorsCurrent[3] = colorBlend[3];\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyBlendColor(bundleList: Nullable<WebGPUBundleList>): void {\r\n        if (bundleList) {\r\n            bundleList.addItem(new WebGPURenderItemBlendColor(this._alphaState._blendConstants.slice()));\r\n        } else {\r\n            this._getCurrentRenderPass().setBlendConstant(this._alphaState._blendConstants as GPUColor);\r\n        }\r\n    }\r\n\r\n    private _resetRenderPassStates() {\r\n        this._viewportsCurrent.x = this._viewportsCurrent.y = this._viewportsCurrent.w = this._viewportsCurrent.h = 0;\r\n        this._scissorsCurrent.x = this._scissorsCurrent.y = this._scissorsCurrent.w = this._scissorsCurrent.h = 0;\r\n        this._stencilRefsCurrent = -1;\r\n        this._blendColorsCurrent[0] = this._blendColorsCurrent[1] = this._blendColorsCurrent[2] = this._blendColorsCurrent[3] = null;\r\n    }\r\n\r\n    /**\r\n     * Clear the current render buffer or the current render target (if any is set up)\r\n     * @param color defines the color to use\r\n     * @param backBuffer defines if the back buffer must be cleared\r\n     * @param depth defines if the depth buffer must be cleared\r\n     * @param stencil defines if the stencil buffer must be cleared\r\n     * @param stencilClearValue defines the value to use to clear the stencil buffer (default is 0)\r\n     */\r\n    public clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil: boolean = false, stencilClearValue = 0): void {\r\n        // Some PGs are using color3...\r\n        if (color && color.a === undefined) {\r\n            color.a = 1;\r\n        }\r\n\r\n        if (stencil) {\r\n            this._clearStencilValue = stencilClearValue;\r\n        }\r\n\r\n        const hasScissor = this._scissorIsActive();\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log([\"frame #\" + (this as any)._count + \" - clear - backBuffer=\", backBuffer, \" depth=\", depth, \" stencil=\", stencil, \" scissor is active=\", hasScissor]);\r\n            }\r\n        }\r\n\r\n        // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\r\n        if (this._currentRenderTarget) {\r\n            if (hasScissor) {\r\n                if (!this._currentRenderPass) {\r\n                    this._startRenderTargetRenderPass(this._currentRenderTarget, false, backBuffer ? color : null, depth, stencil);\r\n                }\r\n                this._applyScissor(!this.compatibilityMode ? this._bundleList : null);\r\n                this._clearFullQuad(backBuffer ? color : null, depth, stencil);\r\n            } else {\r\n                if (this._currentRenderPass) {\r\n                    this._endCurrentRenderPass();\r\n                }\r\n                this._startRenderTargetRenderPass(this._currentRenderTarget, true, backBuffer ? color : null, depth, stencil);\r\n            }\r\n        } else {\r\n            if (!this._currentRenderPass || !hasScissor) {\r\n                this._startMainRenderPass(!hasScissor, backBuffer ? color : null, depth, stencil);\r\n            }\r\n            if (hasScissor) {\r\n                this._applyScissor(!this.compatibilityMode ? this._bundleList : null);\r\n                this._clearFullQuad(backBuffer ? color : null, depth, stencil);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _clearFullQuad(clearColor?: Nullable<IColor4Like>, clearDepth?: boolean, clearStencil?: boolean): void {\r\n        const renderPass = !this.compatibilityMode ? null : this._getCurrentRenderPass();\r\n\r\n        this._clearQuad.setColorFormat(this._colorFormat);\r\n        this._clearQuad.setDepthStencilFormat(this._depthTextureFormat);\r\n        this._clearQuad.setMRTAttachments(\r\n            this._cacheRenderPipeline.mrtAttachments ?? [],\r\n            this._cacheRenderPipeline.mrtTextureArray ?? [],\r\n            this._cacheRenderPipeline.mrtTextureCount\r\n        );\r\n\r\n        if (!this.compatibilityMode) {\r\n            this._bundleList.addItem(new WebGPURenderItemStencilRef(this._clearStencilValue));\r\n        } else {\r\n            renderPass!.setStencilReference(this._clearStencilValue);\r\n        }\r\n\r\n        const bundle = this._clearQuad.clear(renderPass, clearColor, clearDepth, clearStencil, this.currentSampleCount);\r\n\r\n        if (!this.compatibilityMode) {\r\n            this._bundleList.addBundle(bundle!);\r\n            this._applyStencilRef(this._bundleList);\r\n            this._reportDrawCall();\r\n        } else {\r\n            this._applyStencilRef(null);\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Vertex/Index/Storage Buffers\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param data the data or the size for the vertex buffer\r\n     * @param _updatable whether the buffer should be created as updatable\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns the new buffer\r\n     */\r\n    public createVertexBuffer(data: DataArray | number, _updatable?: boolean, label?: string): DataBuffer {\r\n        let view: ArrayBufferView | number;\r\n\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n\r\n        const dataBuffer = this._bufferManager.createBuffer(\r\n            view,\r\n            WebGPUConstants.BufferUsage.Vertex | WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.Storage,\r\n            label\r\n        );\r\n        return dataBuffer;\r\n    }\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param data the data for the dynamic vertex buffer\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns the new buffer\r\n     */\r\n    public createDynamicVertexBuffer(data: DataArray, label?: string): DataBuffer {\r\n        return this.createVertexBuffer(data, undefined, label);\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the content of the index buffer\r\n     * @param _updatable defines if the index buffer must be updatable\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns a new buffer\r\n     */\r\n    public createIndexBuffer(indices: IndicesArray, _updatable?: boolean, label?: string): DataBuffer {\r\n        let is32Bits = true;\r\n        let view: ArrayBufferView | undefined;\r\n\r\n        if (indices instanceof Uint32Array || indices instanceof Int32Array) {\r\n            view = indices;\r\n        } else if (indices instanceof Uint16Array) {\r\n            view = indices;\r\n            is32Bits = false;\r\n        } else {\r\n            for (let index = 0; index < indices.length; index++) {\r\n                if (indices[index] > 65535) {\r\n                    view = new Uint32Array(indices);\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!view) {\r\n                view = new Uint16Array(indices);\r\n                is32Bits = false;\r\n            }\r\n        }\r\n\r\n        const dataBuffer = this._bufferManager.createBuffer(\r\n            view,\r\n            WebGPUConstants.BufferUsage.Index | WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.Storage,\r\n            label\r\n        );\r\n        dataBuffer.is32Bits = is32Bits;\r\n        return dataBuffer;\r\n    }\r\n\r\n    /**\r\n     * Update a dynamic index buffer\r\n     * @param indexBuffer defines the target index buffer\r\n     * @param indices defines the data to update\r\n     * @param offset defines the offset in the target index buffer where update should start\r\n     */\r\n    public override updateDynamicIndexBuffer(indexBuffer: DataBuffer, indices: IndicesArray, offset: number = 0): void {\r\n        const gpuBuffer = indexBuffer as WebGPUDataBuffer;\r\n\r\n        let view: ArrayBufferView;\r\n        if (indexBuffer.is32Bits) {\r\n            view = indices instanceof Uint32Array ? indices : new Uint32Array(indices);\r\n        } else {\r\n            view = indices instanceof Uint16Array ? indices : new Uint16Array(indices);\r\n        }\r\n\r\n        this._bufferManager.setSubData(gpuBuffer, offset, view);\r\n    }\r\n\r\n    /**\r\n     * Updates a dynamic vertex buffer.\r\n     * @param vertexBuffer the vertex buffer to update\r\n     * @param data the data used to update the vertex buffer\r\n     * @param byteOffset the byte offset of the data\r\n     * @param byteLength the byte length of the data\r\n     */\r\n    public override updateDynamicVertexBuffer(vertexBuffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n        const dataBuffer = vertexBuffer as WebGPUDataBuffer;\r\n        if (byteOffset === undefined) {\r\n            byteOffset = 0;\r\n        }\r\n\r\n        let view: ArrayBufferView;\r\n        if (byteLength === undefined) {\r\n            if (data instanceof Array) {\r\n                view = new Float32Array(data);\r\n            } else if (data instanceof ArrayBuffer) {\r\n                view = new Uint8Array(data);\r\n            } else {\r\n                view = data;\r\n            }\r\n            byteLength = view.byteLength;\r\n        } else {\r\n            if (data instanceof Array) {\r\n                view = new Float32Array(data);\r\n            } else if (data instanceof ArrayBuffer) {\r\n                view = new Uint8Array(data);\r\n            } else {\r\n                view = data;\r\n            }\r\n        }\r\n\r\n        this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _createBuffer(data: DataArray | number, creationFlags: number, label?: string): DataBuffer {\r\n        let view: ArrayBufferView | number;\r\n\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n\r\n        let flags = 0;\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_READ) {\r\n            flags |= WebGPUConstants.BufferUsage.CopySrc;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_WRITE) {\r\n            flags |= WebGPUConstants.BufferUsage.CopyDst;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_UNIFORM) {\r\n            flags |= WebGPUConstants.BufferUsage.Uniform;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_VERTEX) {\r\n            flags |= WebGPUConstants.BufferUsage.Vertex;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_INDEX) {\r\n            flags |= WebGPUConstants.BufferUsage.Index;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_STORAGE) {\r\n            flags |= WebGPUConstants.BufferUsage.Storage;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_INDIRECT) {\r\n            flags |= WebGPUConstants.BufferUsage.Indirect;\r\n        }\r\n\r\n        return this._bufferManager.createBuffer(view, flags, label);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public bindBuffersDirectly(): void {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"Not implemented on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public updateAndBindInstancesBuffer(): void {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"Not implemented on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * Unbind all instance attributes\r\n     */\r\n    public unbindInstanceAttributes(): void {\r\n        // Does nothing\r\n    }\r\n\r\n    /**\r\n     * Bind a list of vertex buffers with the engine\r\n     * @param vertexBuffers defines the list of vertex buffers to bind\r\n     * @param indexBuffer defines the index buffer to bind\r\n     * @param _effect defines the effect associated with the vertex buffers\r\n     * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers\r\n     */\r\n    public bindBuffers(\r\n        vertexBuffers: { [key: string]: Nullable<VertexBuffer> },\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        _effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): void {\r\n        this._currentVertexBuffers = vertexBuffers;\r\n        this._currentIndexBuffer = indexBuffer;\r\n        this._currentOverrideVertexBuffers = overrideVertexBuffers ?? null;\r\n        this._cacheRenderPipeline.setBuffers(this._currentVertexBuffers, this._currentIndexBuffer, this._currentOverrideVertexBuffers);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseBuffer(buffer: DataBuffer): boolean {\r\n        return this._bufferManager.releaseBuffer(buffer);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Uniform Buffers\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Create an uniform buffer\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param elements defines the content of the uniform buffer\r\n     * @param label defines a name for the buffer (for debugging purpose)\r\n     * @returns the webGL uniform buffer\r\n     */\r\n    public createUniformBuffer(elements: FloatArray, label?: string): DataBuffer {\r\n        let view: Float32Array;\r\n        if (elements instanceof Array) {\r\n            view = new Float32Array(elements);\r\n        } else {\r\n            view = elements;\r\n        }\r\n\r\n        const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst, label);\r\n        return dataBuffer;\r\n    }\r\n\r\n    /**\r\n     * Create a dynamic uniform buffer (no different from a non dynamic uniform buffer in WebGPU)\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param elements defines the content of the uniform buffer\r\n     * @param label defines a name for the buffer (for debugging purpose)\r\n     * @returns the webGL uniform buffer\r\n     */\r\n    public createDynamicUniformBuffer(elements: FloatArray, label?: string): DataBuffer {\r\n        return this.createUniformBuffer(elements, label);\r\n    }\r\n\r\n    /**\r\n     * Update an existing uniform buffer\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param uniformBuffer defines the target uniform buffer\r\n     * @param elements defines the content to update\r\n     * @param offset defines the offset in the uniform buffer where update should start\r\n     * @param count defines the size of the data to update\r\n     */\r\n    public updateUniformBuffer(uniformBuffer: DataBuffer, elements: FloatArray, offset?: number, count?: number): void {\r\n        if (offset === undefined) {\r\n            offset = 0;\r\n        }\r\n\r\n        const dataBuffer = uniformBuffer as WebGPUDataBuffer;\r\n        let view: Float32Array;\r\n        if (count === undefined) {\r\n            if (elements instanceof Float32Array) {\r\n                view = elements;\r\n            } else {\r\n                view = new Float32Array(elements);\r\n            }\r\n            count = view.byteLength;\r\n        } else {\r\n            if (elements instanceof Float32Array) {\r\n                view = elements;\r\n            } else {\r\n                view = new Float32Array(elements);\r\n            }\r\n        }\r\n\r\n        this._bufferManager.setSubData(dataBuffer, offset, view, 0, count);\r\n    }\r\n\r\n    /**\r\n     * Bind a buffer to the current draw context\r\n     * @param buffer defines the buffer to bind\r\n     * @param _location not used in WebGPU\r\n     * @param name Name of the uniform variable to bind\r\n     */\r\n    public bindUniformBufferBase(buffer: DataBuffer, _location: number, name: string): void {\r\n        this._currentDrawContext.setBuffer(name, buffer as WebGPUDataBuffer);\r\n    }\r\n\r\n    /**\r\n     * Unused in WebGPU\r\n     */\r\n    public bindUniformBlock(): void {}\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Effects\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Create a new effect (used to store vertex/fragment shaders)\r\n     * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)\r\n     * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object\r\n     * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use\r\n     * @param samplers defines an array of string used to represent textures\r\n     * @param defines defines the string containing the defines to use to compile the shaders\r\n     * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     * @param extraInitializationsAsync additional async code to run before preparing the effect\r\n     * @returns the new Effect\r\n     */\r\n    public createEffect(\r\n        baseName: string | (IShaderPath & { vertexToken?: string; fragmentToken?: string }),\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | AbstractEngine,\r\n        samplers?: string[],\r\n        defines?: string,\r\n        fallbacks?: EffectFallbacks,\r\n        onCompiled?: Nullable<(effect: Effect) => void>,\r\n        onError?: Nullable<(effect: Effect, errors: string) => void>,\r\n        indexParameters?: any,\r\n        shaderLanguage = ShaderLanguage.GLSL,\r\n        extraInitializationsAsync?: () => Promise<void>\r\n    ): Effect {\r\n        const vertex = typeof baseName === \"string\" ? baseName : baseName.vertexToken || baseName.vertexSource || baseName.vertexElement || baseName.vertex;\r\n        const fragment = typeof baseName === \"string\" ? baseName : baseName.fragmentToken || baseName.fragmentSource || baseName.fragmentElement || baseName.fragment;\r\n        const globalDefines = this._getGlobalDefines()!;\r\n\r\n        const isOptions = (attributesNamesOrOptions as IEffectCreationOptions).attributes !== undefined;\r\n\r\n        let fullDefines = defines ?? (<IEffectCreationOptions>attributesNamesOrOptions).defines ?? \"\";\r\n\r\n        if (globalDefines) {\r\n            fullDefines += \"\\n\" + globalDefines;\r\n        }\r\n\r\n        const name = vertex + \"+\" + fragment + \"@\" + fullDefines;\r\n        if (this._compiledEffects[name]) {\r\n            const compiledEffect = this._compiledEffects[name];\r\n            if (onCompiled && compiledEffect.isReady()) {\r\n                onCompiled(compiledEffect);\r\n            }\r\n            compiledEffect._refCount++;\r\n            return compiledEffect;\r\n        }\r\n        const effect = new Effect(\r\n            baseName,\r\n            attributesNamesOrOptions,\r\n            isOptions ? this : uniformsNamesOrEngine,\r\n            samplers,\r\n            this,\r\n            defines,\r\n            fallbacks,\r\n            onCompiled,\r\n            onError,\r\n            indexParameters,\r\n            name,\r\n            (<IEffectCreationOptions>attributesNamesOrOptions).shaderLanguage ?? shaderLanguage,\r\n            (<IEffectCreationOptions>attributesNamesOrOptions).extraInitializationsAsync ?? extraInitializationsAsync\r\n        );\r\n        this._compiledEffects[name] = effect;\r\n\r\n        return effect;\r\n    }\r\n\r\n    private _compileRawShaderToSpirV(source: string, type: string): Uint32Array {\r\n        return this._glslang.compileGLSL(source, type);\r\n    }\r\n\r\n    private _compileShaderToSpirV(source: string, type: string, defines: Nullable<string>, shaderVersion: string): Uint32Array {\r\n        return this._compileRawShaderToSpirV(shaderVersion + (defines ? defines + \"\\n\" : \"\") + source, type);\r\n    }\r\n\r\n    private _getWGSLShader(source: string, type: string, defines: Nullable<string>): string {\r\n        if (defines) {\r\n            defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\r\n        } else {\r\n            defines = \"\";\r\n        }\r\n        return defines + source;\r\n    }\r\n\r\n    private _createPipelineStageDescriptor(\r\n        vertexShader: Uint32Array | string,\r\n        fragmentShader: Uint32Array | string,\r\n        shaderLanguage: ShaderLanguage,\r\n        disableUniformityAnalysisInVertex: boolean,\r\n        disableUniformityAnalysisInFragment: boolean\r\n    ): IWebGPURenderPipelineStageDescriptor {\r\n        if (this._tintWASM && shaderLanguage === ShaderLanguage.GLSL) {\r\n            vertexShader = this._tintWASM.convertSpirV2WGSL(vertexShader as Uint32Array, disableUniformityAnalysisInVertex);\r\n            fragmentShader = this._tintWASM.convertSpirV2WGSL(fragmentShader as Uint32Array, disableUniformityAnalysisInFragment);\r\n        }\r\n\r\n        return {\r\n            vertexStage: {\r\n                module: this._device.createShaderModule({\r\n                    label: \"vertex\",\r\n                    code: vertexShader,\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n            fragmentStage: {\r\n                module: this._device.createShaderModule({\r\n                    label: \"fragment\",\r\n                    code: fragmentShader,\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n        };\r\n    }\r\n\r\n    private _compileRawPipelineStageDescriptor(vertexCode: string, fragmentCode: string, shaderLanguage: ShaderLanguage): IWebGPURenderPipelineStageDescriptor {\r\n        const disableUniformityAnalysisInVertex = vertexCode.indexOf(Constants.DISABLEUA) >= 0;\r\n        const disableUniformityAnalysisInFragment = fragmentCode.indexOf(Constants.DISABLEUA) >= 0;\r\n\r\n        const vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(vertexCode, \"vertex\") : vertexCode;\r\n        const fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(fragmentCode, \"fragment\") : fragmentCode;\r\n\r\n        return this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment);\r\n    }\r\n\r\n    private _compilePipelineStageDescriptor(\r\n        vertexCode: string,\r\n        fragmentCode: string,\r\n        defines: Nullable<string>,\r\n        shaderLanguage: ShaderLanguage\r\n    ): IWebGPURenderPipelineStageDescriptor {\r\n        this.onBeforeShaderCompilationObservable.notifyObservers(this);\r\n\r\n        const disableUniformityAnalysisInVertex = vertexCode.indexOf(Constants.DISABLEUA) >= 0;\r\n        const disableUniformityAnalysisInFragment = fragmentCode.indexOf(Constants.DISABLEUA) >= 0;\r\n\r\n        const shaderVersion = \"#version 450\\n\";\r\n        const vertexShader =\r\n            shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(vertexCode, \"vertex\", defines, shaderVersion) : this._getWGSLShader(vertexCode, \"vertex\", defines);\r\n        const fragmentShader =\r\n            shaderLanguage === ShaderLanguage.GLSL\r\n                ? this._compileShaderToSpirV(fragmentCode, \"fragment\", defines, shaderVersion)\r\n                : this._getWGSLShader(fragmentCode, \"fragment\", defines);\r\n\r\n        const program = this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment);\r\n\r\n        this.onAfterShaderCompilationObservable.notifyObservers(this);\r\n\r\n        return program;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public createRawShaderProgram(): WebGLProgram {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"Not available on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public createShaderProgram(): WebGLProgram {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"Not available on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * Inline functions in shader code that are marked to be inlined\r\n     * @param code code to inline\r\n     * @returns inlined code\r\n     */\r\n    public inlineShaderCode(code: string): string {\r\n        const sci = new ShaderCodeInliner(code);\r\n        sci.debug = false;\r\n        sci.processCode();\r\n        return sci.code;\r\n    }\r\n\r\n    /**\r\n     * Creates a new pipeline context\r\n     * @param shaderProcessingContext defines the shader processing context used during the processing if available\r\n     * @returns the new pipeline\r\n     */\r\n    public createPipelineContext(shaderProcessingContext: Nullable<_IShaderProcessingContext>): IPipelineContext {\r\n        return new WebGPUPipelineContext(shaderProcessingContext! as WebGPUShaderProcessingContext, this);\r\n    }\r\n\r\n    /**\r\n     * Creates a new material context\r\n     * @returns the new context\r\n     */\r\n    public createMaterialContext(): WebGPUMaterialContext | undefined {\r\n        return new WebGPUMaterialContext();\r\n    }\r\n\r\n    /**\r\n     * Creates a new draw context\r\n     * @returns the new context\r\n     */\r\n    public createDrawContext(): WebGPUDrawContext | undefined {\r\n        return new WebGPUDrawContext(this._bufferManager, this._dummyIndexBuffer);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\r\n    public async _preparePipelineContextAsync(\r\n        pipelineContext: IPipelineContext,\r\n        vertexSourceCode: string,\r\n        fragmentSourceCode: string,\r\n        createAsRaw: boolean,\r\n        rawVertexSourceCode: string,\r\n        rawFragmentSourceCode: string,\r\n        _rebuildRebind: any,\r\n        defines: Nullable<string>,\r\n        _transformFeedbackVaryings: Nullable<string[]>,\r\n        _key: string,\r\n        onReady: () => void\r\n    ) {\r\n        const webGpuContext = pipelineContext as WebGPUPipelineContext;\r\n        const shaderLanguage = webGpuContext.shaderProcessingContext.shaderLanguage;\r\n\r\n        if (shaderLanguage === ShaderLanguage.GLSL && !this._glslangAndTintAreFullyLoaded) {\r\n            await this.prepareGlslangAndTintAsync();\r\n        }\r\n\r\n        if (this.dbgShowShaderCode) {\r\n            Logger.Log([\"defines\", defines]);\r\n            Logger.Log(vertexSourceCode);\r\n            Logger.Log(fragmentSourceCode);\r\n            Logger.Log(\"***********************************************\");\r\n        }\r\n\r\n        webGpuContext.sources = {\r\n            fragment: fragmentSourceCode,\r\n            vertex: vertexSourceCode,\r\n            rawVertex: rawVertexSourceCode,\r\n            rawFragment: rawFragmentSourceCode,\r\n        };\r\n\r\n        if (createAsRaw) {\r\n            webGpuContext.stages = this._compileRawPipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, shaderLanguage);\r\n        } else {\r\n            webGpuContext.stages = this._compilePipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, defines, shaderLanguage);\r\n        }\r\n\r\n        onReady();\r\n    }\r\n\r\n    /**\r\n     * Gets the list of active attributes for a given WebGPU program\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param attributesNames defines the list of attribute names to get\r\n     * @returns an array of indices indicating the offset of each attribute\r\n     */\r\n    public getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[] {\r\n        const results = new Array(attributesNames.length);\r\n        const gpuPipelineContext = pipelineContext as WebGPUPipelineContext;\r\n\r\n        for (let i = 0; i < attributesNames.length; i++) {\r\n            const attributeName = attributesNames[i];\r\n            const attributeLocation = gpuPipelineContext.shaderProcessingContext.availableAttributes[attributeName];\r\n            if (attributeLocation === undefined) {\r\n                continue;\r\n            }\r\n\r\n            results[i] = attributeLocation;\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Activates an effect, making it the current one (ie. the one used for rendering)\r\n     * @param effect defines the effect to activate\r\n     */\r\n    public enableEffect(effect: Nullable<Effect | DrawWrapper>): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (!IsWrapper(effect)) {\r\n            this._currentEffect = effect;\r\n            this._currentMaterialContext = this._defaultMaterialContext;\r\n            this._currentDrawContext = this._defaultDrawContext;\r\n            this._counters.numEnableEffects++;\r\n            if (this.dbgLogIfNotDrawWrapper) {\r\n                Logger.Warn(\r\n                    `enableEffect has been called with an Effect and not a Wrapper! effect.uniqueId=${effect.uniqueId}, effect.name=${effect.name}, effect.name.vertex=${typeof effect.name === \"string\" ? \"\" : effect.name.vertex}, effect.name.fragment=${typeof effect.name === \"string\" ? \"\" : effect.name.fragment}`,\r\n                    10\r\n                );\r\n            }\r\n        } else if (\r\n            !effect.effect ||\r\n            (effect.effect === this._currentEffect &&\r\n                effect.materialContext === this._currentMaterialContext &&\r\n                effect.drawContext === this._currentDrawContext &&\r\n                !this._forceEnableEffect)\r\n        ) {\r\n            if (!effect.effect && this.dbgShowEmptyEnableEffectCalls) {\r\n                Logger.Log([\"drawWrapper=\", effect]);\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"Invalid call to enableEffect: the effect property is empty!\";\r\n            }\r\n            return;\r\n        } else {\r\n            this._currentEffect = effect.effect;\r\n            this._currentMaterialContext = effect.materialContext as WebGPUMaterialContext;\r\n            this._currentDrawContext = effect.drawContext as WebGPUDrawContext;\r\n            this._counters.numEnableDrawWrapper++;\r\n            if (!this._currentMaterialContext) {\r\n                Logger.Log([\"drawWrapper=\", effect]);\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw `Invalid call to enableEffect: the materialContext property is empty!`;\r\n            }\r\n        }\r\n\r\n        this._stencilStateComposer.stencilMaterial = undefined;\r\n\r\n        this._forceEnableEffect = false;\r\n\r\n        if (this._currentEffect.onBind) {\r\n            this._currentEffect.onBind(this._currentEffect);\r\n        }\r\n        if (this._currentEffect._onBindObservable) {\r\n            this._currentEffect._onBindObservable.notifyObservers(this._currentEffect);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseEffect(effect: Effect): void {\r\n        if (this._compiledEffects[effect._key]) {\r\n            delete this._compiledEffects[effect._key];\r\n\r\n            this._deletePipelineContext(effect.getPipelineContext() as WebGPUPipelineContext);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n     */\r\n    public releaseEffects() {\r\n        for (const name in this._compiledEffects) {\r\n            const webGPUPipelineContext = this._compiledEffects[name].getPipelineContext() as WebGPUPipelineContext;\r\n            this._deletePipelineContext(webGPUPipelineContext);\r\n        }\r\n\r\n        this._compiledEffects = {};\r\n\r\n        this.onReleaseEffectsObservable.notifyObservers(this);\r\n    }\r\n\r\n    public _deletePipelineContext(pipelineContext: IPipelineContext): void {\r\n        const webgpuPipelineContext = pipelineContext as WebGPUPipelineContext;\r\n        if (webgpuPipelineContext) {\r\n            resetCachedPipeline(webgpuPipelineContext);\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Textures\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets a boolean indicating that only power of 2 textures are supported\r\n     * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them\r\n     */\r\n    public get needPOTTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _createHardwareTexture(): IHardwareTextureWrapper {\r\n        return new WebGPUHardwareTexture(this);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseTexture(texture: InternalTexture): void {\r\n        const index = this._internalTexturesCache.indexOf(texture);\r\n        if (index !== -1) {\r\n            this._internalTexturesCache.splice(index, 1);\r\n        }\r\n\r\n        this._textureHelper.releaseTexture(texture);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getRGBABufferInternalSizedFormat(): number {\r\n        return Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    public updateTextureComparisonFunction(texture: InternalTexture, comparisonFunction: number): void {\r\n        texture._comparisonFunction = comparisonFunction;\r\n    }\r\n\r\n    /**\r\n     * Creates an internal texture without binding it to a framebuffer\r\n     * @internal\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away\r\n     * @param source source type of the texture\r\n     * @returns a new internal texture\r\n     */\r\n    public _createInternalTexture(\r\n        size: TextureSize,\r\n        options: boolean | InternalTextureCreationOptions,\r\n        delayGPUTextureCreation = true,\r\n        source = InternalTextureSource.Unknown\r\n    ): InternalTexture {\r\n        const fullOptions: InternalTextureCreationOptions = {};\r\n\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            fullOptions.generateMipMaps = options.generateMipMaps;\r\n            fullOptions.createMipMaps = options.createMipMaps;\r\n            fullOptions.type = options.type === undefined ? Constants.TEXTURETYPE_UNSIGNED_BYTE : options.type;\r\n            fullOptions.samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n            fullOptions.format = options.format === undefined ? Constants.TEXTUREFORMAT_RGBA : options.format;\r\n            fullOptions.samples = options.samples ?? 1;\r\n            fullOptions.creationFlags = options.creationFlags ?? 0;\r\n            fullOptions.useSRGBBuffer = options.useSRGBBuffer ?? false;\r\n            fullOptions.label = options.label;\r\n        } else {\r\n            fullOptions.generateMipMaps = options;\r\n            fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n            fullOptions.samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n            fullOptions.format = Constants.TEXTUREFORMAT_RGBA;\r\n            fullOptions.samples = 1;\r\n            fullOptions.creationFlags = 0;\r\n            fullOptions.useSRGBBuffer = false;\r\n        }\r\n\r\n        if (fullOptions.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            fullOptions.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (fullOptions.type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            fullOptions.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (fullOptions.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n            Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\r\n        }\r\n\r\n        const texture = new InternalTexture(this, source);\r\n\r\n        const width = (<{ width: number; height: number; layers?: number }>size).width ?? <number>size;\r\n        const height = (<{ width: number; height: number; layers?: number }>size).height ?? <number>size;\r\n        const depth = (<{ width: number; height: number; depth?: number; layers?: number }>size).depth ?? 0;\r\n        const layers = (<{ width: number; height: number; depth?: number; layers?: number }>size).layers ?? 0;\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = depth || layers;\r\n        texture.isReady = true;\r\n        texture.samples = fullOptions.samples;\r\n        texture.generateMipMaps = !!fullOptions.generateMipMaps;\r\n        texture.samplingMode = fullOptions.samplingMode;\r\n        texture.type = fullOptions.type;\r\n        texture.format = fullOptions.format;\r\n        texture.is2DArray = layers > 0;\r\n        texture.is3D = depth > 0;\r\n        texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._useSRGBBuffer = fullOptions.useSRGBBuffer;\r\n        texture.label = fullOptions.label;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        if (!delayGPUTextureCreation) {\r\n            const createMipMapsOnly = !fullOptions.generateMipMaps && fullOptions.createMipMaps;\r\n\r\n            if (createMipMapsOnly) {\r\n                // So that the call to createGPUTextureForInternalTexture creates the mipmaps\r\n                texture.generateMipMaps = true;\r\n            }\r\n\r\n            this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, layers || 1, fullOptions.creationFlags);\r\n\r\n            if (createMipMapsOnly) {\r\n                // So that we don't automatically generate mipmaps when the render target is unbound\r\n                texture.generateMipMaps = false;\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a hardware texture\r\n     * @param url defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public createTexture(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<(texture: InternalTexture) => void> = null,\r\n        onError: Nullable<(message: string, exception: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture {\r\n        return this._createTextureBase(\r\n            url,\r\n            noMipmap,\r\n            invertY,\r\n            scene,\r\n            samplingMode,\r\n            onLoad,\r\n            onError,\r\n            (\r\n                texture: InternalTexture,\r\n                extension: string,\r\n                scene: Nullable<ISceneLike>,\r\n                img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n                invertY: boolean,\r\n                noMipmap: boolean,\r\n                isCompressed: boolean,\r\n                processFunction: (\r\n                    width: number,\r\n                    height: number,\r\n                    img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n                    extension: string,\r\n                    texture: InternalTexture,\r\n                    continuationCallback: () => void\r\n                ) => boolean\r\n            ) => {\r\n                const imageBitmap = img as ImageBitmap | { width: number; height: number }; // we will never get an HTMLImageElement in WebGPU\r\n\r\n                texture.baseWidth = imageBitmap.width;\r\n                texture.baseHeight = imageBitmap.height;\r\n                texture.width = imageBitmap.width;\r\n                texture.height = imageBitmap.height;\r\n                texture.format = texture.format !== -1 ? texture.format : (format ?? Constants.TEXTUREFORMAT_RGBA);\r\n                texture.type = texture.type !== -1 ? texture.type : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                texture._creationFlags = creationFlags ?? 0;\r\n\r\n                processFunction(texture.width, texture.height, imageBitmap, extension, texture, () => {});\r\n\r\n                if (!texture._hardwareTexture?.underlyingResource) {\r\n                    // the texture could have been created before reaching this point so don't recreate it if already existing\r\n                    const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, imageBitmap.width, imageBitmap.height, undefined, creationFlags);\r\n\r\n                    if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\r\n                        this._textureHelper.updateTexture(\r\n                            imageBitmap,\r\n                            texture,\r\n                            imageBitmap.width,\r\n                            imageBitmap.height,\r\n                            texture.depth,\r\n                            gpuTextureWrapper.format,\r\n                            0,\r\n                            0,\r\n                            invertY,\r\n                            false,\r\n                            0,\r\n                            0\r\n                        );\r\n                        if (!noMipmap && !isCompressed) {\r\n                            this._generateMipmaps(texture, this._uploadEncoder);\r\n                        }\r\n                    }\r\n                } else if (!noMipmap && !isCompressed) {\r\n                    this._generateMipmaps(texture, this._uploadEncoder);\r\n                }\r\n\r\n                if (scene) {\r\n                    scene.removePendingData(texture);\r\n                }\r\n\r\n                texture.isReady = true;\r\n\r\n                texture.onLoadedObservable.notifyObservers(texture);\r\n                texture.onLoadedObservable.clear();\r\n            },\r\n            () => false,\r\n            buffer,\r\n            fallback,\r\n            format,\r\n            forcedExtension,\r\n            mimeType,\r\n            loaderOptions,\r\n            useSRGBBuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Wraps an external web gpu texture in a Babylon texture.\r\n     * @param texture defines the external texture\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapWebGPUTexture(texture: GPUTexture): InternalTexture {\r\n        const hardwareTexture = new WebGPUHardwareTexture(this, texture);\r\n        const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\r\n        internalTexture._hardwareTexture = hardwareTexture;\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Wraps an external web gl texture in a Babylon texture.\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapWebGLTexture(): InternalTexture {\r\n        throw new Error(\"wrapWebGLTexture is not supported, use wrapWebGPUTexture instead.\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getUseSRGBBuffer(useSRGBBuffer: boolean, _noMipmap: boolean): boolean {\r\n        return useSRGBBuffer && this._caps.supportSRGBBuffers;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _unpackFlipY(_value: boolean) {}\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param samplingMode defines the required sampling mode\r\n     * @param texture defines the texture to update\r\n     * @param generateMipMaps defines whether to generate mipmaps for the texture\r\n     */\r\n    public updateTextureSamplingMode(samplingMode: number, texture: InternalTexture, generateMipMaps: boolean = false): void {\r\n        if (generateMipMaps) {\r\n            texture.generateMipMaps = true;\r\n            this._generateMipmaps(texture);\r\n        }\r\n\r\n        texture.samplingMode = samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param texture defines the texture to update\r\n     * @param wrapU defines the texture wrap mode of the u coordinates\r\n     * @param wrapV defines the texture wrap mode of the v coordinates\r\n     * @param wrapR defines the texture wrap mode of the r coordinates\r\n     */\r\n    public updateTextureWrappingMode(texture: InternalTexture, wrapU: Nullable<number>, wrapV: Nullable<number> = null, wrapR: Nullable<number> = null): void {\r\n        if (wrapU !== null) {\r\n            texture._cachedWrapU = wrapU;\r\n        }\r\n        if (wrapV !== null) {\r\n            texture._cachedWrapV = wrapV;\r\n        }\r\n        if ((texture.is2DArray || texture.is3D) && wrapR !== null) {\r\n            texture._cachedWrapR = wrapR;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the dimensions of a texture\r\n     * @param texture texture to update\r\n     * @param width new width of the texture\r\n     * @param height new height of the texture\r\n     * @param depth new depth of the texture\r\n     */\r\n    public updateTextureDimensions(texture: InternalTexture, width: number, height: number, depth: number = 1): void {\r\n        if (!texture._hardwareTexture) {\r\n            // the gpu texture is not created yet, so when it is it will be created with the right dimensions\r\n            return;\r\n        }\r\n\r\n        if (texture.width === width && texture.height === height && texture.depth === depth) {\r\n            return;\r\n        }\r\n\r\n        const additionalUsages = (texture._hardwareTexture as WebGPUHardwareTexture).textureAdditionalUsages;\r\n\r\n        texture._hardwareTexture.release(); // don't defer the releasing! Else we will release at the end of this frame the gpu texture we are about to create in the next line...\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, additionalUsages);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setInternalTexture(name: string, texture: Nullable<InternalTexture | ExternalTexture>, baseName?: string): void {\r\n        baseName = baseName ?? name;\r\n        if (this._currentEffect) {\r\n            const webgpuPipelineContext = this._currentEffect._pipelineContext as WebGPUPipelineContext;\r\n            const availableTexture = webgpuPipelineContext.shaderProcessingContext.availableTextures[baseName];\r\n\r\n            this._currentMaterialContext.setTexture(name, texture);\r\n\r\n            if (availableTexture && availableTexture.autoBindSampler) {\r\n                const samplerName = baseName + Constants.AUTOSAMPLERSUFFIX;\r\n                this._currentMaterialContext.setSampler(samplerName, texture as InternalTexture); // we can safely cast to InternalTexture because ExternalTexture always has autoBindSampler = false\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n     * @param rootUrl defines the url where the file to load is located\r\n     * @param scene defines the current scene\r\n     * @param lodScale defines scale to apply to the mip map selection\r\n     * @param lodOffset defines offset to apply to the mip map selection\r\n     * @param onLoad defines an optional callback raised when the texture is loaded\r\n     * @param onError defines an optional callback raised if there is an issue to load the texture\r\n     * @param format defines the format of the data\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n     * @returns the cube texture as an InternalTexture\r\n     */\r\n    public override createPrefilteredCubeTexture(\r\n        rootUrl: string,\r\n        scene: Nullable<Scene>,\r\n        lodScale: number,\r\n        lodOffset: number,\r\n        onLoad: Nullable<(internalTexture: Nullable<InternalTexture>) => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format?: number,\r\n        forcedExtension: any = null,\r\n        createPolynomials: boolean = true\r\n    ): InternalTexture {\r\n        const callback = (loadData: any) => {\r\n            if (!loadData) {\r\n                if (onLoad) {\r\n                    onLoad(null);\r\n                }\r\n                return;\r\n            }\r\n\r\n            const texture = loadData.texture as InternalTexture;\r\n            if (!createPolynomials) {\r\n                texture._sphericalPolynomial = new SphericalPolynomial();\r\n            } else if (loadData.info.sphericalPolynomial) {\r\n                texture._sphericalPolynomial = loadData.info.sphericalPolynomial;\r\n            }\r\n            texture._source = InternalTextureSource.CubePrefiltered;\r\n\r\n            if (onLoad) {\r\n                onLoad(texture);\r\n            }\r\n        };\r\n\r\n        return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);\r\n    }\r\n\r\n    /**\r\n     * Sets a texture to the according uniform.\r\n     * @param channel The texture channel\r\n     * @param unused unused parameter\r\n     * @param texture The texture to apply\r\n     * @param name The name of the uniform in the effect\r\n     */\r\n    public setTexture(channel: number, unused: Nullable<WebGLUniformLocation>, texture: Nullable<BaseTexture>, name: string): void {\r\n        this._setTexture(channel, texture, false, false, name, name);\r\n    }\r\n\r\n    /**\r\n     * Sets an array of texture to the WebGPU context\r\n     * @param channel defines the channel where the texture array must be set\r\n     * @param unused unused parameter\r\n     * @param textures defines the array of textures to bind\r\n     * @param name name of the channel\r\n     */\r\n    public setTextureArray(channel: number, unused: Nullable<WebGLUniformLocation>, textures: BaseTexture[], name: string): void {\r\n        for (let index = 0; index < textures.length; index++) {\r\n            this._setTexture(-1, textures[index], true, false, name + index.toString(), name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _setTexture(\r\n        channel: number,\r\n        texture: Nullable<BaseTexture>,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        isPartOfTextureArray = false,\r\n        depthStencilTexture = false,\r\n        name = \"\",\r\n        baseName?: string\r\n    ): boolean {\r\n        // name == baseName for a texture that is not part of a texture array\r\n        // Else, name is something like 'myTexture0' / 'myTexture1' / ... and baseName is 'myTexture'\r\n        // baseName is used to look up the texture in the shaderProcessingContext.availableTextures map\r\n        // name is used to look up the texture in the _currentMaterialContext.textures map\r\n        baseName = baseName ?? name;\r\n        if (this._currentEffect) {\r\n            if (!texture) {\r\n                this._currentMaterialContext.setTexture(name, null);\r\n                return false;\r\n            }\r\n\r\n            // Video\r\n            if ((<VideoTexture>texture).video) {\r\n                (<VideoTexture>texture).update();\r\n            } else if (texture.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n                // Delay loading\r\n                texture.delayLoad();\r\n                return false;\r\n            }\r\n\r\n            let internalTexture: Nullable<InternalTexture> = null;\r\n            if (depthStencilTexture) {\r\n                internalTexture = (<RenderTargetTexture>texture).depthStencilTexture!;\r\n            } else if (texture.isReady()) {\r\n                internalTexture = <InternalTexture>texture.getInternalTexture();\r\n            } else if (texture.isCube) {\r\n                internalTexture = this.emptyCubeTexture;\r\n            } else if (texture.is3D) {\r\n                internalTexture = this.emptyTexture3D;\r\n            } else if (texture.is2DArray) {\r\n                internalTexture = this.emptyTexture2DArray;\r\n            } else {\r\n                internalTexture = this.emptyTexture;\r\n            }\r\n\r\n            if (internalTexture && !internalTexture.isMultiview) {\r\n                // CUBIC_MODE and SKYBOX_MODE both require CLAMP_TO_EDGE.  All other modes use REPEAT.\r\n                if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {\r\n                    internalTexture._cachedCoordinatesMode = texture.coordinatesMode;\r\n\r\n                    const textureWrapMode =\r\n                        texture.coordinatesMode !== Constants.TEXTURE_CUBIC_MODE && texture.coordinatesMode !== Constants.TEXTURE_SKYBOX_MODE\r\n                            ? Constants.TEXTURE_WRAP_ADDRESSMODE\r\n                            : Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n                    texture.wrapU = textureWrapMode;\r\n                    texture.wrapV = textureWrapMode;\r\n                }\r\n\r\n                internalTexture._cachedWrapU = texture.wrapU;\r\n                internalTexture._cachedWrapV = texture.wrapV;\r\n                if (internalTexture.is3D) {\r\n                    internalTexture._cachedWrapR = texture.wrapR;\r\n                }\r\n\r\n                this._setAnisotropicLevel(0, internalTexture, texture.anisotropicFilteringLevel);\r\n            }\r\n\r\n            this._setInternalTexture(name, internalTexture, baseName);\r\n        } else {\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    Logger.Log([\"frame #\" + (this as any)._count + \" - _setTexture called with a null _currentEffect! texture=\", texture]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setAnisotropicLevel(target: number, internalTexture: InternalTexture, anisotropicFilteringLevel: number) {\r\n        if (internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {\r\n            internalTexture._cachedAnisotropicFilteringLevel = Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTexture(channel: number, texture: Nullable<InternalTexture>, name: string): void {\r\n        if (channel === undefined) {\r\n            return;\r\n        }\r\n\r\n        this._setInternalTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Generates the mipmaps for a texture\r\n     * @param texture texture to generate the mipmaps for\r\n     */\r\n    public generateMipmaps(texture: InternalTexture): void {\r\n        this._generateMipmaps(texture);\r\n    }\r\n\r\n    /**\r\n     * Update a portion of an internal texture\r\n     * @param texture defines the texture to update\r\n     * @param imageData defines the data to store into the texture\r\n     * @param xOffset defines the x coordinates of the update rectangle\r\n     * @param yOffset defines the y coordinates of the update rectangle\r\n     * @param width defines the width of the update rectangle\r\n     * @param height defines the height of the update rectangle\r\n     * @param faceIndex defines the face index if texture is a cube (0 by default)\r\n     * @param lod defines the lod level to update (0 by default)\r\n     * @param generateMipMaps defines whether to generate mipmaps or not\r\n     */\r\n    public updateTextureData(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        xOffset: number,\r\n        yOffset: number,\r\n        width: number,\r\n        height: number,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        generateMipMaps = false\r\n    ): void {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, xOffset, yOffset);\r\n\r\n        if (generateMipMaps) {\r\n            this._generateMipmaps(texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadCompressedDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        internalFormat: number,\r\n        width: number,\r\n        height: number,\r\n        imageData: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0\r\n    ) {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            texture.format = internalFormat;\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, false, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        babylonInternalFormat?: number,\r\n        useTextureWidthAndHeight = false\r\n    ): void {\r\n        const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);\r\n        const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);\r\n\r\n        const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));\r\n        const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));\r\n\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {\r\n        this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement | ImageBitmap, faceIndex: number = 0, lod: number = 0) {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n        }\r\n\r\n        if (image instanceof HTMLImageElement) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"WebGPU engine: HTMLImageElement not supported in _uploadImageToTexture!\";\r\n        }\r\n\r\n        const bitmap = image; // in WebGPU we will always get an ImageBitmap, not an HTMLImageElement\r\n\r\n        const width = Math.ceil(texture.width / (1 << lod));\r\n        const height = Math.ceil(texture.height / (1 << lod));\r\n\r\n        this._textureHelper.updateTexture(bitmap, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Reads pixels from the current frame buffer. Please note that this function can be slow\r\n     * @param x defines the x coordinate of the rectangle where pixels must be read\r\n     * @param y defines the y coordinate of the rectangle where pixels must be read\r\n     * @param width defines the width of the rectangle where pixels must be read\r\n     * @param height defines the height of the rectangle where pixels must be read\r\n     * @param _hasAlpha defines whether the output should have alpha or not (defaults to true)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @param data defines the data to fill with the read pixels (if not provided, a new one will be created)\r\n     * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    public readPixels(x: number, y: number, width: number, height: number, _hasAlpha = true, flushRenderer = true, data: Nullable<Uint8Array> = null): Promise<ArrayBufferView> {\r\n        const renderPassWrapper = this._getCurrentRenderPassWrapper();\r\n        const hardwareTexture = renderPassWrapper.colorAttachmentGPUTextures[0];\r\n        if (!hardwareTexture) {\r\n            // we are calling readPixels for a render pass with no color texture bound\r\n            return Promise.resolve(new Uint8Array(0));\r\n        }\r\n        const gpuTexture = hardwareTexture.underlyingResource;\r\n        const gpuTextureFormat = hardwareTexture.format;\r\n        if (!gpuTexture) {\r\n            // we are calling readPixels before startMainRenderPass has been called and no RTT is bound, so swapChainTexture is not setup yet!\r\n            return Promise.resolve(new Uint8Array(0));\r\n        }\r\n        if (flushRenderer) {\r\n            this.flushFramebuffer();\r\n        }\r\n        return this._textureHelper.readPixels(gpuTexture, x, y, width, height, gpuTextureFormat, undefined, undefined, data);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Frame management\r\n    //------------------------------------------------------------------------------\r\n\r\n    private _measureFps(): void {\r\n        this._performanceMonitor.sampleFrame();\r\n        this._fps = this._performanceMonitor.averageFPS;\r\n        this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;\r\n    }\r\n\r\n    private _performanceMonitor = new PerformanceMonitor();\r\n    /**\r\n     * Gets the performance monitor attached to this engine\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#engineinstrumentation\r\n     */\r\n    public get performanceMonitor(): PerformanceMonitor {\r\n        return this._performanceMonitor;\r\n    }\r\n\r\n    /**\r\n     * Begin a new frame\r\n     */\r\n    public override beginFrame(): void {\r\n        this._measureFps();\r\n        super.beginFrame();\r\n    }\r\n\r\n    /**\r\n     * End the current frame\r\n     */\r\n    public override endFrame() {\r\n        this._endCurrentRenderPass();\r\n\r\n        this._snapshotRendering.endFrame();\r\n\r\n        this._timestampQuery.endFrame(this._renderEncoder);\r\n        this._timestampIndex = 0;\r\n\r\n        this.flushFramebuffer();\r\n\r\n        this._textureHelper.destroyDeferredTextures();\r\n        this._bufferManager.destroyDeferredBuffers();\r\n\r\n        if (this._features._collectUbosUpdatedInFrame) {\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    const list: Array<string> = [];\r\n                    for (const name in UniformBuffer._UpdatedUbosInFrame) {\r\n                        list.push(name + \":\" + UniformBuffer._UpdatedUbosInFrame[name]);\r\n                    }\r\n                    Logger.Log([\"frame #\" + (this as any)._count + \" - updated ubos -\", list.join(\", \")]);\r\n                }\r\n            }\r\n            UniformBuffer._UpdatedUbosInFrame = {};\r\n        }\r\n\r\n        this.countersLastFrame.numEnableEffects = this._counters.numEnableEffects;\r\n        this.countersLastFrame.numEnableDrawWrapper = this._counters.numEnableDrawWrapper;\r\n        this.countersLastFrame.numBundleCreationNonCompatMode = this._counters.numBundleCreationNonCompatMode;\r\n        this.countersLastFrame.numBundleReuseNonCompatMode = this._counters.numBundleReuseNonCompatMode;\r\n        this._counters.numEnableEffects = 0;\r\n        this._counters.numEnableDrawWrapper = 0;\r\n        this._counters.numBundleCreationNonCompatMode = 0;\r\n        this._counters.numBundleReuseNonCompatMode = 0;\r\n\r\n        this._cacheRenderPipeline.endFrame();\r\n        this._cacheBindGroups.endFrame();\r\n\r\n        this._pendingDebugCommands.length = 0;\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if ((this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log([\"%c frame #\" + (this as any)._count + \" - end\", \"background: #ffff00\"]);\r\n            }\r\n            if ((this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                (this as any)._count++;\r\n                if ((this as any)._count !== this.dbgVerboseLogsNumFrames) {\r\n                    Logger.Log([\"%c frame #\" + (this as any)._count + \" - begin\", \"background: #ffff00\"]);\r\n                }\r\n            }\r\n        }\r\n\r\n        super.endFrame();\r\n    }\r\n\r\n    /**Gets driver info if available */\r\n    public extractDriverInfo() {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Force a WebGPU flush (ie. a flush of all waiting commands)\r\n     */\r\n    public flushFramebuffer(): void {\r\n        // we need to end the current render pass (main or rtt) if any as we are not allowed to submit the command buffers when being in a pass\r\n        this._endCurrentRenderPass();\r\n\r\n        this._commandBuffers[0] = this._uploadEncoder.finish();\r\n        this._commandBuffers[1] = this._renderEncoder.finish();\r\n\r\n        this._device.queue.submit(this._commandBuffers);\r\n\r\n        this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\r\n        this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\r\n\r\n        this._timestampQuery.startFrame(this._uploadEncoder);\r\n\r\n        this._textureHelper.setCommandEncoder(this._uploadEncoder);\r\n\r\n        this._bundleList.reset();\r\n    }\r\n\r\n    /** @internal */\r\n    public _currentFrameBufferIsDefaultFrameBuffer() {\r\n        return this._currentPassIsMainPass();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Render Pass\r\n    //------------------------------------------------------------------------------\r\n\r\n    /** @internal */\r\n    public _startRenderTargetRenderPass(\r\n        renderTargetWrapper: RenderTargetWrapper,\r\n        setClearStates: boolean,\r\n        clearColor: Nullable<IColor4Like>,\r\n        clearDepth: boolean,\r\n        clearStencil: boolean\r\n    ) {\r\n        this._endCurrentRenderPass();\r\n\r\n        const rtWrapper = renderTargetWrapper as WebGPURenderTargetWrapper;\r\n\r\n        const depthStencilTexture = rtWrapper._depthStencilTexture;\r\n        const gpuDepthStencilWrapper = depthStencilTexture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n        const gpuDepthStencilTexture = gpuDepthStencilWrapper?.underlyingResource as Nullable<GPUTexture>;\r\n        const gpuDepthStencilMSAATexture = gpuDepthStencilWrapper?.getMSAATexture(0);\r\n\r\n        const depthMSAATextureView = gpuDepthStencilMSAATexture?.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor!);\r\n        const depthTextureView = depthMSAATextureView ? undefined : gpuDepthStencilTexture?.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor!);\r\n        // We use the MSAA texture format (if available) to determine if it has a stencil aspect or not because, for MSAA depth textures,\r\n        // the format of the \"resolve\" texture (gpuDepthStencilWrapper.format) is a single red channel format, not a depth-stencil format.\r\n        const depthTextureHasStencil = gpuDepthStencilWrapper ? WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilMSAATexture?.format ?? gpuDepthStencilWrapper.format) : false;\r\n        const depthTextureHasDepth = gpuDepthStencilWrapper ? WebGPUTextureHelper.HasDepthAspect(gpuDepthStencilMSAATexture?.format ?? gpuDepthStencilWrapper.format) : false;\r\n\r\n        const colorAttachments: (GPURenderPassColorAttachment | null)[] = [];\r\n\r\n        if (this.useReverseDepthBuffer) {\r\n            this.setDepthFunctionToGreaterOrEqual();\r\n        }\r\n\r\n        const clearColorForIntegerRt = TempColor4;\r\n        if (clearColor) {\r\n            clearColorForIntegerRt.r = clearColor.r * 255;\r\n            clearColorForIntegerRt.g = clearColor.g * 255;\r\n            clearColorForIntegerRt.b = clearColor.b * 255;\r\n            clearColorForIntegerRt.a = clearColor.a * 255;\r\n        }\r\n\r\n        const mustClearColor = setClearStates && clearColor;\r\n        const mustClearDepth = setClearStates && clearDepth;\r\n        const mustClearStencil = setClearStates && clearStencil;\r\n\r\n        if (rtWrapper._attachments && rtWrapper.isMulti) {\r\n            // multi render targets\r\n            if (!this._mrtAttachments || this._mrtAttachments.length === 0) {\r\n                this._mrtAttachments = rtWrapper._defaultAttachments;\r\n            }\r\n            for (let i = 0; i < this._mrtAttachments.length; ++i) {\r\n                const index = this._mrtAttachments[i]; // if index == 0 it means the texture should not be written to => at render pass creation time, it means we should not clear it\r\n                const mrtTexture = rtWrapper.textures![i];\r\n                const gpuMRTWrapper = mrtTexture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n                const gpuMRTTexture = gpuMRTWrapper?.underlyingResource;\r\n                if (gpuMRTWrapper && gpuMRTTexture) {\r\n                    const baseArrayLayer = rtWrapper.getBaseArrayLayer(i);\r\n                    const gpuMSAATexture = gpuMRTWrapper.getMSAATexture(baseArrayLayer);\r\n\r\n                    const viewDescriptor = {\r\n                        ...this._rttRenderPassWrapper.colorAttachmentViewDescriptor!,\r\n                        dimension: mrtTexture.is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n                        format: gpuMRTWrapper.format,\r\n                        baseArrayLayer,\r\n                    };\r\n                    const msaaViewDescriptor = {\r\n                        ...this._rttRenderPassWrapper.colorAttachmentViewDescriptor!,\r\n                        dimension: mrtTexture.is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n                        format: gpuMRTWrapper.format,\r\n                        baseArrayLayer: 0,\r\n                    };\r\n                    const isRtInteger = mrtTexture.type === Constants.TEXTURETYPE_UNSIGNED_INTEGER || mrtTexture.type === Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n\r\n                    const colorTextureView = gpuMRTTexture.createView(viewDescriptor);\r\n                    const colorMSAATextureView = gpuMSAATexture?.createView(msaaViewDescriptor);\r\n\r\n                    colorAttachments.push({\r\n                        view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\r\n                        resolveTarget: gpuMSAATexture && !rtWrapper.disableAutomaticMSAAResolve && rtWrapper.resolveMSAAColors ? colorTextureView : undefined,\r\n                        depthSlice: mrtTexture.is3D ? (rtWrapper.layerIndices?.[i] ?? 0) : undefined,\r\n                        clearValue: index !== 0 && mustClearColor ? (isRtInteger ? clearColorForIntegerRt : clearColor) : undefined,\r\n                        loadOp: index !== 0 && mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                        storeOp: WebGPUConstants.StoreOp.Store,\r\n                    });\r\n                }\r\n            }\r\n            this._cacheRenderPipeline.setMRT(rtWrapper.textures!, this._mrtAttachments.length);\r\n            this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n        } else {\r\n            // single render target\r\n            const internalTexture = rtWrapper.texture;\r\n            if (internalTexture) {\r\n                const gpuWrapper = internalTexture._hardwareTexture as WebGPUHardwareTexture;\r\n                const gpuTexture = gpuWrapper.underlyingResource!;\r\n\r\n                let depthSlice: number | undefined = undefined;\r\n\r\n                if (rtWrapper.is3D) {\r\n                    depthSlice = this._rttRenderPassWrapper.colorAttachmentViewDescriptor!.baseArrayLayer;\r\n                    this._rttRenderPassWrapper.colorAttachmentViewDescriptor!.baseArrayLayer = 0;\r\n                }\r\n\r\n                const gpuMSAATexture = gpuWrapper.getMSAATexture(0);\r\n                const colorTextureView = gpuTexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor!);\r\n                const colorMSAATextureView = gpuMSAATexture?.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor!);\r\n                const isRtInteger = internalTexture.type === Constants.TEXTURETYPE_UNSIGNED_INTEGER || internalTexture.type === Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n\r\n                colorAttachments.push({\r\n                    view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\r\n                    resolveTarget: gpuMSAATexture && !rtWrapper.disableAutomaticMSAAResolve && rtWrapper.resolveMSAAColors ? colorTextureView : undefined,\r\n                    depthSlice,\r\n                    clearValue: mustClearColor ? (isRtInteger ? clearColorForIntegerRt : clearColor) : undefined,\r\n                    loadOp: mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                });\r\n            } else {\r\n                colorAttachments.push(null);\r\n            }\r\n        }\r\n\r\n        this._debugPushGroup?.(\"render target pass\" + (renderTargetWrapper.label ? \" (\" + renderTargetWrapper.label + \")\" : \"\"), 0);\r\n\r\n        this._rttRenderPassWrapper.renderPassDescriptor = {\r\n            label: (renderTargetWrapper.label ?? \"RTT\") + \" - RenderPass\",\r\n            colorAttachments,\r\n            depthStencilAttachment:\r\n                depthStencilTexture && gpuDepthStencilTexture\r\n                    ? {\r\n                          view: depthMSAATextureView ? depthMSAATextureView : depthTextureView!,\r\n                          depthClearValue: mustClearDepth ? (this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue) : undefined,\r\n                          depthLoadOp: rtWrapper.depthReadOnly || !depthTextureHasDepth ? undefined : mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                          depthStoreOp: rtWrapper.depthReadOnly || !depthTextureHasDepth ? undefined : WebGPUConstants.StoreOp.Store,\r\n                          depthReadOnly: rtWrapper.depthReadOnly,\r\n                          stencilClearValue: rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? this._clearStencilValue : undefined,\r\n                          stencilLoadOp:\r\n                              rtWrapper.stencilReadOnly || !depthTextureHasStencil\r\n                                  ? undefined\r\n                                  : rtWrapper._depthStencilTextureWithStencil && mustClearStencil\r\n                                    ? WebGPUConstants.LoadOp.Clear\r\n                                    : WebGPUConstants.LoadOp.Load,\r\n                          stencilStoreOp: rtWrapper.stencilReadOnly || !depthTextureHasStencil ? undefined : WebGPUConstants.StoreOp.Store,\r\n                          stencilReadOnly: rtWrapper.stencilReadOnly,\r\n                      }\r\n                    : undefined,\r\n            occlusionQuerySet: this._occlusionQuery?.hasQueries ? this._occlusionQuery.querySet : undefined,\r\n        };\r\n        this._timestampQuery.startPass(this._rttRenderPassWrapper.renderPassDescriptor, this._timestampIndex);\r\n        this._currentRenderPass = this._renderEncoder.beginRenderPass(this._rttRenderPassWrapper.renderPassDescriptor);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                const internalTexture = rtWrapper.texture!;\r\n                Logger.Log([\r\n                    \"frame #\" +\r\n                        (this as any)._count +\r\n                        \" - render target begin pass - rtt name=\" +\r\n                        renderTargetWrapper.label +\r\n                        \", internalTexture.uniqueId=\" +\r\n                        internalTexture.uniqueId +\r\n                        \", width=\" +\r\n                        internalTexture.width +\r\n                        \", height=\" +\r\n                        internalTexture.height +\r\n                        \", setClearStates=\" +\r\n                        setClearStates,\r\n                    \"renderPassDescriptor=\",\r\n                    this._rttRenderPassWrapper.renderPassDescriptor,\r\n                ]);\r\n            }\r\n        }\r\n\r\n        this._debugFlushPendingCommands?.();\r\n\r\n        this._resetRenderPassStates();\r\n\r\n        if (!gpuDepthStencilWrapper || !WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format)) {\r\n            this._stencilStateComposer.enabled = false;\r\n        }\r\n    }\r\n\r\n    private _startMainRenderPass(setClearStates: boolean, clearColor?: Nullable<IColor4Like>, clearDepth?: boolean, clearStencil?: boolean): void {\r\n        this._endCurrentRenderPass();\r\n\r\n        if (this.useReverseDepthBuffer) {\r\n            this.setDepthFunctionToGreaterOrEqual();\r\n        }\r\n\r\n        const mustClearColor = setClearStates && clearColor;\r\n        const mustClearDepth = setClearStates && clearDepth;\r\n        const mustClearStencil = setClearStates && clearStencil;\r\n\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.clearValue = mustClearColor ? clearColor : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.loadOp = mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.depthClearValue = mustClearDepth\r\n            ? this.useReverseDepthBuffer\r\n                ? this._clearReverseDepthValue\r\n                : this._clearDepthValue\r\n            : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.depthLoadOp = mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.stencilClearValue = mustClearStencil ? this._clearStencilValue : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.stencilLoadOp = !this.isStencilEnable\r\n            ? undefined\r\n            : mustClearStencil\r\n              ? WebGPUConstants.LoadOp.Clear\r\n              : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.occlusionQuerySet = this._occlusionQuery?.hasQueries ? this._occlusionQuery.querySet : undefined;\r\n\r\n        const swapChainTexture = this._context.getCurrentTexture();\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures[0]!.set(swapChainTexture);\r\n\r\n        // Resolve in case of MSAA\r\n        if (this._options.antialias) {\r\n            ViewDescriptorSwapChainAntialiasing.format = swapChainTexture.format;\r\n            this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.resolveTarget = swapChainTexture.createView(ViewDescriptorSwapChainAntialiasing);\r\n        } else {\r\n            ViewDescriptorSwapChain.format = swapChainTexture.format;\r\n            this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.view = swapChainTexture.createView(ViewDescriptorSwapChain);\r\n        }\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log([\r\n                    \"frame #\" + (this as any)._count + \" - main begin pass - texture width=\" + (this._mainTextureExtends as any).width,\r\n                    \" height=\" + (this._mainTextureExtends as any).height + \", setClearStates=\" + setClearStates,\r\n                    \"renderPassDescriptor=\",\r\n                    this._mainRenderPassWrapper.renderPassDescriptor,\r\n                ]);\r\n            }\r\n        }\r\n\r\n        this._debugPushGroup?.(\"main pass\", 0);\r\n\r\n        this._timestampQuery.startPass(this._mainRenderPassWrapper.renderPassDescriptor!, this._timestampIndex);\r\n        this._currentRenderPass = this._renderEncoder.beginRenderPass(this._mainRenderPassWrapper.renderPassDescriptor!);\r\n\r\n        this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n        this._setColorFormat(this._mainRenderPassWrapper);\r\n\r\n        this._debugFlushPendingCommands?.();\r\n\r\n        this._resetRenderPassStates();\r\n\r\n        if (!this._isStencilEnable) {\r\n            this._stencilStateComposer.enabled = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the frame buffer to the specified texture.\r\n     * @param texture The render target wrapper to render to\r\n     * @param faceIndex The face of the texture to render to in case of cube texture\r\n     * @param requiredWidth The width of the target to render to\r\n     * @param requiredHeight The height of the target to render to\r\n     * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n     * @param lodLevel defines the lod level to bind to the frame buffer\r\n     * @param layer defines the 2d array index to bind to frame buffer to\r\n     */\r\n    public bindFramebuffer(\r\n        texture: RenderTargetWrapper,\r\n        faceIndex: number = 0,\r\n        requiredWidth?: number,\r\n        requiredHeight?: number,\r\n        forceFullscreenViewport?: boolean,\r\n        lodLevel = 0,\r\n        layer = 0\r\n    ): void {\r\n        const hardwareTexture = texture.texture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        } else {\r\n            this._endCurrentRenderPass();\r\n        }\r\n        this._currentRenderTarget = texture;\r\n\r\n        const depthStencilTexture = this._currentRenderTarget._depthStencilTexture;\r\n\r\n        this._rttRenderPassWrapper.colorAttachmentGPUTextures[0] = hardwareTexture;\r\n        this._rttRenderPassWrapper.depthTextureFormat = depthStencilTexture ? WebGPUTextureHelper.GetWebGPUTextureFormat(-1, depthStencilTexture.format) : undefined;\r\n\r\n        this._setDepthTextureFormat(this._rttRenderPassWrapper);\r\n        this._setColorFormat(this._rttRenderPassWrapper);\r\n\r\n        this._rttRenderPassWrapper.colorAttachmentViewDescriptor = {\r\n            label: texture.label ? texture.label + \" - Color Attachment View\" : \"RTT - Color Attachment View\",\r\n            format: this._colorFormat as GPUTextureFormat,\r\n            dimension: texture.is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n            mipLevelCount: 1,\r\n            baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\r\n            baseMipLevel: lodLevel,\r\n            arrayLayerCount: 1,\r\n            aspect: WebGPUConstants.TextureAspect.All,\r\n        };\r\n\r\n        this._rttRenderPassWrapper.depthAttachmentViewDescriptor = {\r\n            label: texture.label ? texture.label + \" - Depth Attachment View\" : \"RTT - Depth Attachment View\",\r\n            format: this._depthTextureFormat!,\r\n            dimension: depthStencilTexture && depthStencilTexture.is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n            mipLevelCount: 1,\r\n            baseArrayLayer: depthStencilTexture ? (depthStencilTexture.isCube ? layer * 6 + faceIndex : layer) : 0,\r\n            baseMipLevel: 0,\r\n            arrayLayerCount: 1,\r\n            aspect: WebGPUConstants.TextureAspect.All,\r\n        };\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log([\r\n                    \"frame #\" +\r\n                        (this as any)._count +\r\n                        \" - bindFramebuffer - rtt name=\" +\r\n                        texture.label +\r\n                        \", internalTexture.uniqueId=\" +\r\n                        texture.texture?.uniqueId +\r\n                        \", face=\" +\r\n                        faceIndex +\r\n                        \", lodLevel=\" +\r\n                        lodLevel +\r\n                        \", layer=\" +\r\n                        layer,\r\n                    \"colorAttachmentViewDescriptor=\",\r\n                    this._rttRenderPassWrapper.colorAttachmentViewDescriptor,\r\n                    \"depthAttachmentViewDescriptor=\",\r\n                    this._rttRenderPassWrapper.depthAttachmentViewDescriptor,\r\n                ]);\r\n            }\r\n        }\r\n\r\n        // We don't create the render pass just now, we do a lazy creation of the render pass, hoping the render pass will be created by a call to clear()...\r\n        // However, if snapshot rendering is enabled, we need to create the render pass immediately, to be sure currentRenderPass is not null when _endCurrentRenderPass() is called.\r\n        // (as in snapshot rendering mode, we may not have a call to clear() before _endCurrentRenderPass(), so lazy creation would not work)\r\n        if (this._snapshotRendering.play || this._snapshotRendering.record) {\r\n            this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);\r\n        }\r\n\r\n        if (this._cachedViewport && !forceFullscreenViewport) {\r\n            this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\r\n        } else {\r\n            if (!requiredWidth) {\r\n                requiredWidth = texture.width;\r\n                if (lodLevel) {\r\n                    requiredWidth = requiredWidth / Math.pow(2, lodLevel);\r\n                }\r\n            }\r\n            if (!requiredHeight) {\r\n                requiredHeight = texture.height;\r\n                if (lodLevel) {\r\n                    requiredHeight = requiredHeight / Math.pow(2, lodLevel);\r\n                }\r\n            }\r\n\r\n            this._viewport(0, 0, requiredWidth, requiredHeight);\r\n        }\r\n\r\n        this.wipeCaches();\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target texture from the WebGPU context\r\n     * @param texture defines the render target wrapper to unbind\r\n     * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n     * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n     */\r\n    public unBindFramebuffer(texture: RenderTargetWrapper, disableGenerateMipMaps = false, onBeforeUnbind?: () => void): void {\r\n        const saveCrt = this._currentRenderTarget;\r\n\r\n        this._currentRenderTarget = null; // to be iso with abstractEngine, this._currentRenderTarget must be null when onBeforeUnbind is called\r\n\r\n        if (onBeforeUnbind) {\r\n            onBeforeUnbind();\r\n        }\r\n\r\n        this._currentRenderTarget = saveCrt;\r\n\r\n        this._endCurrentRenderPass();\r\n\r\n        this._resolveAndGenerateMipMapsFramebuffer(texture, disableGenerateMipMaps);\r\n\r\n        this._currentRenderTarget = null;\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log(\"frame #\" + (this as any)._count + \" - unBindFramebuffer - rtt name=\" + texture.label + \", internalTexture.uniqueId=\", texture.texture?.uniqueId);\r\n            }\r\n        }\r\n\r\n        this._mrtAttachments = [];\r\n        this._cacheRenderPipeline.setMRT([]);\r\n        this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n    }\r\n\r\n    private _resolveAndGenerateMipMapsFramebuffer(texture: RenderTargetWrapper, disableGenerateMipMaps = false): void {\r\n        const webglRtWrapper = texture;\r\n\r\n        if (!webglRtWrapper.disableAutomaticMSAAResolve) {\r\n            // we pass false as the second parameter because the color resolve has already been done automatically when the render pass ended\r\n            this.resolveFramebuffer(texture, false);\r\n        }\r\n\r\n        if (!disableGenerateMipMaps) {\r\n            if (texture.isMulti) {\r\n                this.generateMipMapsMultiFramebuffer(texture);\r\n            } else {\r\n                this.generateMipMapsFramebuffer(texture);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates mipmaps for the texture of the (single) render target\r\n     * @param texture The render target containing the texture to generate the mipmaps for\r\n     */\r\n    public generateMipMapsFramebuffer(texture: RenderTargetWrapper): void {\r\n        if (!texture.isMulti && texture.texture?.generateMipMaps && !texture.isCube) {\r\n            this._generateMipmaps(texture.texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resolves the MSAA texture of the render target into its non-MSAA version.\r\n     * Note that if \"texture\" is not a MSAA render target, no resolve is performed.\r\n     * @param texture The render target texture containing the MSAA texture to resolve\r\n     * @param resolveColors If true, resolve the color textures (default: true) - still subject to texture.resolveMSAAColors\r\n     */\r\n    public resolveFramebuffer(texture: RenderTargetWrapper, resolveColors = true): void {\r\n        if (texture.samples <= 1) {\r\n            return;\r\n        }\r\n\r\n        if (texture.resolveMSAAColors && resolveColors) {\r\n            const disableAutomaticMSAAResolve = texture.disableAutomaticMSAAResolve;\r\n\r\n            texture.disableAutomaticMSAAResolve = false;\r\n\r\n            // Simply bind and unbind the framebuffer to trigger the resolve\r\n            this.bindFramebuffer(texture);\r\n            this._startRenderTargetRenderPass(this._currentRenderTarget!, false, null, false, false);\r\n            this.unBindFramebuffer(texture);\r\n\r\n            texture.disableAutomaticMSAAResolve = disableAutomaticMSAAResolve;\r\n        }\r\n\r\n        if (texture.resolveMSAADepth && texture._depthStencilTexture) {\r\n            const gpuTextureWrapper = texture._depthStencilTexture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n            this._textureHelper.resolveMSAADepthTexture(gpuTextureWrapper.getMSAATexture(0)!, gpuTextureWrapper.underlyingResource!, this._renderEncoder);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target and bind the default framebuffer\r\n     */\r\n    public restoreDefaultFramebuffer(): void {\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        } else if (!this._currentRenderPass) {\r\n            this._startMainRenderPass(false);\r\n        }\r\n\r\n        if (this._cachedViewport) {\r\n            this.setViewport(this._cachedViewport);\r\n        }\r\n\r\n        this.wipeCaches();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Render\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setColorFormat(wrapper: IWebGPURenderPassWrapper): void {\r\n        const format = wrapper.colorAttachmentGPUTextures[0]?.format ?? null;\r\n        this._cacheRenderPipeline.setColorFormat(format);\r\n        if (this._colorFormat === format) {\r\n            return;\r\n        }\r\n        this._colorFormat = format;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setDepthTextureFormat(wrapper: IWebGPURenderPassWrapper): void {\r\n        this._cacheRenderPipeline.setDepthStencilFormat(wrapper.depthTextureFormat);\r\n        if (this._depthTextureFormat === wrapper.depthTextureFormat) {\r\n            return;\r\n        }\r\n        this._depthTextureFormat = wrapper.depthTextureFormat;\r\n    }\r\n\r\n    public setDitheringState(): void {\r\n        // Does not exist in WebGPU\r\n    }\r\n\r\n    public setRasterizerState(): void {\r\n        // Does not exist in WebGPU\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void) {\r\n        // No parallel shader compilation.\r\n        // No Async, so direct launch\r\n        action();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public bindSamplers(): void {}\r\n\r\n    /** @internal */\r\n    public _getUnpackAlignement(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTextureDirectly(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public setStateCullFaceType(cullBackFaces?: boolean, force = false) {\r\n        const cullFace = (this.cullBackFaces ?? cullBackFaces ?? true) ? 1 : 2;\r\n        if (this._depthCullingState.cullFace !== cullFace || force) {\r\n            this._depthCullingState.cullFace = cullFace;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set various states to the webGL context\r\n     * @param culling defines culling state: true to enable culling, false to disable it\r\n     * @param zOffset defines the value to apply to zOffset (0 by default)\r\n     * @param force defines if states must be applied even if cache is up to date\r\n     * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\r\n     * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\r\n     * @param stencil stencil states to set\r\n     * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\r\n     */\r\n    public setState(culling: boolean, zOffset: number = 0, force?: boolean, reverseSide = false, cullBackFaces?: boolean, stencil?: IStencilState, zOffsetUnits: number = 0): void {\r\n        // Culling\r\n        if (this._depthCullingState.cull !== culling || force) {\r\n            this._depthCullingState.cull = culling;\r\n        }\r\n\r\n        // Cull face\r\n        this.setStateCullFaceType(cullBackFaces, force);\r\n\r\n        // Z offset\r\n        this.setZOffset(zOffset);\r\n        this.setZOffsetUnits(zOffsetUnits);\r\n\r\n        // Front face\r\n        const frontFace = reverseSide ? (this._currentRenderTarget ? 1 : 2) : this._currentRenderTarget ? 2 : 1;\r\n        if (this._depthCullingState.frontFace !== frontFace || force) {\r\n            this._depthCullingState.frontFace = frontFace;\r\n        }\r\n\r\n        this._stencilStateComposer.stencilMaterial = stencil;\r\n    }\r\n\r\n    private _applyRenderPassChanges(bundleList: Nullable<WebGPUBundleList>): void {\r\n        const mustUpdateStencilRef = !this._stencilStateComposer.enabled ? false : this._mustUpdateStencilRef();\r\n        const mustUpdateBlendColor = !this._alphaState.alphaBlend ? false : this._mustUpdateBlendColor();\r\n\r\n        if (this._mustUpdateViewport()) {\r\n            this._applyViewport(bundleList);\r\n        }\r\n        if (this._mustUpdateScissor()) {\r\n            this._applyScissor(bundleList);\r\n        }\r\n        if (mustUpdateStencilRef) {\r\n            this._applyStencilRef(bundleList);\r\n        }\r\n        if (mustUpdateBlendColor) {\r\n            this._applyBlendColor(bundleList);\r\n        }\r\n    }\r\n\r\n    private _draw(drawType: number, fillMode: number, start: number, count: number, instancesCount: number): void {\r\n        const renderPass = this._getCurrentRenderPass();\r\n        const bundleList = this._bundleList;\r\n\r\n        this.applyStates();\r\n\r\n        const webgpuPipelineContext = this._currentEffect!._pipelineContext as WebGPUPipelineContext;\r\n\r\n        this.bindUniformBufferBase(this._currentRenderTarget ? this._ubInvertY : this._ubDontInvertY, 0, WebGPUShaderProcessor.InternalsUBOName);\r\n\r\n        this._currentDrawContext.setVertexPulling(\r\n            this._currentMaterialContext.useVertexPulling,\r\n            webgpuPipelineContext,\r\n            this._currentVertexBuffers,\r\n            this._cacheRenderPipeline.indexBuffer, // don't use this._currentIndexBuffer, it will have been set to null by _drawArraysType!\r\n            this._currentOverrideVertexBuffers\r\n        );\r\n\r\n        if (webgpuPipelineContext.uniformBuffer) {\r\n            webgpuPipelineContext.uniformBuffer.update();\r\n            this.bindUniformBufferBase(webgpuPipelineContext.uniformBuffer.getBuffer()!, 0, WebGPUShaderProcessor.LeftOvertUBOName);\r\n        }\r\n\r\n        if (this._snapshotRendering.play) {\r\n            this._reportDrawCall();\r\n            return;\r\n        }\r\n\r\n        if (\r\n            !this.compatibilityMode &&\r\n            (this._currentDrawContext.isDirty(this._currentMaterialContext.updateId) || this._currentMaterialContext.isDirty || this._currentMaterialContext.forceBindGroupCreation)\r\n        ) {\r\n            this._currentDrawContext.fastBundle = undefined;\r\n        }\r\n\r\n        const useFastPath = !this.compatibilityMode && this._currentDrawContext.fastBundle;\r\n        let renderPass2: GPURenderPassEncoder | GPURenderBundleEncoder = renderPass;\r\n\r\n        if (useFastPath || this._snapshotRendering.record) {\r\n            this._applyRenderPassChanges(bundleList);\r\n            if (!this._snapshotRendering.record) {\r\n                this._counters.numBundleReuseNonCompatMode++;\r\n                if (this._currentDrawContext.indirectDrawBuffer) {\r\n                    this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\r\n                }\r\n                bundleList.addBundle(this._currentDrawContext.fastBundle);\r\n                this._reportDrawCall();\r\n                return;\r\n            }\r\n\r\n            renderPass2 = bundleList.getBundleEncoder(this._cacheRenderPipeline.colorFormats, this._depthTextureFormat, this.currentSampleCount); // for snapshot recording mode\r\n            bundleList.numDrawCalls++;\r\n        }\r\n\r\n        let textureState = 0;\r\n        if (this._currentMaterialContext.hasFloatOrDepthTextures) {\r\n            let bitVal = 1;\r\n            for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.textureNames.length; ++i) {\r\n                const textureName = webgpuPipelineContext.shaderProcessingContext.textureNames[i];\r\n                const texture = this._currentMaterialContext.textures[textureName]?.texture;\r\n                const textureIsDepth = texture && texture.format >= Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 && texture.format <= Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8;\r\n                if ((texture?.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) || textureIsDepth) {\r\n                    textureState |= bitVal;\r\n                }\r\n                bitVal = bitVal << 1;\r\n            }\r\n        }\r\n\r\n        this._currentMaterialContext.textureState = textureState;\r\n\r\n        const pipeline = this._cacheRenderPipeline.getRenderPipeline(fillMode, this._currentEffect!, this.currentSampleCount, textureState);\r\n\r\n        const bindGroups = this._cacheBindGroups.getBindGroups(webgpuPipelineContext, this._currentDrawContext, this._currentMaterialContext);\r\n\r\n        if (!this._snapshotRendering.record) {\r\n            this._applyRenderPassChanges(!this.compatibilityMode ? bundleList : null);\r\n            if (!this.compatibilityMode) {\r\n                this._counters.numBundleCreationNonCompatMode++;\r\n                renderPass2 = this._device.createRenderBundleEncoder({\r\n                    colorFormats: this._cacheRenderPipeline.colorFormats,\r\n                    depthStencilFormat: this._depthTextureFormat,\r\n                    sampleCount: WebGPUTextureHelper.GetSample(this.currentSampleCount),\r\n                });\r\n            }\r\n        }\r\n\r\n        // bind pipeline\r\n        renderPass2.setPipeline(pipeline);\r\n\r\n        // bind index/vertex buffers\r\n        if (this._currentIndexBuffer) {\r\n            renderPass2.setIndexBuffer(\r\n                this._currentIndexBuffer.underlyingResource,\r\n                this._currentIndexBuffer.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16,\r\n                0\r\n            );\r\n        }\r\n\r\n        const vertexBuffers = this._cacheRenderPipeline.vertexBuffers;\r\n        for (let index = 0; index < vertexBuffers.length; index++) {\r\n            const vertexBuffer = vertexBuffers[index];\r\n\r\n            const buffer = vertexBuffer.effectiveBuffer;\r\n            if (buffer) {\r\n                renderPass2.setVertexBuffer(index, buffer.underlyingResource, vertexBuffer._validOffsetRange ? 0 : vertexBuffer.byteOffset);\r\n            }\r\n        }\r\n\r\n        // bind bind groups\r\n        for (let i = 0; i < bindGroups.length; i++) {\r\n            renderPass2.setBindGroup(i, bindGroups[i]);\r\n        }\r\n\r\n        // draw\r\n        const nonCompatMode = !this.compatibilityMode && !this._snapshotRendering.record;\r\n\r\n        if ((nonCompatMode || this._currentDrawContext._enableIndirectDrawInCompatMode) && this._currentDrawContext.indirectDrawBuffer) {\r\n            this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\r\n            if (drawType === 0) {\r\n                renderPass2.drawIndexedIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\r\n            } else {\r\n                renderPass2.drawIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\r\n            }\r\n        } else if (drawType === 0) {\r\n            renderPass2.drawIndexed(count, instancesCount || 1, start, 0, 0);\r\n        } else {\r\n            renderPass2.draw(count, instancesCount || 1, start, 0);\r\n        }\r\n\r\n        if (nonCompatMode) {\r\n            this._currentDrawContext.fastBundle = (renderPass2 as GPURenderBundleEncoder).finish();\r\n            bundleList.addBundle(this._currentDrawContext.fastBundle);\r\n        }\r\n\r\n        this._reportDrawCall();\r\n    }\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount: number = 1): void {\r\n        this._draw(0, fillMode, indexStart, indexCount, instancesCount);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount: number = 1): void {\r\n        this._currentIndexBuffer = null;\r\n        this._draw(1, fillMode, verticesStart, verticesCount, instancesCount);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dispose\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Dispose and release all associated resources\r\n     */\r\n    public override dispose(): void {\r\n        this._isDisposed = true;\r\n        this.hideLoadingUI();\r\n        this._timestampQuery.dispose();\r\n        this._mainTexture?.destroy();\r\n        this._depthTexture?.destroy();\r\n        this._textureHelper.destroyDeferredTextures();\r\n        this._bufferManager.destroyDeferredBuffers();\r\n        this._device.destroy();\r\n\r\n        _CommonDispose(this, this._renderingCanvas);\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Misc\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets the current render width\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render width\r\n     */\r\n    public getRenderWidth(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.width;\r\n        }\r\n\r\n        return this._renderingCanvas?.width ?? 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current render height\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render height\r\n     */\r\n    public getRenderHeight(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.height;\r\n        }\r\n\r\n        return this._renderingCanvas?.height ?? 0;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Errors\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Get the current error code of the WebGPU context\r\n     * @returns the error code\r\n     */\r\n    public getError(): number {\r\n        // TODO WEBGPU. from the webgpu errors.\r\n        return 0;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              External Textures\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates an external texture\r\n     * @param video video element\r\n     * @returns the external texture, or null if external textures are not supported by the engine\r\n     */\r\n    public createExternalTexture(video: HTMLVideoElement): Nullable<ExternalTexture> {\r\n        const texture = new WebGPUExternalTexture(video);\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Sets an internal texture to the according uniform.\r\n     * @param name The name of the uniform in the effect\r\n     * @param texture The texture to apply\r\n     */\r\n    public setExternalTexture(name: string, texture: Nullable<ExternalTexture>): void {\r\n        if (!texture) {\r\n            this._currentMaterialContext.setTexture(name, null);\r\n            return;\r\n        }\r\n        this._setInternalTexture(name, texture);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Samplers\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Sets a texture sampler to the according uniform.\r\n     * @param name The name of the uniform in the effect\r\n     * @param sampler The sampler to apply\r\n     */\r\n    public setTextureSampler(name: string, sampler: Nullable<TextureSampler>): void {\r\n        this._currentMaterialContext?.setSampler(name, sampler);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Storage Buffers\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a storage buffer\r\n     * @param data the data for the storage buffer or the size of the buffer\r\n     * @param creationFlags flags to use when creating the buffer (see Constants.BUFFER_CREATIONFLAG_XXX). The BUFFER_CREATIONFLAG_STORAGE flag will be automatically added\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns the new buffer\r\n     */\r\n    public createStorageBuffer(data: DataArray | number, creationFlags: number, label?: string): DataBuffer {\r\n        return this._createBuffer(data, creationFlags | Constants.BUFFER_CREATIONFLAG_STORAGE, label);\r\n    }\r\n\r\n    /**\r\n     * Clears a storage buffer to zeroes\r\n     * @param storageBuffer the storage buffer to clear\r\n     * @param byteOffset the byte offset to start clearing (optional)\r\n     * @param byteLength the byte length to clear (optional)\r\n     */\r\n    public clearStorageBuffer(storageBuffer: DataBuffer, byteOffset?: number, byteLength?: number): void {\r\n        this._renderEncoder.clearBuffer(storageBuffer.underlyingResource, byteOffset, byteLength);\r\n    }\r\n\r\n    /**\r\n     * Updates a storage buffer\r\n     * @param buffer the storage buffer to update\r\n     * @param data the data used to update the storage buffer\r\n     * @param byteOffset the byte offset of the data\r\n     * @param byteLength the byte length of the data\r\n     */\r\n    public updateStorageBuffer(buffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n        const dataBuffer = buffer as WebGPUDataBuffer;\r\n        if (byteOffset === undefined) {\r\n            byteOffset = 0;\r\n        }\r\n\r\n        let view: ArrayBufferView;\r\n        if (byteLength === undefined) {\r\n            if (data instanceof Array) {\r\n                view = new Float32Array(data);\r\n            } else if (data instanceof ArrayBuffer) {\r\n                view = new Uint8Array(data);\r\n            } else {\r\n                view = data;\r\n            }\r\n            byteLength = view.byteLength;\r\n        } else {\r\n            if (data instanceof Array) {\r\n                view = new Float32Array(data);\r\n            } else if (data instanceof ArrayBuffer) {\r\n                view = new Uint8Array(data);\r\n            } else {\r\n                view = data;\r\n            }\r\n        }\r\n\r\n        this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\r\n    }\r\n\r\n    private async _readFromGPUBuffer(gpuBuffer: GPUBuffer, size: number, buffer?: ArrayBufferView, noDelay?: boolean): Promise<ArrayBufferView> {\r\n        return await new Promise((resolve, reject) => {\r\n            const readFromBuffer = () => {\r\n                // eslint-disable-next-line github/no-then\r\n                gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, 0, size).then(\r\n                    () => {\r\n                        const copyArrayBuffer = gpuBuffer.getMappedRange(0, size);\r\n                        let data: ArrayBufferView | undefined = buffer;\r\n                        if (data === undefined) {\r\n                            data = new Uint8Array(size);\r\n                            (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                        } else {\r\n                            const ctor = data.constructor as any; // we want to create result data with the same type as buffer (Uint8Array, Float32Array, ...)\r\n                            data = new ctor(data.buffer);\r\n                            (data as any).set(new ctor(copyArrayBuffer));\r\n                        }\r\n                        gpuBuffer.unmap();\r\n                        this._bufferManager.releaseBuffer(gpuBuffer);\r\n                        resolve(data!);\r\n                    },\r\n                    (reason) => {\r\n                        if (this.isDisposed) {\r\n                            resolve(new Uint8Array());\r\n                        } else {\r\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                            reject(reason);\r\n                        }\r\n                    }\r\n                );\r\n            };\r\n\r\n            if (noDelay) {\r\n                this.flushFramebuffer();\r\n                readFromBuffer();\r\n            } else {\r\n                // we are using onEndFrameObservable because we need to map the gpuBuffer AFTER the command buffers\r\n                // have been submitted, else we get the error: \"Buffer used in a submit while mapped\"\r\n                this.onEndFrameObservable.addOnce(() => {\r\n                    readFromBuffer();\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Read data from a storage buffer\r\n     * @param storageBuffer The storage buffer to read from\r\n     * @param offset The offset in the storage buffer to start reading from (default: 0)\r\n     * @param size  The number of bytes to read from the storage buffer (default: capacity of the buffer)\r\n     * @param buffer The buffer to write the data we have read from the storage buffer to (optional)\r\n     * @param noDelay If true, a call to flushFramebuffer will be issued so that the data can be read back immediately and not in engine.onEndFrameObservable. This can speed up data retrieval, at the cost of a small perf penalty (default: false).\r\n     * @returns If not undefined, returns the (promise) buffer (as provided by the 4th parameter) filled with the data, else it returns a (promise) Uint8Array with the data read from the storage buffer\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    public readFromStorageBuffer(storageBuffer: DataBuffer, offset?: number, size?: number, buffer?: ArrayBufferView, noDelay?: boolean): Promise<ArrayBufferView> {\r\n        size = size || storageBuffer.capacity;\r\n\r\n        const gpuBuffer = this._bufferManager.createRawBuffer(\r\n            size,\r\n            WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst,\r\n            undefined,\r\n            \"TempReadFromStorageBuffer\"\r\n        );\r\n\r\n        this._renderEncoder.copyBufferToBuffer(storageBuffer.underlyingResource, offset ?? 0, gpuBuffer, 0, size);\r\n\r\n        return this._readFromGPUBuffer(gpuBuffer, size, buffer, noDelay);\r\n    }\r\n\r\n    /**\r\n     * Read data from multiple storage buffers\r\n     * @param storageBuffers The list of storage buffers to read from\r\n     * @param offset The offset in the storage buffer to start reading from (default: 0). This is the same offset for all storage buffers!\r\n     * @param size  The number of bytes to read from each storage buffer (default: capacity of the first buffer)\r\n     * @param buffer The buffer to write the data we have read from the storage buffers to (optional). If provided, the buffer should be large enough to hold the data from all storage buffers!\r\n     * @param noDelay If true, a call to flushFramebuffer will be issued so that the data can be read back immediately and not in engine.onEndFrameObservable. This can speed up data retrieval, at the cost of a small perf penalty (default: false).\r\n     * @returns If not undefined, returns the (promise) buffer (as provided by the 4th parameter) filled with the data, else it returns a (promise) Uint8Array with the data read from the storage buffer\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    public readFromMultipleStorageBuffers(storageBuffers: DataBuffer[], offset?: number, size?: number, buffer?: ArrayBufferView, noDelay?: boolean): Promise<ArrayBufferView> {\r\n        size = size || storageBuffers[0].capacity;\r\n\r\n        const gpuBuffer = this._bufferManager.createRawBuffer(\r\n            size * storageBuffers.length,\r\n            WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst,\r\n            undefined,\r\n            \"TempReadFromMultipleStorageBuffers\"\r\n        );\r\n\r\n        for (let i = 0; i < storageBuffers.length; i++) {\r\n            this._renderEncoder.copyBufferToBuffer(storageBuffers[i].underlyingResource, offset ?? 0, gpuBuffer, i * size, size);\r\n        }\r\n\r\n        return this._readFromGPUBuffer(gpuBuffer, size * storageBuffers.length, buffer, noDelay);\r\n    }\r\n\r\n    /**\r\n     * Sets a storage buffer in the shader\r\n     * @param name Defines the name of the storage buffer as defined in the shader\r\n     * @param buffer Defines the value to give to the uniform\r\n     */\r\n    public setStorageBuffer(name: string, buffer: Nullable<StorageBuffer>): void {\r\n        this._currentDrawContext?.setBuffer(name, (buffer?.getBuffer() as WebGPUDataBuffer) ?? null);\r\n    }\r\n}\r\n", "import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IMultiRenderTargetOptions } from \"../../../Materials/Textures/multiRenderTarget\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPURenderTargetWrapper } from \"../webgpuRenderTargetWrapper\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Unbind a list of render target textures from the webGL context\r\n         * This is used only when drawBuffer extension or webGL2 are active\r\n         * @param rtWrapper defines the render target wrapper to unbind\r\n         * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n         * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n         */\r\n        unBindMultiColorAttachmentFramebuffer(rtWrapper: RenderTargetWrapper, disableGenerateMipMaps: boolean, onBeforeUnbind?: () => void): void;\r\n\r\n        /**\r\n         * Create a multi render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multiple-render-target\r\n         * @param size defines the size of the texture\r\n         * @param options defines the creation options\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns a new render target wrapper ready to render textures\r\n         */\r\n        createMultipleRenderTarget(size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Update the sample count for a given multiple render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multisample-render-targets\r\n         * @param rtWrapper defines the render target wrapper to update\r\n         * @param samples defines the sample count to set\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n         */\r\n        updateMultipleRenderTargetTextureSampleCount(rtWrapper: Nullable<RenderTargetWrapper>, samples: number, initializeBuffers?: boolean): number;\r\n\r\n        /**\r\n         * Generates mipmaps for the texture of the (multi) render target\r\n         * @param texture The render target containing the textures to generate the mipmaps for\r\n         */\r\n        generateMipMapsMultiFramebuffer(texture: RenderTargetWrapper): void;\r\n\r\n        /**\r\n         * Resolves the MSAA textures of the (multi) render target into their non-MSAA version.\r\n         * Note that if \"texture\" is not a MSAA render target, no resolve is performed.\r\n         * @param texture The render target texture containing the MSAA textures to resolve\r\n         * @param resolveColors If true, resolve the color textures (default: true) - still subject to texture.resolveMSAAColors\r\n         */\r\n        resolveMultiFramebuffer(texture: RenderTargetWrapper, resolveColors?: boolean): void;\r\n\r\n        /**\r\n         * Select a subsets of attachments to draw to.\r\n         * @param attachments gl attachments\r\n         */\r\n        bindAttachments(attachments: number[]): void;\r\n\r\n        /**\r\n         * Creates a layout object to draw/clear on specific textures in a MRT\r\n         * @param textureStatus textureStatus[i] indicates if the i-th is active\r\n         * @param backBufferLayout if true, the layout will be built to account for the back buffer only, and textureStatus won't be used\r\n         * @returns A layout to be fed to the engine, calling `bindAttachments`.\r\n         */\r\n        buildTextureLayout(textureStatus: boolean[], backBufferLayout?: boolean): number[];\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is the canvas frame buffer\r\n         */\r\n        restoreSingleAttachment(): void;\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is not the canvas frame buffer\r\n         */\r\n        restoreSingleAttachmentForRenderTarget(): void;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (\r\n    rtWrapper: RenderTargetWrapper,\r\n    disableGenerateMipMaps: boolean = false,\r\n    onBeforeUnbind?: () => void\r\n): void {\r\n    if (onBeforeUnbind) {\r\n        onBeforeUnbind();\r\n    }\r\n\r\n    this._endCurrentRenderPass();\r\n\r\n    if (!rtWrapper.disableAutomaticMSAAResolve) {\r\n        this.resolveMultiFramebuffer(rtWrapper, false);\r\n    }\r\n\r\n    if (!disableGenerateMipMaps) {\r\n        this.generateMipMapsMultiFramebuffer(rtWrapper);\r\n    }\r\n\r\n    this._currentRenderTarget = null;\r\n\r\n    this._mrtAttachments = [];\r\n    this._cacheRenderPipeline.setMRT([]);\r\n    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n};\r\n\r\nWebGPUEngine.prototype.createMultipleRenderTarget = function (size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper {\r\n    let generateMipMaps = false;\r\n    let generateDepthBuffer = true;\r\n    let generateStencilBuffer = false;\r\n    let generateDepthTexture = false;\r\n    let depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH16;\r\n    let textureCount = 1;\r\n    let samples = 1;\r\n\r\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    const defaultUseSRGBBuffer = false;\r\n    const defaultFormat = Constants.TEXTUREFORMAT_RGBA;\r\n    const defaultTarget = Constants.TEXTURE_2D;\r\n\r\n    let types: number[] = [];\r\n    let samplingModes: number[] = [];\r\n    let useSRGBBuffers: boolean[] = [];\r\n    let formats: number[] = [];\r\n    let targets: number[] = [];\r\n    let faceIndex: number[] = [];\r\n    let layerIndex: number[] = [];\r\n    let layers: number[] = [];\r\n    let labels: string[] = [];\r\n    let creationFlags: number[] = [];\r\n    let dontCreateTextures = false;\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size) as WebGPURenderTargetWrapper;\r\n\r\n    if (options !== undefined) {\r\n        generateMipMaps = options.generateMipMaps ?? false;\r\n        generateDepthBuffer = options.generateDepthBuffer ?? true;\r\n        generateStencilBuffer = options.generateStencilBuffer ?? false;\r\n        generateDepthTexture = options.generateDepthTexture ?? false;\r\n        textureCount = options.textureCount ?? 1;\r\n        depthTextureFormat = options.depthTextureFormat ?? Constants.TEXTUREFORMAT_DEPTH16;\r\n        types = options.types || types;\r\n        samplingModes = options.samplingModes || samplingModes;\r\n        useSRGBBuffers = options.useSRGBBuffers || useSRGBBuffers;\r\n        formats = options.formats || formats;\r\n        targets = options.targetTypes || targets;\r\n        faceIndex = options.faceIndex || faceIndex;\r\n        layerIndex = options.layerIndex || layerIndex;\r\n        layers = options.layerCounts || layers;\r\n        labels = options.labels || labels;\r\n        creationFlags = options.creationFlags || creationFlags;\r\n        samples = options.samples ?? samples;\r\n        dontCreateTextures = options.dontCreateTextures ?? false;\r\n    }\r\n\r\n    const width = (<{ width: number; height: number }>size).width ?? <number>size;\r\n    const height = (<{ width: number; height: number }>size).height ?? <number>size;\r\n\r\n    const textures: InternalTexture[] = [];\r\n    const attachments: number[] = [];\r\n    const defaultAttachments: number[] = [];\r\n\r\n    rtWrapper.label = options?.label ?? \"MultiRenderTargetWrapper\";\r\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\r\n    rtWrapper._attachments = attachments;\r\n    rtWrapper._defaultAttachments = defaultAttachments;\r\n\r\n    let depthStencilTexture: Nullable<InternalTexture> = null;\r\n    if ((generateDepthBuffer || generateStencilBuffer || generateDepthTexture) && !dontCreateTextures) {\r\n        if (!generateDepthTexture) {\r\n            // The caller doesn't want a depth texture, so we are free to use the depth texture format we want.\r\n            // So, we will align with what the WebGL engine does\r\n            if (generateDepthBuffer && generateStencilBuffer) {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH24_STENCIL8;\r\n            } else if (generateDepthBuffer) {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH32_FLOAT;\r\n            } else {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_STENCIL8;\r\n            }\r\n        }\r\n        depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat, rtWrapper.label + \"-DepthStencil\");\r\n    }\r\n\r\n    const mipmapsCreationOnly = options !== undefined && typeof options === \"object\" && options.createMipMaps && !generateMipMaps;\r\n\r\n    for (let i = 0; i < textureCount; i++) {\r\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\r\n        let type = types[i] || defaultType;\r\n\r\n        const format = formats[i] || defaultFormat;\r\n        const useSRGBBuffer = (useSRGBBuffers[i] || defaultUseSRGBBuffer) && this._caps.supportSRGBBuffers;\r\n\r\n        const target = targets[i] || defaultTarget;\r\n        const layerCount = layers[i] ?? 1;\r\n        const creationFlag = creationFlags[i];\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\r\n        }\r\n\r\n        attachments.push(i + 1);\r\n        defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);\r\n\r\n        if (target === -1 || dontCreateTextures) {\r\n            continue;\r\n        }\r\n\r\n        const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\r\n        textures[i] = texture;\r\n\r\n        switch (target) {\r\n            case Constants.TEXTURE_CUBE_MAP:\r\n                texture.isCube = true;\r\n                break;\r\n            case Constants.TEXTURE_3D:\r\n                texture.is3D = true;\r\n                texture.baseDepth = texture.depth = layerCount;\r\n                break;\r\n            case Constants.TEXTURE_2D_ARRAY:\r\n                texture.is2DArray = true;\r\n                texture.baseDepth = texture.depth = layerCount;\r\n                break;\r\n        }\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n        texture.format = format;\r\n        texture.label = labels[i] ?? rtWrapper.label + \"-Texture\" + i;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        if (mipmapsCreationOnly) {\r\n            // createGPUTextureForInternalTexture will only create a texture with mipmaps if generateMipMaps is true, as InternalTexture has no createMipMaps property, separate from generateMipMaps.\r\n            texture.generateMipMaps = true;\r\n        }\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture, undefined, undefined, undefined, creationFlag, true);\r\n\r\n        if (mipmapsCreationOnly) {\r\n            texture.generateMipMaps = false;\r\n        }\r\n    }\r\n\r\n    if (depthStencilTexture) {\r\n        depthStencilTexture.incrementReferences();\r\n        textures[textureCount] = depthStencilTexture;\r\n        this._internalTexturesCache.push(depthStencilTexture);\r\n    }\r\n\r\n    rtWrapper.setTextures(textures);\r\n    rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\r\n\r\n    if (!dontCreateTextures) {\r\n        this.updateMultipleRenderTargetTextureSampleCount(rtWrapper, samples);\r\n    } else {\r\n        rtWrapper._samples = samples;\r\n    }\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nWebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number {\r\n    if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures.length === 0 || rtWrapper.textures[0].samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    const count = rtWrapper.textures.length;\r\n\r\n    if (count === 0) {\r\n        return 1;\r\n    }\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    for (let i = 0; i < count; ++i) {\r\n        const texture = rtWrapper.textures[i];\r\n        const gpuTextureWrapper = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        gpuTextureWrapper?.releaseMSAATexture(rtWrapper.getBaseArrayLayer(i));\r\n    }\r\n\r\n    // Note that rtWrapper.textures can't have null textures, lastTextureIsDepthTexture can't be true if rtWrapper._depthStencilTexture is null\r\n    const lastTextureIsDepthTexture = rtWrapper._depthStencilTexture === rtWrapper.textures[count - 1];\r\n\r\n    for (let i = 0; i < count; ++i) {\r\n        const texture = rtWrapper.textures[i];\r\n        this._textureHelper.createMSAATexture(texture, samples, false, rtWrapper.getBaseArrayLayer(i));\r\n        texture.samples = samples;\r\n    }\r\n\r\n    // Note that the last texture of textures is the depth texture if the depth texture has been generated by the MRT class and so the MSAA texture\r\n    // will be recreated for this texture by the loop above: in that case, there's no need to create the MSAA texture for rtWrapper._depthStencilTexture\r\n    // because rtWrapper._depthStencilTexture is the same texture than the depth texture\r\n    if (rtWrapper._depthStencilTexture && !lastTextureIsDepthTexture) {\r\n        this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\r\n        rtWrapper._depthStencilTexture.samples = samples;\r\n    }\r\n\r\n    rtWrapper._samples = samples;\r\n\r\n    return samples;\r\n};\r\n\r\nWebGPUEngine.prototype.generateMipMapsMultiFramebuffer = function (texture: RenderTargetWrapper): void {\r\n    const rtWrapper = texture as WebGPURenderTargetWrapper;\r\n\r\n    if (!rtWrapper.isMulti) {\r\n        return;\r\n    }\r\n\r\n    const attachments = rtWrapper._attachments!;\r\n    const count = attachments.length;\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n        if (texture.generateMipMaps && !texture.isCube && !texture.is3D) {\r\n            this._generateMipmaps(texture);\r\n        }\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype.resolveMultiFramebuffer = function (texture: RenderTargetWrapper, resolveColors: boolean = true): void {\r\n    this.resolveFramebuffer(texture, resolveColors);\r\n};\r\n\r\nWebGPUEngine.prototype.bindAttachments = function (attachments: number[]): void {\r\n    if (attachments.length === 0 || !this._currentRenderTarget) {\r\n        return;\r\n    }\r\n\r\n    this._mrtAttachments = attachments;\r\n    if (this._currentRenderPass) {\r\n        // the render pass has already been created, we need to call setMRTAttachments to update the state of the attachments\r\n        this._cacheRenderPipeline.setMRTAttachments(attachments);\r\n    } else {\r\n        // the render pass is not created yet so we don't need to call setMRTAttachments: it will be called as part of the render pass creation (see WebGPUEngine._startRenderTargetRenderPass)\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype.buildTextureLayout = function (textureStatus: boolean[], backBufferLayout = false): number[] {\r\n    const result = [];\r\n\r\n    if (backBufferLayout) {\r\n        result.push(1);\r\n    } else {\r\n        for (let i = 0; i < textureStatus.length; i++) {\r\n            if (textureStatus[i]) {\r\n                result.push(i + 1);\r\n            } else {\r\n                result.push(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nWebGPUEngine.prototype.restoreSingleAttachment = function (): void {\r\n    // not sure what to do, probably nothing... This function and restoreSingleAttachmentForRenderTarget are not called in Babylon.js so it's hard to know the use case\r\n};\r\n\r\nWebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function (): void {\r\n    // not sure what to do, probably nothing... This function and restoreSingleAttachment are not called in Babylon.js so it's hard to know the use case\r\n};\r\n"],
  "mappings": "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E,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACvD,QAAQ,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACvD,QAAQ,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACvD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,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",
  "names": ["PowerPreference", "FeatureName", "BufferMapState", "BufferUsage", "MapMode", "TextureDimension", "TextureUsage", "TextureViewDimension", "TextureAspect", "TextureFormat", "AddressMode", "FilterMode", "MipmapFilterMode", "CompareFunction", "ShaderStage", "BufferBindingType", "SamplerBindingType", "TextureSampleType", "StorageTextureAccess", "CompilationMessageType", "PipelineErrorReason", "AutoLayoutMode", "PrimitiveTopology", "FrontFace", "CullMode", "ColorWrite", "BlendFactor", "BlendOperation", "StencilOperation", "IndexFormat", "VertexFormat", "VertexStepMode", "ComputePassTimestampLocation", "RenderPassTimestampLocation", "LoadOp", "StoreOp", "QueryType", "CanvasAlphaMode", "CanvasToneMappingMode", "DeviceLostReason", "ErrorFilter", "name", "name", "name", "name", "name", "PipelineType", "VideoPipelineType", "offset", "offset2", "StatePosition", "topology", "name", "colorStates", "name", "name", "name", "name", "shader", "name", "parameters", "name", "name", "name", "transform", "name", "translation", "name", "kind", "index", "name", "scene", "invertY", "noMipmap", "texture"]
}
