{
  "version": 3,
  "sources": ["../../../dev/core/src/Engines/Extensions/engine.multiRender.ts"],
  "sourcesContent": ["import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { IMultiRenderTargetOptions } from \"../../Materials/Textures/multiRenderTarget\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport { ThinEngine } from \"../thinEngine\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport type { WebGLRenderTargetWrapper } from \"../WebGL/webGLRenderTargetWrapper\";\r\nimport type { WebGLHardwareTexture } from \"../WebGL/webGLHardwareTexture\";\r\nimport type { TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Unbind a list of render target textures from the webGL context\r\n         * This is used only when drawBuffer extension or webGL2 are active\r\n         * @param rtWrapper defines the render target wrapper to unbind\r\n         * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n         * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n         */\r\n        unBindMultiColorAttachmentFramebuffer(rtWrapper: RenderTargetWrapper, disableGenerateMipMaps: boolean, onBeforeUnbind?: () => void): void;\r\n\r\n        /**\r\n         * Create a multi render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multiple-render-target\r\n         * @param size defines the size of the texture\r\n         * @param options defines the creation options\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns a new render target wrapper ready to render textures\r\n         */\r\n        createMultipleRenderTarget(size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Update the sample count for a given multiple render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multisample-render-targets\r\n         * @param rtWrapper defines the render target wrapper to update\r\n         * @param samples defines the sample count to set\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n         */\r\n        updateMultipleRenderTargetTextureSampleCount(rtWrapper: Nullable<RenderTargetWrapper>, samples: number, initializeBuffers?: boolean): number;\r\n\r\n        /**\r\n         * Generates mipmaps for the texture of the (multi) render target\r\n         * @param texture The render target containing the textures to generate the mipmaps for\r\n         */\r\n        generateMipMapsMultiFramebuffer(texture: RenderTargetWrapper): void;\r\n\r\n        /**\r\n         * Resolves the MSAA textures of the (multi) render target into their non-MSAA version.\r\n         * Note that if \"texture\" is not a MSAA render target, no resolve is performed.\r\n         * @param texture The render target texture containing the MSAA textures to resolve\r\n         */\r\n        resolveMultiFramebuffer(texture: RenderTargetWrapper): void;\r\n\r\n        /**\r\n         * Select a subsets of attachments to draw to.\r\n         * @param attachments gl attachments\r\n         */\r\n        bindAttachments(attachments: number[]): void;\r\n\r\n        /**\r\n         * Creates a layout object to draw/clear on specific textures in a MRT\r\n         * @param textureStatus textureStatus[i] indicates if the i-th is active\r\n         * @param backBufferLayout if true, the layout will be built to account for the back buffer only, and textureStatus won't be used\r\n         * @returns A layout to be fed to the engine, calling `bindAttachments`.\r\n         */\r\n        buildTextureLayout(textureStatus: boolean[], backBufferLayout?: boolean): number[];\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is the canvas frame buffer\r\n         */\r\n        restoreSingleAttachment(): void;\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is not the canvas frame buffer\r\n         */\r\n        restoreSingleAttachmentForRenderTarget(): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.restoreSingleAttachment = function (): void {\r\n    const gl = this._gl;\r\n\r\n    this.bindAttachments([gl.BACK]);\r\n};\r\n\r\nThinEngine.prototype.restoreSingleAttachmentForRenderTarget = function (): void {\r\n    const gl = this._gl;\r\n\r\n    this.bindAttachments([gl.COLOR_ATTACHMENT0]);\r\n};\r\n\r\nThinEngine.prototype.buildTextureLayout = function (textureStatus: boolean[], backBufferLayout = false): number[] {\r\n    const gl = this._gl;\r\n\r\n    const result = [];\r\n\r\n    if (backBufferLayout) {\r\n        result.push(gl.BACK);\r\n    } else {\r\n        for (let i = 0; i < textureStatus.length; i++) {\r\n            if (textureStatus[i]) {\r\n                result.push((<any>gl)[\"COLOR_ATTACHMENT\" + i]);\r\n            } else {\r\n                result.push(gl.NONE);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nThinEngine.prototype.bindAttachments = function (attachments: number[]): void {\r\n    const gl = this._gl;\r\n\r\n    gl.drawBuffers(attachments);\r\n};\r\n\r\nThinEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (\r\n    rtWrapper: WebGLRenderTargetWrapper,\r\n    disableGenerateMipMaps: boolean = false,\r\n    onBeforeUnbind?: () => void\r\n): void {\r\n    this._currentRenderTarget = null;\r\n\r\n    if (!rtWrapper.disableAutomaticMSAAResolve) {\r\n        this.resolveMultiFramebuffer(rtWrapper);\r\n    }\r\n\r\n    if (!disableGenerateMipMaps) {\r\n        this.generateMipMapsMultiFramebuffer(rtWrapper);\r\n    }\r\n\r\n    if (onBeforeUnbind) {\r\n        if (rtWrapper._MSAAFramebuffer) {\r\n            // Bind the correct framebuffer\r\n            this._bindUnboundFramebuffer(rtWrapper._framebuffer);\r\n        }\r\n        onBeforeUnbind();\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n};\r\n\r\nThinEngine.prototype.createMultipleRenderTarget = function (size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers: boolean = true): RenderTargetWrapper {\r\n    let generateMipMaps = false;\r\n    let generateDepthBuffer = true;\r\n    let generateStencilBuffer = false;\r\n    let generateDepthTexture = false;\r\n    let depthTextureFormat: number | undefined = undefined;\r\n    let textureCount = 1;\r\n    let samples = 1;\r\n\r\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    const defaultUseSRGBBuffer = false;\r\n    const defaultFormat = Constants.TEXTUREFORMAT_RGBA;\r\n    const defaultTarget = Constants.TEXTURE_2D;\r\n\r\n    let types: number[] = [];\r\n    let samplingModes: number[] = [];\r\n    let useSRGBBuffers: boolean[] = [];\r\n    let formats: number[] = [];\r\n    let targets: number[] = [];\r\n    let faceIndex: number[] = [];\r\n    let layerIndex: number[] = [];\r\n    let layers: number[] = [];\r\n    let labels: string[] = [];\r\n    let dontCreateTextures = false;\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size) as WebGLRenderTargetWrapper;\r\n\r\n    if (options !== undefined) {\r\n        generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\r\n        generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n        generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\r\n        textureCount = options.textureCount ?? 1;\r\n        samples = options.samples ?? samples;\r\n        types = options.types || types;\r\n        samplingModes = options.samplingModes || samplingModes;\r\n        useSRGBBuffers = options.useSRGBBuffers || useSRGBBuffers;\r\n        formats = options.formats || formats;\r\n        targets = options.targetTypes || targets;\r\n        faceIndex = options.faceIndex || faceIndex;\r\n        layerIndex = options.layerIndex || layerIndex;\r\n        layers = options.layerCounts || layers;\r\n        labels = options.labels || labels;\r\n        dontCreateTextures = options.dontCreateTextures ?? false;\r\n\r\n        if (\r\n            this.webGLVersion > 1 &&\r\n            (options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32_FLOAT ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8)\r\n        ) {\r\n            depthTextureFormat = options.depthTextureFormat;\r\n        }\r\n    }\r\n\r\n    if (depthTextureFormat === undefined) {\r\n        depthTextureFormat = generateStencilBuffer ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    // Create the framebuffer\r\n    const currentFramebuffer = this._currentFramebuffer;\r\n    const framebuffer = gl.createFramebuffer();\r\n    this._bindUnboundFramebuffer(framebuffer);\r\n\r\n    const width = (<{ width: number; height: number }>size).width ?? <number>size;\r\n    const height = (<{ width: number; height: number }>size).height ?? <number>size;\r\n\r\n    const textures: InternalTexture[] = [];\r\n    const attachments: number[] = [];\r\n\r\n    const useStencilTexture =\r\n        this.webGLVersion > 1 &&\r\n        (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 ||\r\n            depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 ||\r\n            depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8);\r\n\r\n    rtWrapper.label = options?.label ?? \"MultiRenderTargetWrapper\";\r\n    rtWrapper._framebuffer = framebuffer;\r\n    rtWrapper._generateDepthBuffer = generateDepthTexture || generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = generateDepthTexture ? useStencilTexture : generateStencilBuffer;\r\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, width, height, 1, depthTextureFormat);\r\n    rtWrapper._attachments = attachments;\r\n\r\n    for (let i = 0; i < textureCount; i++) {\r\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\r\n        let type = types[i] || defaultType;\r\n        let useSRGBBuffer = useSRGBBuffers[i] || defaultUseSRGBBuffer;\r\n        const format = formats[i] || defaultFormat;\r\n\r\n        const target = targets[i] || defaultTarget;\r\n        const layerCount = layers[i] ?? 1;\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\r\n        }\r\n\r\n        useSRGBBuffer = useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU);\r\n\r\n        const isWebGL2 = this.webGLVersion > 1;\r\n        const attachment = (<any>gl)[isWebGL2 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n\r\n        attachments.push(attachment);\r\n\r\n        if (target === -1 || dontCreateTextures) {\r\n            continue;\r\n        }\r\n\r\n        const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\r\n        textures[i] = texture;\r\n\r\n        gl.activeTexture((<any>gl)[\"TEXTURE\" + i]);\r\n        gl.bindTexture(target, texture._hardwareTexture!.underlyingResource);\r\n\r\n        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);\r\n        gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n        const internalSizedFormat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\r\n        const internalFormat = this._getInternalFormat(format);\r\n        const webGLTextureType = this._getWebGLTextureType(type);\r\n\r\n        if (isWebGL2 && (target === Constants.TEXTURE_2D_ARRAY || target === Constants.TEXTURE_3D)) {\r\n            if (target === Constants.TEXTURE_2D_ARRAY) {\r\n                texture.is2DArray = true;\r\n            } else {\r\n                texture.is3D = true;\r\n            }\r\n\r\n            texture.baseDepth = texture.depth = layerCount;\r\n\r\n            gl.texImage3D(target, 0, internalSizedFormat, width, height, layerCount, 0, internalFormat, webGLTextureType, null);\r\n        } else if (target === Constants.TEXTURE_CUBE_MAP) {\r\n            // We have to generate all faces to complete the framebuffer\r\n            for (let i = 0; i < 6; i++) {\r\n                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, internalSizedFormat, width, height, 0, internalFormat, webGLTextureType, null);\r\n            }\r\n            texture.isCube = true;\r\n        } else {\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalSizedFormat, width, height, 0, internalFormat, webGLTextureType, null);\r\n        }\r\n\r\n        if (generateMipMaps) {\r\n            gl.generateMipmap(target);\r\n        }\r\n\r\n        // Unbind\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n        texture.format = format;\r\n        texture.label = labels[i] ?? rtWrapper.label + \"-Texture\" + i;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n    }\r\n\r\n    if (generateDepthTexture && this._caps.depthTextureExtension && !dontCreateTextures) {\r\n        // Depth texture\r\n        const depthTexture = new InternalTexture(this, InternalTextureSource.Depth);\r\n\r\n        let depthTextureType = Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n        let glDepthTextureInternalFormat: GLenum = gl.DEPTH_COMPONENT16;\r\n        let glDepthTextureFormat: GLenum = gl.DEPTH_COMPONENT;\r\n        let glDepthTextureType: GLenum = gl.UNSIGNED_SHORT;\r\n        let glDepthTextureAttachment: GLenum = gl.DEPTH_ATTACHMENT;\r\n        if (this.webGLVersion < 2) {\r\n            glDepthTextureInternalFormat = gl.DEPTH_COMPONENT;\r\n        } else {\r\n            if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32_FLOAT) {\r\n                depthTextureType = Constants.TEXTURETYPE_FLOAT;\r\n                glDepthTextureType = gl.FLOAT;\r\n                glDepthTextureInternalFormat = gl.DEPTH_COMPONENT32F;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                glDepthTextureType = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;\r\n                glDepthTextureInternalFormat = gl.DEPTH32F_STENCIL8;\r\n                glDepthTextureFormat = gl.DEPTH_STENCIL;\r\n                glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                glDepthTextureType = gl.UNSIGNED_INT;\r\n                glDepthTextureInternalFormat = gl.DEPTH_COMPONENT24;\r\n                glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 || depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_INT_24_8;\r\n                glDepthTextureType = gl.UNSIGNED_INT_24_8;\r\n                glDepthTextureInternalFormat = gl.DEPTH24_STENCIL8;\r\n                glDepthTextureFormat = gl.DEPTH_STENCIL;\r\n                glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\r\n            }\r\n        }\r\n\r\n        this._bindTextureDirectly(gl.TEXTURE_2D, depthTexture, true);\r\n\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, glDepthTextureInternalFormat, width, height, 0, glDepthTextureFormat, glDepthTextureType, null);\r\n\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, glDepthTextureAttachment, gl.TEXTURE_2D, depthTexture._hardwareTexture!.underlyingResource, 0);\r\n\r\n        this._bindTextureDirectly(gl.TEXTURE_2D, null);\r\n\r\n        rtWrapper._depthStencilTexture = depthTexture;\r\n        rtWrapper._depthStencilTextureWithStencil = useStencilTexture;\r\n\r\n        depthTexture.baseWidth = width;\r\n        depthTexture.baseHeight = height;\r\n        depthTexture.width = width;\r\n        depthTexture.height = height;\r\n        depthTexture.isReady = true;\r\n        depthTexture.samples = 1;\r\n        depthTexture.generateMipMaps = generateMipMaps;\r\n        depthTexture.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        depthTexture.format = depthTextureFormat;\r\n        depthTexture.type = depthTextureType;\r\n        depthTexture.label = rtWrapper.label + \"-DepthStencil\";\r\n\r\n        textures[textureCount] = depthTexture;\r\n        this._internalTexturesCache.push(depthTexture);\r\n    }\r\n    rtWrapper.setTextures(textures);\r\n    if (initializeBuffers) {\r\n        gl.drawBuffers(attachments);\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(currentFramebuffer);\r\n\r\n    rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\r\n\r\n    this.resetTextureCache();\r\n\r\n    if (!dontCreateTextures) {\r\n        this.updateMultipleRenderTargetTextureSampleCount(rtWrapper, samples, initializeBuffers);\r\n    } else if (samples > 1) {\r\n        const framebuffer = gl.createFramebuffer();\r\n\r\n        if (!framebuffer) {\r\n            throw new Error(\"Unable to create multi sampled framebuffer\");\r\n        }\r\n\r\n        rtWrapper._samples = samples;\r\n        rtWrapper._MSAAFramebuffer = framebuffer;\r\n\r\n        if (textureCount > 0 && initializeBuffers) {\r\n            this._bindUnboundFramebuffer(framebuffer);\r\n            gl.drawBuffers(attachments);\r\n            this._bindUnboundFramebuffer(currentFramebuffer);\r\n        }\r\n    }\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nThinEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (\r\n    rtWrapper: Nullable<WebGLRenderTargetWrapper>,\r\n    samples: number,\r\n    initializeBuffers: boolean = true\r\n): number {\r\n    if (this.webGLVersion < 2 || !rtWrapper) {\r\n        return 1;\r\n    }\r\n\r\n    if (rtWrapper.samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    const gl = this._gl;\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    // Dispose previous render buffers\r\n    if (rtWrapper._depthStencilBuffer) {\r\n        gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);\r\n        rtWrapper._depthStencilBuffer = null;\r\n    }\r\n\r\n    if (rtWrapper._MSAAFramebuffer) {\r\n        gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);\r\n        rtWrapper._MSAAFramebuffer = null;\r\n    }\r\n\r\n    const count = rtWrapper._attachments!.length; // We do it this way instead of rtWrapper.textures.length to avoid taking into account the depth/stencil texture, in case it has been created\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n        const hardwareTexture = texture._hardwareTexture as Nullable<WebGLHardwareTexture>;\r\n\r\n        hardwareTexture?.releaseMSAARenderBuffers();\r\n    }\r\n\r\n    if (samples > 1 && typeof gl.renderbufferStorageMultisample === \"function\") {\r\n        const framebuffer = gl.createFramebuffer();\r\n\r\n        if (!framebuffer) {\r\n            throw new Error(\"Unable to create multi sampled framebuffer\");\r\n        }\r\n\r\n        rtWrapper._MSAAFramebuffer = framebuffer;\r\n        this._bindUnboundFramebuffer(framebuffer);\r\n\r\n        const attachments = [];\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            const texture = rtWrapper.textures![i];\r\n            const hardwareTexture = texture._hardwareTexture as WebGLHardwareTexture;\r\n            const attachment = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n\r\n            const colorRenderbuffer = this._createRenderBuffer(\r\n                texture.width,\r\n                texture.height,\r\n                samples,\r\n                -1 /* not used */,\r\n                this._getRGBABufferInternalSizedFormat(texture.type, texture.format, texture._useSRGBBuffer),\r\n                attachment\r\n            );\r\n\r\n            if (!colorRenderbuffer) {\r\n                throw new Error(\"Unable to create multi sampled framebuffer\");\r\n            }\r\n\r\n            hardwareTexture.addMSAARenderBuffer(colorRenderbuffer);\r\n            texture.samples = samples;\r\n\r\n            attachments.push(attachment);\r\n        }\r\n        if (initializeBuffers) {\r\n            gl.drawBuffers(attachments);\r\n        }\r\n    } else {\r\n        this._bindUnboundFramebuffer(rtWrapper._framebuffer);\r\n    }\r\n\r\n    const depthFormat = rtWrapper._depthStencilTexture ? rtWrapper._depthStencilTexture.format : undefined;\r\n\r\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(\r\n        rtWrapper._generateStencilBuffer,\r\n        rtWrapper._generateDepthBuffer,\r\n        rtWrapper.width,\r\n        rtWrapper.height,\r\n        samples,\r\n        depthFormat\r\n    );\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n\r\n    rtWrapper._samples = samples;\r\n\r\n    return samples;\r\n};\r\n\r\nThinEngine.prototype.generateMipMapsMultiFramebuffer = function (texture: RenderTargetWrapper): void {\r\n    const rtWrapper = texture as WebGLRenderTargetWrapper;\r\n    const gl = this._gl;\r\n\r\n    if (!rtWrapper.isMulti) {\r\n        return;\r\n    }\r\n\r\n    for (let i = 0; i < rtWrapper._attachments!.length; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n        if (texture?.generateMipMaps && !texture?.isCube && !texture?.is3D) {\r\n            this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            this._bindTextureDirectly(gl.TEXTURE_2D, null);\r\n        }\r\n    }\r\n};\r\n\r\nThinEngine.prototype.resolveMultiFramebuffer = function (texture: RenderTargetWrapper): void {\r\n    const rtWrapper = texture as WebGLRenderTargetWrapper;\r\n    const gl = this._gl;\r\n\r\n    if (!rtWrapper._MSAAFramebuffer || !rtWrapper.isMulti) {\r\n        return;\r\n    }\r\n\r\n    let bufferBits = rtWrapper.resolveMSAAColors ? gl.COLOR_BUFFER_BIT : 0;\r\n    bufferBits |= rtWrapper._generateDepthBuffer && rtWrapper.resolveMSAADepth ? gl.DEPTH_BUFFER_BIT : 0;\r\n    bufferBits |= rtWrapper._generateStencilBuffer && rtWrapper.resolveMSAAStencil ? gl.STENCIL_BUFFER_BIT : 0;\r\n\r\n    const attachments = rtWrapper._attachments!;\r\n    const count = attachments.length;\r\n\r\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, rtWrapper._MSAAFramebuffer);\r\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, rtWrapper._framebuffer);\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n\r\n        for (let j = 0; j < count; j++) {\r\n            attachments[j] = gl.NONE;\r\n        }\r\n\r\n        attachments[i] = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n        gl.readBuffer(attachments[i]);\r\n        gl.drawBuffers(attachments);\r\n        gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, bufferBits, gl.NEAREST);\r\n    }\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        attachments[i] = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n    }\r\n\r\n    gl.drawBuffers(attachments);\r\n    gl.bindFramebuffer(this._gl.FRAMEBUFFER, rtWrapper._MSAAFramebuffer);\r\n};\r\n"],
  "mappings": "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",
  "names": ["i", "framebuffer", "texture"]
}
