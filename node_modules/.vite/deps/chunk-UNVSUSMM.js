import {
  AbstractAudioBus
} from "./chunk-CTBFYZQI.js";
import {
  _HasSpatialAudioOptions,
  _SpatialWebAudio,
  _StereoAudio,
  _WebAudioBusAndSoundSubGraph
} from "./chunk-2UA55PIM.js";

// node_modules/@babylonjs/core/AudioV2/abstractAudio/audioBus.js
var AudioBus = class extends AbstractAudioBus {
  constructor(name, engine, options) {
    super(name, engine);
    this._spatialAutoUpdate = true;
    this._spatialMinUpdateTime = 0;
    this._outBus = null;
    this._spatial = null;
    this._onOutBusDisposed = () => {
      this.outBus = this.engine.defaultMainBus;
    };
    if (typeof options.spatialAutoUpdate === "boolean") {
      this._spatialAutoUpdate = options.spatialAutoUpdate;
    }
    if (typeof options.spatialMinUpdateTime === "number") {
      this._spatialMinUpdateTime = options.spatialMinUpdateTime;
    }
  }
  /**
   * The output bus of the audio bus. Defaults to the audio engine's default main bus.
   */
  get outBus() {
    return this._outBus;
  }
  set outBus(outBus) {
    if (this._outBus === outBus) {
      return;
    }
    if (this._outBus) {
      this._outBus.onDisposeObservable.removeCallback(this._onOutBusDisposed);
      if (!this._disconnect(this._outBus)) {
        throw new Error("Disconnect failed");
      }
    }
    this._outBus = outBus;
    if (this._outBus) {
      this._outBus.onDisposeObservable.add(this._onOutBusDisposed);
      if (!this._connect(this._outBus)) {
        throw new Error("Connect failed");
      }
    }
  }
  /**
   * The spatial audio features.
   */
  get spatial() {
    if (this._spatial) {
      return this._spatial;
    }
    return this._initSpatialProperty();
  }
  /**
   * Releases associated resources.
   */
  dispose() {
    super.dispose();
    this._spatial?.dispose();
    this._spatial = null;
    this._outBus = null;
  }
  _initSpatialProperty() {
    return this._spatial = this._createSpatialProperty(this._spatialAutoUpdate, this._spatialMinUpdateTime);
  }
};

// node_modules/@babylonjs/core/AudioV2/webAudio/webAudioBus.js
var _WebAudioBus = class __WebAudioBus extends AudioBus {
  /** @internal */
  constructor(name, engine, options) {
    super(name, engine, options);
    this._stereo = null;
    this._subGraph = new __WebAudioBus._SubGraph(this);
  }
  /** @internal */
  async _initAsync(options) {
    if (options.outBus) {
      this.outBus = options.outBus;
    } else {
      await this.engine.isReadyPromise;
      this.outBus = this.engine.defaultMainBus;
    }
    await this._subGraph.initAsync(options);
    if (_HasSpatialAudioOptions(options)) {
      this._initSpatialProperty();
    }
    this.engine._addNode(this);
  }
  /** @internal */
  dispose() {
    super.dispose();
    this._stereo = null;
    this.engine._removeNode(this);
  }
  /** @internal */
  get _inNode() {
    return this._subGraph._inNode;
  }
  /** @internal */
  get _outNode() {
    return this._subGraph._outNode;
  }
  /** @internal */
  get stereo() {
    return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));
  }
  /** @internal */
  getClassName() {
    return "_WebAudioBus";
  }
  _createSpatialProperty(autoUpdate, minUpdateTime) {
    return new _SpatialWebAudio(this._subGraph, autoUpdate, minUpdateTime);
  }
  _connect(node) {
    const connected = super._connect(node);
    if (!connected) {
      return false;
    }
    if (node._inNode) {
      this._outNode?.connect(node._inNode);
    }
    return true;
  }
  _disconnect(node) {
    const disconnected = super._disconnect(node);
    if (!disconnected) {
      return false;
    }
    if (node._inNode) {
      this._outNode?.disconnect(node._inNode);
    }
    return true;
  }
};
_WebAudioBus._SubGraph = class extends _WebAudioBusAndSoundSubGraph {
  get _downstreamNodes() {
    return this._owner._downstreamNodes ?? null;
  }
  get _upstreamNodes() {
    return this._owner._upstreamNodes ?? null;
  }
};

export {
  AudioBus,
  _WebAudioBus
};
//# sourceMappingURL=chunk-UNVSUSMM.js.map
