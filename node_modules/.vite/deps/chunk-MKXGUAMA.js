import {
  PointerEventTypes,
  PointerInfo,
  PointerInfoPre
} from "./chunk-GDN55HFK.js";
import {
  BoundingInfo,
  PickingInfo,
  SubMesh
} from "./chunk-XXRAASSB.js";
import {
  Node
} from "./chunk-GTH34XAW.js";
import {
  UniqueIdGenerator
} from "./chunk-WKXRXUEO.js";
import {
  AddClipPlaneUniforms,
  BindBonesParameters,
  BindClipPlane,
  BindMorphTargetParameters,
  BindSceneUniformBuffer,
  FloatingOriginCurrentScene,
  GetFullOffsetViewProjectionToRef,
  GetOffsetTransformMatrices,
  OverrideMatrixFunctions,
  PrepareDefinesAndAttributesForMorphTargets,
  PrepareStringDefinesForClipPlanes,
  PushAttributesForInstances,
  ResetMatrixFunctions
} from "./chunk-CJAG5RQO.js";
import {
  UniformBuffer
} from "./chunk-7TY3ONLS.js";
import {
  Axis,
  Engine,
  Frustum,
  ObjectRenderer,
  PostProcess,
  PostProcessManager,
  RenderTargetTexture,
  RenderingManager,
  SmartArray,
  SmartArrayNoDuplicate
} from "./chunk-IHY5TJQW.js";
import {
  PerfCounter
} from "./chunk-LJSODA3L.js";
import {
  LightConstants
} from "./chunk-WAGTS43G.js";
import {
  Plane,
  Texture,
  ThinTexture
} from "./chunk-O66XN53B.js";
import {
  SerializationHelper,
  Tags
} from "./chunk-TKIUBJMH.js";
import {
  Color3,
  Color4,
  TmpColors
} from "./chunk-U2UVPF42.js";
import {
  Matrix,
  Quaternion,
  TmpVectors,
  Vector2,
  Vector3,
  Vector4,
  _ObserveArray
} from "./chunk-7VMTUWKL.js";
import {
  IsWrapper
} from "./chunk-HH2LNXRK.js";
import {
  Tools
} from "./chunk-ELESU4WA.js";
import {
  DrawWrapper,
  EffectRenderer,
  EffectWrapper,
  Viewport
} from "./chunk-PGX2ZGYF.js";
import {
  VertexBuffer
} from "./chunk-LAFJMI44.js";
import {
  __decorate,
  expandToProperty,
  serialize,
  serializeAsColor3,
  serializeAsColor4,
  serializeAsColorCurves,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-4I36N4OB.js";
import {
  LoadFile,
  ReadFile,
  RequestFile
} from "./chunk-REZB3B6G.js";
import {
  GetClass,
  RegisterClass
} from "./chunk-S7NDMBDF.js";
import {
  Mix,
  _RetryWithInterval
} from "./chunk-HCBQOPUQ.js";
import {
  _WarnImport
} from "./chunk-OWCZTH5B.js";
import {
  IsNavigatorAvailable,
  IsWindowObjectExist,
  PrecisionDate
} from "./chunk-AZNEH5GV.js";
import {
  EngineStore
} from "./chunk-ZVW3KNNR.js";
import {
  Observable
} from "./chunk-2YUEJ7I2.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";

// node_modules/@babylonjs/core/Actions/abstractActionManager.js
var AbstractActionManager = class _AbstractActionManager {
  constructor() {
    this.hoverCursor = "";
    this.actions = [];
    this.isRecursive = false;
    this.disposeWhenUnowned = true;
  }
  /**
   * Does exist one action manager with at least one trigger
   **/
  static get HasTriggers() {
    for (const t in _AbstractActionManager.Triggers) {
      if (Object.prototype.hasOwnProperty.call(_AbstractActionManager.Triggers, t)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Does exist one action manager with at least one pick trigger
   **/
  static get HasPickTriggers() {
    for (const t in _AbstractActionManager.Triggers) {
      if (Object.prototype.hasOwnProperty.call(_AbstractActionManager.Triggers, t)) {
        const tAsInt = parseInt(t);
        if (tAsInt >= 1 && tAsInt <= 7) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Does exist one action manager that handles actions of a given trigger
   * @param trigger defines the trigger to be tested
   * @returns a boolean indicating whether the trigger is handled by at least one action manager
   **/
  static HasSpecificTrigger(trigger) {
    for (const t in _AbstractActionManager.Triggers) {
      if (Object.prototype.hasOwnProperty.call(_AbstractActionManager.Triggers, t)) {
        const tAsInt = parseInt(t);
        if (tAsInt === trigger) {
          return true;
        }
      }
    }
    return false;
  }
};
AbstractActionManager.Triggers = {};

// node_modules/@babylonjs/core/Actions/actionEvent.js
var ActionEvent = class _ActionEvent {
  /**
   * Creates a new ActionEvent
   * @param source The mesh or sprite that triggered the action
   * @param pointerX The X mouse cursor position at the time of the event
   * @param pointerY The Y mouse cursor position at the time of the event
   * @param meshUnderPointer The mesh that is currently pointed at (can be null)
   * @param sourceEvent the original (browser) event that triggered the ActionEvent
   * @param additionalData additional data for the event
   */
  constructor(source, pointerX, pointerY, meshUnderPointer, sourceEvent, additionalData) {
    this.source = source;
    this.pointerX = pointerX;
    this.pointerY = pointerY;
    this.meshUnderPointer = meshUnderPointer;
    this.sourceEvent = sourceEvent;
    this.additionalData = additionalData;
  }
  /**
   * Helper function to auto-create an ActionEvent from a source mesh.
   * @param source The source mesh that triggered the event
   * @param evt The original (browser) event
   * @param additionalData additional data for the event
   * @returns the new ActionEvent
   */
  static CreateNew(source, evt, additionalData) {
    const scene = source.getScene();
    return new _ActionEvent(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer || source, evt, additionalData);
  }
  /**
   * Helper function to auto-create an ActionEvent from a source sprite
   * @param source The source sprite that triggered the event
   * @param scene Scene associated with the sprite
   * @param evt The original (browser) event
   * @param additionalData additional data for the event
   * @returns the new ActionEvent
   */
  static CreateNewFromSprite(source, scene, evt, additionalData) {
    return new _ActionEvent(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt, additionalData);
  }
  /**
   * Helper function to auto-create an ActionEvent from a scene. If triggered by a mesh use ActionEvent.CreateNew
   * @param scene the scene where the event occurred
   * @param evt The original (browser) event
   * @returns the new ActionEvent
   */
  static CreateNewFromScene(scene, evt) {
    return new _ActionEvent(null, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt);
  }
  /**
   * Helper function to auto-create an ActionEvent from a primitive
   * @param prim defines the target primitive
   * @param pointerPos defines the pointer position
   * @param evt The original (browser) event
   * @param additionalData additional data for the event
   * @returns the new ActionEvent
   */
  static CreateNewFromPrimitive(prim, pointerPos, evt, additionalData) {
    return new _ActionEvent(prim, pointerPos.x, pointerPos.y, null, evt, additionalData);
  }
};

// node_modules/@babylonjs/core/Misc/stringDictionary.js
var StringDictionary = class {
  constructor() {
    this._count = 0;
    this._data = {};
  }
  /**
   * This will clear this dictionary and copy the content from the 'source' one.
   * If the T value is a custom object, it won't be copied/cloned, the same object will be used
   * @param source the dictionary to take the content from and copy to this dictionary
   */
  copyFrom(source) {
    this.clear();
    source.forEach((t, v) => this.add(t, v));
  }
  /**
   * Get a value based from its key
   * @param key the given key to get the matching value from
   * @returns the value if found, otherwise undefined is returned
   */
  get(key) {
    const val = this._data[key];
    if (val !== void 0) {
      return val;
    }
    return void 0;
  }
  /**
   * Get a value from its key or add it if it doesn't exist.
   * This method will ensure you that a given key/data will be present in the dictionary.
   * @param key the given key to get the matching value from
   * @param factory the factory that will create the value if the key is not present in the dictionary.
   * The factory will only be invoked if there's no data for the given key.
   * @returns the value corresponding to the key.
   */
  getOrAddWithFactory(key, factory) {
    let val = this.get(key);
    if (val !== void 0) {
      return val;
    }
    val = factory(key);
    if (val) {
      this.add(key, val);
    }
    return val;
  }
  /**
   * Get a value from its key if present in the dictionary otherwise add it
   * @param key the key to get the value from
   * @param val if there's no such key/value pair in the dictionary add it with this value
   * @returns the value corresponding to the key
   */
  getOrAdd(key, val) {
    const curVal = this.get(key);
    if (curVal !== void 0) {
      return curVal;
    }
    this.add(key, val);
    return val;
  }
  /**
   * Check if there's a given key in the dictionary
   * @param key the key to check for
   * @returns true if the key is present, false otherwise
   */
  contains(key) {
    return this._data[key] !== void 0;
  }
  /**
   * Add a new key and its corresponding value
   * @param key the key to add
   * @param value the value corresponding to the key
   * @returns true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary
   */
  add(key, value) {
    if (this._data[key] !== void 0) {
      return false;
    }
    this._data[key] = value;
    ++this._count;
    return true;
  }
  /**
   * Update a specific value associated to a key
   * @param key defines the key to use
   * @param value defines the value to store
   * @returns true if the value was updated (or false if the key was not found)
   */
  set(key, value) {
    if (this._data[key] === void 0) {
      return false;
    }
    this._data[key] = value;
    return true;
  }
  /**
   * Get the element of the given key and remove it from the dictionary
   * @param key defines the key to search
   * @returns the value associated with the key or null if not found
   */
  getAndRemove(key) {
    const val = this.get(key);
    if (val !== void 0) {
      delete this._data[key];
      --this._count;
      return val;
    }
    return null;
  }
  /**
   * Remove a key/value from the dictionary.
   * @param key the key to remove
   * @returns true if the item was successfully deleted, false if no item with such key exist in the dictionary
   */
  remove(key) {
    if (this.contains(key)) {
      delete this._data[key];
      --this._count;
      return true;
    }
    return false;
  }
  /**
   * Clear the whole content of the dictionary
   */
  clear() {
    this._data = {};
    this._count = 0;
  }
  /**
   * Gets the current count
   */
  get count() {
    return this._count;
  }
  /**
   * Execute a callback on each key/val of the dictionary.
   * Note that you can remove any element in this dictionary in the callback implementation
   * @param callback the callback to execute on a given key/value pair
   */
  forEach(callback) {
    for (const cur in this._data) {
      const val = this._data[cur];
      callback(cur, val);
    }
  }
  /**
   * Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.
   * If the callback returns null or undefined the method will iterate to the next key/value pair
   * Note that you can remove any element in this dictionary in the callback implementation
   * @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned
   * @returns the first item
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  first(callback) {
    for (const cur in this._data) {
      const val = this._data[cur];
      const res = callback(cur, val);
      if (res) {
        return res;
      }
    }
    return null;
  }
};

// node_modules/@babylonjs/core/Materials/colorCurves.functions.js
function PrepareUniformsForColorCurves(uniformsList) {
  uniformsList.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative");
}

// node_modules/@babylonjs/core/Materials/colorCurves.js
var ColorCurves = class _ColorCurves {
  constructor() {
    this._dirty = true;
    this._tempColor = new Color4(0, 0, 0, 0);
    this._globalCurve = new Color4(0, 0, 0, 0);
    this._highlightsCurve = new Color4(0, 0, 0, 0);
    this._midtonesCurve = new Color4(0, 0, 0, 0);
    this._shadowsCurve = new Color4(0, 0, 0, 0);
    this._positiveCurve = new Color4(0, 0, 0, 0);
    this._negativeCurve = new Color4(0, 0, 0, 0);
    this._globalHue = 30;
    this._globalDensity = 0;
    this._globalSaturation = 0;
    this._globalExposure = 0;
    this._highlightsHue = 30;
    this._highlightsDensity = 0;
    this._highlightsSaturation = 0;
    this._highlightsExposure = 0;
    this._midtonesHue = 30;
    this._midtonesDensity = 0;
    this._midtonesSaturation = 0;
    this._midtonesExposure = 0;
    this._shadowsHue = 30;
    this._shadowsDensity = 0;
    this._shadowsSaturation = 0;
    this._shadowsExposure = 0;
  }
  /**
   * Gets the global Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  get globalHue() {
    return this._globalHue;
  }
  /**
   * Sets the global Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  set globalHue(value) {
    this._globalHue = value;
    this._dirty = true;
  }
  /**
   * Gets the global Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  get globalDensity() {
    return this._globalDensity;
  }
  /**
   * Sets the global Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  set globalDensity(value) {
    this._globalDensity = value;
    this._dirty = true;
  }
  /**
   * Gets the global Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  get globalSaturation() {
    return this._globalSaturation;
  }
  /**
   * Sets the global Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  set globalSaturation(value) {
    this._globalSaturation = value;
    this._dirty = true;
  }
  /**
   * Gets the global Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  get globalExposure() {
    return this._globalExposure;
  }
  /**
   * Sets the global Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  set globalExposure(value) {
    this._globalExposure = value;
    this._dirty = true;
  }
  /**
   * Gets the highlights Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  get highlightsHue() {
    return this._highlightsHue;
  }
  /**
   * Sets the highlights Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  set highlightsHue(value) {
    this._highlightsHue = value;
    this._dirty = true;
  }
  /**
   * Gets the highlights Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  get highlightsDensity() {
    return this._highlightsDensity;
  }
  /**
   * Sets the highlights Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  set highlightsDensity(value) {
    this._highlightsDensity = value;
    this._dirty = true;
  }
  /**
   * Gets the highlights Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  get highlightsSaturation() {
    return this._highlightsSaturation;
  }
  /**
   * Sets the highlights Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  set highlightsSaturation(value) {
    this._highlightsSaturation = value;
    this._dirty = true;
  }
  /**
   * Gets the highlights Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  get highlightsExposure() {
    return this._highlightsExposure;
  }
  /**
   * Sets the highlights Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  set highlightsExposure(value) {
    this._highlightsExposure = value;
    this._dirty = true;
  }
  /**
   * Gets the midtones Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  get midtonesHue() {
    return this._midtonesHue;
  }
  /**
   * Sets the midtones Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  set midtonesHue(value) {
    this._midtonesHue = value;
    this._dirty = true;
  }
  /**
   * Gets the midtones Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  get midtonesDensity() {
    return this._midtonesDensity;
  }
  /**
   * Sets the midtones Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  set midtonesDensity(value) {
    this._midtonesDensity = value;
    this._dirty = true;
  }
  /**
   * Gets the midtones Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  get midtonesSaturation() {
    return this._midtonesSaturation;
  }
  /**
   * Sets the midtones Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  set midtonesSaturation(value) {
    this._midtonesSaturation = value;
    this._dirty = true;
  }
  /**
   * Gets the midtones Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  get midtonesExposure() {
    return this._midtonesExposure;
  }
  /**
   * Sets the midtones Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  set midtonesExposure(value) {
    this._midtonesExposure = value;
    this._dirty = true;
  }
  /**
   * Gets the shadows Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  get shadowsHue() {
    return this._shadowsHue;
  }
  /**
   * Sets the shadows Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  set shadowsHue(value) {
    this._shadowsHue = value;
    this._dirty = true;
  }
  /**
   * Gets the shadows Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  get shadowsDensity() {
    return this._shadowsDensity;
  }
  /**
   * Sets the shadows Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  set shadowsDensity(value) {
    this._shadowsDensity = value;
    this._dirty = true;
  }
  /**
   * Gets the shadows Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  get shadowsSaturation() {
    return this._shadowsSaturation;
  }
  /**
   * Sets the shadows Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  set shadowsSaturation(value) {
    this._shadowsSaturation = value;
    this._dirty = true;
  }
  /**
   * Gets the shadows Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  get shadowsExposure() {
    return this._shadowsExposure;
  }
  /**
   * Sets the shadows Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  set shadowsExposure(value) {
    this._shadowsExposure = value;
    this._dirty = true;
  }
  /**
   * Returns the class name
   * @returns The class name
   */
  getClassName() {
    return "ColorCurves";
  }
  /**
   * Binds the color curves to the shader.
   * @param colorCurves The color curve to bind
   * @param effect The effect to bind to
   * @param positiveUniform The positive uniform shader parameter
   * @param neutralUniform The neutral uniform shader parameter
   * @param negativeUniform The negative uniform shader parameter
   */
  static Bind(colorCurves, effect, positiveUniform = "vCameraColorCurvePositive", neutralUniform = "vCameraColorCurveNeutral", negativeUniform = "vCameraColorCurveNegative") {
    if (colorCurves._dirty) {
      colorCurves._dirty = false;
      colorCurves._getColorGradingDataToRef(colorCurves._globalHue, colorCurves._globalDensity, colorCurves._globalSaturation, colorCurves._globalExposure, colorCurves._globalCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._highlightsHue, colorCurves._highlightsDensity, colorCurves._highlightsSaturation, colorCurves._highlightsExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._highlightsCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._midtonesHue, colorCurves._midtonesDensity, colorCurves._midtonesSaturation, colorCurves._midtonesExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._midtonesCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._shadowsHue, colorCurves._shadowsDensity, colorCurves._shadowsSaturation, colorCurves._shadowsExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._shadowsCurve);
      colorCurves._highlightsCurve.subtractToRef(colorCurves._midtonesCurve, colorCurves._positiveCurve);
      colorCurves._midtonesCurve.subtractToRef(colorCurves._shadowsCurve, colorCurves._negativeCurve);
    }
    if (effect) {
      effect.setFloat4(positiveUniform, colorCurves._positiveCurve.r, colorCurves._positiveCurve.g, colorCurves._positiveCurve.b, colorCurves._positiveCurve.a);
      effect.setFloat4(neutralUniform, colorCurves._midtonesCurve.r, colorCurves._midtonesCurve.g, colorCurves._midtonesCurve.b, colorCurves._midtonesCurve.a);
      effect.setFloat4(negativeUniform, colorCurves._negativeCurve.r, colorCurves._negativeCurve.g, colorCurves._negativeCurve.b, colorCurves._negativeCurve.a);
    }
  }
  /**
   * Returns color grading data based on a hue, density, saturation and exposure value.
   * @param hue
   * @param density
   * @param saturation The saturation.
   * @param exposure The exposure.
   * @param result The result data container.
   */
  _getColorGradingDataToRef(hue, density, saturation, exposure, result) {
    if (hue == null) {
      return;
    }
    hue = _ColorCurves._Clamp(hue, 0, 360);
    density = _ColorCurves._Clamp(density, -100, 100);
    saturation = _ColorCurves._Clamp(saturation, -100, 100);
    exposure = _ColorCurves._Clamp(exposure, -100, 100);
    density = _ColorCurves._ApplyColorGradingSliderNonlinear(density);
    density *= 0.5;
    exposure = _ColorCurves._ApplyColorGradingSliderNonlinear(exposure);
    if (density < 0) {
      density *= -1;
      hue = (hue + 180) % 360;
    }
    _ColorCurves._FromHSBToRef(hue, density, 50 + 0.25 * exposure, result);
    result.scaleToRef(2, result);
    result.a = 1 + 0.01 * saturation;
  }
  /**
   * Takes an input slider value and returns an adjusted value that provides extra control near the centre.
   * @param value The input slider value in range [-100,100].
   * @returns Adjusted value.
   */
  static _ApplyColorGradingSliderNonlinear(value) {
    value /= 100;
    let x = Math.abs(value);
    x = Math.pow(x, 2);
    if (value < 0) {
      x *= -1;
    }
    x *= 100;
    return x;
  }
  /**
   * Returns an RGBA Color4 based on Hue, Saturation and Brightness (also referred to as value, HSV).
   * @param hue The hue (H) input.
   * @param saturation The saturation (S) input.
   * @param brightness The brightness (B) input.
   * @param result An RGBA color represented as Vector4.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static _FromHSBToRef(hue, saturation, brightness, result) {
    let h = _ColorCurves._Clamp(hue, 0, 360);
    const s = _ColorCurves._Clamp(saturation / 100, 0, 1);
    const v = _ColorCurves._Clamp(brightness / 100, 0, 1);
    if (s === 0) {
      result.r = v;
      result.g = v;
      result.b = v;
    } else {
      h /= 60;
      const i = Math.floor(h);
      const f = h - i;
      const p = v * (1 - s);
      const q = v * (1 - s * f);
      const t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          result.r = v;
          result.g = t;
          result.b = p;
          break;
        case 1:
          result.r = q;
          result.g = v;
          result.b = p;
          break;
        case 2:
          result.r = p;
          result.g = v;
          result.b = t;
          break;
        case 3:
          result.r = p;
          result.g = q;
          result.b = v;
          break;
        case 4:
          result.r = t;
          result.g = p;
          result.b = v;
          break;
        default:
          result.r = v;
          result.g = p;
          result.b = q;
          break;
      }
    }
    result.a = 1;
  }
  /**
   * Returns a value clamped between min and max
   * @param value The value to clamp
   * @param min The minimum of value
   * @param max The maximum of value
   * @returns The clamped value.
   */
  static _Clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }
  /**
   * Clones the current color curve instance.
   * @returns The cloned curves
   */
  clone() {
    return SerializationHelper.Clone(() => new _ColorCurves(), this);
  }
  /**
   * Serializes the current color curve instance to a json representation.
   * @returns a JSON representation
   */
  serialize() {
    return SerializationHelper.Serialize(this);
  }
  /**
   * Parses the color curve from a json representation.
   * @param source the JSON source to parse
   * @returns The parsed curves
   */
  static Parse(source) {
    return SerializationHelper.Parse(() => new _ColorCurves(), source, null, null);
  }
};
ColorCurves.PrepareUniforms = PrepareUniformsForColorCurves;
__decorate([
  serialize()
], ColorCurves.prototype, "_globalHue", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_globalDensity", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_globalSaturation", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_globalExposure", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsHue", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsDensity", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsSaturation", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsExposure", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesHue", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesDensity", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesSaturation", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesExposure", void 0);
SerializationHelper._ColorCurvesParser = ColorCurves.Parse;

// node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.functions.js
function PrepareUniformsForImageProcessing(uniforms, defines) {
  if (defines.EXPOSURE) {
    uniforms.push("exposureLinear");
  }
  if (defines.CONTRAST) {
    uniforms.push("contrast");
  }
  if (defines.COLORGRADING) {
    uniforms.push("colorTransformSettings");
  }
  if (defines.VIGNETTE || defines.DITHER) {
    uniforms.push("vInverseScreenSize");
  }
  if (defines.VIGNETTE) {
    uniforms.push("vignetteSettings1");
    uniforms.push("vignetteSettings2");
  }
  if (defines.COLORCURVES) {
    PrepareUniformsForColorCurves(uniforms);
  }
  if (defines.DITHER) {
    uniforms.push("ditherIntensity");
  }
}
function PrepareSamplersForImageProcessing(samplersList, defines) {
  if (defines.COLORGRADING) {
    samplersList.push("txColorTransform");
  }
}

// node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.js
var ImageProcessingConfiguration = class _ImageProcessingConfiguration {
  constructor() {
    this.colorCurves = new ColorCurves();
    this._colorCurvesEnabled = false;
    this._colorGradingEnabled = false;
    this._colorGradingWithGreenDepth = true;
    this._colorGradingBGR = true;
    this._exposure = 1;
    this._toneMappingEnabled = false;
    this._toneMappingType = _ImageProcessingConfiguration.TONEMAPPING_STANDARD;
    this._contrast = 1;
    this.vignetteStretch = 0;
    this.vignetteCenterX = 0;
    this.vignetteCenterY = 0;
    this.vignetteWeight = 1.5;
    this.vignetteColor = new Color4(0, 0, 0, 0);
    this.vignetteCameraFov = 0.5;
    this._vignetteBlendMode = _ImageProcessingConfiguration.VIGNETTEMODE_MULTIPLY;
    this._vignetteEnabled = false;
    this._ditheringEnabled = false;
    this._ditheringIntensity = 1 / 255;
    this._skipFinalColorClamp = false;
    this._applyByPostProcess = false;
    this._isEnabled = true;
    this.outputTextureWidth = 0;
    this.outputTextureHeight = 0;
    this.onUpdateParameters = new Observable();
  }
  /**
   * Gets whether the color curves effect is enabled.
   */
  get colorCurvesEnabled() {
    return this._colorCurvesEnabled;
  }
  /**
   * Sets whether the color curves effect is enabled.
   */
  set colorCurvesEnabled(value) {
    if (this._colorCurvesEnabled === value) {
      return;
    }
    this._colorCurvesEnabled = value;
    this._updateParameters();
  }
  /**
   * Color grading LUT texture used in the effect if colorGradingEnabled is set to true
   */
  get colorGradingTexture() {
    return this._colorGradingTexture;
  }
  /**
   * Color grading LUT texture used in the effect if colorGradingEnabled is set to true
   */
  set colorGradingTexture(value) {
    if (this._colorGradingTexture === value) {
      return;
    }
    this._colorGradingTexture = value;
    this._updateParameters();
  }
  /**
   * Gets whether the color grading effect is enabled.
   */
  get colorGradingEnabled() {
    return this._colorGradingEnabled;
  }
  /**
   * Sets whether the color grading effect is enabled.
   */
  set colorGradingEnabled(value) {
    if (this._colorGradingEnabled === value) {
      return;
    }
    this._colorGradingEnabled = value;
    this._updateParameters();
  }
  /**
   * Gets whether the color grading effect is using a green depth for the 3d Texture.
   */
  get colorGradingWithGreenDepth() {
    return this._colorGradingWithGreenDepth;
  }
  /**
   * Sets whether the color grading effect is using a green depth for the 3d Texture.
   */
  set colorGradingWithGreenDepth(value) {
    if (this._colorGradingWithGreenDepth === value) {
      return;
    }
    this._colorGradingWithGreenDepth = value;
    this._updateParameters();
  }
  /**
   * Gets whether the color grading texture contains BGR values.
   */
  get colorGradingBGR() {
    return this._colorGradingBGR;
  }
  /**
   * Sets whether the color grading texture contains BGR values.
   */
  set colorGradingBGR(value) {
    if (this._colorGradingBGR === value) {
      return;
    }
    this._colorGradingBGR = value;
    this._updateParameters();
  }
  /**
   * Gets the Exposure used in the effect.
   */
  get exposure() {
    return this._exposure;
  }
  /**
   * Sets the Exposure used in the effect.
   */
  set exposure(value) {
    if (this._exposure === value) {
      return;
    }
    this._exposure = value;
    this._updateParameters();
  }
  /**
   * Gets whether the tone mapping effect is enabled.
   */
  get toneMappingEnabled() {
    return this._toneMappingEnabled;
  }
  /**
   * Sets whether the tone mapping effect is enabled.
   */
  set toneMappingEnabled(value) {
    if (this._toneMappingEnabled === value) {
      return;
    }
    this._toneMappingEnabled = value;
    this._updateParameters();
  }
  /**
   * Gets the type of tone mapping effect.
   */
  get toneMappingType() {
    return this._toneMappingType;
  }
  /**
   * Sets the type of tone mapping effect used in BabylonJS.
   */
  set toneMappingType(value) {
    if (this._toneMappingType === value) {
      return;
    }
    this._toneMappingType = value;
    this._updateParameters();
  }
  /**
   * Gets the contrast used in the effect.
   */
  get contrast() {
    return this._contrast;
  }
  /**
   * Sets the contrast used in the effect.
   */
  set contrast(value) {
    if (this._contrast === value) {
      return;
    }
    this._contrast = value;
    this._updateParameters();
  }
  /**
   * Back Compat: Vignette center Y Offset.
   * @deprecated use vignetteCenterY instead
   */
  get vignetteCentreY() {
    return this.vignetteCenterY;
  }
  set vignetteCentreY(value) {
    this.vignetteCenterY = value;
  }
  /**
   * Back Compat: Vignette center X Offset.
   * @deprecated use vignetteCenterX instead
   */
  get vignetteCentreX() {
    return this.vignetteCenterX;
  }
  set vignetteCentreX(value) {
    this.vignetteCenterX = value;
  }
  /**
   * Gets the vignette blend mode allowing different kind of effect.
   */
  get vignetteBlendMode() {
    return this._vignetteBlendMode;
  }
  /**
   * Sets the vignette blend mode allowing different kind of effect.
   */
  set vignetteBlendMode(value) {
    if (this._vignetteBlendMode === value) {
      return;
    }
    this._vignetteBlendMode = value;
    this._updateParameters();
  }
  /**
   * Gets whether the vignette effect is enabled.
   */
  get vignetteEnabled() {
    return this._vignetteEnabled;
  }
  /**
   * Sets whether the vignette effect is enabled.
   */
  set vignetteEnabled(value) {
    if (this._vignetteEnabled === value) {
      return;
    }
    this._vignetteEnabled = value;
    this._updateParameters();
  }
  /**
   * Gets whether the dithering effect is enabled.
   * The dithering effect can be used to reduce banding.
   */
  get ditheringEnabled() {
    return this._ditheringEnabled;
  }
  /**
   * Sets whether the dithering effect is enabled.
   * The dithering effect can be used to reduce banding.
   */
  set ditheringEnabled(value) {
    if (this._ditheringEnabled === value) {
      return;
    }
    this._ditheringEnabled = value;
    this._updateParameters();
  }
  /**
   * Gets the dithering intensity. 0 is no dithering. Default is 1.0 / 255.0.
   */
  get ditheringIntensity() {
    return this._ditheringIntensity;
  }
  /**
   * Sets the dithering intensity. 0 is no dithering. Default is 1.0 / 255.0.
   */
  set ditheringIntensity(value) {
    if (this._ditheringIntensity === value) {
      return;
    }
    this._ditheringIntensity = value;
    this._updateParameters();
  }
  /**
   * If apply by post process is set to true, setting this to true will skip the final color clamp step in the fragment shader
   * Applies to PBR materials.
   */
  get skipFinalColorClamp() {
    return this._skipFinalColorClamp;
  }
  /**
   * If apply by post process is set to true, setting this to true will skip the final color clamp step in the fragment shader
   * Applies to PBR materials.
   */
  set skipFinalColorClamp(value) {
    if (this._skipFinalColorClamp === value) {
      return;
    }
    this._skipFinalColorClamp = value;
    this._updateParameters();
  }
  /**
   * Gets whether the image processing is applied through a post process or not.
   */
  get applyByPostProcess() {
    return this._applyByPostProcess;
  }
  /**
   * Sets whether the image processing is applied through a post process or not.
   */
  set applyByPostProcess(value) {
    if (this._applyByPostProcess === value) {
      return;
    }
    this._applyByPostProcess = value;
    this._updateParameters();
  }
  /**
   * Gets whether the image processing is enabled or not.
   */
  get isEnabled() {
    return this._isEnabled;
  }
  /**
   * Sets whether the image processing is enabled or not.
   */
  set isEnabled(value) {
    if (this._isEnabled === value) {
      return;
    }
    this._isEnabled = value;
    this._updateParameters();
  }
  /**
   * Method called each time the image processing information changes requires to recompile the effect.
   */
  _updateParameters() {
    this.onUpdateParameters.notifyObservers(this);
  }
  /**
   * Gets the current class name.
   * @returns "ImageProcessingConfiguration"
   */
  getClassName() {
    return "ImageProcessingConfiguration";
  }
  /**
   * Prepare the list of defines associated to the shader.
   * @param defines the list of defines to complete
   * @param forPostProcess Define if we are currently in post process mode or not
   */
  prepareDefines(defines, forPostProcess = false) {
    if (forPostProcess !== this.applyByPostProcess || !this._isEnabled) {
      defines.VIGNETTE = false;
      defines.TONEMAPPING = 0;
      defines.CONTRAST = false;
      defines.EXPOSURE = false;
      defines.COLORCURVES = false;
      defines.COLORGRADING = false;
      defines.COLORGRADING3D = false;
      defines.DITHER = false;
      defines.IMAGEPROCESSING = false;
      defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
      defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled;
      return;
    }
    defines.VIGNETTE = this.vignetteEnabled;
    defines.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === _ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY;
    defines.VIGNETTEBLENDMODEOPAQUE = !defines.VIGNETTEBLENDMODEMULTIPLY;
    if (!this._toneMappingEnabled) {
      defines.TONEMAPPING = 0;
    } else {
      switch (this._toneMappingType) {
        case _ImageProcessingConfiguration.TONEMAPPING_KHR_PBR_NEUTRAL:
          defines.TONEMAPPING = 3;
          break;
        case _ImageProcessingConfiguration.TONEMAPPING_ACES:
          defines.TONEMAPPING = 2;
          break;
        default:
          defines.TONEMAPPING = 1;
          break;
      }
    }
    defines.CONTRAST = this.contrast !== 1;
    defines.EXPOSURE = this.exposure !== 1;
    defines.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves;
    defines.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture;
    if (defines.COLORGRADING) {
      defines.COLORGRADING3D = this.colorGradingTexture.is3D;
    } else {
      defines.COLORGRADING3D = false;
    }
    defines.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth;
    defines.SAMPLER3DBGRMAP = this.colorGradingBGR;
    defines.DITHER = this._ditheringEnabled;
    defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess;
    defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
    defines.IMAGEPROCESSING = defines.VIGNETTE || !!defines.TONEMAPPING || defines.CONTRAST || defines.EXPOSURE || defines.COLORCURVES || defines.COLORGRADING || defines.DITHER;
  }
  /**
   * Returns true if all the image processing information are ready.
   * @returns True if ready, otherwise, false
   */
  isReady() {
    return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();
  }
  /**
   * Binds the image processing to the shader.
   * @param effect The effect to bind to
   * @param overrideAspectRatio Override the aspect ratio of the effect
   */
  bind(effect, overrideAspectRatio) {
    if (this._colorCurvesEnabled && this.colorCurves) {
      ColorCurves.Bind(this.colorCurves, effect);
    }
    if (this._vignetteEnabled || this._ditheringEnabled) {
      const inverseWidth = 1 / (this.outputTextureWidth || effect.getEngine().getRenderWidth());
      const inverseHeight = 1 / (this.outputTextureHeight || effect.getEngine().getRenderHeight());
      effect.setFloat2("vInverseScreenSize", inverseWidth, inverseHeight);
      if (this._ditheringEnabled) {
        effect.setFloat("ditherIntensity", 0.5 * this._ditheringIntensity);
      }
      if (this._vignetteEnabled) {
        const aspectRatio = overrideAspectRatio != null ? overrideAspectRatio : inverseHeight / inverseWidth;
        let vignetteScaleY = Math.tan(this.vignetteCameraFov * 0.5);
        let vignetteScaleX = vignetteScaleY * aspectRatio;
        const vignetteScaleGeometricMean = Math.sqrt(vignetteScaleX * vignetteScaleY);
        vignetteScaleX = Mix(vignetteScaleX, vignetteScaleGeometricMean, this.vignetteStretch);
        vignetteScaleY = Mix(vignetteScaleY, vignetteScaleGeometricMean, this.vignetteStretch);
        effect.setFloat4("vignetteSettings1", vignetteScaleX, vignetteScaleY, -vignetteScaleX * this.vignetteCenterX, -vignetteScaleY * this.vignetteCenterY);
        const vignettePower = -2 * this.vignetteWeight;
        effect.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, vignettePower);
      }
    }
    effect.setFloat("exposureLinear", this.exposure);
    effect.setFloat("contrast", this.contrast);
    if (this.colorGradingTexture) {
      effect.setTexture("txColorTransform", this.colorGradingTexture);
      const textureSize = this.colorGradingTexture.getSize().height;
      effect.setFloat4(
        "colorTransformSettings",
        (textureSize - 1) / textureSize,
        // textureScale
        0.5 / textureSize,
        // textureOffset
        textureSize,
        // textureSize
        this.colorGradingTexture.level
        // weight
      );
    }
  }
  /**
   * Clones the current image processing instance.
   * @returns The cloned image processing
   */
  clone() {
    return SerializationHelper.Clone(() => new _ImageProcessingConfiguration(), this);
  }
  /**
   * Serializes the current image processing instance to a json representation.
   * @returns a JSON representation
   */
  serialize() {
    return SerializationHelper.Serialize(this);
  }
  /**
   * Parses the image processing from a json representation.
   * @param source the JSON source to parse
   * @returns The parsed image processing
   */
  static Parse(source) {
    const parsed = SerializationHelper.Parse(() => new _ImageProcessingConfiguration(), source, null, null);
    if (source.vignetteCentreX !== void 0) {
      parsed.vignetteCenterX = source.vignetteCentreX;
    }
    if (source.vignetteCentreY !== void 0) {
      parsed.vignetteCenterY = source.vignetteCentreY;
    }
    return parsed;
  }
  /**
   * Used to apply the vignette as a mix with the pixel color.
   */
  static get VIGNETTEMODE_MULTIPLY() {
    return this._VIGNETTEMODE_MULTIPLY;
  }
  /**
   * Used to apply the vignette as a replacement of the pixel color.
   */
  static get VIGNETTEMODE_OPAQUE() {
    return this._VIGNETTEMODE_OPAQUE;
  }
};
ImageProcessingConfiguration.TONEMAPPING_STANDARD = 0;
ImageProcessingConfiguration.TONEMAPPING_ACES = 1;
ImageProcessingConfiguration.TONEMAPPING_KHR_PBR_NEUTRAL = 2;
ImageProcessingConfiguration.PrepareUniforms = PrepareUniformsForImageProcessing;
ImageProcessingConfiguration.PrepareSamplers = PrepareSamplersForImageProcessing;
ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY = 0;
ImageProcessingConfiguration._VIGNETTEMODE_OPAQUE = 1;
__decorate([
  serializeAsColorCurves()
], ImageProcessingConfiguration.prototype, "colorCurves", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorCurvesEnabled", void 0);
__decorate([
  serializeAsTexture("colorGradingTexture")
], ImageProcessingConfiguration.prototype, "_colorGradingTexture", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorGradingEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorGradingWithGreenDepth", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorGradingBGR", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_exposure", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_toneMappingEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_toneMappingType", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_contrast", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteStretch", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteCenterX", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteCenterY", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteWeight", void 0);
__decorate([
  serializeAsColor4()
], ImageProcessingConfiguration.prototype, "vignetteColor", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteCameraFov", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_vignetteBlendMode", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_vignetteEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_ditheringEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_ditheringIntensity", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_skipFinalColorClamp", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_applyByPostProcess", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_isEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "outputTextureWidth", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "outputTextureHeight", void 0);
SerializationHelper._ImageProcessingConfigurationParser = ImageProcessingConfiguration.Parse;
RegisterClass("BABYLON.ImageProcessingConfiguration", ImageProcessingConfiguration);

// node_modules/@babylonjs/core/sceneComponent.js
var SceneComponentConstants = class {
};
SceneComponentConstants.NAME_EFFECTLAYER = "EffectLayer";
SceneComponentConstants.NAME_LAYER = "Layer";
SceneComponentConstants.NAME_LENSFLARESYSTEM = "LensFlareSystem";
SceneComponentConstants.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer";
SceneComponentConstants.NAME_PARTICLESYSTEM = "ParticleSystem";
SceneComponentConstants.NAME_GAMEPAD = "Gamepad";
SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue";
SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer";
SceneComponentConstants.NAME_PREPASSRENDERER = "PrePassRenderer";
SceneComponentConstants.NAME_DEPTHRENDERER = "DepthRenderer";
SceneComponentConstants.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer";
SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager";
SceneComponentConstants.NAME_SPRITE = "Sprite";
SceneComponentConstants.NAME_SUBSURFACE = "SubSurface";
SceneComponentConstants.NAME_OUTLINERENDERER = "Outline";
SceneComponentConstants.NAME_PROCEDURALTEXTURE = "ProceduralTexture";
SceneComponentConstants.NAME_SHADOWGENERATOR = "ShadowGenerator";
SceneComponentConstants.NAME_OCTREE = "Octree";
SceneComponentConstants.NAME_PHYSICSENGINE = "PhysicsEngine";
SceneComponentConstants.NAME_AUDIO = "Audio";
SceneComponentConstants.NAME_FLUIDRENDERER = "FluidRenderer";
SceneComponentConstants.NAME_IBLCDFGENERATOR = "iblCDFGenerator";
SceneComponentConstants.NAME_CLUSTEREDLIGHTING = "ClusteredLighting";
SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER = 0;
SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;
SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS = 0;
SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1;
SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER = 2;
SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0;
SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER = 1;
SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS = 0;
SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE = 1;
SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE = 1;
SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;
SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;
SceneComponentConstants.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;
SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;
SceneComponentConstants.STEP_BEFORECLEAR_PREPASS = 1;
SceneComponentConstants.STEP_BEFORERENDERTARGETCLEAR_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER = 1;
SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS = 0;
SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1;
SceneComponentConstants.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2;
SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3;
SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER = 4;
SceneComponentConstants.STEP_AFTERCAMERADRAW_FLUIDRENDERER = 5;
SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER = 0;
SceneComponentConstants.STEP_AFTERRENDER_AUDIO = 0;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER = 1;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_CLUSTEREDLIGHTING = 2;
SceneComponentConstants.STEP_POINTERMOVE_SPRITE = 0;
SceneComponentConstants.STEP_POINTERDOWN_SPRITE = 0;
SceneComponentConstants.STEP_POINTERUP_SPRITE = 0;
var Stage = class _Stage extends Array {
  /**
   * Hide ctor from the rest of the world.
   * @param items The items to add.
   */
  constructor(items) {
    super(...items);
  }
  /**
   * Creates a new Stage.
   * @returns A new instance of a Stage
   */
  static Create() {
    return Object.create(_Stage.prototype);
  }
  /**
   * Registers a step in an ordered way in the targeted stage.
   * @param index Defines the position to register the step in
   * @param component Defines the component attached to the step
   * @param action Defines the action to launch during the step
   */
  registerStep(index, component, action) {
    let i = 0;
    let maxIndex = Number.MAX_VALUE;
    for (; i < this.length; i++) {
      const step = this[i];
      maxIndex = step.index;
      if (index < maxIndex) {
        break;
      }
    }
    this.splice(i, 0, { index, component, action: action.bind(component) });
  }
  /**
   * Clears all the steps from the stage.
   */
  clear() {
    this.length = 0;
  }
};

// node_modules/@babylonjs/core/Events/keyboardEvents.js
var KeyboardEventTypes = class {
};
KeyboardEventTypes.KEYDOWN = 1;
KeyboardEventTypes.KEYUP = 2;
var KeyboardInfo = class {
  /**
   * Instantiates a new keyboard info.
   * This class is used to store keyboard related info for the onKeyboardObservable event.
   * @param type Defines the type of event (KeyboardEventTypes)
   * @param event Defines the related dom event
   */
  constructor(type, event) {
    this.type = type;
    this.event = event;
  }
};
var KeyboardInfoPre = class extends KeyboardInfo {
  /**
   * Defines whether the engine should skip the next onKeyboardObservable associated to this pre.
   * @deprecated use skipOnKeyboardObservable property instead
   */
  get skipOnPointerObservable() {
    return this.skipOnKeyboardObservable;
  }
  set skipOnPointerObservable(value) {
    this.skipOnKeyboardObservable = value;
  }
  /**
   * Instantiates a new keyboard pre info.
   * This class is used to store keyboard related info for the onPreKeyboardObservable event.
   * @param type Defines the type of event (KeyboardEventTypes)
   * @param event Defines the related dom event
   */
  constructor(type, event) {
    super(type, event);
    this.type = type;
    this.event = event;
    this.skipOnKeyboardObservable = false;
  }
};

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceEnums.js
var DeviceType;
(function(DeviceType2) {
  DeviceType2[DeviceType2["Generic"] = 0] = "Generic";
  DeviceType2[DeviceType2["Keyboard"] = 1] = "Keyboard";
  DeviceType2[DeviceType2["Mouse"] = 2] = "Mouse";
  DeviceType2[DeviceType2["Touch"] = 3] = "Touch";
  DeviceType2[DeviceType2["DualShock"] = 4] = "DualShock";
  DeviceType2[DeviceType2["Xbox"] = 5] = "Xbox";
  DeviceType2[DeviceType2["Switch"] = 6] = "Switch";
  DeviceType2[DeviceType2["DualSense"] = 7] = "DualSense";
})(DeviceType || (DeviceType = {}));
var PointerInput;
(function(PointerInput2) {
  PointerInput2[PointerInput2["Horizontal"] = 0] = "Horizontal";
  PointerInput2[PointerInput2["Vertical"] = 1] = "Vertical";
  PointerInput2[PointerInput2["LeftClick"] = 2] = "LeftClick";
  PointerInput2[PointerInput2["MiddleClick"] = 3] = "MiddleClick";
  PointerInput2[PointerInput2["RightClick"] = 4] = "RightClick";
  PointerInput2[PointerInput2["BrowserBack"] = 5] = "BrowserBack";
  PointerInput2[PointerInput2["BrowserForward"] = 6] = "BrowserForward";
  PointerInput2[PointerInput2["MouseWheelX"] = 7] = "MouseWheelX";
  PointerInput2[PointerInput2["MouseWheelY"] = 8] = "MouseWheelY";
  PointerInput2[PointerInput2["MouseWheelZ"] = 9] = "MouseWheelZ";
  PointerInput2[PointerInput2["Move"] = 12] = "Move";
})(PointerInput || (PointerInput = {}));
var NativePointerInput;
(function(NativePointerInput2) {
  NativePointerInput2[NativePointerInput2["Horizontal"] = 0] = "Horizontal";
  NativePointerInput2[NativePointerInput2["Vertical"] = 1] = "Vertical";
  NativePointerInput2[NativePointerInput2["LeftClick"] = 2] = "LeftClick";
  NativePointerInput2[NativePointerInput2["MiddleClick"] = 3] = "MiddleClick";
  NativePointerInput2[NativePointerInput2["RightClick"] = 4] = "RightClick";
  NativePointerInput2[NativePointerInput2["BrowserBack"] = 5] = "BrowserBack";
  NativePointerInput2[NativePointerInput2["BrowserForward"] = 6] = "BrowserForward";
  NativePointerInput2[NativePointerInput2["MouseWheelX"] = 7] = "MouseWheelX";
  NativePointerInput2[NativePointerInput2["MouseWheelY"] = 8] = "MouseWheelY";
  NativePointerInput2[NativePointerInput2["MouseWheelZ"] = 9] = "MouseWheelZ";
  NativePointerInput2[NativePointerInput2["DeltaHorizontal"] = 10] = "DeltaHorizontal";
  NativePointerInput2[NativePointerInput2["DeltaVertical"] = 11] = "DeltaVertical";
})(NativePointerInput || (NativePointerInput = {}));
var DualShockInput;
(function(DualShockInput2) {
  DualShockInput2[DualShockInput2["Cross"] = 0] = "Cross";
  DualShockInput2[DualShockInput2["Circle"] = 1] = "Circle";
  DualShockInput2[DualShockInput2["Square"] = 2] = "Square";
  DualShockInput2[DualShockInput2["Triangle"] = 3] = "Triangle";
  DualShockInput2[DualShockInput2["L1"] = 4] = "L1";
  DualShockInput2[DualShockInput2["R1"] = 5] = "R1";
  DualShockInput2[DualShockInput2["L2"] = 6] = "L2";
  DualShockInput2[DualShockInput2["R2"] = 7] = "R2";
  DualShockInput2[DualShockInput2["Share"] = 8] = "Share";
  DualShockInput2[DualShockInput2["Options"] = 9] = "Options";
  DualShockInput2[DualShockInput2["L3"] = 10] = "L3";
  DualShockInput2[DualShockInput2["R3"] = 11] = "R3";
  DualShockInput2[DualShockInput2["DPadUp"] = 12] = "DPadUp";
  DualShockInput2[DualShockInput2["DPadDown"] = 13] = "DPadDown";
  DualShockInput2[DualShockInput2["DPadLeft"] = 14] = "DPadLeft";
  DualShockInput2[DualShockInput2["DPadRight"] = 15] = "DPadRight";
  DualShockInput2[DualShockInput2["Home"] = 16] = "Home";
  DualShockInput2[DualShockInput2["TouchPad"] = 17] = "TouchPad";
  DualShockInput2[DualShockInput2["LStickXAxis"] = 18] = "LStickXAxis";
  DualShockInput2[DualShockInput2["LStickYAxis"] = 19] = "LStickYAxis";
  DualShockInput2[DualShockInput2["RStickXAxis"] = 20] = "RStickXAxis";
  DualShockInput2[DualShockInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(DualShockInput || (DualShockInput = {}));
var DualSenseInput;
(function(DualSenseInput2) {
  DualSenseInput2[DualSenseInput2["Cross"] = 0] = "Cross";
  DualSenseInput2[DualSenseInput2["Circle"] = 1] = "Circle";
  DualSenseInput2[DualSenseInput2["Square"] = 2] = "Square";
  DualSenseInput2[DualSenseInput2["Triangle"] = 3] = "Triangle";
  DualSenseInput2[DualSenseInput2["L1"] = 4] = "L1";
  DualSenseInput2[DualSenseInput2["R1"] = 5] = "R1";
  DualSenseInput2[DualSenseInput2["L2"] = 6] = "L2";
  DualSenseInput2[DualSenseInput2["R2"] = 7] = "R2";
  DualSenseInput2[DualSenseInput2["Create"] = 8] = "Create";
  DualSenseInput2[DualSenseInput2["Options"] = 9] = "Options";
  DualSenseInput2[DualSenseInput2["L3"] = 10] = "L3";
  DualSenseInput2[DualSenseInput2["R3"] = 11] = "R3";
  DualSenseInput2[DualSenseInput2["DPadUp"] = 12] = "DPadUp";
  DualSenseInput2[DualSenseInput2["DPadDown"] = 13] = "DPadDown";
  DualSenseInput2[DualSenseInput2["DPadLeft"] = 14] = "DPadLeft";
  DualSenseInput2[DualSenseInput2["DPadRight"] = 15] = "DPadRight";
  DualSenseInput2[DualSenseInput2["Home"] = 16] = "Home";
  DualSenseInput2[DualSenseInput2["TouchPad"] = 17] = "TouchPad";
  DualSenseInput2[DualSenseInput2["LStickXAxis"] = 18] = "LStickXAxis";
  DualSenseInput2[DualSenseInput2["LStickYAxis"] = 19] = "LStickYAxis";
  DualSenseInput2[DualSenseInput2["RStickXAxis"] = 20] = "RStickXAxis";
  DualSenseInput2[DualSenseInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(DualSenseInput || (DualSenseInput = {}));
var XboxInput;
(function(XboxInput2) {
  XboxInput2[XboxInput2["A"] = 0] = "A";
  XboxInput2[XboxInput2["B"] = 1] = "B";
  XboxInput2[XboxInput2["X"] = 2] = "X";
  XboxInput2[XboxInput2["Y"] = 3] = "Y";
  XboxInput2[XboxInput2["LB"] = 4] = "LB";
  XboxInput2[XboxInput2["RB"] = 5] = "RB";
  XboxInput2[XboxInput2["LT"] = 6] = "LT";
  XboxInput2[XboxInput2["RT"] = 7] = "RT";
  XboxInput2[XboxInput2["Back"] = 8] = "Back";
  XboxInput2[XboxInput2["Start"] = 9] = "Start";
  XboxInput2[XboxInput2["LS"] = 10] = "LS";
  XboxInput2[XboxInput2["RS"] = 11] = "RS";
  XboxInput2[XboxInput2["DPadUp"] = 12] = "DPadUp";
  XboxInput2[XboxInput2["DPadDown"] = 13] = "DPadDown";
  XboxInput2[XboxInput2["DPadLeft"] = 14] = "DPadLeft";
  XboxInput2[XboxInput2["DPadRight"] = 15] = "DPadRight";
  XboxInput2[XboxInput2["Home"] = 16] = "Home";
  XboxInput2[XboxInput2["LStickXAxis"] = 17] = "LStickXAxis";
  XboxInput2[XboxInput2["LStickYAxis"] = 18] = "LStickYAxis";
  XboxInput2[XboxInput2["RStickXAxis"] = 19] = "RStickXAxis";
  XboxInput2[XboxInput2["RStickYAxis"] = 20] = "RStickYAxis";
})(XboxInput || (XboxInput = {}));
var SwitchInput;
(function(SwitchInput2) {
  SwitchInput2[SwitchInput2["B"] = 0] = "B";
  SwitchInput2[SwitchInput2["A"] = 1] = "A";
  SwitchInput2[SwitchInput2["Y"] = 2] = "Y";
  SwitchInput2[SwitchInput2["X"] = 3] = "X";
  SwitchInput2[SwitchInput2["L"] = 4] = "L";
  SwitchInput2[SwitchInput2["R"] = 5] = "R";
  SwitchInput2[SwitchInput2["ZL"] = 6] = "ZL";
  SwitchInput2[SwitchInput2["ZR"] = 7] = "ZR";
  SwitchInput2[SwitchInput2["Minus"] = 8] = "Minus";
  SwitchInput2[SwitchInput2["Plus"] = 9] = "Plus";
  SwitchInput2[SwitchInput2["LS"] = 10] = "LS";
  SwitchInput2[SwitchInput2["RS"] = 11] = "RS";
  SwitchInput2[SwitchInput2["DPadUp"] = 12] = "DPadUp";
  SwitchInput2[SwitchInput2["DPadDown"] = 13] = "DPadDown";
  SwitchInput2[SwitchInput2["DPadLeft"] = 14] = "DPadLeft";
  SwitchInput2[SwitchInput2["DPadRight"] = 15] = "DPadRight";
  SwitchInput2[SwitchInput2["Home"] = 16] = "Home";
  SwitchInput2[SwitchInput2["Capture"] = 17] = "Capture";
  SwitchInput2[SwitchInput2["LStickXAxis"] = 18] = "LStickXAxis";
  SwitchInput2[SwitchInput2["LStickYAxis"] = 19] = "LStickYAxis";
  SwitchInput2[SwitchInput2["RStickXAxis"] = 20] = "RStickXAxis";
  SwitchInput2[SwitchInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(SwitchInput || (SwitchInput = {}));

// node_modules/@babylonjs/core/Events/deviceInputEvents.js
var DeviceInputEventType;
(function(DeviceInputEventType2) {
  DeviceInputEventType2[DeviceInputEventType2["PointerMove"] = 0] = "PointerMove";
  DeviceInputEventType2[DeviceInputEventType2["PointerDown"] = 1] = "PointerDown";
  DeviceInputEventType2[DeviceInputEventType2["PointerUp"] = 2] = "PointerUp";
})(DeviceInputEventType || (DeviceInputEventType = {}));
var EventConstants = class {
};
EventConstants.DOM_DELTA_PIXEL = 0;
EventConstants.DOM_DELTA_LINE = 1;
EventConstants.DOM_DELTA_PAGE = 2;

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSource.js
var DeviceSource = class {
  /**
   * Default Constructor
   * @param deviceInputSystem - Reference to DeviceInputSystem
   * @param deviceType - Type of device
   * @param deviceSlot - "Slot" or index that device is referenced in
   */
  constructor(deviceInputSystem, deviceType, deviceSlot = 0) {
    this.deviceType = deviceType;
    this.deviceSlot = deviceSlot;
    this.onInputChangedObservable = new Observable();
    this._deviceInputSystem = deviceInputSystem;
  }
  /**
   * Get input for specific input
   * @param inputIndex - index of specific input on device
   * @returns Input value from DeviceInputSystem
   */
  getInput(inputIndex) {
    return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, inputIndex);
  }
};

// node_modules/@babylonjs/core/DeviceInput/eventFactory.js
var DeviceEventFactory = class {
  /**
   * Create device input events based on provided type and slot
   *
   * @param deviceType Type of device
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param inputIndex Id of input to be checked
   * @param currentState Current value for given input
   * @param deviceInputSystem Reference to DeviceInputSystem
   * @param elementToAttachTo HTMLElement to reference as target for inputs
   * @param pointerId PointerId to use for pointer events
   * @returns IUIEvent object
   */
  static CreateDeviceEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo, pointerId) {
    switch (deviceType) {
      case DeviceType.Keyboard:
        return this._CreateKeyboardEvent(inputIndex, currentState, deviceInputSystem, elementToAttachTo);
      case DeviceType.Mouse:
        if (inputIndex === PointerInput.MouseWheelX || inputIndex === PointerInput.MouseWheelY || inputIndex === PointerInput.MouseWheelZ) {
          return this._CreateWheelEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
        }
      // eslint-disable-next-line no-fallthrough
      case DeviceType.Touch:
        return this._CreatePointerEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo, pointerId);
      default:
        throw `Unable to generate event for device ${DeviceType[deviceType]}`;
    }
  }
  /**
   * Creates pointer event
   *
   * @param deviceType Type of device
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param inputIndex Id of input to be checked
   * @param currentState Current value for given input
   * @param deviceInputSystem Reference to DeviceInputSystem
   * @param elementToAttachTo HTMLElement to reference as target for inputs
   * @param pointerId PointerId to use for pointer events
   * @returns IUIEvent object (Pointer)
   */
  static _CreatePointerEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo, pointerId) {
    const evt = this._CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
    if (deviceType === DeviceType.Mouse) {
      evt.deviceType = DeviceType.Mouse;
      evt.pointerId = 1;
      evt.pointerType = "mouse";
    } else {
      evt.deviceType = DeviceType.Touch;
      evt.pointerId = pointerId ?? deviceSlot;
      evt.pointerType = "touch";
    }
    let buttons = 0;
    buttons += deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.LeftClick);
    buttons += deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.RightClick) * 2;
    buttons += deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.MiddleClick) * 4;
    evt.buttons = buttons;
    if (inputIndex === PointerInput.Move) {
      evt.type = "pointermove";
    } else if (inputIndex >= PointerInput.LeftClick && inputIndex <= PointerInput.RightClick) {
      evt.type = currentState === 1 ? "pointerdown" : "pointerup";
      evt.button = inputIndex - 2;
    }
    return evt;
  }
  /**
   * Create Mouse Wheel Event
   * @param deviceType Type of device
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param inputIndex Id of input to be checked
   * @param currentState Current value for given input
   * @param deviceInputSystem Reference to DeviceInputSystem
   * @param elementToAttachTo HTMLElement to reference as target for inputs
   * @returns IUIEvent object (Wheel)
   */
  static _CreateWheelEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    const evt = this._CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
    evt.pointerId = 1;
    evt.type = "wheel";
    evt.deltaMode = EventConstants.DOM_DELTA_PIXEL;
    evt.deltaX = 0;
    evt.deltaY = 0;
    evt.deltaZ = 0;
    switch (inputIndex) {
      case PointerInput.MouseWheelX:
        evt.deltaX = currentState;
        break;
      case PointerInput.MouseWheelY:
        evt.deltaY = currentState;
        break;
      case PointerInput.MouseWheelZ:
        evt.deltaZ = currentState;
        break;
    }
    return evt;
  }
  /**
   * Create Mouse Event
   * @param deviceType Type of device
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param inputIndex Id of input to be checked
   * @param currentState Current value for given input
   * @param deviceInputSystem Reference to DeviceInputSystem
   * @param elementToAttachTo HTMLElement to reference as target for inputs
   * @returns IUIEvent object (Mouse)
   */
  static _CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    const evt = this._CreateEvent(elementToAttachTo);
    const pointerX = deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.Horizontal);
    const pointerY = deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.Vertical);
    if (elementToAttachTo) {
      evt.movementX = 0;
      evt.movementY = 0;
      evt.offsetX = evt.movementX - elementToAttachTo.getBoundingClientRect().x;
      evt.offsetY = evt.movementY - elementToAttachTo.getBoundingClientRect().y;
    } else {
      evt.movementX = deviceInputSystem.pollInput(
        deviceType,
        deviceSlot,
        10
        /* NativePointerInput.DeltaHorizontal */
      );
      evt.movementY = deviceInputSystem.pollInput(
        deviceType,
        deviceSlot,
        11
        /* NativePointerInput.DeltaVertical */
      );
      evt.offsetX = 0;
      evt.offsetY = 0;
    }
    this._CheckNonCharacterKeys(evt, deviceInputSystem);
    evt.clientX = pointerX;
    evt.clientY = pointerY;
    evt.x = pointerX;
    evt.y = pointerY;
    evt.deviceType = deviceType;
    evt.deviceSlot = deviceSlot;
    evt.inputIndex = inputIndex;
    return evt;
  }
  /**
   * Create Keyboard Event
   * @param inputIndex Id of input to be checked
   * @param currentState Current value for given input
   * @param deviceInputSystem Reference to DeviceInputSystem
   * @param elementToAttachTo HTMLElement to reference as target for inputs
   * @returns IEvent object (Keyboard)
   */
  static _CreateKeyboardEvent(inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    const evt = this._CreateEvent(elementToAttachTo);
    this._CheckNonCharacterKeys(evt, deviceInputSystem);
    evt.deviceType = DeviceType.Keyboard;
    evt.deviceSlot = 0;
    evt.inputIndex = inputIndex;
    evt.type = currentState === 1 ? "keydown" : "keyup";
    evt.key = String.fromCharCode(inputIndex);
    evt.keyCode = inputIndex;
    return evt;
  }
  /**
   * Add parameters for non-character keys (Ctrl, Alt, Meta, Shift)
   * @param evt Event object to add parameters to
   * @param deviceInputSystem DeviceInputSystem to pull values from
   */
  static _CheckNonCharacterKeys(evt, deviceInputSystem) {
    const isKeyboardActive = deviceInputSystem.isDeviceAvailable(DeviceType.Keyboard);
    const altKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 18) === 1;
    const ctrlKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 17) === 1;
    const metaKey = isKeyboardActive && (deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 91) === 1 || deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 92) === 1 || deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 93) === 1);
    const shiftKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 16) === 1;
    evt.altKey = altKey;
    evt.ctrlKey = ctrlKey;
    evt.metaKey = metaKey;
    evt.shiftKey = shiftKey;
  }
  /**
   * Create base event object
   * @param elementToAttachTo Value to use as event target
   * @returns
   */
  static _CreateEvent(elementToAttachTo) {
    const evt = {};
    evt.preventDefault = () => {
    };
    evt.target = elementToAttachTo;
    return evt;
  }
};

// node_modules/@babylonjs/core/DeviceInput/nativeDeviceInputSystem.js
var NativeDeviceInputSystem = class {
  constructor(onDeviceConnected, onDeviceDisconnected, onInputChanged) {
    this._nativeInput = _native.DeviceInputSystem ? new _native.DeviceInputSystem(onDeviceConnected, onDeviceDisconnected, (deviceType, deviceSlot, inputIndex, currentState) => {
      const evt = DeviceEventFactory.CreateDeviceEvent(deviceType, deviceSlot, inputIndex, currentState, this);
      onInputChanged(deviceType, deviceSlot, evt);
    }) : this._createDummyNativeInput();
  }
  // Public functions
  /**
   * Checks for current device input value, given an id and input index. Throws exception if requested device not initialized.
   * @param deviceType Enum specifying device type
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param inputIndex Id of input to be checked
   * @returns Current value of input
   */
  pollInput(deviceType, deviceSlot, inputIndex) {
    return this._nativeInput.pollInput(deviceType, deviceSlot, inputIndex);
  }
  /**
   * Check for a specific device in the DeviceInputSystem
   * @param deviceType Type of device to check for
   * @returns bool with status of device's existence
   */
  isDeviceAvailable(deviceType) {
    return deviceType === DeviceType.Mouse || deviceType === DeviceType.Touch;
  }
  /**
   * Dispose of all the observables
   */
  dispose() {
    this._nativeInput.dispose();
  }
  /**
   * For versions of BabylonNative that don't have the NativeInput plugin initialized, create a dummy version
   * @returns Object with dummy functions
   */
  _createDummyNativeInput() {
    const nativeInput = {
      pollInput: () => {
        return 0;
      },
      isDeviceAvailable: () => {
        return false;
      },
      dispose: () => {
      }
    };
    return nativeInput;
  }
};

// node_modules/@babylonjs/core/DeviceInput/webDeviceInputSystem.js
var MAX_KEYCODES = 255;
var MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;
var WebDeviceInputSystem = class {
  /**
   * Constructor for the WebDeviceInputSystem
   * @param engine Engine to reference
   * @param onDeviceConnected Callback to execute when device is connected
   * @param onDeviceDisconnected Callback to execute when device is disconnected
   * @param onInputChanged Callback to execute when input changes on device
   */
  constructor(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged) {
    this._inputs = [];
    this._keyboardActive = false;
    this._pointerActive = false;
    this._usingSafari = Tools.IsSafari();
    this._usingMacOs = IsNavigatorAvailable() && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
    this._keyboardDownEvent = (evt) => {
    };
    this._keyboardUpEvent = (evt) => {
    };
    this._keyboardBlurEvent = (evt) => {
    };
    this._pointerMoveEvent = (evt) => {
    };
    this._pointerDownEvent = (evt) => {
    };
    this._pointerUpEvent = (evt) => {
    };
    this._pointerCancelEvent = (evt) => {
    };
    this._pointerCancelTouch = (pointerId) => {
    };
    this._pointerLeaveEvent = (evt) => {
    };
    this._pointerWheelEvent = (evt) => {
    };
    this._pointerBlurEvent = (evt) => {
    };
    this._pointerMacOsChromeOutEvent = (evt) => {
    };
    this._eventsAttached = false;
    this._mouseId = -1;
    this._isUsingFirefox = IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf("Firefox") !== -1;
    this._isUsingChromium = IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf("Chrome") !== -1;
    this._maxTouchPoints = 0;
    this._pointerInputClearObserver = null;
    this._gamepadConnectedEvent = (evt) => {
    };
    this._gamepadDisconnectedEvent = (evt) => {
    };
    this._eventPrefix = Tools.GetPointerPrefix(engine);
    this._engine = engine;
    this._onDeviceConnected = onDeviceConnected;
    this._onDeviceDisconnected = onDeviceDisconnected;
    this._onInputChanged = onInputChanged;
    this._mouseId = this._isUsingFirefox ? 0 : 1;
    this._enableEvents();
    if (this._usingMacOs) {
      this._metaKeys = [];
    }
    if (!this._engine._onEngineViewChanged) {
      this._engine._onEngineViewChanged = () => {
        this._enableEvents();
      };
    }
  }
  // Public functions
  /**
   * Checks for current device input value, given an id and input index. Throws exception if requested device not initialized.
   * @param deviceType Enum specifying device type
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param inputIndex Id of input to be checked
   * @returns Current value of input
   */
  pollInput(deviceType, deviceSlot, inputIndex) {
    const device = this._inputs[deviceType][deviceSlot];
    if (!device) {
      throw `Unable to find device ${DeviceType[deviceType]}`;
    }
    if (deviceType >= DeviceType.DualShock && deviceType <= DeviceType.DualSense) {
      this._updateDevice(deviceType, deviceSlot, inputIndex);
    }
    const currentValue = device[inputIndex];
    if (currentValue === void 0) {
      throw `Unable to find input ${inputIndex} for device ${DeviceType[deviceType]} in slot ${deviceSlot}`;
    }
    if (inputIndex === PointerInput.Move) {
      Tools.Warn(`Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data.`);
    }
    return currentValue;
  }
  /**
   * Check for a specific device in the DeviceInputSystem
   * @param deviceType Type of device to check for
   * @returns bool with status of device's existence
   */
  isDeviceAvailable(deviceType) {
    return this._inputs[deviceType] !== void 0;
  }
  /**
   * Dispose of all the eventlisteners
   */
  dispose() {
    this._onDeviceConnected = () => {
    };
    this._onDeviceDisconnected = () => {
    };
    this._onInputChanged = () => {
    };
    delete this._engine._onEngineViewChanged;
    if (this._elementToAttachTo) {
      this._disableEvents();
    }
  }
  /**
   * Enable listening for user input events
   */
  _enableEvents() {
    const inputElement = this?._engine.getInputElement();
    if (inputElement && (!this._eventsAttached || this._elementToAttachTo !== inputElement)) {
      this._disableEvents();
      if (this._inputs) {
        for (const inputs of this._inputs) {
          if (inputs) {
            for (const deviceSlotKey in inputs) {
              const deviceSlot = +deviceSlotKey;
              const device = inputs[deviceSlot];
              if (device) {
                for (let inputIndex = 0; inputIndex < device.length; inputIndex++) {
                  device[inputIndex] = 0;
                }
              }
            }
          }
        }
      }
      this._elementToAttachTo = inputElement;
      this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;
      this._handleKeyActions();
      this._handlePointerActions();
      this._handleGamepadActions();
      this._eventsAttached = true;
      this._checkForConnectedDevices();
    }
  }
  /**
   * Disable listening for user input events
   */
  _disableEvents() {
    if (this._elementToAttachTo) {
      this._elementToAttachTo.removeEventListener("blur", this._keyboardBlurEvent);
      this._elementToAttachTo.removeEventListener("blur", this._pointerBlurEvent);
      this._elementToAttachTo.removeEventListener("keydown", this._keyboardDownEvent);
      this._elementToAttachTo.removeEventListener("keyup", this._keyboardUpEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "down", this._pointerDownEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "up", this._pointerUpEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "leave", this._pointerLeaveEvent);
      this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent);
      if (this._usingMacOs && this._isUsingChromium) {
        this._elementToAttachTo.removeEventListener("lostpointercapture", this._pointerMacOsChromeOutEvent);
      }
      window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent);
      window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
    }
    if (this._pointerInputClearObserver) {
      this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);
    }
    this._eventsAttached = false;
  }
  /**
   * Checks for existing connections to devices and register them, if necessary
   * Currently handles gamepads and mouse
   */
  _checkForConnectedDevices() {
    if (navigator.getGamepads) {
      const gamepads = navigator.getGamepads();
      for (const gamepad of gamepads) {
        if (gamepad) {
          this._addGamePad(gamepad);
        }
      }
    }
    if (typeof matchMedia === "function" && matchMedia("(pointer:fine)").matches) {
      this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);
    }
  }
  // Private functions
  /**
   * Add a gamepad to the DeviceInputSystem
   * @param gamepad A single DOM Gamepad object
   */
  _addGamePad(gamepad) {
    const deviceType = this._getGamepadDeviceType(gamepad.id);
    const deviceSlot = gamepad.index;
    this._gamepads = this._gamepads || new Array(gamepad.index + 1);
    this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);
    this._gamepads[deviceSlot] = deviceType;
  }
  /**
   * Add pointer device to DeviceInputSystem
   * @param deviceType Type of Pointer to add
   * @param deviceSlot Pointer ID (0 for mouse, pointerId for Touch)
   * @param currentX Current X at point of adding
   * @param currentY Current Y at point of adding
   */
  _addPointerDevice(deviceType, deviceSlot, currentX, currentY) {
    if (!this._pointerActive) {
      this._pointerActive = true;
    }
    this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);
    const pointer = this._inputs[deviceType][deviceSlot];
    pointer[0] = currentX;
    pointer[1] = currentY;
  }
  /**
   * Add device and inputs to device array
   * @param deviceType Enum specifying device type
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param numberOfInputs Number of input entries to create for given device
   */
  _registerDevice(deviceType, deviceSlot, numberOfInputs) {
    if (deviceSlot === void 0) {
      throw `Unable to register device ${DeviceType[deviceType]} to undefined slot.`;
    }
    if (!this._inputs[deviceType]) {
      this._inputs[deviceType] = {};
    }
    if (!this._inputs[deviceType][deviceSlot]) {
      const device = new Array(numberOfInputs);
      device.fill(0);
      this._inputs[deviceType][deviceSlot] = device;
      this._onDeviceConnected(deviceType, deviceSlot);
    }
  }
  /**
   * Given a specific device name, remove that device from the device map
   * @param deviceType Enum specifying device type
   * @param deviceSlot "Slot" or index that device is referenced in
   */
  _unregisterDevice(deviceType, deviceSlot) {
    if (this._inputs[deviceType][deviceSlot]) {
      delete this._inputs[deviceType][deviceSlot];
      this._onDeviceDisconnected(deviceType, deviceSlot);
    }
  }
  /**
   * Handle all actions that come from keyboard interaction
   */
  _handleKeyActions() {
    this._keyboardDownEvent = (evt) => {
      if (!this._keyboardActive) {
        this._keyboardActive = true;
        this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);
      }
      const kbKey = this._inputs[DeviceType.Keyboard][0];
      if (kbKey) {
        kbKey[evt.keyCode] = 1;
        const deviceEvent = evt;
        deviceEvent.inputIndex = evt.keyCode;
        if (this._usingMacOs && evt.metaKey && evt.key !== "Meta") {
          if (!this._metaKeys.includes(evt.keyCode)) {
            this._metaKeys.push(evt.keyCode);
          }
        }
        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
      }
    };
    this._keyboardUpEvent = (evt) => {
      if (!this._keyboardActive) {
        this._keyboardActive = true;
        this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);
      }
      const kbKey = this._inputs[DeviceType.Keyboard][0];
      if (kbKey) {
        kbKey[evt.keyCode] = 0;
        const deviceEvent = evt;
        deviceEvent.inputIndex = evt.keyCode;
        if (this._usingMacOs && evt.key === "Meta" && this._metaKeys.length > 0) {
          for (const keyCode of this._metaKeys) {
            const deviceEvent2 = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, keyCode, 0, this, this._elementToAttachTo);
            kbKey[keyCode] = 0;
            this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent2);
          }
          this._metaKeys.splice(0, this._metaKeys.length);
        }
        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
      }
    };
    this._keyboardBlurEvent = () => {
      if (this._keyboardActive) {
        const kbKey = this._inputs[DeviceType.Keyboard][0];
        for (let i = 0; i < kbKey.length; i++) {
          if (kbKey[i] !== 0) {
            kbKey[i] = 0;
            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 0, this, this._elementToAttachTo);
            this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
          }
        }
        if (this._usingMacOs) {
          this._metaKeys.splice(0, this._metaKeys.length);
        }
      }
    };
    this._elementToAttachTo.addEventListener("keydown", this._keyboardDownEvent);
    this._elementToAttachTo.addEventListener("keyup", this._keyboardUpEvent);
    this._elementToAttachTo.addEventListener("blur", this._keyboardBlurEvent);
  }
  /**
   * Handle all actions that come from pointer interaction
   */
  _handlePointerActions() {
    this._maxTouchPoints = IsNavigatorAvailable() && navigator.maxTouchPoints || 2;
    if (!this._activeTouchIds) {
      this._activeTouchIds = new Array(this._maxTouchPoints);
    }
    for (let i = 0; i < this._maxTouchPoints; i++) {
      this._activeTouchIds[i] = -1;
    }
    this._pointerMoveEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      let deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);
      if (deviceType === DeviceType.Touch && deviceSlot === -1) {
        const idx = this._activeTouchIds.indexOf(-1);
        if (idx >= 0) {
          deviceSlot = idx;
          this._activeTouchIds[idx] = evt.pointerId;
          this._onDeviceConnected(deviceType, deviceSlot);
        } else {
          Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);
          return;
        }
      }
      if (!this._inputs[deviceType]) {
        this._inputs[deviceType] = {};
      }
      if (!this._inputs[deviceType][deviceSlot]) {
        this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
      }
      const pointer = this._inputs[deviceType][deviceSlot];
      if (pointer) {
        const deviceEvent = evt;
        deviceEvent.inputIndex = PointerInput.Move;
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        if (deviceType === DeviceType.Touch && pointer[PointerInput.LeftClick] === 0) {
          pointer[PointerInput.LeftClick] = 1;
        }
        if (evt.pointerId === void 0) {
          evt.pointerId = this._mouseId;
        }
        this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (!this._usingSafari && evt.button !== -1) {
          deviceEvent.inputIndex = evt.button + 2;
          pointer[evt.button + 2] = pointer[evt.button + 2] ? 0 : 1;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    this._pointerDownEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      let deviceSlot = deviceType === DeviceType.Mouse ? 0 : evt.pointerId;
      if (deviceType === DeviceType.Touch) {
        let idx = this._activeTouchIds.indexOf(evt.pointerId);
        if (idx === -1) {
          idx = this._activeTouchIds.indexOf(-1);
        }
        if (idx >= 0) {
          deviceSlot = idx;
          this._activeTouchIds[idx] = evt.pointerId;
        } else {
          Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);
          return;
        }
      }
      if (!this._inputs[deviceType]) {
        this._inputs[deviceType] = {};
      }
      if (!this._inputs[deviceType][deviceSlot]) {
        this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
      } else if (deviceType === DeviceType.Touch) {
        this._onDeviceConnected(deviceType, deviceSlot);
      }
      const pointer = this._inputs[deviceType][deviceSlot];
      if (pointer) {
        const previousHorizontal = pointer[PointerInput.Horizontal];
        const previousVertical = pointer[PointerInput.Vertical];
        if (deviceType === DeviceType.Mouse) {
          if (evt.pointerId === void 0) {
            evt.pointerId = this._mouseId;
          }
          if (!document.pointerLockElement) {
            try {
              this._elementToAttachTo.setPointerCapture(this._mouseId);
            } catch (e) {
            }
          }
        } else {
          if (evt.pointerId && !document.pointerLockElement) {
            try {
              this._elementToAttachTo.setPointerCapture(evt.pointerId);
            } catch (e) {
            }
          }
        }
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        pointer[evt.button + 2] = 1;
        const deviceEvent = evt;
        deviceEvent.inputIndex = evt.button + 2;
        this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = PointerInput.Move;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    this._pointerUpEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      const deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);
      if (deviceType === DeviceType.Touch) {
        if (deviceSlot === -1) {
          return;
        } else {
          this._activeTouchIds[deviceSlot] = -1;
        }
      }
      const pointer = this._inputs[deviceType]?.[deviceSlot];
      let button = evt.button;
      let shouldProcessPointerUp = pointer && pointer[button + 2] !== 0;
      if (!shouldProcessPointerUp && this._isUsingFirefox && this._usingMacOs && pointer) {
        button = button === 2 ? 0 : 2;
        shouldProcessPointerUp = pointer[button + 2] !== 0;
      }
      if (shouldProcessPointerUp) {
        const previousHorizontal = pointer[PointerInput.Horizontal];
        const previousVertical = pointer[PointerInput.Vertical];
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        pointer[button + 2] = 0;
        const deviceEvent = evt;
        if (evt.pointerId === void 0) {
          evt.pointerId = this._mouseId;
        }
        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = PointerInput.Move;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        deviceEvent.inputIndex = button + 2;
        if (deviceType === DeviceType.Mouse && this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {
          this._elementToAttachTo.releasePointerCapture(this._mouseId);
        } else if (evt.pointerId && this._elementToAttachTo.hasPointerCapture?.(evt.pointerId)) {
          this._elementToAttachTo.releasePointerCapture(evt.pointerId);
        }
        this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (deviceType === DeviceType.Touch) {
          this._onDeviceDisconnected(deviceType, deviceSlot);
        }
      }
    };
    this._pointerCancelTouch = (pointerId) => {
      const deviceSlot = this._activeTouchIds.indexOf(pointerId);
      if (deviceSlot === -1) {
        return;
      }
      if (this._elementToAttachTo.hasPointerCapture?.(pointerId)) {
        this._elementToAttachTo.releasePointerCapture(pointerId);
      }
      this._inputs[DeviceType.Touch][deviceSlot][PointerInput.LeftClick] = 0;
      const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo, pointerId);
      this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);
      this._activeTouchIds[deviceSlot] = -1;
      this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);
    };
    this._pointerCancelEvent = (evt) => {
      if (evt.pointerType === "mouse") {
        const pointer = this._inputs[DeviceType.Mouse][0];
        if (this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {
          this._elementToAttachTo.releasePointerCapture(this._mouseId);
        }
        for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {
          if (pointer[inputIndex] === 1) {
            pointer[inputIndex] = 0;
            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);
            this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);
          }
        }
      } else {
        this._pointerCancelTouch(evt.pointerId);
      }
    };
    this._pointerLeaveEvent = (evt) => {
      if (evt.pointerType === "pen") {
        this._pointerCancelTouch(evt.pointerId);
      }
    };
    this._wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
    let passiveSupported = false;
    const noop = function() {
    };
    try {
      const options = Object.defineProperty({}, "passive", {
        get: function() {
          passiveSupported = true;
        }
      });
      this._elementToAttachTo.addEventListener("test", noop, options);
      this._elementToAttachTo.removeEventListener("test", noop, options);
    } catch (e) {
    }
    this._pointerBlurEvent = () => {
      if (this.isDeviceAvailable(DeviceType.Mouse)) {
        const pointer = this._inputs[DeviceType.Mouse][0];
        if (this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {
          this._elementToAttachTo.releasePointerCapture(this._mouseId);
        }
        for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {
          if (pointer[inputIndex] === 1) {
            pointer[inputIndex] = 0;
            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);
            this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);
          }
        }
      }
      if (this.isDeviceAvailable(DeviceType.Touch)) {
        const pointer = this._inputs[DeviceType.Touch];
        for (let deviceSlot = 0; deviceSlot < this._activeTouchIds.length; deviceSlot++) {
          const pointerId = this._activeTouchIds[deviceSlot];
          if (this._elementToAttachTo.hasPointerCapture?.(pointerId)) {
            this._elementToAttachTo.releasePointerCapture(pointerId);
          }
          if (pointerId !== -1 && pointer[deviceSlot]?.[PointerInput.LeftClick] === 1) {
            pointer[deviceSlot][PointerInput.LeftClick] = 0;
            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo, pointerId);
            this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);
            this._activeTouchIds[deviceSlot] = -1;
            this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);
          }
        }
      }
    };
    this._pointerWheelEvent = (evt) => {
      const deviceType = DeviceType.Mouse;
      const deviceSlot = 0;
      if (!this._inputs[deviceType]) {
        this._inputs[deviceType] = [];
      }
      if (!this._inputs[deviceType][deviceSlot]) {
        this._pointerActive = true;
        this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);
      }
      const pointer = this._inputs[deviceType][deviceSlot];
      if (pointer) {
        pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;
        pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;
        pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;
        const deviceEvent = evt;
        if (evt.pointerId === void 0) {
          evt.pointerId = this._mouseId;
        }
        if (pointer[PointerInput.MouseWheelX] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelX;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        if (pointer[PointerInput.MouseWheelY] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelY;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        if (pointer[PointerInput.MouseWheelZ] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelZ;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    if (this._usingMacOs && this._isUsingChromium) {
      this._pointerMacOsChromeOutEvent = (evt) => {
        if (evt.buttons > 1) {
          this._pointerCancelEvent(evt);
        }
      };
      this._elementToAttachTo.addEventListener("lostpointercapture", this._pointerMacOsChromeOutEvent);
    }
    this._elementToAttachTo.addEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "down", this._pointerDownEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "up", this._pointerUpEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "leave", this._pointerLeaveEvent);
    this._elementToAttachTo.addEventListener("blur", this._pointerBlurEvent);
    this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? { passive: false } : false);
    this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(() => {
      if (this.isDeviceAvailable(DeviceType.Mouse)) {
        const pointer = this._inputs[DeviceType.Mouse][0];
        pointer[PointerInput.MouseWheelX] = 0;
        pointer[PointerInput.MouseWheelY] = 0;
        pointer[PointerInput.MouseWheelZ] = 0;
      }
    });
  }
  /**
   * Handle all actions that come from gamepad interaction
   */
  _handleGamepadActions() {
    this._gamepadConnectedEvent = (evt) => {
      this._addGamePad(evt.gamepad);
    };
    this._gamepadDisconnectedEvent = (evt) => {
      if (this._gamepads) {
        const deviceType = this._getGamepadDeviceType(evt.gamepad.id);
        const deviceSlot = evt.gamepad.index;
        this._unregisterDevice(deviceType, deviceSlot);
        delete this._gamepads[deviceSlot];
      }
    };
    window.addEventListener("gamepadconnected", this._gamepadConnectedEvent);
    window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
  }
  /**
   * Update all non-event based devices with each frame
   * @param deviceType Enum specifying device type
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param inputIndex Id of input to be checked
   */
  _updateDevice(deviceType, deviceSlot, inputIndex) {
    const gp = navigator.getGamepads()[deviceSlot];
    if (gp && deviceType === this._gamepads[deviceSlot]) {
      const device = this._inputs[deviceType][deviceSlot];
      if (inputIndex >= gp.buttons.length) {
        device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();
      } else {
        device[inputIndex] = gp.buttons[inputIndex].value;
      }
    }
  }
  /**
   * Gets DeviceType from the device name
   * @param deviceName Name of Device from DeviceInputSystem
   * @returns DeviceType enum value
   */
  _getGamepadDeviceType(deviceName) {
    if (deviceName.indexOf("054c") !== -1) {
      return deviceName.indexOf("0ce6") !== -1 ? DeviceType.DualSense : DeviceType.DualShock;
    } else if (deviceName.indexOf("Xbox One") !== -1 || deviceName.search("Xbox 360") !== -1 || deviceName.search("xinput") !== -1) {
      return DeviceType.Xbox;
    } else if (deviceName.indexOf("057e") !== -1) {
      return DeviceType.Switch;
    }
    return DeviceType.Generic;
  }
  /**
   * Get DeviceType from a given pointer/mouse/touch event.
   * @param evt PointerEvent to evaluate
   * @returns DeviceType interpreted from event
   */
  _getPointerType(evt) {
    let deviceType = DeviceType.Mouse;
    if (evt.pointerType === "touch" || evt.pointerType === "pen" || evt.touches) {
      deviceType = DeviceType.Touch;
    }
    return deviceType;
  }
};

// node_modules/@babylonjs/core/DeviceInput/internalDeviceSourceManager.js
var InternalDeviceSourceManager = class {
  constructor(engine) {
    this._registeredManagers = new Array();
    this._refCount = 0;
    this.registerManager = (manager) => {
      for (let deviceType = 0; deviceType < this._devices.length; deviceType++) {
        const device = this._devices[deviceType];
        for (const deviceSlotKey in device) {
          const deviceSlot = +deviceSlotKey;
          manager._addDevice(new DeviceSource(this._deviceInputSystem, deviceType, deviceSlot));
        }
      }
      this._registeredManagers.push(manager);
    };
    this.unregisterManager = (manager) => {
      const idx = this._registeredManagers.indexOf(manager);
      if (idx > -1) {
        this._registeredManagers.splice(idx, 1);
      }
    };
    const numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
    this._devices = new Array(numberOfDeviceTypes);
    const onDeviceConnected = (deviceType, deviceSlot) => {
      if (!this._devices[deviceType]) {
        this._devices[deviceType] = new Array();
      }
      if (!this._devices[deviceType][deviceSlot]) {
        this._devices[deviceType][deviceSlot] = deviceSlot;
      }
      for (const manager of this._registeredManagers) {
        const deviceSource = new DeviceSource(this._deviceInputSystem, deviceType, deviceSlot);
        manager._addDevice(deviceSource);
      }
    };
    const onDeviceDisconnected = (deviceType, deviceSlot) => {
      if (this._devices[deviceType]?.[deviceSlot]) {
        delete this._devices[deviceType][deviceSlot];
      }
      for (const manager of this._registeredManagers) {
        manager._removeDevice(deviceType, deviceSlot);
      }
    };
    const onInputChanged = (deviceType, deviceSlot, eventData) => {
      if (eventData) {
        for (const manager of this._registeredManagers) {
          manager._onInputChanged(deviceType, deviceSlot, eventData);
        }
      }
    };
    if (typeof _native !== "undefined") {
      this._deviceInputSystem = new NativeDeviceInputSystem(onDeviceConnected, onDeviceDisconnected, onInputChanged);
    } else {
      this._deviceInputSystem = new WebDeviceInputSystem(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged);
    }
  }
  dispose() {
    this._deviceInputSystem.dispose();
  }
};

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSourceManager.js
var DeviceSourceManager = class {
  // Public Functions
  /**
   * Gets a DeviceSource, given a type and slot
   * @param deviceType - Type of Device
   * @param deviceSlot - Slot or ID of device
   * @returns DeviceSource
   */
  getDeviceSource(deviceType, deviceSlot) {
    if (deviceSlot === void 0) {
      if (this._firstDevice[deviceType] === void 0) {
        return null;
      }
      deviceSlot = this._firstDevice[deviceType];
    }
    if (!this._devices[deviceType] || this._devices[deviceType][deviceSlot] === void 0) {
      return null;
    }
    return this._devices[deviceType][deviceSlot];
  }
  /**
   * Gets an array of DeviceSource objects for a given device type
   * @param deviceType - Type of Device
   * @returns All available DeviceSources of a given type
   */
  getDeviceSources(deviceType) {
    if (!this._devices[deviceType]) {
      return [];
    }
    return this._devices[deviceType].filter((source) => {
      return !!source;
    });
  }
  /**
   * Default constructor
   * @param engine - Used to get canvas (if applicable)
   */
  constructor(engine) {
    const numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
    this._devices = new Array(numberOfDeviceTypes);
    this._firstDevice = new Array(numberOfDeviceTypes);
    this._engine = engine;
    if (!this._engine._deviceSourceManager) {
      this._engine._deviceSourceManager = new InternalDeviceSourceManager(engine);
    }
    this._engine._deviceSourceManager._refCount++;
    this.onDeviceConnectedObservable = new Observable((observer) => {
      for (const devices of this._devices) {
        if (devices) {
          for (const device of devices) {
            if (device) {
              this.onDeviceConnectedObservable.notifyObserver(observer, device);
            }
          }
        }
      }
    });
    this.onDeviceDisconnectedObservable = new Observable();
    this._engine._deviceSourceManager.registerManager(this);
    this._onDisposeObserver = engine.onDisposeObservable.add(() => {
      this.dispose();
    });
  }
  /**
   * Dispose of DeviceSourceManager
   */
  dispose() {
    this.onDeviceConnectedObservable.clear();
    this.onDeviceDisconnectedObservable.clear();
    if (this._engine._deviceSourceManager) {
      this._engine._deviceSourceManager.unregisterManager(this);
      if (--this._engine._deviceSourceManager._refCount < 1) {
        this._engine._deviceSourceManager.dispose();
        delete this._engine._deviceSourceManager;
      }
    }
    this._engine.onDisposeObservable.remove(this._onDisposeObserver);
  }
  // Hidden Functions
  /**
   * @param deviceSource - Source to add
   * @internal
   */
  _addDevice(deviceSource) {
    if (!this._devices[deviceSource.deviceType]) {
      this._devices[deviceSource.deviceType] = [];
    }
    if (!this._devices[deviceSource.deviceType][deviceSource.deviceSlot]) {
      this._devices[deviceSource.deviceType][deviceSource.deviceSlot] = deviceSource;
      this._updateFirstDevices(deviceSource.deviceType);
    }
    this.onDeviceConnectedObservable.notifyObservers(deviceSource);
  }
  /**
   * @param deviceType - DeviceType
   * @param deviceSlot - DeviceSlot
   * @internal
   */
  _removeDevice(deviceType, deviceSlot) {
    const deviceSource = this._devices[deviceType]?.[deviceSlot];
    this.onDeviceDisconnectedObservable.notifyObservers(deviceSource);
    if (this._devices[deviceType]?.[deviceSlot]) {
      delete this._devices[deviceType][deviceSlot];
    }
    this._updateFirstDevices(deviceType);
  }
  /**
   * @param deviceType - DeviceType
   * @param deviceSlot - DeviceSlot
   * @param eventData - Event
   * @internal
   */
  _onInputChanged(deviceType, deviceSlot, eventData) {
    this._devices[deviceType]?.[deviceSlot]?.onInputChangedObservable.notifyObservers(eventData);
  }
  // Private Functions
  _updateFirstDevices(type) {
    switch (type) {
      case DeviceType.Keyboard:
      case DeviceType.Mouse:
        this._firstDevice[type] = 0;
        break;
      case DeviceType.Touch:
      case DeviceType.DualSense:
      case DeviceType.DualShock:
      case DeviceType.Xbox:
      case DeviceType.Switch:
      case DeviceType.Generic: {
        delete this._firstDevice[type];
        const devices = this._devices[type];
        if (devices) {
          for (let i = 0; i < devices.length; i++) {
            if (devices[i]) {
              this._firstDevice[type] = i;
              break;
            }
          }
        }
        break;
      }
    }
  }
};

// node_modules/@babylonjs/core/FrameGraph/frameGraphTypes.js
var backbufferColorTextureHandle = 0;
var backbufferDepthStencilTextureHandle = 1;

// node_modules/@babylonjs/core/FrameGraph/Passes/pass.js
var FrameGraphPass = class {
  /** @internal */
  constructor(name, _parentTask, _context) {
    this.name = name;
    this._parentTask = _parentTask;
    this._context = _context;
    this.disabled = false;
  }
  /**
   * Initializes the pass.
   * This function is called once after the frame graph has been built
   * @param func The function to initialize the pass.
   */
  setInitializeFunc(func) {
    this._initFunc = func;
  }
  /**
   * Sets the function to execute when the pass is executed
   * @param func The function to execute when the pass is executed
   */
  setExecuteFunc(func) {
    this._executeFunc = func;
  }
  /** @internal */
  _execute() {
    if (!this.disabled) {
      this._executeFunc(this._context);
    }
  }
  /** @internal */
  _initialize() {
    this._initFunc?.(this._context);
  }
  /** @internal */
  _isValid() {
    return this._executeFunc !== void 0 ? null : "Execute function is not set (call setExecuteFunc to set it)";
  }
  /** @internal */
  _dispose() {
  }
};

// node_modules/@babylonjs/core/FrameGraph/Passes/objectListPass.js
var FrameGraphObjectListPass = class extends FrameGraphPass {
  /**
   * Checks if a pass is an object list pass.
   * @param pass The pass to check.
   * @returns True if the pass is an object list pass, else false.
   */
  static IsObjectListPass(pass) {
    return pass.setObjectList !== void 0;
  }
  /**
   * Gets the object list used by the pass.
   */
  get objectList() {
    return this._objectList;
  }
  /**
   * Sets the object list to use for the pass.
   * @param objectList The object list to use for the pass.
   */
  setObjectList(objectList) {
    this._objectList = objectList;
  }
  /** @internal */
  constructor(name, parentTask, context, engine) {
    super(name, parentTask, context);
    this._engine = engine;
  }
  /** @internal */
  _isValid() {
    const errMsg = super._isValid();
    return errMsg ? errMsg : this._objectList !== void 0 ? null : "Object list is not set (call setObjectList to set it)";
  }
};

// node_modules/@babylonjs/core/FrameGraph/Passes/renderPass.js
var FrameGraphRenderPass = class extends FrameGraphPass {
  /**
   * Checks if a pass is a render pass.
   * @param pass The pass to check.
   * @returns True if the pass is a render pass, else false.
   */
  static IsRenderPass(pass) {
    return pass.setRenderTarget !== void 0;
  }
  /**
   * Gets the handle(s) of the render target(s) used by the render pass.
   */
  get renderTarget() {
    return this._renderTarget;
  }
  /**
   * Gets the handle of the render target depth used by the render pass.
   */
  get renderTargetDepth() {
    return this._renderTargetDepth;
  }
  /**
   * Gets the frame graph render target used by the render pass.
   */
  get frameGraphRenderTarget() {
    return this._frameGraphRenderTarget;
  }
  /** @internal */
  constructor(name, parentTask, context, engine) {
    super(name, parentTask, context);
    this._dependencies = /* @__PURE__ */ new Set();
    this.depthReadOnly = false;
    this.stencilReadOnly = false;
    this._engine = engine;
  }
  /**
   * Sets the render target(s) to use for rendering.
   * @param renderTargetHandle The render target to use for rendering, or an array of render targets to use for multi render target rendering.
   */
  setRenderTarget(renderTargetHandle) {
    this._renderTarget = renderTargetHandle;
  }
  /**
   * Sets the render target depth to use for rendering.
   * @param renderTargetHandle The render target depth to use for rendering.
   */
  setRenderTargetDepth(renderTargetHandle) {
    this._renderTargetDepth = renderTargetHandle;
  }
  /**
   * Adds dependencies to the render pass.
   * @param dependencies The dependencies to add.
   */
  addDependencies(dependencies) {
    if (dependencies === void 0) {
      return;
    }
    if (Array.isArray(dependencies)) {
      for (const dependency of dependencies) {
        this._dependencies.add(dependency);
      }
    } else {
      this._dependencies.add(dependencies);
    }
  }
  /**
   * Collects the dependencies of the render pass.
   * @param dependencies The set of dependencies to update.
   */
  collectDependencies(dependencies) {
    const iterator = this._dependencies.keys();
    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
      dependencies.add(key.value);
    }
    if (this._renderTarget !== void 0) {
      if (Array.isArray(this._renderTarget)) {
        for (const handle of this._renderTarget) {
          if (handle !== void 0) {
            dependencies.add(handle);
          }
        }
      } else {
        dependencies.add(this._renderTarget);
      }
    }
    if (this._renderTargetDepth !== void 0) {
      dependencies.add(this._renderTargetDepth);
    }
  }
  /** @internal */
  _initialize() {
    this._frameGraphRenderTarget = this._context.createRenderTarget(this.name, this._renderTarget, this._renderTargetDepth, this.depthReadOnly, this.stencilReadOnly);
    super._initialize();
  }
  /** @internal */
  _execute() {
    this._context.bindRenderTarget(this._frameGraphRenderTarget);
    super._execute();
    this._context._flushDebugMessages();
    const renderTargetWrapper = this._frameGraphRenderTarget.renderTargetWrapper;
    if (renderTargetWrapper && renderTargetWrapper.samples > 1 && (renderTargetWrapper.resolveMSAAColors || renderTargetWrapper.resolveMSAADepth || renderTargetWrapper.resolveMSAAStencil)) {
      this._context.bindRenderTarget(void 0, `Resolve MSAA${this.name ? " (" + this.name + ")" : ""}`, true);
      this._context._flushDebugMessages();
    }
  }
  /** @internal */
  _isValid() {
    const errMsg = super._isValid();
    return errMsg ? errMsg : this._renderTarget !== void 0 || this.renderTargetDepth !== void 0 ? null : "Render target and render target depth cannot both be undefined.";
  }
  /** @internal */
  _dispose() {
    this._frameGraphRenderTarget?.dispose();
  }
};

// node_modules/@babylonjs/core/FrameGraph/frameGraphTask.js
var FrameGraphTask = class {
  /**
   * The name of the task.
   */
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  /**
   * Whether the task is disabled.
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
  }
  /**
   * Gets the render passes of the task.
   */
  get passes() {
    return this._passes;
  }
  /**
   * Gets the disabled render passes of the task.
   */
  get passesDisabled() {
    return this._passesDisabled;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "FrameGraphTask";
  }
  /**
   * This function is called once after the task has been added to the frame graph and before the frame graph is built for the first time.
   * This allows you to initialize asynchronous resources, which is not possible in the constructor.
   * @returns A promise that resolves when the initialization is complete.
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  initAsync() {
    return Promise.resolve();
  }
  /**
   * Checks if the task is ready to be executed.
   * @returns True if the task is ready to be executed, else false.
   */
  isReady() {
    return true;
  }
  /**
   * Disposes of the task.
   */
  dispose() {
    this._reset();
    this.onTexturesAllocatedObservable.clear();
    this.onBeforeTaskExecute.clear();
    this.onAfterTaskExecute.clear();
  }
  /**
   * Constructs a new frame graph task.
   * @param name The name of the task.
   * @param frameGraph The frame graph this task is associated with.
   */
  constructor(name, frameGraph) {
    this._passes = [];
    this._passesDisabled = [];
    this._disabled = false;
    this.onTexturesAllocatedObservable = new Observable();
    this.onBeforeTaskExecute = new Observable();
    this.onAfterTaskExecute = new Observable();
    this.name = name;
    this._frameGraph = frameGraph;
    this._reset();
  }
  /** @internal */
  _reset() {
    for (const pass of this._passes) {
      pass._dispose();
    }
    for (const pass of this._passesDisabled) {
      pass._dispose();
    }
    this._passes.length = 0;
    this._passesDisabled.length = 0;
  }
  /** @internal */
  _addPass(pass, disabled) {
    if (disabled) {
      this._passesDisabled.push(pass);
    } else {
      this._passes.push(pass);
    }
  }
  /** @internal */
  _checkTask() {
    let outputTexture = null;
    let outputDepthTexture = null;
    let outputObjectList;
    for (const pass of this._passes) {
      const errMsg = pass._isValid();
      if (errMsg) {
        throw new Error(`Pass "${pass.name}" is not valid. ${errMsg}`);
      }
      if (FrameGraphRenderPass.IsRenderPass(pass)) {
        const handles = Array.isArray(pass.renderTarget) ? pass.renderTarget : [pass.renderTarget];
        outputTexture = [];
        for (const handle of handles) {
          if (handle !== void 0) {
            outputTexture.push(this._frameGraph.textureManager.getTextureFromHandle(handle));
          }
        }
        outputDepthTexture = pass.renderTargetDepth !== void 0 ? this._frameGraph.textureManager.getTextureFromHandle(pass.renderTargetDepth) : null;
      } else if (FrameGraphObjectListPass.IsObjectListPass(pass)) {
        outputObjectList = pass.objectList;
      }
    }
    let disabledOutputTexture = null;
    let disabledOutputTextureHandle = [];
    let disabledOutputDepthTexture = null;
    let disabledOutputObjectList;
    for (const pass of this._passesDisabled) {
      const errMsg = pass._isValid();
      if (errMsg) {
        throw new Error(`Pass "${pass.name}" is not valid. ${errMsg}`);
      }
      if (FrameGraphRenderPass.IsRenderPass(pass)) {
        const handles = Array.isArray(pass.renderTarget) ? pass.renderTarget : [pass.renderTarget];
        disabledOutputTexture = [];
        for (const handle of handles) {
          if (handle !== void 0) {
            disabledOutputTexture.push(this._frameGraph.textureManager.getTextureFromHandle(handle));
          }
        }
        disabledOutputTextureHandle = handles;
        disabledOutputDepthTexture = pass.renderTargetDepth !== void 0 ? this._frameGraph.textureManager.getTextureFromHandle(pass.renderTargetDepth) : null;
      } else if (FrameGraphObjectListPass.IsObjectListPass(pass)) {
        disabledOutputObjectList = pass.objectList;
      }
    }
    if (this._passesDisabled.length > 0) {
      if (!this._checkSameRenderTarget(outputTexture, disabledOutputTexture)) {
        let ok = true;
        for (const handle of disabledOutputTextureHandle) {
          if (handle !== void 0 && !this._frameGraph.textureManager.isHistoryTexture(handle)) {
            ok = false;
            break;
          }
        }
        if (!ok) {
          throw new Error(`The output texture of the task "${this.name}" is different when it is enabled or disabled.`);
        }
      }
      if (outputDepthTexture !== disabledOutputDepthTexture && disabledOutputDepthTexture !== null) {
        throw new Error(`The output depth texture of the task "${this.name}" is different when it is enabled or disabled.`);
      }
      if (outputObjectList !== disabledOutputObjectList && disabledOutputObjectList !== null) {
        throw new Error(`The output object list of the task "${this.name}" is different when it is enabled or disabled.`);
      }
    }
  }
  /** @internal */
  _execute() {
    const passes = this._disabled && this._passesDisabled.length > 0 ? this._passesDisabled : this._passes;
    this.onBeforeTaskExecute.notifyObservers(this);
    this._frameGraph.engine._debugPushGroup?.(`${this.getClassName()} (${this.name})`, 2);
    for (const pass of passes) {
      pass._execute();
    }
    this._frameGraph.engine._debugPopGroup?.(2);
    this.onAfterTaskExecute.notifyObservers(this);
  }
  /** @internal */
  _initializePasses() {
    this._frameGraph.engine._debugPushGroup?.(`${this.getClassName()} (${this.name})`, 2);
    for (const pass of this._passes) {
      pass._initialize();
    }
    for (const pass of this._passesDisabled) {
      pass._initialize();
    }
    this._frameGraph.engine._debugPopGroup?.(2);
  }
  _checkSameRenderTarget(src, dst) {
    if (src === null || dst === null) {
      return src === dst;
    }
    if (src.length !== dst.length) {
      return false;
    }
    for (let i = 0; i < src.length; i++) {
      if (src[i] !== dst[i]) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/@babylonjs/core/Lights/light.js
var Light = class _Light extends Node {
  /**
   * Defines how far from the source the light is impacting in scene units.
   * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
   */
  get range() {
    return this._range;
  }
  /**
   * Defines how far from the source the light is impacting in scene units.
   * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
   */
  set range(value) {
    this._range = value;
    this._inverseSquaredRange = 1 / (this.range * this.range);
  }
  /**
   * Gets the photometric scale used to interpret the intensity.
   * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
   */
  get intensityMode() {
    return this._intensityMode;
  }
  /**
   * Sets the photometric scale used to interpret the intensity.
   * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
   */
  set intensityMode(value) {
    this._intensityMode = value;
    this._computePhotometricScale();
  }
  /**
   * Gets the light radius used by PBR Materials to simulate soft area lights.
   */
  get radius() {
    return this._radius;
  }
  /**
   * sets the light radius used by PBR Materials to simulate soft area lights.
   */
  set radius(value) {
    this._radius = value;
    this._computePhotometricScale();
  }
  /**
   * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
   * the current shadow generator.
   */
  get shadowEnabled() {
    return this._shadowEnabled;
  }
  /**
   * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
   * the current shadow generator.
   */
  set shadowEnabled(value) {
    if (this._shadowEnabled === value) {
      return;
    }
    this._shadowEnabled = value;
    this._markMeshesAsLightDirty();
  }
  /**
   * Gets the only meshes impacted by this light.
   */
  get includedOnlyMeshes() {
    return this._includedOnlyMeshes;
  }
  /**
   * Sets the only meshes impacted by this light.
   */
  set includedOnlyMeshes(value) {
    this._includedOnlyMeshes = value;
    this._hookArrayForIncludedOnly(value);
  }
  /**
   * Gets the meshes not impacted by this light.
   */
  get excludedMeshes() {
    return this._excludedMeshes;
  }
  /**
   * Sets the meshes not impacted by this light.
   */
  set excludedMeshes(value) {
    this._excludedMeshes = value;
    this._hookArrayForExcluded(value);
  }
  /**
   * Gets the layer id use to find what meshes are not impacted by the light.
   * Inactive if 0
   */
  get excludeWithLayerMask() {
    return this._excludeWithLayerMask;
  }
  /**
   * Sets the layer id use to find what meshes are not impacted by the light.
   * Inactive if 0
   */
  set excludeWithLayerMask(value) {
    this._excludeWithLayerMask = value;
    this._resyncMeshes();
  }
  /**
   * Gets the layer id use to find what meshes are impacted by the light.
   * Inactive if 0
   */
  get includeOnlyWithLayerMask() {
    return this._includeOnlyWithLayerMask;
  }
  /**
   * Sets the layer id use to find what meshes are impacted by the light.
   * Inactive if 0
   */
  set includeOnlyWithLayerMask(value) {
    this._includeOnlyWithLayerMask = value;
    this._resyncMeshes();
  }
  /**
   * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
   */
  get lightmapMode() {
    return this._lightmapMode;
  }
  /**
   * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
   */
  set lightmapMode(value) {
    if (this._lightmapMode === value) {
      return;
    }
    this._lightmapMode = value;
    this._markMeshesAsLightDirty();
  }
  /**
   * Returns the view matrix.
   * @param _faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.
   * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getViewMatrix(_faceIndex) {
    return null;
  }
  /**
   * Returns the projection matrix.
   * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).
   * @param _viewMatrix The view transform matrix of the light (optional).
   * @param _renderList The list of meshes to take into account when calculating the projection matrix (optional).
   * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getProjectionMatrix(_viewMatrix, _renderList) {
    return null;
  }
  /**
   * Creates a Light object in the scene.
   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
   * @param name The friendly name of the light
   * @param scene The scene the light belongs too
   */
  constructor(name, scene) {
    super(name, scene, false);
    this.diffuse = new Color3(1, 1, 1);
    this.specular = new Color3(1, 1, 1);
    this.falloffType = _Light.FALLOFF_DEFAULT;
    this.intensity = 1;
    this._range = Number.MAX_VALUE;
    this._inverseSquaredRange = 0;
    this._photometricScale = 1;
    this._intensityMode = _Light.INTENSITYMODE_AUTOMATIC;
    this._radius = 1e-5;
    this.renderPriority = 0;
    this._shadowEnabled = true;
    this._excludeWithLayerMask = 0;
    this._includeOnlyWithLayerMask = 0;
    this._lightmapMode = 0;
    this._shadowGenerators = null;
    this._excludedMeshesIds = new Array();
    this._includedOnlyMeshesIds = new Array();
    this._currentViewDepth = 0;
    this._isLight = true;
    this.getScene().addLight(this);
    this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), void 0, void 0, name);
    this._buildUniformLayout();
    this.includedOnlyMeshes = [];
    this.excludedMeshes = [];
    this._resyncMeshes();
  }
  /**
   * Sets the passed Effect "effect" with the Light textures.
   * @param effect The effect to update
   * @param lightIndex The index of the light in the effect to update
   * @returns The light
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  transferTexturesToEffect(effect, lightIndex) {
    return this;
  }
  /**
   * Binds the lights information from the scene to the effect for the given mesh.
   * @param lightIndex Light index
   * @param scene The scene where the light belongs to
   * @param effect The effect we are binding the data to
   * @param useSpecular Defines if specular is supported
   * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows
   */
  _bindLight(lightIndex, scene, effect, useSpecular, receiveShadows = true) {
    const iAsString = lightIndex.toString();
    let needUpdate = false;
    this._uniformBuffer.bindToEffect(effect, "Light" + iAsString);
    if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {
      this._renderId = scene.getRenderId();
      this._lastUseSpecular = useSpecular;
      const scaledIntensity = this.getScaledIntensity();
      this.transferToEffect(effect, iAsString);
      this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);
      this._uniformBuffer.updateColor4("vLightDiffuse", TmpColors.Color3[0], this.range, iAsString);
      if (useSpecular) {
        this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);
        this._uniformBuffer.updateColor4("vLightSpecular", TmpColors.Color3[1], this.radius, iAsString);
      }
      needUpdate = true;
    }
    this.transferTexturesToEffect(effect, iAsString);
    if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {
      const shadowGenerator = this.getShadowGenerator(scene.activeCamera) ?? this.getShadowGenerator();
      if (shadowGenerator) {
        shadowGenerator.bindShadowLight(iAsString, effect);
        needUpdate = true;
      }
    }
    if (needUpdate) {
      this._uniformBuffer.update();
    } else {
      this._uniformBuffer.bindUniformBuffer();
    }
  }
  /**
   * Returns the string "Light".
   * @returns the class name
   */
  getClassName() {
    return "Light";
  }
  /**
   * Converts the light information to a readable string for debug purpose.
   * @param fullDetails Supports for multiple levels of logging within scene loading
   * @returns the human readable light info
   */
  toString(fullDetails) {
    let ret = "Name: " + this.name;
    ret += ", type: " + ["Point", "Directional", "Spot", "Hemispheric", "Clustered"][this.getTypeID()];
    if (this.animations) {
      for (let i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    return ret;
  }
  /** @internal */
  _syncParentEnabledState() {
    super._syncParentEnabledState();
    if (!this.isDisposed()) {
      this._resyncMeshes();
    }
  }
  /**
   * Set the enabled state of this node.
   * @param value - the new enabled state
   */
  setEnabled(value) {
    super.setEnabled(value);
    this._resyncMeshes();
  }
  /**
   * Returns the Light associated shadow generator if any.
   * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator
   * @returns the associated shadow generator.
   */
  getShadowGenerator(camera = null) {
    if (this._shadowGenerators === null) {
      return null;
    }
    return this._shadowGenerators.get(camera) ?? null;
  }
  /**
   * Returns all the shadow generators associated to this light
   * @returns
   */
  getShadowGenerators() {
    return this._shadowGenerators;
  }
  /**
   * Returns a Vector3, the absolute light position in the World.
   * @returns the world space position of the light
   */
  getAbsolutePosition() {
    return Vector3.Zero();
  }
  /**
   * Specifies if the light will affect the passed mesh.
   * @param mesh The mesh to test against the light
   * @returns true the mesh is affected otherwise, false.
   */
  canAffectMesh(mesh) {
    if (!mesh) {
      return true;
    }
    if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {
      return false;
    }
    if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {
      return false;
    }
    if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {
      return false;
    }
    if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {
      return false;
    }
    return true;
  }
  /**
   * Releases resources associated with this node.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    if (this._shadowGenerators) {
      const iterator = this._shadowGenerators.values();
      for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
        const shadowGenerator = key.value;
        shadowGenerator.dispose();
      }
      this._shadowGenerators = null;
    }
    this.getScene().stopAnimation(this);
    if (this._parentContainer) {
      const index = this._parentContainer.lights.indexOf(this);
      if (index > -1) {
        this._parentContainer.lights.splice(index, 1);
      }
      this._parentContainer = null;
    }
    for (const mesh of this.getScene().meshes) {
      mesh._removeLightSource(this, true);
    }
    this._uniformBuffer.dispose();
    this.getScene().removeLight(this);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  /**
   * Returns the light type ID (integer).
   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getTypeID() {
    return 0;
  }
  /**
   * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.
   * @returns the scaled intensity in intensity mode unit
   */
  getScaledIntensity() {
    return this._photometricScale * this.intensity;
  }
  /**
   * Returns a new Light object, named "name", from the current one.
   * @param name The name of the cloned light
   * @param newParent The parent of this light, if it has one
   * @returns the new created light
   */
  clone(name, newParent = null) {
    const constructor = _Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());
    if (!constructor) {
      return null;
    }
    const clonedLight = SerializationHelper.Clone(constructor, this);
    if (name) {
      clonedLight.name = name;
    }
    if (newParent) {
      clonedLight.parent = newParent;
    }
    clonedLight.setEnabled(this.isEnabled());
    this.onClonedObservable.notifyObservers(clonedLight);
    return clonedLight;
  }
  /**
   * Serializes the current light into a Serialization object.
   * @returns the serialized object.
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getTypeID();
    if (this.parent) {
      this.parent._serializeAsParent(serializationObject);
    }
    if (this.excludedMeshes.length > 0) {
      serializationObject.excludedMeshesIds = [];
      for (const mesh of this.excludedMeshes) {
        serializationObject.excludedMeshesIds.push(mesh.id);
      }
    }
    if (this.includedOnlyMeshes.length > 0) {
      serializationObject.includedOnlyMeshesIds = [];
      for (const mesh of this.includedOnlyMeshes) {
        serializationObject.includedOnlyMeshesIds.push(mesh.id);
      }
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  }
  /**
   * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.
   * This new light is named "name" and added to the passed scene.
   * @param type Type according to the types available in Light.LIGHTTYPEID_x
   * @param name The friendly name of the light
   * @param scene The scene the new light will belong to
   * @returns the constructor function
   */
  static GetConstructorFromName(type, name, scene) {
    const constructorFunc = Node.Construct("Light_Type_" + type, name, scene);
    if (constructorFunc) {
      return constructorFunc;
    }
    return null;
  }
  /**
   * Parses the passed "parsedLight" and returns a new instanced Light from this parsing.
   * @param parsedLight The JSON representation of the light
   * @param scene The scene to create the parsed light in
   * @returns the created light after parsing
   */
  static Parse(parsedLight, scene) {
    const constructor = _Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);
    if (!constructor) {
      return null;
    }
    const light = SerializationHelper.Parse(constructor, parsedLight, scene);
    if (parsedLight.excludedMeshesIds) {
      light._excludedMeshesIds = parsedLight.excludedMeshesIds;
    }
    if (parsedLight.includedOnlyMeshesIds) {
      light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;
    }
    if (parsedLight.parentId !== void 0) {
      light._waitingParentId = parsedLight.parentId;
    }
    if (parsedLight.parentInstanceIndex !== void 0) {
      light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;
    }
    if (parsedLight.falloffType !== void 0) {
      light.falloffType = parsedLight.falloffType;
    }
    if (parsedLight.lightmapMode !== void 0) {
      light.lightmapMode = parsedLight.lightmapMode;
    }
    if (parsedLight.animations) {
      for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {
        const parsedAnimation = parsedLight.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          light.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(light, parsedLight, scene);
    }
    if (parsedLight.autoAnimate) {
      scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1);
    }
    if (parsedLight.isEnabled !== void 0) {
      light.setEnabled(parsedLight.isEnabled);
    }
    return light;
  }
  _hookArrayForExcluded(array) {
    const oldPush = array.push;
    array.push = (...items) => {
      const result = oldPush.apply(array, items);
      for (const item of items) {
        item._resyncLightSource(this);
      }
      return result;
    };
    const oldSplice = array.splice;
    array.splice = (index, deleteCount) => {
      const deleted = oldSplice.apply(array, [index, deleteCount]);
      for (const item of deleted) {
        item._resyncLightSource(this);
      }
      return deleted;
    };
    for (const item of array) {
      item._resyncLightSource(this);
    }
  }
  _hookArrayForIncludedOnly(array) {
    const oldPush = array.push;
    array.push = (...items) => {
      const result = oldPush.apply(array, items);
      this._resyncMeshes();
      return result;
    };
    const oldSplice = array.splice;
    array.splice = (index, deleteCount) => {
      const deleted = oldSplice.apply(array, [index, deleteCount]);
      this._resyncMeshes();
      return deleted;
    };
    this._resyncMeshes();
  }
  _resyncMeshes() {
    for (const mesh of this.getScene().meshes) {
      mesh._resyncLightSource(this);
    }
  }
  /**
   * Forces the meshes to update their light related information in their rendering used effects
   * @internal Internal Use Only
   */
  _markMeshesAsLightDirty() {
    for (const mesh of this.getScene().meshes) {
      if (mesh.lightSources.indexOf(this) !== -1) {
        mesh._markSubMeshesAsLightDirty();
      }
    }
  }
  /**
   * Recomputes the cached photometric scale if needed.
   */
  _computePhotometricScale() {
    this._photometricScale = this._getPhotometricScale();
    this.getScene().resetCachedMaterial();
  }
  /**
   * @returns the Photometric Scale according to the light type and intensity mode.
   */
  _getPhotometricScale() {
    let photometricScale = 0;
    const lightTypeID = this.getTypeID();
    let photometricMode = this.intensityMode;
    if (photometricMode === _Light.INTENSITYMODE_AUTOMATIC) {
      if (lightTypeID === _Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
        photometricMode = _Light.INTENSITYMODE_ILLUMINANCE;
      } else {
        photometricMode = _Light.INTENSITYMODE_LUMINOUSINTENSITY;
      }
    }
    switch (lightTypeID) {
      case _Light.LIGHTTYPEID_POINTLIGHT:
      case _Light.LIGHTTYPEID_SPOTLIGHT:
        switch (photometricMode) {
          case _Light.INTENSITYMODE_LUMINOUSPOWER:
            photometricScale = 1 / (4 * Math.PI);
            break;
          case _Light.INTENSITYMODE_LUMINOUSINTENSITY:
            photometricScale = 1;
            break;
          case _Light.INTENSITYMODE_LUMINANCE:
            photometricScale = this.radius * this.radius;
            break;
        }
        break;
      case _Light.LIGHTTYPEID_DIRECTIONALLIGHT:
        switch (photometricMode) {
          case _Light.INTENSITYMODE_ILLUMINANCE:
            photometricScale = 1;
            break;
          case _Light.INTENSITYMODE_LUMINANCE: {
            let apexAngleRadians = this.radius;
            apexAngleRadians = Math.max(apexAngleRadians, 1e-3);
            const solidAngle = 2 * Math.PI * (1 - Math.cos(apexAngleRadians));
            photometricScale = solidAngle;
            break;
          }
        }
        break;
      case _Light.LIGHTTYPEID_HEMISPHERICLIGHT:
        photometricScale = 1;
        break;
    }
    return photometricScale;
  }
  /**
   * Reorder the light in the scene according to their defined priority.
   * @internal Internal Use Only
   */
  _reorderLightsInScene() {
    const scene = this.getScene();
    if (this._renderPriority != 0) {
      scene.requireLightSorting = true;
    }
    this.getScene().sortLightsByPriority();
  }
  /**
   * @internal
   */
  _isReady() {
    return true;
  }
};
Light.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;
Light.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;
Light.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;
Light.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;
Light.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;
Light.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;
Light.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;
Light.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;
Light.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;
Light.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;
Light.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;
Light.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;
Light.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;
Light.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;
Light.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;
Light.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;
Light.LIGHTTYPEID_RECT_AREALIGHT = LightConstants.LIGHTTYPEID_RECT_AREALIGHT;
__decorate([
  serializeAsColor3()
], Light.prototype, "diffuse", void 0);
__decorate([
  serializeAsColor3()
], Light.prototype, "specular", void 0);
__decorate([
  serialize()
], Light.prototype, "falloffType", void 0);
__decorate([
  serialize()
], Light.prototype, "intensity", void 0);
__decorate([
  serialize()
], Light.prototype, "range", null);
__decorate([
  serialize()
], Light.prototype, "intensityMode", null);
__decorate([
  serialize()
], Light.prototype, "radius", null);
__decorate([
  serialize()
], Light.prototype, "_renderPriority", void 0);
__decorate([
  expandToProperty("_reorderLightsInScene")
], Light.prototype, "renderPriority", void 0);
__decorate([
  serialize("shadowEnabled")
], Light.prototype, "_shadowEnabled", void 0);
__decorate([
  serialize("excludeWithLayerMask")
], Light.prototype, "_excludeWithLayerMask", void 0);
__decorate([
  serialize("includeOnlyWithLayerMask")
], Light.prototype, "_includeOnlyWithLayerMask", void 0);
__decorate([
  serialize("lightmapMode")
], Light.prototype, "_lightmapMode", void 0);

// node_modules/@babylonjs/core/PostProcesses/thinBlurPostProcess.js
var ThinBlurPostProcess = class _ThinBlurPostProcess extends EffectWrapper {
  _gatherImports(useWebGPU, list) {
    if (useWebGPU) {
      this._webGPUReady = true;
      list.push(Promise.all([import("./kernelBlur.fragment-AO3EZR5M.js"), import("./kernelBlur.vertex-T6M3AJK3.js")]));
    } else {
      list.push(Promise.all([import("./kernelBlur.fragment-XD2HHPHM.js"), import("./kernelBlur.vertex-JXPTWPYG.js")]));
    }
  }
  /**
   * Constructs a new blur post process
   * @param name Name of the effect
   * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
   * @param direction Direction in which to apply the blur
   * @param kernel Kernel size of the blur
   * @param options Options to configure the effect
   */
  constructor(name, engine = null, direction, kernel, options) {
    const blockCompilationFinal = !!options?.blockCompilation;
    super({
      ...options,
      name,
      engine: engine || Engine.LastCreatedEngine,
      useShaderStore: true,
      useAsPostProcess: true,
      fragmentShader: _ThinBlurPostProcess.FragmentUrl,
      uniforms: _ThinBlurPostProcess.Uniforms,
      samplers: _ThinBlurPostProcess.Samplers,
      vertexUrl: _ThinBlurPostProcess.VertexUrl,
      blockCompilation: true
    });
    this._packedFloat = false;
    this._staticDefines = "";
    this.textureWidth = 0;
    this.textureHeight = 0;
    this._staticDefines = options ? Array.isArray(options.defines) ? options.defines.join("\n") : options.defines || "" : "";
    this.options.blockCompilation = blockCompilationFinal;
    if (direction !== void 0) {
      this.direction = direction;
    }
    if (kernel !== void 0) {
      this.kernel = kernel;
    }
  }
  /**
   * Sets the length in pixels of the blur sample region
   */
  set kernel(v) {
    if (this._idealKernel === v) {
      return;
    }
    v = Math.max(v, 1);
    this._idealKernel = v;
    this._kernel = this._nearestBestKernel(v);
    if (!this.options.blockCompilation) {
      this._updateParameters();
    }
  }
  /**
   * Gets the length in pixels of the blur sample region
   */
  get kernel() {
    return this._idealKernel;
  }
  /**
   * Sets whether or not the blur needs to unpack/repack floats
   */
  set packedFloat(v) {
    if (this._packedFloat === v) {
      return;
    }
    this._packedFloat = v;
    if (!this.options.blockCompilation) {
      this._updateParameters();
    }
  }
  /**
   * Gets whether or not the blur is unpacking/repacking floats
   */
  get packedFloat() {
    return this._packedFloat;
  }
  bind(noDefaultBindings = false) {
    super.bind(noDefaultBindings);
    this._drawWrapper.effect.setFloat2("delta", 1 / this.textureWidth * this.direction.x, 1 / this.textureHeight * this.direction.y);
  }
  /** @internal */
  _updateParameters(onCompiled, onError) {
    const n = this._kernel;
    const centerIndex = (n - 1) / 2;
    let offsets = [];
    let weights = [];
    let totalWeight = 0;
    for (let i = 0; i < n; i++) {
      const u = i / (n - 1);
      const w = this._gaussianWeight(u * 2 - 1);
      offsets[i] = i - centerIndex;
      weights[i] = w;
      totalWeight += w;
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] /= totalWeight;
    }
    const linearSamplingWeights = [];
    const linearSamplingOffsets = [];
    const linearSamplingMap = [];
    for (let i = 0; i <= centerIndex; i += 2) {
      const j = Math.min(i + 1, Math.floor(centerIndex));
      const singleCenterSample = i === j;
      if (singleCenterSample) {
        linearSamplingMap.push({ o: offsets[i], w: weights[i] });
      } else {
        const sharedCell = j === centerIndex;
        const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);
        const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);
        if (offsetLinear === 0) {
          linearSamplingMap.push({ o: offsets[i], w: weights[i] });
          linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });
        } else {
          linearSamplingMap.push({ o: offsetLinear, w: weightLinear });
          linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });
        }
      }
    }
    for (let i = 0; i < linearSamplingMap.length; i++) {
      linearSamplingOffsets[i] = linearSamplingMap[i].o;
      linearSamplingWeights[i] = linearSamplingMap[i].w;
    }
    offsets = linearSamplingOffsets;
    weights = linearSamplingWeights;
    const maxVaryingRows = this.options.engine.getCaps().maxVaryingVectors - (this.options.shaderLanguage === 1 ? 1 : 0);
    const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1;
    let varyingCount = Math.min(offsets.length, freeVaryingVec2);
    let defines = "";
    defines += this._staticDefines;
    if (this._staticDefines.indexOf("DOF") != -1) {
      defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}
`;
      varyingCount--;
    }
    for (let i = 0; i < varyingCount; i++) {
      defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}
`;
      defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}
`;
    }
    let depCount = 0;
    for (let i = freeVaryingVec2; i < offsets.length; i++) {
      defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}
`;
      defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}
`;
      depCount++;
    }
    if (this.packedFloat) {
      defines += `#define PACKEDFLOAT 1`;
    }
    this.options.blockCompilation = false;
    this.updateEffect(defines, null, null, {
      varyingCount,
      depCount
    }, onCompiled, onError);
  }
  /**
   * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.
   * Other odd kernels optimize correctly but require proportionally more samples, even kernels are
   * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we
   * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.
   * The gaps between physical kernels are compensated for in the weighting of the samples
   * @param idealKernel Ideal blur kernel.
   * @returns Nearest best kernel.
   */
  _nearestBestKernel(idealKernel) {
    const v = Math.round(idealKernel);
    for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {
      if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {
        return Math.max(k, 3);
      }
    }
    return Math.max(v, 3);
  }
  /**
   * Calculates the value of a Gaussian distribution with sigma 3 at a given point.
   * @param x The point on the Gaussian distribution to sample.
   * @returns the value of the Gaussian function at x.
   */
  _gaussianWeight(x) {
    const sigma = 1 / 3;
    const denominator = Math.sqrt(2 * Math.PI) * sigma;
    const exponent = -(x * x / (2 * sigma * sigma));
    const weight = 1 / denominator * Math.exp(exponent);
    return weight;
  }
  /**
   * Generates a string that can be used as a floating point number in GLSL.
   * @param x Value to print.
   * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).
   * @returns GLSL float string.
   */
  _glslFloat(x, decimalFigures = 8) {
    return x.toFixed(decimalFigures).replace(/0+$/, "");
  }
};
ThinBlurPostProcess.VertexUrl = "kernelBlur";
ThinBlurPostProcess.FragmentUrl = "kernelBlur";
ThinBlurPostProcess.Uniforms = ["delta", "direction"];
ThinBlurPostProcess.Samplers = ["circleOfConfusionSampler"];

// node_modules/@babylonjs/core/PostProcesses/blurPostProcess.js
var BlurPostProcess = class _BlurPostProcess extends PostProcess {
  /** The direction in which to blur the image. */
  get direction() {
    return this._effectWrapper.direction;
  }
  set direction(value) {
    this._effectWrapper.direction = value;
  }
  /**
   * Sets the length in pixels of the blur sample region
   */
  set kernel(v) {
    this._effectWrapper.kernel = v;
  }
  /**
   * Gets the length in pixels of the blur sample region
   */
  get kernel() {
    return this._effectWrapper.kernel;
  }
  /**
   * Sets whether or not the blur needs to unpack/repack floats
   */
  set packedFloat(v) {
    this._effectWrapper.packedFloat = v;
  }
  /**
   * Gets whether or not the blur is unpacking/repacking floats
   */
  get packedFloat() {
    return this._effectWrapper.packedFloat;
  }
  /**
   * Gets a string identifying the name of the class
   * @returns "BlurPostProcess" string
   */
  getClassName() {
    return "BlurPostProcess";
  }
  /**
   * Creates a new instance BlurPostProcess
   * @param name The name of the effect.
   * @param direction The direction in which to blur the image.
   * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.
   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
   * @param camera The camera to apply the render pass to.
   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
   * @param engine The engine which the post process will be applied. (default: current engine)
   * @param reusable If the post process can be reused on the same frame. (default: false)
   * @param textureType Type of textures used when performing the post process. (default: 0)
   * @param defines
   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)
   */
  constructor(name, direction, kernel, options, camera = null, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable, textureType = 0, defines = "", blockCompilation = false, textureFormat = 5) {
    const blockCompilationFinal = typeof options === "number" ? blockCompilation : !!options.blockCompilation;
    const localOptions = {
      uniforms: ThinBlurPostProcess.Uniforms,
      samplers: ThinBlurPostProcess.Samplers,
      size: typeof options === "number" ? options : void 0,
      camera,
      samplingMode,
      engine,
      reusable,
      textureType,
      vertexUrl: ThinBlurPostProcess.VertexUrl,
      indexParameters: { varyingCount: 0, depCount: 0 },
      textureFormat,
      defines,
      ...options,
      blockCompilation: true
    };
    super(name, ThinBlurPostProcess.FragmentUrl, {
      effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinBlurPostProcess(name, engine, void 0, void 0, localOptions) : void 0,
      ...localOptions
    });
    this._effectWrapper.options.blockCompilation = blockCompilationFinal;
    this.direction = direction;
    this.onApplyObservable.add(() => {
      this._effectWrapper.textureWidth = this._outputTexture ? this._outputTexture.width : this.width;
      this._effectWrapper.textureHeight = this._outputTexture ? this._outputTexture.height : this.height;
    });
    this.kernel = kernel;
  }
  updateEffect(_defines = null, _uniforms = null, _samplers = null, _indexParameters, onCompiled, onError) {
    this._effectWrapper._updateParameters(onCompiled, onError);
  }
  /**
   * @internal
   */
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new _BlurPostProcess(parsedPostProcess.name, parsedPostProcess.direction, parsedPostProcess.kernel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, void 0, false);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serializeAsVector2()
], BlurPostProcess.prototype, "direction", null);
__decorate([
  serialize()
], BlurPostProcess.prototype, "kernel", null);
__decorate([
  serialize()
], BlurPostProcess.prototype, "packedFloat", null);
RegisterClass("BABYLON.BlurPostProcess", BlurPostProcess);

// node_modules/@babylonjs/core/Materials/effectFallbacks.js
var EffectFallbacks = class {
  constructor() {
    this._defines = {};
    this._currentRank = 32;
    this._maxRank = -1;
    this._mesh = null;
  }
  /**
   * Removes the fallback from the bound mesh.
   */
  unBindMesh() {
    this._mesh = null;
  }
  /**
   * Adds a fallback on the specified property.
   * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)
   * @param define The name of the define in the shader
   */
  addFallback(rank, define) {
    if (!this._defines[rank]) {
      if (rank < this._currentRank) {
        this._currentRank = rank;
      }
      if (rank > this._maxRank) {
        this._maxRank = rank;
      }
      this._defines[rank] = new Array();
    }
    this._defines[rank].push(define);
  }
  /**
   * Sets the mesh to use CPU skinning when needing to fallback.
   * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)
   * @param mesh The mesh to use the fallbacks.
   */
  addCPUSkinningFallback(rank, mesh) {
    this._mesh = mesh;
    if (rank < this._currentRank) {
      this._currentRank = rank;
    }
    if (rank > this._maxRank) {
      this._maxRank = rank;
    }
  }
  /**
   * Checks to see if more fallbacks are still available.
   */
  get hasMoreFallbacks() {
    return this._currentRank <= this._maxRank;
  }
  /**
   * Removes the defines that should be removed when falling back.
   * @param currentDefines defines the current define statements for the shader.
   * @param effect defines the current effect we try to compile
   * @returns The resulting defines with defines of the current rank removed.
   */
  reduce(currentDefines, effect) {
    if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {
      this._mesh.computeBonesUsingShaders = false;
      currentDefines = currentDefines.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0");
      effect._bonesComputationForcedToCPU = true;
      const scene = this._mesh.getScene();
      for (let index = 0; index < scene.meshes.length; index++) {
        const otherMesh = scene.meshes[index];
        if (!otherMesh.material) {
          if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {
            otherMesh.computeBonesUsingShaders = false;
          }
          continue;
        }
        if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {
          continue;
        }
        if (otherMesh.material.getEffect() === effect) {
          otherMesh.computeBonesUsingShaders = false;
        } else if (otherMesh.subMeshes) {
          for (const subMesh of otherMesh.subMeshes) {
            const subMeshEffect = subMesh.effect;
            if (subMeshEffect === effect) {
              otherMesh.computeBonesUsingShaders = false;
              break;
            }
          }
        }
      }
    } else {
      const currentFallbacks = this._defines[this._currentRank];
      if (currentFallbacks) {
        for (let index = 0; index < currentFallbacks.length; index++) {
          currentDefines = currentDefines.replace("#define " + currentFallbacks[index], "");
        }
      }
      this._currentRank++;
    }
    return currentDefines;
  }
};

// node_modules/@babylonjs/core/Lights/Shadows/shadowGenerator.js
var ShadowGenerator = class _ShadowGenerator {
  /**
   * Gets the bias: offset applied on the depth preventing acnea (in light direction).
   */
  get bias() {
    return this._bias;
  }
  /**
   * Sets the bias: offset applied on the depth preventing acnea (in light direction).
   */
  set bias(bias) {
    this._bias = bias;
  }
  /**
   * Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).
   */
  get normalBias() {
    return this._normalBias;
  }
  /**
   * Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).
   */
  set normalBias(normalBias) {
    this._normalBias = normalBias;
  }
  /**
   * Gets the blur box offset: offset applied during the blur pass.
   * Only useful if useKernelBlur = false
   */
  get blurBoxOffset() {
    return this._blurBoxOffset;
  }
  /**
   * Sets the blur box offset: offset applied during the blur pass.
   * Only useful if useKernelBlur = false
   */
  set blurBoxOffset(value) {
    if (this._blurBoxOffset === value) {
      return;
    }
    this._blurBoxOffset = value;
    this._disposeBlurPostProcesses();
  }
  /**
   * Gets the blur scale: scale of the blurred texture compared to the main shadow map.
   * 2 means half of the size.
   */
  get blurScale() {
    return this._blurScale;
  }
  /**
   * Sets the blur scale: scale of the blurred texture compared to the main shadow map.
   * 2 means half of the size.
   */
  set blurScale(value) {
    if (this._blurScale === value) {
      return;
    }
    this._blurScale = value;
    this._disposeBlurPostProcesses();
  }
  /**
   * Gets the blur kernel: kernel size of the blur pass.
   * Only useful if useKernelBlur = true
   */
  get blurKernel() {
    return this._blurKernel;
  }
  /**
   * Sets the blur kernel: kernel size of the blur pass.
   * Only useful if useKernelBlur = true
   */
  set blurKernel(value) {
    if (this._blurKernel === value) {
      return;
    }
    this._blurKernel = value;
    this._disposeBlurPostProcesses();
  }
  /**
   * Gets whether the blur pass is a kernel blur (if true) or box blur.
   * Only useful in filtered mode (useBlurExponentialShadowMap...)
   */
  get useKernelBlur() {
    return this._useKernelBlur;
  }
  /**
   * Sets whether the blur pass is a kernel blur (if true) or box blur.
   * Only useful in filtered mode (useBlurExponentialShadowMap...)
   */
  set useKernelBlur(value) {
    if (this._useKernelBlur === value) {
      return;
    }
    this._useKernelBlur = value;
    this._disposeBlurPostProcesses();
  }
  /**
   * Gets the depth scale used in ESM mode.
   */
  get depthScale() {
    return this._depthScale !== void 0 ? this._depthScale : this._light.getDepthScale();
  }
  /**
   * Sets the depth scale used in ESM mode.
   * This can override the scale stored on the light.
   */
  set depthScale(value) {
    this._depthScale = value;
  }
  _validateFilter(filter) {
    return filter;
  }
  /**
   * Gets the current mode of the shadow generator (normal, PCF, ESM...).
   * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
   */
  get filter() {
    return this._filter;
  }
  /**
   * Sets the current mode of the shadow generator (normal, PCF, ESM...).
   * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
   */
  set filter(value) {
    value = this._validateFilter(value);
    if (this._light.needCube()) {
      if (value === _ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {
        this.useExponentialShadowMap = true;
        return;
      } else if (value === _ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
        this.useCloseExponentialShadowMap = true;
        return;
      } else if (value === _ShadowGenerator.FILTER_PCF || value === _ShadowGenerator.FILTER_PCSS) {
        this.usePoissonSampling = true;
        return;
      }
    }
    if (value === _ShadowGenerator.FILTER_PCF || value === _ShadowGenerator.FILTER_PCSS) {
      if (!this._scene.getEngine()._features.supportShadowSamplers) {
        this.usePoissonSampling = true;
        return;
      }
    }
    if (this._filter === value) {
      return;
    }
    this._filter = value;
    this._disposeBlurPostProcesses();
    this._applyFilterValues();
    this._light._markMeshesAsLightDirty();
  }
  /**
   * Gets if the current filter is set to Poisson Sampling.
   */
  get usePoissonSampling() {
    return this.filter === _ShadowGenerator.FILTER_POISSONSAMPLING;
  }
  /**
   * Sets the current filter to Poisson Sampling.
   */
  set usePoissonSampling(value) {
    const filter = this._validateFilter(_ShadowGenerator.FILTER_POISSONSAMPLING);
    if (!value && this.filter !== _ShadowGenerator.FILTER_POISSONSAMPLING) {
      return;
    }
    this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets if the current filter is set to ESM.
   */
  get useExponentialShadowMap() {
    return this.filter === _ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP;
  }
  /**
   * Sets the current filter is to ESM.
   */
  set useExponentialShadowMap(value) {
    const filter = this._validateFilter(_ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP);
    if (!value && this.filter !== _ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP) {
      return;
    }
    this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets if the current filter is set to filtered ESM.
   */
  get useBlurExponentialShadowMap() {
    return this.filter === _ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP;
  }
  /**
   * Gets if the current filter is set to filtered  ESM.
   */
  set useBlurExponentialShadowMap(value) {
    const filter = this._validateFilter(_ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP);
    if (!value && this.filter !== _ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {
      return;
    }
    this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets if the current filter is set to "close ESM" (using the inverse of the
   * exponential to prevent steep falloff artifacts).
   */
  get useCloseExponentialShadowMap() {
    return this.filter === _ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP;
  }
  /**
   * Sets the current filter to "close ESM" (using the inverse of the
   * exponential to prevent steep falloff artifacts).
   */
  set useCloseExponentialShadowMap(value) {
    const filter = this._validateFilter(_ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP);
    if (!value && this.filter !== _ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP) {
      return;
    }
    this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets if the current filter is set to filtered "close ESM" (using the inverse of the
   * exponential to prevent steep falloff artifacts).
   */
  get useBlurCloseExponentialShadowMap() {
    return this.filter === _ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;
  }
  /**
   * Sets the current filter to filtered "close ESM" (using the inverse of the
   * exponential to prevent steep falloff artifacts).
   */
  set useBlurCloseExponentialShadowMap(value) {
    const filter = this._validateFilter(_ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);
    if (!value && this.filter !== _ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
      return;
    }
    this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets if the current filter is set to "PCF" (percentage closer filtering).
   */
  get usePercentageCloserFiltering() {
    return this.filter === _ShadowGenerator.FILTER_PCF;
  }
  /**
   * Sets the current filter to "PCF" (percentage closer filtering).
   */
  set usePercentageCloserFiltering(value) {
    const filter = this._validateFilter(_ShadowGenerator.FILTER_PCF);
    if (!value && this.filter !== _ShadowGenerator.FILTER_PCF) {
      return;
    }
    this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets the PCF or PCSS Quality.
   * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
   */
  get filteringQuality() {
    return this._filteringQuality;
  }
  /**
   * Sets the PCF or PCSS Quality.
   * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
   */
  set filteringQuality(filteringQuality) {
    if (this._filteringQuality === filteringQuality) {
      return;
    }
    this._filteringQuality = filteringQuality;
    this._disposeBlurPostProcesses();
    this._applyFilterValues();
    this._light._markMeshesAsLightDirty();
  }
  /**
   * Gets if the current filter is set to "PCSS" (contact hardening).
   */
  get useContactHardeningShadow() {
    return this.filter === _ShadowGenerator.FILTER_PCSS;
  }
  /**
   * Sets the current filter to "PCSS" (contact hardening).
   */
  set useContactHardeningShadow(value) {
    const filter = this._validateFilter(_ShadowGenerator.FILTER_PCSS);
    if (!value && this.filter !== _ShadowGenerator.FILTER_PCSS) {
      return;
    }
    this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
   * Using a ratio helps keeping shape stability independently of the map size.
   *
   * It does not account for the light projection as it was having too much
   * instability during the light setup or during light position changes.
   *
   * Only valid if useContactHardeningShadow is true.
   */
  get contactHardeningLightSizeUVRatio() {
    return this._contactHardeningLightSizeUVRatio;
  }
  /**
   * Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
   * Using a ratio helps keeping shape stability independently of the map size.
   *
   * It does not account for the light projection as it was having too much
   * instability during the light setup or during light position changes.
   *
   * Only valid if useContactHardeningShadow is true.
   */
  set contactHardeningLightSizeUVRatio(contactHardeningLightSizeUVRatio) {
    this._contactHardeningLightSizeUVRatio = contactHardeningLightSizeUVRatio;
  }
  /** Gets or sets the actual darkness of a shadow */
  get darkness() {
    return this._darkness;
  }
  set darkness(value) {
    this.setDarkness(value);
  }
  /**
   * Returns the darkness value (float). This can only decrease the actual darkness of a shadow.
   * 0 means strongest and 1 would means no shadow.
   * @returns the darkness.
   */
  getDarkness() {
    return this._darkness;
  }
  /**
   * Sets the darkness value (float). This can only decrease the actual darkness of a shadow.
   * @param darkness The darkness value 0 means strongest and 1 would means no shadow.
   * @returns the shadow generator allowing fluent coding.
   */
  setDarkness(darkness) {
    if (darkness >= 1) {
      this._darkness = 1;
    } else if (darkness <= 0) {
      this._darkness = 0;
    } else {
      this._darkness = darkness;
    }
    return this;
  }
  /** Gets or sets the ability to have transparent shadow */
  get transparencyShadow() {
    return this._transparencyShadow;
  }
  set transparencyShadow(value) {
    this.setTransparencyShadow(value);
  }
  /**
   * Sets the ability to have transparent shadow (boolean).
   * @param transparent True if transparent else False
   * @returns the shadow generator allowing fluent coding
   */
  setTransparencyShadow(transparent) {
    this._transparencyShadow = transparent;
    return this;
  }
  /**
   * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
   * @returns The render target texture if present otherwise, null
   */
  getShadowMap() {
    return this._shadowMap;
  }
  /**
   * Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
   * @returns The render target texture if the shadow map is present otherwise, null
   */
  getShadowMapForRendering() {
    if (this._shadowMap2) {
      return this._shadowMap2;
    }
    return this._shadowMap;
  }
  /**
   * Gets the class name of that object
   * @returns "ShadowGenerator"
   */
  getClassName() {
    return _ShadowGenerator.CLASSNAME;
  }
  /**
   * Helper function to add a mesh and its descendants to the list of shadow casters.
   * @param mesh Mesh to add
   * @param includeDescendants boolean indicating if the descendants should be added. Default to true
   * @returns the Shadow Generator itself
   */
  addShadowCaster(mesh, includeDescendants = true) {
    if (!this._shadowMap) {
      return this;
    }
    if (!this._shadowMap.renderList) {
      this._shadowMap.renderList = [];
    }
    if (this._shadowMap.renderList.indexOf(mesh) === -1) {
      this._shadowMap.renderList.push(mesh);
    }
    if (includeDescendants) {
      for (const childMesh of mesh.getChildMeshes()) {
        if (this._shadowMap.renderList.indexOf(childMesh) === -1) {
          this._shadowMap.renderList.push(childMesh);
        }
      }
    }
    return this;
  }
  /**
   * Helper function to remove a mesh and its descendants from the list of shadow casters
   * @param mesh Mesh to remove
   * @param includeDescendants boolean indicating if the descendants should be removed. Default to true
   * @returns the Shadow Generator itself
   */
  removeShadowCaster(mesh, includeDescendants = true) {
    if (!this._shadowMap || !this._shadowMap.renderList) {
      return this;
    }
    const index = this._shadowMap.renderList.indexOf(mesh);
    if (index !== -1) {
      this._shadowMap.renderList.splice(index, 1);
    }
    if (includeDescendants) {
      for (const child of mesh.getChildren()) {
        this.removeShadowCaster(child);
      }
    }
    return this;
  }
  /**
   * Returns the associated light object.
   * @returns the light generating the shadow
   */
  getLight() {
    return this._light;
  }
  /**
   * Gets the shader language used in this generator.
   */
  get shaderLanguage() {
    return this._shaderLanguage;
  }
  _getCamera() {
    return this._camera ?? this._scene.activeCamera;
  }
  /**
   * Gets or sets the size of the texture what stores the shadows
   */
  get mapSize() {
    return this._mapSize;
  }
  set mapSize(size) {
    this._mapSize = size;
    this._light._markMeshesAsLightDirty();
    this.recreateShadowMap();
  }
  /**
   * Creates a ShadowGenerator object.
   * A ShadowGenerator is the required tool to use the shadows.
   * Each light casting shadows needs to use its own ShadowGenerator.
   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows
   * @param mapSize The size of the texture what stores the shadows. Example : 1024.
   * @param light The light object generating the shadows.
   * @param usefullFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
   * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it
   * @param useRedTextureType Forces the generator to use a Red instead of a RGBA type for the shadow map texture format (default: false)
   * @param forceGLSL defines a boolean indicating if the shader must be compiled in GLSL even if we are using WebGPU
   */
  constructor(mapSize, light, usefullFloatFirst, camera, useRedTextureType, forceGLSL = false) {
    this.onBeforeShadowMapRenderObservable = new Observable();
    this.onAfterShadowMapRenderObservable = new Observable();
    this.onBeforeShadowMapRenderMeshObservable = new Observable();
    this.onAfterShadowMapRenderMeshObservable = new Observable();
    this.doNotSerialize = false;
    this._bias = 5e-5;
    this._normalBias = 0;
    this._blurBoxOffset = 1;
    this._blurScale = 2;
    this._blurKernel = 1;
    this._useKernelBlur = false;
    this._filter = _ShadowGenerator.FILTER_NONE;
    this._filteringQuality = _ShadowGenerator.QUALITY_HIGH;
    this._contactHardeningLightSizeUVRatio = 0.1;
    this._darkness = 0;
    this._transparencyShadow = false;
    this.enableSoftTransparentShadow = false;
    this.useOpacityTextureForTransparentShadow = false;
    this.frustumEdgeFalloff = 0;
    this._shaderLanguage = 0;
    this.forceBackFacesOnly = false;
    this._lightDirection = Vector3.Zero();
    this._viewMatrix = Matrix.Zero();
    this._projectionMatrix = Matrix.Zero();
    this._transformMatrix = Matrix.Zero();
    this._cachedPosition = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cachedDirection = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._currentFaceIndex = 0;
    this._currentFaceIndexCache = 0;
    this._defaultTextureMatrix = Matrix.Identity();
    this._shadersLoaded = false;
    this._mapSize = mapSize;
    this._light = light;
    this._scene = light.getScene();
    this._camera = camera ?? null;
    this._useRedTextureType = !!useRedTextureType;
    this._initShaderSourceAsync(forceGLSL);
    let shadowGenerators = light._shadowGenerators;
    if (!shadowGenerators) {
      shadowGenerators = light._shadowGenerators = /* @__PURE__ */ new Map();
    }
    shadowGenerators.set(this._camera, this);
    this.id = light.id;
    this._useUBO = this._scene.getEngine().supportsUniformBuffers;
    if (this._useUBO) {
      this._sceneUBOs = [];
      this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light "${this._light.name}")`));
    }
    _ShadowGenerator._SceneComponentInitialization(this._scene);
    const caps = this._scene.getEngine().getCaps();
    if (!usefullFloatFirst) {
      if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
        this._textureType = 2;
      } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
        this._textureType = 1;
      } else {
        this._textureType = 0;
      }
    } else {
      if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
        this._textureType = 1;
      } else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
        this._textureType = 2;
      } else {
        this._textureType = 0;
      }
    }
    this._initializeGenerator();
    this._applyFilterValues();
  }
  _initializeGenerator() {
    this._light._markMeshesAsLightDirty();
    this._initializeShadowMap();
  }
  _createTargetRenderTexture() {
    const engine = this._scene.getEngine();
    this._shadowMap?.dispose();
    if (engine._features.supportDepthStencilTexture) {
      this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube(), void 0, false, false, void 0, this._useRedTextureType ? 6 : 5);
      this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true, void 0, void 0, void 0, `DepthStencilForShadowGenerator-${this._light.name}`);
    } else {
      this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube());
    }
    this._shadowMap.noPrePassRenderer = true;
  }
  _initializeShadowMap() {
    this._createTargetRenderTexture();
    if (this._shadowMap === null) {
      return;
    }
    this._shadowMap.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._shadowMap.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._shadowMap.anisotropicFilteringLevel = 1;
    this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    this._shadowMap.renderParticles = false;
    this._shadowMap.ignoreCameraViewport = true;
    if (this._storedUniqueId) {
      this._shadowMap.uniqueId = this._storedUniqueId;
    }
    this._shadowMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => this._renderForShadowMap(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes);
    this._shadowMap.customIsReadyFunction = (mesh, _refreshRate, preWarm) => {
      if (!preWarm || !mesh.subMeshes) {
        return true;
      }
      let isReady = true;
      for (const subMesh of mesh.subMeshes) {
        const renderingMesh = subMesh.getRenderingMesh();
        const scene = this._scene;
        const engine2 = scene.getEngine();
        const material = subMesh.getMaterial();
        if (!material || subMesh.verticesCount === 0 || this.customAllowRendering && !this.customAllowRendering(subMesh)) {
          continue;
        }
        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
        if (batch.mustReturn) {
          continue;
        }
        const hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
        const isTransparent = material.needAlphaBlendingForMesh(renderingMesh);
        isReady = this.isReady(subMesh, hardwareInstancedRendering, isTransparent) && isReady;
      }
      return isReady;
    };
    const engine = this._scene.getEngine();
    this._shadowMap.onBeforeBindObservable.add(() => {
      this._currentSceneUBO = this._scene.getSceneUniformBuffer();
      engine._debugPushGroup?.(`shadow map generation for pass id ${engine.currentRenderPassId}`, 1);
    });
    this._shadowMap.onBeforeRenderObservable.add((faceIndex) => {
      if (this._sceneUBOs) {
        this._scene.setSceneUniformBuffer(this._sceneUBOs[0]);
      }
      this._currentFaceIndex = faceIndex;
      if (this._filter === _ShadowGenerator.FILTER_PCF) {
        engine.setColorWrite(false);
      }
      this.getTransformMatrix();
      FloatingOriginCurrentScene.eyeAtCamera = false;
      this._scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);
      if (this._useUBO) {
        this._scene.getSceneUniformBuffer().unbindEffect();
        this._scene.finalizeSceneUbo();
      }
    });
    this._shadowMap.onAfterUnbindObservable.add(() => {
      if (this._sceneUBOs) {
        this._scene.setSceneUniformBuffer(this._currentSceneUBO);
      }
      FloatingOriginCurrentScene.eyeAtCamera = true;
      this._scene.updateTransformMatrix();
      if (this._filter === _ShadowGenerator.FILTER_PCF) {
        engine.setColorWrite(true);
      }
      if (!this.useBlurExponentialShadowMap && !this.useBlurCloseExponentialShadowMap) {
        engine._debugPopGroup?.(1);
        return;
      }
      const shadowMap = this.getShadowMapForRendering();
      if (shadowMap) {
        this._scene.postProcessManager.directRender(this._blurPostProcesses, shadowMap.renderTarget, true);
        engine.unBindFramebuffer(shadowMap.renderTarget, true);
      }
      engine._debugPopGroup?.(1);
    });
    const clearZero = new Color4(0, 0, 0, 0);
    const clearOne = new Color4(1, 1, 1, 1);
    this._shadowMap.onClearObservable.add((engine2) => {
      if (this._filter === _ShadowGenerator.FILTER_PCF) {
        engine2.clear(clearOne, false, true, false);
      } else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
        engine2.clear(clearZero, true, true, false);
      } else {
        engine2.clear(clearOne, true, true, false);
      }
    });
    this._shadowMap.onResizeObservable.add((rtt) => {
      this._storedUniqueId = this._shadowMap.uniqueId;
      this._mapSize = rtt.getRenderSize();
      this._light._markMeshesAsLightDirty();
      this.recreateShadowMap();
    });
    for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {
      this._shadowMap.setRenderingAutoClearDepthStencil(i, false);
    }
  }
  async _initShaderSourceAsync(forceGLSL = false) {
    const engine = this._scene.getEngine();
    if (engine.isWebGPU && !forceGLSL && !_ShadowGenerator.ForceGLSL) {
      this._shaderLanguage = 1;
      await Promise.all([
        import("./shadowMap.fragment-2JZKYSLB.js"),
        import("./shadowMap.vertex-MSL5TE5H.js"),
        import("./depthBoxBlur.fragment-WYCRAQME.js"),
        import("./shadowMapFragmentSoftTransparentShadow-BRKVDIUB.js")
      ]);
    } else {
      await Promise.all([
        import("./shadowMap.fragment-HPENC2FJ.js"),
        import("./shadowMap.vertex-FUPPXMYI.js"),
        import("./depthBoxBlur.fragment-NJHNYQCD.js"),
        import("./shadowMapFragmentSoftTransparentShadow-NIZQJEPN.js")
      ]);
    }
    this._shadersLoaded = true;
  }
  _initializeBlurRTTAndPostProcesses() {
    const engine = this._scene.getEngine();
    const targetSize = this._mapSize / this.blurScale;
    if (!this.useKernelBlur || this.blurScale !== 1) {
      this._shadowMap2 = new RenderTargetTexture(this._light.name + "_shadowMap2", targetSize, this._scene, false, true, this._textureType, void 0, void 0, false);
      this._shadowMap2.wrapU = Texture.CLAMP_ADDRESSMODE;
      this._shadowMap2.wrapV = Texture.CLAMP_ADDRESSMODE;
      this._shadowMap2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    }
    if (this.useKernelBlur) {
      this._kernelBlurXPostprocess = new BlurPostProcess(this._light.name + "KernelBlurX", new Vector2(1, 0), this.blurKernel, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
      this._kernelBlurXPostprocess.width = targetSize;
      this._kernelBlurXPostprocess.height = targetSize;
      this._kernelBlurXPostprocess.externalTextureSamplerBinding = true;
      this._kernelBlurXPostprocess.onApplyObservable.add((effect) => {
        effect.setTexture("textureSampler", this._shadowMap);
      });
      this._kernelBlurYPostprocess = new BlurPostProcess(this._light.name + "KernelBlurY", new Vector2(0, 1), this.blurKernel, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
      this._kernelBlurXPostprocess.autoClear = false;
      this._kernelBlurYPostprocess.autoClear = false;
      if (this._textureType === 0) {
        this._kernelBlurXPostprocess.packedFloat = true;
        this._kernelBlurYPostprocess.packedFloat = true;
      }
      this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess];
    } else {
      this._boxBlurPostprocess = new PostProcess(this._light.name + "DepthBoxBlur", "depthBoxBlur", ["screenSize", "boxOffset"], [], 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, "#define OFFSET " + this._blurBoxOffset, this._textureType, void 0, void 0, void 0, void 0, this._shaderLanguage);
      this._boxBlurPostprocess.externalTextureSamplerBinding = true;
      this._boxBlurPostprocess.onApplyObservable.add((effect) => {
        effect.setFloat2("screenSize", targetSize, targetSize);
        effect.setTexture("textureSampler", this._shadowMap);
      });
      this._boxBlurPostprocess.autoClear = false;
      this._blurPostProcesses = [this._boxBlurPostprocess];
    }
  }
  _renderForShadowMap(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
    let index;
    if (depthOnlySubMeshes.length) {
      for (index = 0; index < depthOnlySubMeshes.length; index++) {
        this._renderSubMeshForShadowMap(depthOnlySubMeshes.data[index]);
      }
    }
    for (index = 0; index < opaqueSubMeshes.length; index++) {
      this._renderSubMeshForShadowMap(opaqueSubMeshes.data[index]);
    }
    for (index = 0; index < alphaTestSubMeshes.length; index++) {
      this._renderSubMeshForShadowMap(alphaTestSubMeshes.data[index]);
    }
    if (this._transparencyShadow) {
      for (index = 0; index < transparentSubMeshes.length; index++) {
        this._renderSubMeshForShadowMap(transparentSubMeshes.data[index], true);
      }
    } else {
      for (index = 0; index < transparentSubMeshes.length; index++) {
        transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;
      }
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, mesh) {
    effect.setMatrix("viewProjection", this.getTransformMatrix());
  }
  _renderSubMeshForShadowMap(subMesh, isTransparent = false) {
    const renderingMesh = subMesh.getRenderingMesh();
    const effectiveMesh = subMesh.getEffectiveMesh();
    const scene = this._scene;
    const engine = scene.getEngine();
    const material = subMesh.getMaterial();
    effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
    if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {
      return;
    }
    const useRHS = scene.useRightHandedSystem;
    const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;
    let sideOrientation = material._getEffectiveOrientation(renderingMesh);
    if (detNeg && !useRHS || !detNeg && useRHS) {
      sideOrientation = sideOrientation === 0 ? 1 : 0;
    }
    const reverseSideOrientation = sideOrientation === 0;
    engine.setState(material.backFaceCulling, void 0, void 0, reverseSideOrientation, material.cullBackFaces);
    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
    if (batch.mustReturn) {
      return;
    }
    const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
    if (this.customAllowRendering && !this.customAllowRendering(subMesh)) {
      return;
    }
    if (this.isReady(subMesh, hardwareInstancedRendering, isTransparent)) {
      subMesh._renderId = scene.getRenderId();
      const shadowDepthWrapper = material.shadowDepthWrapper;
      const drawWrapper = shadowDepthWrapper?.getEffect(subMesh, this, engine.currentRenderPassId) ?? subMesh._getDrawWrapper();
      const effect = DrawWrapper.GetEffect(drawWrapper);
      engine.enableEffect(drawWrapper);
      if (!hardwareInstancedRendering) {
        renderingMesh._bind(subMesh, effect, material.fillMode);
      }
      this.getTransformMatrix();
      effect.setFloat3("biasAndScaleSM", this.bias, this.normalBias, this.depthScale);
      if (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
        effect.setVector3("lightDataSM", this._cachedDirection);
      } else {
        effect.setVector3("lightDataSM", this._cachedPosition.subtractToRef(this._scene.floatingOriginOffset, TmpVectors.Vector3[0]));
      }
      const camera = this._getCamera();
      effect.setFloat2("depthValuesSM", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera));
      if (isTransparent && this.enableSoftTransparentShadow) {
        effect.setFloat2("softTransparentShadowSM", effectiveMesh.visibility * material.alpha, this._opacityTexture?.getAlphaFromRGB ? 1 : 0);
      }
      if (shadowDepthWrapper) {
        subMesh._setMainDrawWrapperOverride(drawWrapper);
        if (shadowDepthWrapper.standalone) {
          shadowDepthWrapper.baseMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
        } else {
          material.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
        }
        subMesh._setMainDrawWrapperOverride(null);
      } else {
        if (this._opacityTexture) {
          effect.setTexture("diffuseSampler", this._opacityTexture);
          effect.setMatrix("diffuseMatrix", this._opacityTexture.getTextureMatrix() || this._defaultTextureMatrix);
        }
        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
          const skeleton = renderingMesh.skeleton;
          if (skeleton.isUsingTextureForMatrices) {
            const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);
            if (!boneTexture) {
              return;
            }
            effect.setTexture("boneSampler", boneTexture);
            effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
          } else {
            effect.setMatrices("mBones", skeleton.getTransformMatrices(renderingMesh));
          }
        }
        BindMorphTargetParameters(renderingMesh, effect);
        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
          renderingMesh.morphTargetManager._bind(effect);
        }
        const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;
        if (bvaManager && bvaManager.isEnabled) {
          bvaManager.bind(effect, hardwareInstancedRendering);
        }
        BindClipPlane(effect, material, scene);
      }
      if (!this._useUBO && !shadowDepthWrapper) {
        this._bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, effectiveMesh);
      }
      BindSceneUniformBuffer(effect, this._scene.getSceneUniformBuffer());
      this._scene.getSceneUniformBuffer().bindUniformBuffer();
      const world = effectiveMesh.getWorldMatrix();
      if (hardwareInstancedRendering) {
        effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
        effectiveMesh.transferToEffect(world);
      }
      if (this.forceBackFacesOnly) {
        engine.setState(true, 0, false, true, material.cullBackFaces);
      }
      this.onBeforeShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
      this.onBeforeShadowMapRenderObservable.notifyObservers(effect);
      renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, worldOverride) => {
        if (effectiveMesh !== renderingMesh && !isInstance) {
          renderingMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
          renderingMesh.transferToEffect(worldOverride);
        } else {
          effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
          effectiveMesh.transferToEffect(isInstance ? worldOverride : world);
        }
      });
      if (this.forceBackFacesOnly) {
        engine.setState(true, 0, false, false, material.cullBackFaces);
      }
      this.onAfterShadowMapRenderObservable.notifyObservers(effect);
      this.onAfterShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
    } else {
      if (this._shadowMap) {
        this._shadowMap.resetRefreshCounter();
      }
    }
  }
  _applyFilterValues() {
    if (!this._shadowMap) {
      return;
    }
    if (this.filter === _ShadowGenerator.FILTER_NONE || this.filter === _ShadowGenerator.FILTER_PCSS) {
      this._shadowMap.updateSamplingMode(Texture.NEAREST_SAMPLINGMODE);
    } else {
      this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    }
  }
  /**
   * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.
   * @param onCompiled Callback triggered at the and of the effects compilation
   * @param options Sets of optional options forcing the compilation with different modes
   */
  forceCompilation(onCompiled, options) {
    const localOptions = {
      useInstances: false,
      ...options
    };
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    const renderList = shadowMap.renderList;
    if (!renderList) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    const subMeshes = [];
    for (const mesh of renderList) {
      subMeshes.push(...mesh.subMeshes);
    }
    if (subMeshes.length === 0) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    let currentIndex = 0;
    const checkReady = () => {
      if (!this._scene || !this._scene.getEngine()) {
        return;
      }
      while (this.isReady(subMeshes[currentIndex], localOptions.useInstances, subMeshes[currentIndex].getMaterial()?.needAlphaBlendingForMesh(subMeshes[currentIndex].getMesh()) ?? false)) {
        currentIndex++;
        if (currentIndex >= subMeshes.length) {
          if (onCompiled) {
            onCompiled(this);
          }
          return;
        }
      }
      setTimeout(checkReady, 16);
    };
    checkReady();
  }
  /**
   * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.
   * @param options Sets of optional options forcing the compilation with different modes
   * @returns A promise that resolves when the compilation completes
   */
  async forceCompilationAsync(options) {
    return await new Promise((resolve) => {
      this.forceCompilation(() => {
        resolve();
      }, options);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _isReadyCustomDefines(defines, subMesh, useInstances) {
  }
  _prepareShadowDefines(subMesh, useInstances, defines, isTransparent) {
    defines.push("#define SM_LIGHTTYPE_" + this._light.getClassName().toUpperCase());
    defines.push("#define SM_FLOAT " + (this._textureType !== 0 ? "1" : "0"));
    defines.push("#define SM_ESM " + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? "1" : "0"));
    defines.push("#define SM_DEPTHTEXTURE " + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? "1" : "0"));
    const mesh = subMesh.getMesh();
    defines.push("#define SM_NORMALBIAS " + (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind) ? "1" : "0"));
    defines.push("#define SM_DIRECTIONINLIGHTDATA " + (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT ? "1" : "0"));
    defines.push("#define SM_USEDISTANCE " + (this._light.needCube() ? "1" : "0"));
    defines.push("#define SM_SOFTTRANSPARENTSHADOW " + (this.enableSoftTransparentShadow && isTransparent ? "1" : "0"));
    this._isReadyCustomDefines(defines, subMesh, useInstances);
    return defines;
  }
  /**
   * Determine whether the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
   * @param subMesh The submesh we want to render in the shadow map
   * @param useInstances Defines whether will draw in the map using instances
   * @param isTransparent Indicates that isReady is called for a transparent subMesh
   * @returns true if ready otherwise, false
   */
  isReady(subMesh, useInstances, isTransparent) {
    if (!this._shadersLoaded) {
      return false;
    }
    const material = subMesh.getMaterial(), shadowDepthWrapper = material?.shadowDepthWrapper;
    this._opacityTexture = null;
    if (!material) {
      return false;
    }
    const defines = [];
    this._prepareShadowDefines(subMesh, useInstances, defines, isTransparent);
    if (shadowDepthWrapper) {
      if (!shadowDepthWrapper.isReadyForSubMesh(subMesh, defines, this, useInstances, this._scene.getEngine().currentRenderPassId)) {
        return false;
      }
    } else {
      const subMeshEffect = subMesh._getDrawWrapper(void 0, true);
      let effect = subMeshEffect.effect;
      let cachedDefines = subMeshEffect.defines;
      const attribs = [VertexBuffer.PositionKind];
      const mesh = subMesh.getMesh();
      let useNormal = false;
      let uv1 = false;
      let uv2 = false;
      const color = false;
      if (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
        attribs.push(VertexBuffer.NormalKind);
        defines.push("#define NORMAL");
        useNormal = true;
        if (mesh.nonUniformScaling) {
          defines.push("#define NONUNIFORMSCALING");
        }
      }
      const needAlphaTesting = material.needAlphaTestingForMesh(mesh);
      if (needAlphaTesting || material.needAlphaBlendingForMesh(mesh)) {
        if (this.useOpacityTextureForTransparentShadow) {
          this._opacityTexture = material.opacityTexture;
        } else {
          this._opacityTexture = material.getAlphaTestTexture();
        }
        if (this._opacityTexture) {
          if (!this._opacityTexture.isReady()) {
            return false;
          }
          const alphaCutOff = material.alphaCutOff ?? _ShadowGenerator.DEFAULT_ALPHA_CUTOFF;
          defines.push("#define ALPHATEXTURE");
          if (needAlphaTesting) {
            defines.push(`#define ALPHATESTVALUE ${alphaCutOff}${alphaCutOff % 1 === 0 ? "." : ""}`);
          }
          if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
            attribs.push(VertexBuffer.UVKind);
            defines.push("#define UV1");
            uv1 = true;
          }
          if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
            if (this._opacityTexture.coordinatesIndex === 1) {
              attribs.push(VertexBuffer.UV2Kind);
              defines.push("#define UV2");
              uv2 = true;
            }
          }
        }
      }
      const fallbacks = new EffectFallbacks();
      if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
        attribs.push(VertexBuffer.MatricesIndicesKind);
        attribs.push(VertexBuffer.MatricesWeightsKind);
        if (mesh.numBoneInfluencers > 4) {
          attribs.push(VertexBuffer.MatricesIndicesExtraKind);
          attribs.push(VertexBuffer.MatricesWeightsExtraKind);
        }
        const skeleton = mesh.skeleton;
        defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
        if (mesh.numBoneInfluencers > 0) {
          fallbacks.addCPUSkinningFallback(0, mesh);
        }
        if (skeleton.isUsingTextureForMatrices) {
          defines.push("#define BONETEXTURE");
        } else {
          defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
        }
      } else {
        defines.push("#define NUM_BONE_INFLUENCERS 0");
      }
      const numMorphInfluencers = mesh.morphTargetManager ? PrepareDefinesAndAttributesForMorphTargets(
        mesh.morphTargetManager,
        defines,
        attribs,
        mesh,
        true,
        // usePositionMorph
        useNormal,
        // useNormalMorph
        false,
        // useTangentMorph
        uv1,
        // useUVMorph
        uv2,
        // useUV2Morph
        color
        // useColorMorph
      ) : 0;
      PrepareStringDefinesForClipPlanes(material, this._scene, defines);
      if (useInstances) {
        defines.push("#define INSTANCES");
        PushAttributesForInstances(attribs);
        if (subMesh.getRenderingMesh().hasThinInstances) {
          defines.push("#define THIN_INSTANCES");
        }
      }
      if (this.customShaderOptions) {
        if (this.customShaderOptions.defines) {
          for (const define of this.customShaderOptions.defines) {
            if (defines.indexOf(define) === -1) {
              defines.push(define);
            }
          }
        }
      }
      const bvaManager = mesh.bakedVertexAnimationManager;
      if (bvaManager && bvaManager.isEnabled) {
        defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
        if (useInstances) {
          attribs.push("bakedVertexAnimationSettingsInstanced");
        }
      }
      const join = defines.join("\n");
      if (cachedDefines !== join) {
        cachedDefines = join;
        let shaderName = "shadowMap";
        const uniforms = [
          "world",
          "mBones",
          "viewProjection",
          "diffuseMatrix",
          "lightDataSM",
          "depthValuesSM",
          "biasAndScaleSM",
          "morphTargetInfluences",
          "morphTargetCount",
          "boneTextureWidth",
          "softTransparentShadowSM",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices",
          "bakedVertexAnimationSettings",
          "bakedVertexAnimationTextureSizeInverted",
          "bakedVertexAnimationTime",
          "bakedVertexAnimationTexture"
        ];
        const samplers = ["diffuseSampler", "boneSampler", "morphTargets", "bakedVertexAnimationTexture"];
        const uniformBuffers = ["Scene", "Mesh"];
        AddClipPlaneUniforms(uniforms);
        if (this.customShaderOptions) {
          shaderName = this.customShaderOptions.shaderName;
          if (this.customShaderOptions.attributes) {
            for (const attrib of this.customShaderOptions.attributes) {
              if (attribs.indexOf(attrib) === -1) {
                attribs.push(attrib);
              }
            }
          }
          if (this.customShaderOptions.uniforms) {
            for (const uniform of this.customShaderOptions.uniforms) {
              if (uniforms.indexOf(uniform) === -1) {
                uniforms.push(uniform);
              }
            }
          }
          if (this.customShaderOptions.samplers) {
            for (const sampler of this.customShaderOptions.samplers) {
              if (samplers.indexOf(sampler) === -1) {
                samplers.push(sampler);
              }
            }
          }
        }
        const engine = this._scene.getEngine();
        effect = engine.createEffect(shaderName, {
          attributes: attribs,
          uniformsNames: uniforms,
          uniformBuffersNames: uniformBuffers,
          samplers,
          defines: join,
          fallbacks,
          onCompiled: null,
          onError: null,
          indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },
          shaderLanguage: this._shaderLanguage
        }, engine);
        subMeshEffect.setEffect(effect, cachedDefines);
      }
      if (!effect.isReady()) {
        return false;
      }
    }
    if (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
      if (!this._blurPostProcesses || !this._blurPostProcesses.length) {
        this._initializeBlurRTTAndPostProcesses();
      }
    }
    if (this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady()) {
      return false;
    }
    if (this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady()) {
      return false;
    }
    if (this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady()) {
      return false;
    }
    return true;
  }
  /**
   * Prepare all the defines in a material relying on a shadow map at the specified light index.
   * @param defines Defines of the material we want to update
   * @param lightIndex Index of the light in the enabled light list of the material
   */
  prepareDefines(defines, lightIndex) {
    const scene = this._scene;
    const light = this._light;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    defines["SHADOW" + lightIndex] = true;
    if (this.useContactHardeningShadow) {
      defines["SHADOWPCSS" + lightIndex] = true;
      if (this._filteringQuality === _ShadowGenerator.QUALITY_LOW) {
        defines["SHADOWLOWQUALITY" + lightIndex] = true;
      } else if (this._filteringQuality === _ShadowGenerator.QUALITY_MEDIUM) {
        defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
      }
    } else if (this.usePercentageCloserFiltering) {
      defines["SHADOWPCF" + lightIndex] = true;
      if (this._filteringQuality === _ShadowGenerator.QUALITY_LOW) {
        defines["SHADOWLOWQUALITY" + lightIndex] = true;
      } else if (this._filteringQuality === _ShadowGenerator.QUALITY_MEDIUM) {
        defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
      }
    } else if (this.usePoissonSampling) {
      defines["SHADOWPOISSON" + lightIndex] = true;
    } else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
      defines["SHADOWESM" + lightIndex] = true;
    } else if (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
      defines["SHADOWCLOSEESM" + lightIndex] = true;
    }
    if (light.needCube()) {
      defines["SHADOWCUBE" + lightIndex] = true;
    }
  }
  /**
   * Binds the shadow related information inside of an effect (information like near, far, darkness...
   * defined in the generator but impacting the effect).
   * @param lightIndex Index of the light in the enabled light list of the material owning the effect
   * @param effect The effect we are binding the information for
   */
  bindShadowLight(lightIndex, effect) {
    const light = this._light;
    const scene = this._scene;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    const camera = this._getCamera();
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return;
    }
    if (!light.needCube()) {
      const offset = scene.floatingOriginOffset;
      const transform = this.getTransformMatrix();
      const lightMatrix = scene.floatingOriginMode ? GetFullOffsetViewProjectionToRef(offset, this._viewMatrix, this._projectionMatrix, TmpVectors.Matrix[0]) : transform;
      effect.setMatrix("lightMatrix" + lightIndex, lightMatrix);
    }
    const shadowMapForRendering = this.getShadowMapForRendering();
    if (this._filter === _ShadowGenerator.FILTER_PCF) {
      effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMapForRendering);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), shadowMap.getSize().width, 1 / shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
    } else if (this._filter === _ShadowGenerator.FILTER_PCSS) {
      effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMapForRendering);
      effect.setTexture("depthTexture" + lightIndex, shadowMapForRendering);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / shadowMap.getSize().width, this._contactHardeningLightSizeUVRatio * shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
    } else {
      effect.setTexture("shadowTexture" + lightIndex, shadowMapForRendering);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), this.blurScale / shadowMap.getSize().width, this.depthScale, this.frustumEdgeFalloff, lightIndex);
    }
    light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
  }
  /**
   * Gets the view matrix used to render the shadow map.
   */
  get viewMatrix() {
    return this._viewMatrix;
  }
  /**
   * Gets the projection matrix used to render the shadow map.
   */
  get projectionMatrix() {
    return this._projectionMatrix;
  }
  /**
   * Gets the transformation matrix used to project the meshes into the map from the light point of view.
   * (eq to shadow projection matrix * light transform matrix)
   * @returns The transform matrix used to create the shadow map
   */
  getTransformMatrix() {
    const scene = this._scene;
    if (this._currentRenderId === scene.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) {
      return this._transformMatrix;
    }
    this._currentRenderId = scene.getRenderId();
    this._currentFaceIndexCache = this._currentFaceIndex;
    let lightPosition = this._light.position;
    if (this._light.computeTransformedInformation()) {
      lightPosition = this._light.transformedPosition;
    }
    Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection);
    if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1) {
      this._lightDirection.z = 1e-13;
    }
    if (this._light.needProjectionMatrixCompute() || !this._cachedPosition || !this._cachedDirection || !lightPosition.equals(this._cachedPosition) || !this._lightDirection.equals(this._cachedDirection)) {
      this._cachedPosition.copyFrom(lightPosition);
      this._cachedDirection.copyFrom(this._lightDirection);
      Matrix.LookAtLHToRef(lightPosition, lightPosition.add(this._lightDirection), Vector3.Up(), this._viewMatrix);
      const shadowMap = this.getShadowMap();
      if (shadowMap) {
        const renderList = shadowMap.renderList;
        if (renderList) {
          this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, renderList);
        }
      }
      this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    }
    return this._transformMatrix;
  }
  /**
   * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
   * Cube and 2D textures for instance.
   */
  recreateShadowMap() {
    const shadowMap = this._shadowMap;
    if (!shadowMap) {
      return;
    }
    const renderList = shadowMap.renderList;
    this._disposeRTTandPostProcesses();
    this._initializeGenerator();
    this.filter = this._filter;
    this._applyFilterValues();
    if (renderList) {
      if (!this._shadowMap.renderList) {
        this._shadowMap.renderList = [];
      }
      for (const mesh of renderList) {
        this._shadowMap.renderList.push(mesh);
      }
    } else {
      this._shadowMap.renderList = null;
    }
  }
  _disposeBlurPostProcesses() {
    if (this._shadowMap2) {
      this._shadowMap2.dispose();
      this._shadowMap2 = null;
    }
    if (this._boxBlurPostprocess) {
      this._boxBlurPostprocess.dispose();
      this._boxBlurPostprocess = null;
    }
    if (this._kernelBlurXPostprocess) {
      this._kernelBlurXPostprocess.dispose();
      this._kernelBlurXPostprocess = null;
    }
    if (this._kernelBlurYPostprocess) {
      this._kernelBlurYPostprocess.dispose();
      this._kernelBlurYPostprocess = null;
    }
    this._blurPostProcesses = [];
  }
  _disposeRTTandPostProcesses() {
    if (this._shadowMap) {
      this._shadowMap.dispose();
      this._shadowMap = null;
    }
    this._disposeBlurPostProcesses();
  }
  _disposeSceneUBOs() {
    if (this._sceneUBOs) {
      for (const ubo of this._sceneUBOs) {
        ubo.dispose();
      }
      this._sceneUBOs = [];
    }
  }
  /**
   * Disposes the ShadowGenerator.
   * Returns nothing.
   */
  dispose() {
    this._disposeRTTandPostProcesses();
    this._disposeSceneUBOs();
    if (this._light) {
      if (this._light._shadowGenerators) {
        const iterator = this._light._shadowGenerators.entries();
        for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {
          const [camera, shadowGenerator] = entry.value;
          if (shadowGenerator === this) {
            this._light._shadowGenerators.delete(camera);
          }
        }
        if (this._light._shadowGenerators.size === 0) {
          this._light._shadowGenerators = null;
        }
      }
      this._light._markMeshesAsLightDirty();
    }
    this.onBeforeShadowMapRenderMeshObservable.clear();
    this.onBeforeShadowMapRenderObservable.clear();
    this.onAfterShadowMapRenderMeshObservable.clear();
    this.onAfterShadowMapRenderObservable.clear();
  }
  /**
   * Serializes the shadow generator setup to a json object.
   * @returns The serialized JSON object
   */
  serialize() {
    const serializationObject = {};
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return serializationObject;
    }
    serializationObject.className = this.getClassName();
    serializationObject.lightId = this._light.id;
    serializationObject.cameraId = this._camera?.id;
    serializationObject.id = this.id;
    serializationObject.mapSize = shadowMap.getRenderSize();
    serializationObject.forceBackFacesOnly = this.forceBackFacesOnly;
    serializationObject.darkness = this.getDarkness();
    serializationObject.transparencyShadow = this._transparencyShadow;
    serializationObject.frustumEdgeFalloff = this.frustumEdgeFalloff;
    serializationObject.bias = this.bias;
    serializationObject.normalBias = this.normalBias;
    serializationObject.usePercentageCloserFiltering = this.usePercentageCloserFiltering;
    serializationObject.useContactHardeningShadow = this.useContactHardeningShadow;
    serializationObject.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio;
    serializationObject.filteringQuality = this.filteringQuality;
    serializationObject.useExponentialShadowMap = this.useExponentialShadowMap;
    serializationObject.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.usePoissonSampling = this.usePoissonSampling;
    serializationObject.depthScale = this.depthScale;
    serializationObject.blurBoxOffset = this.blurBoxOffset;
    serializationObject.blurKernel = this.blurKernel;
    serializationObject.blurScale = this.blurScale;
    serializationObject.useKernelBlur = this.useKernelBlur;
    serializationObject.renderList = [];
    if (shadowMap.renderList) {
      for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
        const mesh = shadowMap.renderList[meshIndex];
        serializationObject.renderList.push(mesh.id);
      }
    }
    return serializationObject;
  }
  /**
   * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
   * @param parsedShadowGenerator The JSON object to parse
   * @param scene The scene to create the shadow map for
   * @param constr A function that builds a shadow generator or undefined to create an instance of the default shadow generator
   * @returns The parsed shadow generator
   */
  static Parse(parsedShadowGenerator, scene, constr) {
    const light = scene.getLightById(parsedShadowGenerator.lightId);
    const camera = parsedShadowGenerator.cameraId !== void 0 ? scene.getCameraById(parsedShadowGenerator.cameraId) : null;
    const shadowGenerator = constr ? constr(parsedShadowGenerator.mapSize, light, camera) : new _ShadowGenerator(parsedShadowGenerator.mapSize, light, void 0, camera);
    const shadowMap = shadowGenerator.getShadowMap();
    if (parsedShadowGenerator.renderList.length && shadowMap) {
      const renderSet = new Set(parsedShadowGenerator.renderList);
      let renderList = shadowMap.renderList;
      if (!renderList) {
        renderList = shadowMap.renderList = [];
      }
      const meshes = scene.meshes;
      for (const mesh of meshes) {
        if (renderSet.has(mesh.id)) {
          renderList.push(mesh);
        }
      }
    }
    if (parsedShadowGenerator.id !== void 0) {
      shadowGenerator.id = parsedShadowGenerator.id;
    }
    shadowGenerator.forceBackFacesOnly = !!parsedShadowGenerator.forceBackFacesOnly;
    if (parsedShadowGenerator.darkness !== void 0) {
      shadowGenerator.setDarkness(parsedShadowGenerator.darkness);
    }
    if (parsedShadowGenerator.transparencyShadow) {
      shadowGenerator.setTransparencyShadow(true);
    }
    if (parsedShadowGenerator.frustumEdgeFalloff !== void 0) {
      shadowGenerator.frustumEdgeFalloff = parsedShadowGenerator.frustumEdgeFalloff;
    }
    if (parsedShadowGenerator.bias !== void 0) {
      shadowGenerator.bias = parsedShadowGenerator.bias;
    }
    if (parsedShadowGenerator.normalBias !== void 0) {
      shadowGenerator.normalBias = parsedShadowGenerator.normalBias;
    }
    if (parsedShadowGenerator.usePercentageCloserFiltering) {
      shadowGenerator.usePercentageCloserFiltering = true;
    } else if (parsedShadowGenerator.useContactHardeningShadow) {
      shadowGenerator.useContactHardeningShadow = true;
    } else if (parsedShadowGenerator.usePoissonSampling) {
      shadowGenerator.usePoissonSampling = true;
    } else if (parsedShadowGenerator.useExponentialShadowMap) {
      shadowGenerator.useExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurExponentialShadowMap) {
      shadowGenerator.useBlurExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useCloseExponentialShadowMap) {
      shadowGenerator.useCloseExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurCloseExponentialShadowMap) {
      shadowGenerator.useBlurCloseExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useVarianceShadowMap) {
      shadowGenerator.useExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurVarianceShadowMap) {
      shadowGenerator.useBlurExponentialShadowMap = true;
    }
    if (parsedShadowGenerator.contactHardeningLightSizeUVRatio !== void 0) {
      shadowGenerator.contactHardeningLightSizeUVRatio = parsedShadowGenerator.contactHardeningLightSizeUVRatio;
    }
    if (parsedShadowGenerator.filteringQuality !== void 0) {
      shadowGenerator.filteringQuality = parsedShadowGenerator.filteringQuality;
    }
    if (parsedShadowGenerator.depthScale) {
      shadowGenerator.depthScale = parsedShadowGenerator.depthScale;
    }
    if (parsedShadowGenerator.blurScale) {
      shadowGenerator.blurScale = parsedShadowGenerator.blurScale;
    }
    if (parsedShadowGenerator.blurBoxOffset) {
      shadowGenerator.blurBoxOffset = parsedShadowGenerator.blurBoxOffset;
    }
    if (parsedShadowGenerator.useKernelBlur) {
      shadowGenerator.useKernelBlur = parsedShadowGenerator.useKernelBlur;
    }
    if (parsedShadowGenerator.blurKernel) {
      shadowGenerator.blurKernel = parsedShadowGenerator.blurKernel;
    }
    return shadowGenerator;
  }
};
ShadowGenerator.CLASSNAME = "ShadowGenerator";
ShadowGenerator.ForceGLSL = false;
ShadowGenerator.FILTER_NONE = 0;
ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP = 1;
ShadowGenerator.FILTER_POISSONSAMPLING = 2;
ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP = 3;
ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;
ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;
ShadowGenerator.FILTER_PCF = 6;
ShadowGenerator.FILTER_PCSS = 7;
ShadowGenerator.QUALITY_HIGH = 0;
ShadowGenerator.QUALITY_MEDIUM = 1;
ShadowGenerator.QUALITY_LOW = 2;
ShadowGenerator.DEFAULT_ALPHA_CUTOFF = 0.5;
ShadowGenerator._SceneComponentInitialization = (_) => {
  throw _WarnImport("ShadowGeneratorSceneComponent");
};

// node_modules/@babylonjs/core/Cameras/camera.js
var Camera = class _Camera extends Node {
  /**
   * Define the current local position of the camera in the scene
   */
  get position() {
    return this._position;
  }
  set position(newPosition) {
    this._position = newPosition;
  }
  /**
   * The vector the camera should consider as up.
   * (default is Vector3(0, 1, 0) aka Vector3.Up())
   */
  set upVector(vec) {
    this._upVector = vec;
  }
  get upVector() {
    return this._upVector;
  }
  /**
   * The screen area in scene units squared
   */
  get screenArea() {
    let x = 0;
    let y = 0;
    if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
      if (this.fovMode === _Camera.FOVMODE_VERTICAL_FIXED) {
        y = this.minZ * 2 * Math.tan(this.fov / 2);
        x = this.getEngine().getAspectRatio(this) * y;
      } else {
        x = this.minZ * 2 * Math.tan(this.fov / 2);
        y = x / this.getEngine().getAspectRatio(this);
      }
    } else {
      const halfWidth = this.getEngine().getRenderWidth() / 2;
      const halfHeight = this.getEngine().getRenderHeight() / 2;
      x = (this.orthoRight ?? halfWidth) - (this.orthoLeft ?? -halfWidth);
      y = (this.orthoTop ?? halfHeight) - (this.orthoBottom ?? -halfHeight);
    }
    return x * y;
  }
  /**
   * Define the current limit on the left side for an orthographic camera
   * In scene unit
   */
  set orthoLeft(value) {
    this._orthoLeft = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoLeft = value;
    }
  }
  get orthoLeft() {
    return this._orthoLeft;
  }
  /**
   * Define the current limit on the right side for an orthographic camera
   * In scene unit
   */
  set orthoRight(value) {
    this._orthoRight = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoRight = value;
    }
  }
  get orthoRight() {
    return this._orthoRight;
  }
  /**
   * Define the current limit on the bottom side for an orthographic camera
   * In scene unit
   */
  set orthoBottom(value) {
    this._orthoBottom = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoBottom = value;
    }
  }
  get orthoBottom() {
    return this._orthoBottom;
  }
  /**
   * Define the current limit on the top side for an orthographic camera
   * In scene unit
   */
  set orthoTop(value) {
    this._orthoTop = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoTop = value;
    }
  }
  get orthoTop() {
    return this._orthoTop;
  }
  /**
   * Sets the camera's field of view in radians based on the focal length and sensor size.
   * @param value the focal length of the camera in mm.
   * @param sensorSize the sensor width size of the camera in mm. (default is 36mm, which is a full frame sensor)
   */
  setFocalLength(value, sensorSize = 36) {
    this.fov = 2 * Math.atan(sensorSize / (2 * value));
  }
  /**
   * Define the mode of the camera (Camera.PERSPECTIVE_CAMERA or Camera.ORTHOGRAPHIC_CAMERA)
   */
  set mode(mode) {
    this._mode = mode;
    for (const rigCamera of this._rigCameras) {
      rigCamera.mode = mode;
    }
  }
  get mode() {
    return this._mode;
  }
  /**
   * Gets a flag indicating that the camera has moved in some way since the last call to Camera.update()
   */
  get hasMoved() {
    return this._hasMoved;
  }
  /**
   * Instantiates a new camera object.
   * This should not be used directly but through the inherited cameras: ArcRotate, Free...
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras
   * @param name Defines the name of the camera in the scene
   * @param position Defines the position of the camera
   * @param scene Defines the scene the camera belongs too
   * @param setActiveOnSceneIfNoneActive Defines if the camera should be set as active after creation if no other camera have been defined in the scene
   */
  constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {
    super(name, scene, false);
    this._position = Vector3.Zero();
    this._upVector = Vector3.Up();
    this.oblique = null;
    this._orthoLeft = null;
    this._orthoRight = null;
    this._orthoBottom = null;
    this._orthoTop = null;
    this.fov = 0.8;
    this.projectionPlaneTilt = 0;
    this.minZ = 1;
    this.maxZ = 1e4;
    this.inertia = 0.9;
    this._mode = _Camera.PERSPECTIVE_CAMERA;
    this.isIntermediate = false;
    this.viewport = new Viewport(0, 0, 1, 1);
    this.layerMask = 268435455;
    this.fovMode = _Camera.FOVMODE_VERTICAL_FIXED;
    this.cameraRigMode = _Camera.RIG_MODE_NONE;
    this.ignoreCameraMaxZ = false;
    this.customRenderTargets = [];
    this.outputRenderTarget = null;
    this.onViewMatrixChangedObservable = new Observable();
    this.onProjectionMatrixChangedObservable = new Observable();
    this.onAfterCheckInputsObservable = new Observable();
    this.onRestoreStateObservable = new Observable();
    this.isRigCamera = false;
    this._hasMoved = false;
    this._rigCameras = new Array();
    this._skipRendering = false;
    this._projectionMatrix = new Matrix();
    this._postProcesses = new Array();
    this._activeMeshes = new SmartArray(256);
    this._globalPosition = Vector3.Zero();
    this._computedViewMatrix = Matrix.Identity();
    this._doNotComputeProjectionMatrix = false;
    this._transformMatrix = Matrix.Zero();
    this._refreshFrustumPlanes = true;
    this._absoluteRotation = Quaternion.Identity();
    this._isCamera = true;
    this._isLeftCamera = false;
    this._isRightCamera = false;
    this.getScene().addCamera(this);
    if (setActiveOnSceneIfNoneActive && !this.getScene().activeCamera) {
      this.getScene().activeCamera = this;
    }
    this.position = position;
    this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${name}`);
  }
  /**
   * Store current camera state (fov, position, etc..)
   * @returns the camera
   */
  storeState() {
    this._stateStored = true;
    this._storedFov = this.fov;
    return this;
  }
  /**
   * Returns true if a state has been stored by calling storeState method.
   * @returns true if state has been stored.
   */
  hasStateStored() {
    return !!this._stateStored;
  }
  /**
   * Restores the camera state values if it has been stored. You must call storeState() first
   * @returns true if restored and false otherwise
   */
  _restoreStateValues() {
    if (!this._stateStored) {
      return false;
    }
    this.fov = this._storedFov;
    return true;
  }
  /**
   * Restored camera state. You must call storeState() first.
   * @returns true if restored and false otherwise
   */
  restoreState() {
    if (this._restoreStateValues()) {
      this.onRestoreStateObservable.notifyObservers(this);
      return true;
    }
    return false;
  }
  /**
   * Gets the class name of the camera.
   * @returns the class name
   */
  getClassName() {
    return "Camera";
  }
  /**
   * Gets a string representation of the camera useful for debug purpose.
   * @param fullDetails Defines that a more verbose level of logging is required
   * @returns the string representation
   */
  toString(fullDetails) {
    let ret = "Name: " + this.name;
    ret += ", type: " + this.getClassName();
    if (this.animations) {
      for (let i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    return ret;
  }
  /**
   * Automatically tilts the projection plane, using `projectionPlaneTilt`, to correct the perspective effect on vertical lines.
   */
  applyVerticalCorrection() {
    const rot = this.absoluteRotation.toEulerAngles();
    this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -rot.x : rot.x;
  }
  /**
   * Gets the current world space position of the camera.
   */
  get globalPosition() {
    return this._globalPosition;
  }
  /**
   * Gets the list of active meshes this frame (meshes no culled or excluded by lod s in the frame)
   * @returns the active meshe list
   */
  getActiveMeshes() {
    return this._activeMeshes;
  }
  /**
   * Check whether a mesh is part of the current active mesh list of the camera
   * @param mesh Defines the mesh to check
   * @returns true if active, false otherwise
   */
  isActiveMesh(mesh) {
    return this._activeMeshes.indexOf(mesh) !== -1;
  }
  /**
   * Is this camera ready to be used/rendered
   * @param completeCheck defines if a complete check (including post processes) has to be done (false by default)
   * @returns true if the camera is ready
   */
  isReady(completeCheck = false) {
    if (completeCheck) {
      for (const pp of this._postProcesses) {
        if (pp && !pp.isReady()) {
          return false;
        }
      }
    }
    return super.isReady(completeCheck);
  }
  /** @internal */
  _initCache() {
    super._initCache();
    this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.mode = void 0;
    this._cache.minZ = void 0;
    this._cache.maxZ = void 0;
    this._cache.fov = void 0;
    this._cache.fovMode = void 0;
    this._cache.aspectRatio = void 0;
    this._cache.orthoLeft = void 0;
    this._cache.orthoRight = void 0;
    this._cache.orthoBottom = void 0;
    this._cache.orthoTop = void 0;
    this._cache.obliqueAngle = void 0;
    this._cache.obliqueLength = void 0;
    this._cache.obliqueOffset = void 0;
    this._cache.renderWidth = void 0;
    this._cache.renderHeight = void 0;
  }
  /**
   * @internal
   */
  _updateCache(ignoreParentClass) {
    if (!ignoreParentClass) {
      super._updateCache();
    }
    this._cache.position.copyFrom(this.position);
    this._cache.upVector.copyFrom(this.upVector);
  }
  /** @internal */
  _isSynchronized() {
    return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();
  }
  /** @internal */
  _isSynchronizedViewMatrix() {
    if (!super._isSynchronized()) {
      return false;
    }
    return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();
  }
  /** @internal */
  _isSynchronizedProjectionMatrix() {
    const maxZ = this.ignoreCameraMaxZ ? 0 : this.maxZ;
    let isSynchronized = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === maxZ;
    if (!isSynchronized) {
      return false;
    }
    const engine = this.getEngine();
    if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
      isSynchronized = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === engine.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt;
    } else {
      isSynchronized = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === engine.getRenderWidth() && this._cache.renderHeight === engine.getRenderHeight();
      if (this.oblique) {
        isSynchronized = isSynchronized && this._cache.obliqueAngle === this.oblique.angle && this._cache.obliqueLength === this.oblique.length && this._cache.obliqueOffset === this.oblique.offset;
      }
    }
    return isSynchronized;
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * This function is here because typescript removes the typing of the last function.
   * @param _ignored defines an ignored parameter kept for backward compatibility.
   * @param _noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(_ignored, _noPreventDefault) {
  }
  /**
   * Detach the current controls from the specified dom element.
   * This function is here because typescript removes the typing of the last function.
   * @param _ignored defines an ignored parameter kept for backward compatibility.
   */
  detachControl(_ignored) {
  }
  /**
   * Update the camera state according to the different inputs gathered during the frame.
   */
  update() {
    this._hasMoved = false;
    this._checkInputs();
    if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
      this._updateRigCameras();
    }
    this.getViewMatrix();
    this.getProjectionMatrix();
  }
  /** @internal */
  _checkInputs() {
    this.onAfterCheckInputsObservable.notifyObservers(this);
  }
  /** @internal */
  get rigCameras() {
    return this._rigCameras;
  }
  /**
   * Gets the post process used by the rig cameras
   */
  get rigPostProcess() {
    return this._rigPostProcess;
  }
  /**
   * Internal, gets the first post process.
   * @returns the first post process to be run on this camera.
   */
  _getFirstPostProcess() {
    for (let ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {
      if (this._postProcesses[ppIndex] !== null) {
        return this._postProcesses[ppIndex];
      }
    }
    return null;
  }
  _cascadePostProcessesToRigCams() {
    const firstPostProcess = this._getFirstPostProcess();
    if (firstPostProcess) {
      firstPostProcess.markTextureDirty();
    }
    for (let i = 0, len = this._rigCameras.length; i < len; i++) {
      const cam = this._rigCameras[i];
      const rigPostProcess = cam._rigPostProcess;
      if (rigPostProcess) {
        const isPass = rigPostProcess.getEffectName() === "pass";
        if (isPass) {
          cam.isIntermediate = this._postProcesses.length === 0;
        }
        cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);
        rigPostProcess.markTextureDirty();
      } else {
        cam._postProcesses = this._postProcesses.slice(0);
      }
    }
  }
  /**
   * Attach a post process to the camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess
   * @param postProcess The post process to attach to the camera
   * @param insertAt The position of the post process in case several of them are in use in the scene
   * @returns the position the post process has been inserted at
   */
  attachPostProcess(postProcess, insertAt = null) {
    if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {
      Logger.Error("You're trying to reuse a post process not defined as reusable.");
      return 0;
    }
    if (insertAt == null || insertAt < 0) {
      this._postProcesses.push(postProcess);
    } else if (this._postProcesses[insertAt] === null) {
      this._postProcesses[insertAt] = postProcess;
    } else {
      this._postProcesses.splice(insertAt, 0, postProcess);
    }
    this._cascadePostProcessesToRigCams();
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    return this._postProcesses.indexOf(postProcess);
  }
  /**
   * Detach a post process to the camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess
   * @param postProcess The post process to detach from the camera
   */
  detachPostProcess(postProcess) {
    const idx = this._postProcesses.indexOf(postProcess);
    if (idx !== -1) {
      this._postProcesses[idx] = null;
    }
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    this._cascadePostProcessesToRigCams();
  }
  /**
   * Gets the current world matrix of the camera
   * @returns the world matrix
   */
  getWorldMatrix() {
    if (this._isSynchronizedViewMatrix()) {
      return this._worldMatrix;
    }
    this.getViewMatrix();
    return this._worldMatrix;
  }
  /** @internal */
  _getViewMatrix() {
    return Matrix.Identity();
  }
  /**
   * Gets the current view matrix of the camera.
   * @param force forces the camera to recompute the matrix without looking at the cached state
   * @returns the view matrix
   */
  getViewMatrix(force) {
    if (!force && this._isSynchronizedViewMatrix()) {
      return this._computedViewMatrix;
    }
    this._hasMoved = true;
    this.updateCache();
    this._computedViewMatrix = this._getViewMatrix();
    this._currentRenderId = this.getScene().getRenderId();
    this._childUpdateId++;
    this._refreshFrustumPlanes = true;
    if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {
      this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);
    }
    if (this.parent && this.parent.onViewMatrixChangedObservable) {
      this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent);
    }
    this.onViewMatrixChangedObservable.notifyObservers(this);
    this._computedViewMatrix.invertToRef(this._worldMatrix);
    this._worldMatrix.getTranslationToRef(this._globalPosition);
    return this._computedViewMatrix;
  }
  /**
   * Freeze the projection matrix.
   * It will prevent the cache check of the camera projection compute and can speed up perf
   * if no parameter of the camera are meant to change
   * @param projection Defines manually a projection if necessary
   */
  freezeProjectionMatrix(projection) {
    this._doNotComputeProjectionMatrix = true;
    if (projection !== void 0) {
      this._projectionMatrix = projection;
    }
  }
  /**
   * Unfreeze the projection matrix if it has previously been freezed by freezeProjectionMatrix.
   */
  unfreezeProjectionMatrix() {
    this._doNotComputeProjectionMatrix = false;
  }
  /**
   * Gets the current projection matrix of the camera.
   * @param force forces the camera to recompute the matrix without looking at the cached state
   * @returns the projection matrix
   */
  getProjectionMatrix(force) {
    if (this._doNotComputeProjectionMatrix || !force && this._isSynchronizedProjectionMatrix()) {
      return this._projectionMatrix;
    }
    const maxZ = this.ignoreCameraMaxZ ? 0 : this.maxZ;
    this._cache.mode = this.mode;
    this._cache.minZ = this.minZ;
    this._cache.maxZ = maxZ;
    this._refreshFrustumPlanes = true;
    const engine = this.getEngine();
    const scene = this.getScene();
    const reverseDepth = engine.useReverseDepthBuffer;
    if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
      this._cache.fov = this.fov;
      this._cache.fovMode = this.fovMode;
      this._cache.aspectRatio = engine.getAspectRatio(this);
      this._cache.projectionPlaneTilt = this.projectionPlaneTilt;
      if (this.minZ <= 0) {
        this.minZ = 0.1;
      }
      let getProjectionMatrix;
      if (scene.useRightHandedSystem) {
        getProjectionMatrix = Matrix.PerspectiveFovRHToRef;
      } else {
        getProjectionMatrix = Matrix.PerspectiveFovLHToRef;
      }
      getProjectionMatrix(this.fov, engine.getAspectRatio(this), reverseDepth ? maxZ : this.minZ, reverseDepth ? this.minZ : maxZ, this._projectionMatrix, this.fovMode === _Camera.FOVMODE_VERTICAL_FIXED, engine.isNDCHalfZRange, this.projectionPlaneTilt, reverseDepth);
    } else {
      const halfWidth = engine.getRenderWidth() / 2;
      const halfHeight = engine.getRenderHeight() / 2;
      if (scene.useRightHandedSystem) {
        if (this.oblique) {
          Matrix.ObliqueOffCenterRHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? maxZ : this.minZ, reverseDepth ? this.minZ : maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, engine.isNDCHalfZRange);
        } else {
          Matrix.OrthoOffCenterRHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? maxZ : this.minZ, reverseDepth ? this.minZ : maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
        }
      } else {
        if (this.oblique) {
          Matrix.ObliqueOffCenterLHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? maxZ : this.minZ, reverseDepth ? this.minZ : maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, engine.isNDCHalfZRange);
        } else {
          Matrix.OrthoOffCenterLHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? maxZ : this.minZ, reverseDepth ? this.minZ : maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
        }
      }
      this._cache.orthoLeft = this.orthoLeft;
      this._cache.orthoRight = this.orthoRight;
      this._cache.orthoBottom = this.orthoBottom;
      this._cache.orthoTop = this.orthoTop;
      this._cache.obliqueAngle = this.oblique?.angle;
      this._cache.obliqueLength = this.oblique?.length;
      this._cache.obliqueOffset = this.oblique?.offset;
      this._cache.renderWidth = engine.getRenderWidth();
      this._cache.renderHeight = engine.getRenderHeight();
    }
    this.onProjectionMatrixChangedObservable.notifyObservers(this);
    return this._projectionMatrix;
  }
  /**
   * Gets the transformation matrix (ie. the multiplication of view by projection matrices)
   * @returns a Matrix
   */
  getTransformationMatrix() {
    this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    return this._transformMatrix;
  }
  _computeObliqueDistance(offset) {
    const arcRotateCamera = this;
    const targetCamera = this;
    return (arcRotateCamera.radius || (targetCamera.target ? Vector3.Distance(this.position, targetCamera.target) : this.position.length())) + offset;
  }
  /** @internal */
  _updateFrustumPlanes() {
    if (!this._refreshFrustumPlanes) {
      return;
    }
    this.getTransformationMatrix();
    if (!this._frustumPlanes) {
      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
    } else {
      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
    }
    this._refreshFrustumPlanes = false;
  }
  /**
   * Checks if a cullable object (mesh...) is in the camera frustum
   * This checks the bounding box center. See isCompletelyInFrustum for a full bounding check
   * @param target The object to check
   * @param checkRigCameras If the rig cameras should be checked (eg. with VR camera both eyes should be checked) (Default: false)
   * @returns true if the object is in frustum otherwise false
   */
  isInFrustum(target, checkRigCameras = false) {
    this._updateFrustumPlanes();
    if (checkRigCameras && this.rigCameras.length > 0) {
      let result = false;
      for (const cam of this.rigCameras) {
        cam._updateFrustumPlanes();
        result = result || target.isInFrustum(cam._frustumPlanes);
      }
      return result;
    } else {
      return target.isInFrustum(this._frustumPlanes);
    }
  }
  /**
   * Checks if a cullable object (mesh...) is in the camera frustum
   * Unlike isInFrustum this checks the full bounding box
   * @param target The object to check
   * @returns true if the object is in frustum otherwise false
   */
  isCompletelyInFrustum(target) {
    this._updateFrustumPlanes();
    return target.isCompletelyInFrustum(this._frustumPlanes);
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Gets a ray in the forward direction from the camera.
   * @param length Defines the length of the ray to create
   * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a world space ray
   * @param origin Defines the start point of the ray which defaults to the camera position
   * @returns the forward ray
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getForwardRay(length = 100, transform, origin) {
    throw _WarnImport("Ray");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Gets a ray in the forward direction from the camera.
   * @param refRay the ray to (re)use when setting the values
   * @param length Defines the length of the ray to create
   * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a world space ray
   * @param origin Defines the start point of the ray which defaults to the camera position
   * @returns the forward ray
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getForwardRayToRef(refRay, length = 100, transform, origin) {
    throw _WarnImport("Ray");
  }
  /**
   * Releases resources associated with this node.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this.onViewMatrixChangedObservable.clear();
    this.onProjectionMatrixChangedObservable.clear();
    this.onAfterCheckInputsObservable.clear();
    this.onRestoreStateObservable.clear();
    if (this.inputs) {
      this.inputs.clear();
    }
    this.getScene().stopAnimation(this);
    this.getScene().removeCamera(this);
    while (this._rigCameras.length > 0) {
      const camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    if (this._parentContainer) {
      const index = this._parentContainer.cameras.indexOf(this);
      if (index > -1) {
        this._parentContainer.cameras.splice(index, 1);
      }
      this._parentContainer = null;
    }
    if (this._rigPostProcess) {
      this._rigPostProcess.dispose(this);
      this._rigPostProcess = null;
      this._postProcesses.length = 0;
    } else if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
      this._rigPostProcess = null;
      this._postProcesses.length = 0;
    } else {
      let i2 = this._postProcesses.length;
      while (--i2 >= 0) {
        const postProcess = this._postProcesses[i2];
        if (postProcess) {
          postProcess.dispose(this);
        }
      }
    }
    let i = this.customRenderTargets.length;
    while (--i >= 0) {
      this.customRenderTargets[i].dispose();
    }
    this.customRenderTargets.length = 0;
    this._activeMeshes.dispose();
    this.getScene().getEngine().releaseRenderPassId(this.renderPassId);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  /**
   * Gets the left camera of a rig setup in case of Rigged Camera
   */
  get isLeftCamera() {
    return this._isLeftCamera;
  }
  /**
   * Gets the right camera of a rig setup in case of Rigged Camera
   */
  get isRightCamera() {
    return this._isRightCamera;
  }
  /**
   * Gets the left camera of a rig setup in case of Rigged Camera
   */
  get leftCamera() {
    if (this._rigCameras.length < 1) {
      return null;
    }
    return this._rigCameras[0];
  }
  /**
   * Gets the right camera of a rig setup in case of Rigged Camera
   */
  get rightCamera() {
    if (this._rigCameras.length < 2) {
      return null;
    }
    return this._rigCameras[1];
  }
  /**
   * Gets the left camera target of a rig setup in case of Rigged Camera
   * @returns the target position
   */
  getLeftTarget() {
    if (this._rigCameras.length < 1) {
      return null;
    }
    return this._rigCameras[0].getTarget();
  }
  /**
   * Gets the right camera target of a rig setup in case of Rigged Camera
   * @returns the target position
   */
  getRightTarget() {
    if (this._rigCameras.length < 2) {
      return null;
    }
    return this._rigCameras[1].getTarget();
  }
  /**
   * @internal
   */
  setCameraRigMode(mode, rigParams) {
    if (this.cameraRigMode === mode) {
      return;
    }
    while (this._rigCameras.length > 0) {
      const camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    this.cameraRigMode = mode;
    this._cameraRigParams = {};
    this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;
    this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);
    if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
      const leftCamera = this.createRigCamera(this.name + "_L", 0);
      if (leftCamera) {
        leftCamera._isLeftCamera = true;
      }
      const rightCamera = this.createRigCamera(this.name + "_R", 1);
      if (rightCamera) {
        rightCamera._isRightCamera = true;
      }
      if (leftCamera && rightCamera) {
        this._rigCameras.push(leftCamera);
        this._rigCameras.push(rightCamera);
      }
    }
    this._setRigMode(rigParams);
    this._cascadePostProcessesToRigCams();
    this.update();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _setRigMode(rigParams) {
  }
  /** @internal */
  _getVRProjectionMatrix() {
    Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.ignoreCameraMaxZ ? 0 : this.maxZ, this._cameraRigParams.vrWorkMatrix, true, this.getEngine().isNDCHalfZRange);
    this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);
    return this._projectionMatrix;
  }
  /**
   * @internal
   */
  setCameraRigParameter(name, value) {
    if (!this._cameraRigParams) {
      this._cameraRigParams = {};
    }
    this._cameraRigParams[name] = value;
    if (name === "interaxialDistance") {
      this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);
    }
  }
  /**
   * needs to be overridden by children so sub has required properties to be copied
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createRigCamera(name, cameraIndex) {
    return null;
  }
  /**
   * May need to be overridden by children
   * @internal
   */
  _updateRigCameras() {
    for (let i = 0; i < this._rigCameras.length; i++) {
      this._rigCameras[i].minZ = this.minZ;
      this._rigCameras[i].maxZ = this.ignoreCameraMaxZ ? 0 : this.maxZ;
      this._rigCameras[i].fov = this.fov;
      this._rigCameras[i].upVector.copyFrom(this.upVector);
    }
    if (this.cameraRigMode === _Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {
      this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;
    }
  }
  /** @internal */
  _setupInputs() {
  }
  /**
   * Serialiaze the camera setup to a json representation
   * @returns the JSON representation
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getClassName();
    if (this.parent) {
      this.parent._serializeAsParent(serializationObject);
    }
    if (this.inputs) {
      this.inputs.serialize(serializationObject);
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  }
  /**
   * Clones the current camera.
   * @param name The cloned camera name
   * @param newParent The cloned camera's new parent (none by default)
   * @returns the cloned camera
   */
  clone(name, newParent = null) {
    const camera = SerializationHelper.Clone(_Camera.GetConstructorFromName(this.getClassName(), name, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
    camera.name = name;
    camera.parent = newParent;
    this.onClonedObservable.notifyObservers(camera);
    return camera;
  }
  /**
   * Gets the direction of the camera relative to a given local axis.
   * @param localAxis Defines the reference axis to provide a relative direction.
   * @returns the direction
   */
  getDirection(localAxis) {
    const result = Vector3.Zero();
    this.getDirectionToRef(localAxis, result);
    return result;
  }
  /**
   * Returns the current camera absolute rotation
   */
  get absoluteRotation() {
    this.getWorldMatrix().decompose(void 0, this._absoluteRotation);
    return this._absoluteRotation;
  }
  /**
   * Gets the direction of the camera relative to a given local axis into a passed vector.
   * @param localAxis Defines the reference axis to provide a relative direction.
   * @param result Defines the vector to store the result in
   */
  getDirectionToRef(localAxis, result) {
    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
  }
  /**
   * Gets a camera constructor for a given camera type
   * @param type The type of the camera to construct (should be equal to one of the camera class name)
   * @param name The name of the camera the result will be able to instantiate
   * @param scene The scene the result will construct the camera in
   * @param interaxial_distance In case of stereoscopic setup, the distance between both eyes
   * @param isStereoscopicSideBySide In case of stereoscopic setup, should the sereo be side b side
   * @returns a factory method to construct the camera
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static GetConstructorFromName(type, name, scene, interaxial_distance = 0, isStereoscopicSideBySide = true) {
    const constructorFunc = Node.Construct(type, name, scene, {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      interaxial_distance,
      isStereoscopicSideBySide
    });
    if (constructorFunc) {
      return constructorFunc;
    }
    return () => _Camera._CreateDefaultParsedCamera(name, scene);
  }
  /**
   * Compute the world  matrix of the camera.
   * @returns the camera world matrix
   */
  computeWorldMatrix() {
    return this.getWorldMatrix();
  }
  /**
   * Parse a JSON and creates the camera from the parsed information
   * @param parsedCamera The JSON to parse
   * @param scene The scene to instantiate the camera in
   * @returns the newly constructed camera
   */
  static Parse(parsedCamera, scene) {
    const type = parsedCamera.type;
    const construct = _Camera.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);
    const camera = SerializationHelper.Parse(construct, parsedCamera, scene);
    if (parsedCamera.parentId !== void 0) {
      camera._waitingParentId = parsedCamera.parentId;
    }
    if (parsedCamera.parentInstanceIndex !== void 0) {
      camera._waitingParentInstanceIndex = parsedCamera.parentInstanceIndex;
    }
    if (camera.inputs) {
      camera.inputs.parse(parsedCamera);
      camera._setupInputs();
    }
    if (parsedCamera.upVector) {
      camera.upVector = Vector3.FromArray(parsedCamera.upVector);
    }
    if (camera.setPosition) {
      camera.position.copyFromFloats(0, 0, 0);
      camera.setPosition(Vector3.FromArray(parsedCamera.position));
    }
    if (parsedCamera.target) {
      if (camera.setTarget) {
        camera.setTarget(Vector3.FromArray(parsedCamera.target));
      }
    }
    if (parsedCamera.cameraRigMode) {
      const rigParams = parsedCamera.interaxial_distance ? { interaxialDistance: parsedCamera.interaxial_distance } : {};
      camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);
    }
    if (parsedCamera.animations) {
      for (let animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {
        const parsedAnimation = parsedCamera.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          camera.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(camera, parsedCamera, scene);
    }
    if (parsedCamera.autoAnimate) {
      scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1);
    }
    if (parsedCamera.isEnabled !== void 0) {
      camera.setEnabled(parsedCamera.isEnabled);
    }
    return camera;
  }
  /** @internal */
  _calculateHandednessMultiplier() {
    let handednessMultiplier = this.getScene().useRightHandedSystem ? -1 : 1;
    if (this.parent && this.parent._getWorldMatrixDeterminant() < 0) {
      handednessMultiplier *= -1;
    }
    return handednessMultiplier;
  }
};
Camera._CreateDefaultParsedCamera = (name, scene) => {
  throw _WarnImport("UniversalCamera");
};
Camera.PERSPECTIVE_CAMERA = 0;
Camera.ORTHOGRAPHIC_CAMERA = 1;
Camera.FOVMODE_VERTICAL_FIXED = 0;
Camera.FOVMODE_HORIZONTAL_FIXED = 1;
Camera.RIG_MODE_NONE = 0;
Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
Camera.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
Camera.RIG_MODE_VR = 20;
Camera.RIG_MODE_CUSTOM = 22;
Camera.ForceAttachControlToAlwaysPreventDefault = false;
__decorate([
  serializeAsVector3("position")
], Camera.prototype, "_position", void 0);
__decorate([
  serializeAsVector3("upVector")
], Camera.prototype, "_upVector", void 0);
__decorate([
  serialize()
], Camera.prototype, "orthoLeft", null);
__decorate([
  serialize()
], Camera.prototype, "orthoRight", null);
__decorate([
  serialize()
], Camera.prototype, "orthoBottom", null);
__decorate([
  serialize()
], Camera.prototype, "orthoTop", null);
__decorate([
  serialize()
], Camera.prototype, "fov", void 0);
__decorate([
  serialize()
], Camera.prototype, "projectionPlaneTilt", void 0);
__decorate([
  serialize()
], Camera.prototype, "minZ", void 0);
__decorate([
  serialize()
], Camera.prototype, "maxZ", void 0);
__decorate([
  serialize()
], Camera.prototype, "inertia", void 0);
__decorate([
  serialize()
], Camera.prototype, "mode", null);
__decorate([
  serialize()
], Camera.prototype, "layerMask", void 0);
__decorate([
  serialize()
], Camera.prototype, "fovMode", void 0);
__decorate([
  serialize()
], Camera.prototype, "cameraRigMode", void 0);
__decorate([
  serialize()
], Camera.prototype, "interaxialDistance", void 0);
__decorate([
  serialize()
], Camera.prototype, "isStereoscopicSideBySide", void 0);
__decorate([
  serialize()
], Camera.prototype, "ignoreCameraMaxZ", void 0);

// node_modules/@babylonjs/core/Rendering/depthRenderer.js
var DepthRenderer = class _DepthRenderer {
  /**
   * Gets the shader language used in this material.
   */
  get shaderLanguage() {
    return this._shaderLanguage;
  }
  /**
   * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer
   * @param mesh mesh or array of meshes
   * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.
   */
  setMaterialForRendering(mesh, material) {
    this._depthMap.setMaterialForRendering(mesh, material);
  }
  /**
   * Instantiates a depth renderer
   * @param scene The scene the renderer belongs to
   * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)
   * @param camera The camera to be used to render the depth map (default: scene's active camera)
   * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z
   * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...) (default: TRILINEAR_SAMPLINGMODE)
   * @param storeCameraSpaceZ Defines whether the depth stored is the Z coordinate in camera space. If true, storeNonLinearDepth has no effect. (Default: false)
   * @param name Name of the render target (default: DepthRenderer)
   * @param existingRenderTargetTexture An existing render target texture to use (default: undefined). If not provided, a new render target texture will be created.
   */
  constructor(scene, type = 1, camera = null, storeNonLinearDepth = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, storeCameraSpaceZ = false, name, existingRenderTargetTexture) {
    this._shaderLanguage = 0;
    this.enabled = true;
    this.forceDepthWriteTransparentMeshes = false;
    this.useOnlyInActiveCamera = false;
    this.reverseCulling = false;
    this._shadersLoaded = false;
    this._scene = scene;
    this._storeNonLinearDepth = storeNonLinearDepth;
    this._storeCameraSpaceZ = storeCameraSpaceZ;
    this.isPacked = type === 0;
    if (this.isPacked) {
      this.clearColor = new Color4(1, 1, 1, 1);
    } else {
      this.clearColor = new Color4(storeCameraSpaceZ ? 0 : 1, 0, 0, 1);
    }
    this._initShaderSourceAsync();
    _DepthRenderer._SceneComponentInitialization(this._scene);
    const engine = scene.getEngine();
    this._camera = camera;
    if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {
      if (type === 1 && !engine._caps.textureFloatLinearFiltering) {
        samplingMode = Texture.NEAREST_SAMPLINGMODE;
      }
      if (type === 2 && !engine._caps.textureHalfFloatLinearFiltering) {
        samplingMode = Texture.NEAREST_SAMPLINGMODE;
      }
    }
    const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? 5 : 6;
    this._depthMap = existingRenderTargetTexture ?? new RenderTargetTexture(name ?? "DepthRenderer", { width: engine.getRenderWidth(), height: engine.getRenderHeight() }, this._scene, false, true, type, false, samplingMode, void 0, void 0, void 0, format);
    this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._depthMap.refreshRate = 1;
    this._depthMap.renderParticles = false;
    this._depthMap.renderList = null;
    this._depthMap.noPrePassRenderer = true;
    this._depthMap.activeCamera = this._camera;
    this._depthMap.ignoreCameraViewport = true;
    this._depthMap.useCameraPostProcesses = false;
    this._depthMap.onClearObservable.add((engine2) => {
      engine2.clear(this.clearColor, true, true, true);
    });
    this._depthMap.onBeforeBindObservable.add(() => {
      engine._debugPushGroup?.("depth renderer", 1);
    });
    this._depthMap.onAfterUnbindObservable.add(() => {
      engine._debugPopGroup?.(1);
    });
    this._depthMap.customIsReadyFunction = (mesh, refreshRate, preWarm) => {
      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {
        for (let i = 0; i < mesh.subMeshes.length; ++i) {
          const subMesh = mesh.subMeshes[i];
          const renderingMesh = subMesh.getRenderingMesh();
          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
          const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
          if (!this.isReady(subMesh, hardwareInstancedRendering)) {
            return false;
          }
        }
      }
      return true;
    };
    const renderSubMesh = (subMesh) => {
      const renderingMesh = subMesh.getRenderingMesh();
      const effectiveMesh = subMesh.getEffectiveMesh();
      const scene2 = this._scene;
      const engine2 = scene2.getEngine();
      const material = subMesh.getMaterial();
      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
      if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene2.getRenderId()) {
        return;
      }
      const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;
      let sideOrientation = material._getEffectiveOrientation(renderingMesh);
      if (detNeg) {
        sideOrientation = sideOrientation === 0 ? 1 : 0;
      }
      const reverseSideOrientation = sideOrientation === 0;
      engine2.setState(material.backFaceCulling, 0, false, reverseSideOrientation, this.reverseCulling ? !material.cullBackFaces : material.cullBackFaces);
      const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
      if (batch.mustReturn) {
        return;
      }
      const hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
      const camera2 = this._camera || scene2.activeCamera;
      if (this.isReady(subMesh, hardwareInstancedRendering) && camera2) {
        subMesh._renderId = scene2.getRenderId();
        let renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine2.currentRenderPassId];
        if (renderingMaterial === void 0 && effectiveMesh.getClassName() === "GaussianSplattingMesh") {
          const gsMaterial = effectiveMesh.material;
          renderingMaterial = gsMaterial.makeDepthRenderingMaterial(this._scene, this._shaderLanguage);
          this.setMaterialForRendering(effectiveMesh, renderingMaterial);
          if (!renderingMaterial.isReady()) {
            return;
          }
        }
        let drawWrapper = subMesh._getDrawWrapper();
        if (!drawWrapper && renderingMaterial) {
          drawWrapper = renderingMaterial._getDrawWrapper();
        }
        const cameraIsOrtho = camera2.mode === Camera.ORTHOGRAPHIC_CAMERA;
        if (!drawWrapper) {
          return;
        }
        const effect = drawWrapper.effect;
        engine2.enableEffect(drawWrapper);
        if (!hardwareInstancedRendering) {
          renderingMesh._bind(subMesh, effect, material.fillMode);
        }
        if (!renderingMaterial) {
          effect.setMatrix("viewProjection", scene2.getTransformMatrix());
          effect.setMatrix("world", effectiveMesh.getWorldMatrix());
          if (this._storeCameraSpaceZ) {
            effect.setMatrix("view", scene2.getViewMatrix());
          }
        } else {
          renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);
        }
        let minZ, maxZ;
        if (cameraIsOrtho) {
          minZ = !engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : 1;
          maxZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : 1;
        } else {
          minZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? camera2.minZ : engine2.isNDCHalfZRange ? 0 : camera2.minZ;
          maxZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : camera2.maxZ;
        }
        effect.setFloat2("depthValues", minZ, minZ + maxZ);
        if (!renderingMaterial) {
          if (material.needAlphaTestingForMesh(effectiveMesh)) {
            const alphaTexture = material.getAlphaTestTexture();
            if (alphaTexture) {
              effect.setTexture("diffuseSampler", alphaTexture);
              effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
            }
          }
          BindBonesParameters(renderingMesh, effect);
          BindClipPlane(effect, material, scene2);
          BindMorphTargetParameters(renderingMesh, effect);
          if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
            renderingMesh.morphTargetManager._bind(effect);
          }
          const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;
          if (bvaManager && bvaManager.isEnabled) {
            bvaManager.bind(effect, hardwareInstancedRendering);
          }
          if (material.pointsCloud) {
            effect.setFloat("pointSize", material.pointSize);
          }
        }
        renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix("world", world));
      }
    };
    this._depthMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {
      let index;
      if (depthOnlySubMeshes.length) {
        for (index = 0; index < depthOnlySubMeshes.length; index++) {
          renderSubMesh(depthOnlySubMeshes.data[index]);
        }
      }
      for (index = 0; index < opaqueSubMeshes.length; index++) {
        renderSubMesh(opaqueSubMeshes.data[index]);
      }
      for (index = 0; index < alphaTestSubMeshes.length; index++) {
        renderSubMesh(alphaTestSubMeshes.data[index]);
      }
      if (this.forceDepthWriteTransparentMeshes) {
        for (index = 0; index < transparentSubMeshes.length; index++) {
          renderSubMesh(transparentSubMeshes.data[index]);
        }
      } else {
        for (index = 0; index < transparentSubMeshes.length; index++) {
          transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;
        }
      }
    };
  }
  async _initShaderSourceAsync(forceGLSL = false) {
    const engine = this._scene.getEngine();
    if (engine.isWebGPU && !forceGLSL && !_DepthRenderer.ForceGLSL) {
      this._shaderLanguage = 1;
      await Promise.all([import("./depth.vertex-QSLB5UUJ.js"), import("./depth.fragment-W5OGO4OC.js")]);
    } else {
      await Promise.all([import("./depth.vertex-G6JHURO3.js"), import("./depth.fragment-FB4LWFMM.js")]);
    }
    this._shadersLoaded = true;
  }
  /**
   * Creates the depth rendering effect and checks if the effect is ready.
   * @param subMesh The submesh to be used to render the depth map of
   * @param useInstances If multiple world instances should be used
   * @returns if the depth renderer is ready to render the depth map
   */
  isReady(subMesh, useInstances) {
    if (!this._shadersLoaded) {
      return false;
    }
    const engine = this._scene.getEngine();
    const mesh = subMesh.getMesh();
    const scene = mesh.getScene();
    const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];
    if (renderingMaterial) {
      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);
    }
    const material = subMesh.getMaterial();
    if (!material || material.disableDepthWrite) {
      return false;
    }
    const defines = [];
    const attribs = [VertexBuffer.PositionKind];
    let uv1 = false;
    let uv2 = false;
    const color = false;
    if (material.needAlphaTestingForMesh(mesh) && material.getAlphaTestTexture()) {
      defines.push("#define ALPHATEST");
      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
        attribs.push(VertexBuffer.UVKind);
        defines.push("#define UV1");
        uv1 = true;
      }
      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
        attribs.push(VertexBuffer.UV2Kind);
        defines.push("#define UV2");
        uv2 = true;
      }
    }
    const fallbacks = new EffectFallbacks();
    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      if (mesh.numBoneInfluencers > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      const skeleton = mesh.skeleton;
      if (skeleton.isUsingTextureForMatrices) {
        defines.push("#define BONETEXTURE");
      } else {
        defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
      }
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    const numMorphInfluencers = mesh.morphTargetManager ? PrepareDefinesAndAttributesForMorphTargets(
      mesh.morphTargetManager,
      defines,
      attribs,
      mesh,
      true,
      // usePositionMorph
      false,
      // useNormalMorph
      false,
      // useTangentMorph
      uv1,
      // useUVMorph
      uv2,
      // useUV2Morph
      color
      // useColorMorph
    ) : 0;
    if (material.pointsCloud) {
      defines.push("#define POINTSIZE");
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      PushAttributesForInstances(attribs);
      if (subMesh.getRenderingMesh().hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
      }
    }
    const bvaManager = mesh.bakedVertexAnimationManager;
    if (bvaManager && bvaManager.isEnabled) {
      defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
      if (useInstances) {
        attribs.push("bakedVertexAnimationSettingsInstanced");
      }
    }
    if (this._storeNonLinearDepth) {
      defines.push("#define NONLINEARDEPTH");
    }
    if (this._storeCameraSpaceZ) {
      defines.push("#define STORE_CAMERASPACE_Z");
    }
    if (this.isPacked) {
      defines.push("#define PACKED");
    }
    PrepareStringDefinesForClipPlanes(material, scene, defines);
    const drawWrapper = subMesh._getDrawWrapper(void 0, true);
    const cachedDefines = drawWrapper.defines;
    const join = defines.join("\n");
    if (cachedDefines !== join) {
      const uniforms = [
        "world",
        "mBones",
        "boneTextureWidth",
        "pointSize",
        "viewProjection",
        "view",
        "diffuseMatrix",
        "depthValues",
        "morphTargetInfluences",
        "morphTargetCount",
        "morphTargetTextureInfo",
        "morphTargetTextureIndices",
        "bakedVertexAnimationSettings",
        "bakedVertexAnimationTextureSizeInverted",
        "bakedVertexAnimationTime",
        "bakedVertexAnimationTexture"
      ];
      const samplers = ["diffuseSampler", "morphTargets", "boneSampler", "bakedVertexAnimationTexture"];
      AddClipPlaneUniforms(uniforms);
      drawWrapper.setEffect(engine.createEffect("depth", {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: [],
        samplers,
        defines: join,
        fallbacks,
        onCompiled: null,
        onError: null,
        indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },
        shaderLanguage: this._shaderLanguage
      }, engine), join);
    }
    return drawWrapper.effect.isReady();
  }
  /**
   * Gets the texture which the depth map will be written to.
   * @returns The depth map texture
   */
  getDepthMap() {
    return this._depthMap;
  }
  /**
   * Disposes of the depth renderer.
   */
  dispose() {
    const keysToDelete = [];
    for (const key in this._scene._depthRenderer) {
      const depthRenderer = this._scene._depthRenderer[key];
      if (depthRenderer === this) {
        keysToDelete.push(key);
      }
    }
    if (keysToDelete.length > 0) {
      this._depthMap.dispose();
      for (const key of keysToDelete) {
        delete this._scene._depthRenderer[key];
      }
    }
  }
};
DepthRenderer.ForceGLSL = false;
DepthRenderer._SceneComponentInitialization = (_) => {
  throw _WarnImport("DepthRendererSceneComponent");
};

// node_modules/@babylonjs/core/Misc/thinMinMaxReducer.js
var DepthTextureType;
(function(DepthTextureType2) {
  DepthTextureType2[DepthTextureType2["NormalizedViewDepth"] = 0] = "NormalizedViewDepth";
  DepthTextureType2[DepthTextureType2["ViewDepth"] = 1] = "ViewDepth";
  DepthTextureType2[DepthTextureType2["ScreenDepth"] = 2] = "ScreenDepth";
})(DepthTextureType || (DepthTextureType = {}));
var ThinMinMaxReducerPostProcess = class _ThinMinMaxReducerPostProcess extends EffectWrapper {
  _gatherImports(useWebGPU, list) {
    if (useWebGPU) {
      this._webGPUReady = true;
      list.push(import("./minmaxRedux.fragment-VB2DD5DJ.js"));
    } else {
      list.push(import("./minmaxRedux.fragment-UGC7O67N.js"));
    }
  }
  constructor(name, engine = null, defines = "", options) {
    super({
      ...options,
      name,
      engine: engine || Engine.LastCreatedEngine,
      useShaderStore: true,
      useAsPostProcess: true,
      fragmentShader: _ThinMinMaxReducerPostProcess.FragmentUrl,
      uniforms: _ThinMinMaxReducerPostProcess.Uniforms,
      defines
    });
    this.textureWidth = 0;
    this.textureHeight = 0;
  }
  bind(noDefaultBindings = false) {
    super.bind(noDefaultBindings);
    const effect = this.drawWrapper.effect;
    if (this.textureWidth === 1 || this.textureHeight === 1) {
      effect.setInt2("texSize", this.textureWidth, this.textureHeight);
    } else {
      effect.setFloat2("texSize", this.textureWidth, this.textureHeight);
    }
  }
};
ThinMinMaxReducerPostProcess.FragmentUrl = "minmaxRedux";
ThinMinMaxReducerPostProcess.Uniforms = ["texSize"];
var BufferFloat = new Float32Array(4 * 1 * 1);
var BufferUint8 = new Uint8Array(4 * 1 * 1);
var MinMax = { min: 0, max: 0 };
var ThinMinMaxReducer = class {
  get depthRedux() {
    return this._depthRedux;
  }
  set depthRedux(value) {
    if (this._depthRedux === value) {
      return;
    }
    this._depthRedux = value;
    this._recreatePostProcesses();
  }
  get textureWidth() {
    return this._textureWidth;
  }
  get textureHeight() {
    return this._textureHeight;
  }
  constructor(scene, depthRedux = true) {
    this.onAfterReductionPerformed = new Observable();
    this._textureWidth = 0;
    this._textureHeight = 0;
    this._scene = scene;
    this._depthRedux = depthRedux;
    this.reductionSteps = [];
  }
  setTextureDimensions(width, height, depthTextureType = 0) {
    if (width === this._textureWidth && height === this._textureHeight && depthTextureType === this._depthTextureType) {
      return false;
    }
    this._textureWidth = width;
    this._textureHeight = height;
    this._depthTextureType = depthTextureType;
    this._recreatePostProcesses();
    return true;
  }
  readMinMax(texture) {
    const isFloat = texture.type === Engine.TEXTURETYPE_FLOAT || texture.type === Engine.TEXTURETYPE_HALF_FLOAT;
    const buffer = isFloat ? BufferFloat : BufferUint8;
    this._scene.getEngine()._readTexturePixels(texture, 1, 1, -1, 0, buffer, false);
    MinMax.min = buffer[0];
    MinMax.max = buffer[1];
    if (!isFloat) {
      MinMax.min = MinMax.min / 255;
      MinMax.max = MinMax.max / 255;
    }
    if (MinMax.min >= MinMax.max) {
      MinMax.min = 0;
      MinMax.max = 1;
    }
    this.onAfterReductionPerformed.notifyObservers(MinMax);
  }
  dispose(disposeAll = true) {
    if (disposeAll) {
      this.onAfterReductionPerformed.clear();
      this._textureWidth = 0;
      this._textureHeight = 0;
    }
    for (let i = 0; i < this.reductionSteps.length; ++i) {
      this.reductionSteps[i].dispose();
    }
    this.reductionSteps.length = 0;
  }
  _recreatePostProcesses() {
    this.dispose(false);
    const scene = this._scene;
    let w = this.textureWidth, h = this.textureHeight;
    const reductionInitial = new ThinMinMaxReducerPostProcess("Initial reduction phase", scene.getEngine(), "#define INITIAL" + (this._depthRedux ? "\n#define DEPTH_REDUX" : "") + (this._depthTextureType === 1 ? "\n#define VIEW_DEPTH" : ""));
    reductionInitial.textureWidth = w;
    reductionInitial.textureHeight = h;
    this.reductionSteps.push(reductionInitial);
    let index = 1;
    while (w > 1 || h > 1) {
      w = Math.max(Math.round(w / 2), 1);
      h = Math.max(Math.round(h / 2), 1);
      const reduction = new ThinMinMaxReducerPostProcess("Reduction phase " + index, scene.getEngine(), "#define " + (w == 1 && h == 1 ? "LAST" : w == 1 || h == 1 ? "ONEBEFORELAST" : "MAIN"));
      reduction.textureWidth = w;
      reduction.textureHeight = h;
      this.reductionSteps.push(reduction);
      index++;
    }
  }
};

// node_modules/@babylonjs/core/Misc/minMaxReducer.js
var MinMaxReducer = class {
  /**
   * Observable triggered when the computation has been performed
   */
  get onAfterReductionPerformed() {
    return this._thinMinMaxReducer.onAfterReductionPerformed;
  }
  /**
   * Creates a min/max reducer
   * @param camera The camera to use for the post processes
   */
  constructor(camera) {
    this._onAfterUnbindObserver = null;
    this._forceFullscreenViewport = true;
    this._activated = false;
    this._camera = camera;
    this._postProcessManager = new PostProcessManager(camera.getScene());
    this._thinMinMaxReducer = new ThinMinMaxReducer(camera.getScene());
    this._reductionSteps = [];
    this._onContextRestoredObserver = camera.getEngine().onContextRestoredObservable.add(() => {
      this._postProcessManager._rebuild();
    });
  }
  /**
   * Gets the texture used to read the values from.
   */
  get sourceTexture() {
    return this._sourceTexture;
  }
  /**
   * Sets the source texture to read the values from.
   * One must indicate if the texture is a depth texture or not through the depthRedux parameter
   * because in such textures '1' value must not be taken into account to compute the maximum
   * as this value is used to clear the texture.
   * Note that the computation is not activated by calling this function, you must call activate() for that!
   * @param sourceTexture The texture to read the values from. The values should be in the red channel.
   * @param depthRedux Indicates if the texture is a depth texture or not
   * @param type The type of the textures created for the reduction (defaults to TEXTURETYPE_HALF_FLOAT)
   * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)
   */
  setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {
    if (sourceTexture === this._sourceTexture) {
      return;
    }
    this._thinMinMaxReducer.depthRedux = depthRedux;
    this.deactivate();
    this._sourceTexture = sourceTexture;
    this._forceFullscreenViewport = forceFullscreenViewport;
    if (this._thinMinMaxReducer.setTextureDimensions(sourceTexture.getRenderWidth(), sourceTexture.getRenderHeight())) {
      this._disposePostProcesses();
      const reductionSteps = this._thinMinMaxReducer.reductionSteps;
      for (let i = 0; i < reductionSteps.length; ++i) {
        const reductionStep = reductionSteps[i];
        const postProcess = new PostProcess(reductionStep.name, ThinMinMaxReducerPostProcess.FragmentUrl, {
          effectWrapper: reductionStep,
          samplingMode: 1,
          engine: this._camera.getScene().getEngine(),
          textureType: type,
          textureFormat: 7,
          size: { width: reductionStep.textureWidth, height: reductionStep.textureHeight }
        });
        this._reductionSteps.push(postProcess);
        postProcess.autoClear = false;
        postProcess.forceFullscreenViewport = forceFullscreenViewport;
        if (i === 0) {
          postProcess.externalTextureSamplerBinding = true;
          postProcess.onApplyObservable.add((effect) => {
            effect.setTexture("textureSampler", this._sourceTexture);
          });
        }
        if (i === reductionSteps.length - 1) {
          this._reductionSteps[i - 1].onAfterRenderObservable.add(() => {
            this._thinMinMaxReducer.readMinMax(postProcess.inputTexture.texture);
          });
        }
      }
    }
  }
  /**
   * Defines the refresh rate of the computation.
   * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
   */
  get refreshRate() {
    return this._sourceTexture ? this._sourceTexture.refreshRate : -1;
  }
  set refreshRate(value) {
    if (this._sourceTexture) {
      this._sourceTexture.refreshRate = value;
    }
  }
  /**
   * Gets the activation status of the reducer
   */
  get activated() {
    return this._activated;
  }
  /**
   * Activates the reduction computation.
   * When activated, the observers registered in onAfterReductionPerformed are
   * called after the computation is performed
   */
  activate() {
    if (this._onAfterUnbindObserver || !this._sourceTexture) {
      return;
    }
    this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(() => {
      const engine = this._camera.getScene().getEngine();
      engine._debugPushGroup?.(`min max reduction`, 1);
      this._reductionSteps[0].activate(this._camera);
      this._postProcessManager.directRender(this._reductionSteps, this._reductionSteps[0].inputTexture, this._forceFullscreenViewport, 0, 0, true, this._reductionSteps.length - 1);
      engine.unBindFramebuffer(this._reductionSteps[this._reductionSteps.length - 1].inputTexture, false);
      engine._debugPopGroup?.(1);
    });
    this._activated = true;
  }
  /**
   * Deactivates the reduction computation.
   */
  deactivate() {
    if (!this._onAfterUnbindObserver || !this._sourceTexture) {
      return;
    }
    this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
    this._onAfterUnbindObserver = null;
    this._activated = false;
  }
  /**
   * Disposes the min/max reducer
   * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.
   */
  dispose(disposeAll = true) {
    if (!disposeAll) {
      return;
    }
    this.onAfterReductionPerformed.clear();
    this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
    this._onContextRestoredObserver = void 0;
    this._disposePostProcesses();
    this._postProcessManager.dispose();
    this._postProcessManager = void 0;
    this._thinMinMaxReducer.dispose();
    this._thinMinMaxReducer = void 0;
    this._sourceTexture = null;
  }
  _disposePostProcesses() {
    for (let i = 0; i < this._reductionSteps.length; ++i) {
      this._reductionSteps[i].dispose();
    }
    this._reductionSteps.length = 0;
  }
};

// node_modules/@babylonjs/core/Misc/depthReducer.js
var DepthReducer = class extends MinMaxReducer {
  /**
   * Gets the depth renderer used for the computation.
   * Note that the result is null if you provide your own renderer when calling setDepthRenderer.
   */
  get depthRenderer() {
    return this._depthRenderer;
  }
  /**
   * Creates a depth reducer
   * @param camera The camera used to render the depth texture
   */
  constructor(camera) {
    super(camera);
  }
  /**
   * Sets the depth renderer to use to generate the depth map
   * @param depthRenderer The depth renderer to use. If not provided, a new one will be created automatically
   * @param type The texture type of the depth map (default: TEXTURETYPE_HALF_FLOAT)
   * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)
   */
  setDepthRenderer(depthRenderer = null, type = 2, forceFullscreenViewport = true) {
    const scene = this._camera.getScene();
    if (this._depthRenderer) {
      delete scene._depthRenderer[this._depthRendererId];
      this._depthRenderer.dispose();
      this._depthRenderer = null;
    }
    if (depthRenderer === null) {
      if (!scene._depthRenderer) {
        scene._depthRenderer = {};
      }
      this._depthRendererId = "minmax_" + this._camera.id;
      depthRenderer = this._depthRenderer = new DepthRenderer(scene, type, this._camera, false, 1, false, `DepthRenderer ${this._depthRendererId}`);
      depthRenderer.enabled = false;
      scene._depthRenderer[this._depthRendererId] = depthRenderer;
    }
    super.setSourceTexture(depthRenderer.getDepthMap(), true, type, forceFullscreenViewport);
  }
  /**
   * @internal
   */
  setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {
    super.setSourceTexture(sourceTexture, depthRedux, type, forceFullscreenViewport);
  }
  /**
   * Activates the reduction computation.
   * When activated, the observers registered in onAfterReductionPerformed are
   * called after the computation is performed
   */
  activate() {
    if (this._depthRenderer) {
      this._depthRenderer.enabled = true;
    }
    super.activate();
  }
  /**
   * Deactivates the reduction computation.
   */
  deactivate() {
    super.deactivate();
    if (this._depthRenderer) {
      this._depthRenderer.enabled = false;
    }
  }
  /**
   * Disposes the depth reducer
   * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.
   */
  dispose(disposeAll = true) {
    super.dispose(disposeAll);
    if (this._depthRenderer && disposeAll) {
      this._depthRenderer.dispose();
      this._depthRenderer = null;
    }
  }
};

// node_modules/@babylonjs/core/Lights/Shadows/cascadedShadowGenerator.js
var UpDir = Vector3.Up();
var ZeroVec = Vector3.Zero();
var Tmpv1 = new Vector3();
var Tmpv2 = new Vector3();
var TmpMatrix = new Matrix();
var CascadedShadowGenerator = class _CascadedShadowGenerator extends ShadowGenerator {
  _validateFilter(filter) {
    if (filter === ShadowGenerator.FILTER_NONE || filter === ShadowGenerator.FILTER_PCF || filter === ShadowGenerator.FILTER_PCSS) {
      return filter;
    }
    Logger.Error('Unsupported filter "' + filter + '"!');
    return ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets or set the number of cascades used by the CSM.
   */
  get numCascades() {
    return this._numCascades;
  }
  set numCascades(value) {
    value = Math.min(Math.max(value, _CascadedShadowGenerator.MIN_CASCADES_COUNT), _CascadedShadowGenerator.MAX_CASCADES_COUNT);
    if (value === this._numCascades) {
      return;
    }
    this._numCascades = value;
    this.recreateShadowMap();
    this._recreateSceneUBOs();
  }
  /**
   * Enables or disables the shadow casters bounding info computation.
   * If your shadow casters don't move, you can disable this feature.
   * If it is enabled, the bounding box computation is done every frame.
   */
  get freezeShadowCastersBoundingInfo() {
    return this._freezeShadowCastersBoundingInfo;
  }
  set freezeShadowCastersBoundingInfo(freeze) {
    if (this._freezeShadowCastersBoundingInfoObservable && freeze) {
      this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);
      this._freezeShadowCastersBoundingInfoObservable = null;
    }
    if (!this._freezeShadowCastersBoundingInfoObservable && !freeze) {
      this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(() => this._computeShadowCastersBoundingInfo());
    }
    this._freezeShadowCastersBoundingInfo = freeze;
    if (freeze) {
      this._computeShadowCastersBoundingInfo();
    }
  }
  _computeShadowCastersBoundingInfo() {
    this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._scbiMax.copyFromFloats(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    if (this._shadowMap && this._shadowMap.renderList) {
      const renderList = this._shadowMap.renderList;
      for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
        const mesh = renderList[meshIndex];
        if (!mesh) {
          continue;
        }
        const boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;
        this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);
        this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);
      }
    }
    this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);
  }
  /**
   * Gets or sets the shadow casters bounding info.
   * If you provide your own shadow casters bounding info, first enable freezeShadowCastersBoundingInfo
   * so that the system won't overwrite the bounds you provide
   */
  get shadowCastersBoundingInfo() {
    return this._shadowCastersBoundingInfo;
  }
  set shadowCastersBoundingInfo(boundingInfo) {
    this._shadowCastersBoundingInfo = boundingInfo;
  }
  /**
   * Sets the minimal and maximal distances to use when computing the cascade breaks.
   *
   * The values of min / max are typically the depth zmin and zmax values of your scene, for a given frame.
   * If you don't know these values, simply leave them to their defaults and don't call this function.
   * @param min minimal distance for the breaks (default to 0.)
   * @param max maximal distance for the breaks (default to 1.)
   */
  setMinMaxDistance(min, max) {
    if (this._minDistance === min && this._maxDistance === max) {
      return;
    }
    if (min > max) {
      min = 0;
      max = 1;
    }
    if (min < 0) {
      min = 0;
    }
    if (max > 1) {
      max = 1;
    }
    this._minDistance = min;
    this._maxDistance = max;
    this._breaksAreDirty = true;
  }
  /** Gets the minimal distance used in the cascade break computation */
  get minDistance() {
    return this._minDistance;
  }
  /** Gets the maximal distance used in the cascade break computation */
  get maxDistance() {
    return this._maxDistance;
  }
  /**
   * Gets the class name of that object
   * @returns "CascadedShadowGenerator"
   */
  getClassName() {
    return _CascadedShadowGenerator.CLASSNAME;
  }
  /**
   * Gets a cascade minimum extents
   * @param cascadeIndex index of the cascade
   * @returns the minimum cascade extents
   */
  getCascadeMinExtents(cascadeIndex) {
    return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMinExtents[cascadeIndex] : null;
  }
  /**
   * Gets a cascade maximum extents
   * @param cascadeIndex index of the cascade
   * @returns the maximum cascade extents
   */
  getCascadeMaxExtents(cascadeIndex) {
    return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMaxExtents[cascadeIndex] : null;
  }
  /**
   * Gets the shadow max z distance. It's the limit beyond which shadows are not displayed.
   * It defaults to camera.maxZ
   */
  get shadowMaxZ() {
    if (!this._getCamera()) {
      return 0;
    }
    return this._shadowMaxZ;
  }
  /**
   * Sets the shadow max z distance.
   */
  set shadowMaxZ(value) {
    const camera = this._getCamera();
    if (!camera) {
      this._shadowMaxZ = value;
      return;
    }
    if (this._shadowMaxZ === value || value < camera.minZ || value > camera.maxZ && camera.maxZ !== 0) {
      return;
    }
    this._shadowMaxZ = value;
    this._light._markMeshesAsLightDirty();
    this._breaksAreDirty = true;
  }
  /**
   * Gets or sets the debug flag.
   * When enabled, the cascades are materialized by different colors on the screen.
   */
  get debug() {
    return this._debug;
  }
  set debug(dbg) {
    this._debug = dbg;
    this._light._markMeshesAsLightDirty();
  }
  /**
   * Gets or sets the depth clamping value.
   *
   * When enabled, it improves the shadow quality because the near z plane of the light frustum don't need to be adjusted
   * to account for the shadow casters far away.
   *
   * Note that this property is incompatible with PCSS filtering, so it won't be used in that case.
   */
  get depthClamp() {
    return this._depthClamp;
  }
  set depthClamp(value) {
    this._depthClamp = value;
  }
  /**
   * Gets or sets the percentage of blending between two cascades (value between 0. and 1.).
   * It defaults to 0.1 (10% blending).
   */
  get cascadeBlendPercentage() {
    return this._cascadeBlendPercentage;
  }
  set cascadeBlendPercentage(value) {
    this._cascadeBlendPercentage = value;
    this._light._markMeshesAsLightDirty();
  }
  /**
   * Gets or set the lambda parameter.
   * This parameter is used to split the camera frustum and create the cascades.
   * It's a value between 0. and 1.: If 0, the split is a uniform split of the frustum, if 1 it is a logarithmic split.
   * For all values in-between, it's a linear combination of the uniform and logarithm split algorithm.
   */
  get lambda() {
    return this._lambda;
  }
  set lambda(value) {
    const lambda = Math.min(Math.max(value, 0), 1);
    if (this._lambda == lambda) {
      return;
    }
    this._lambda = lambda;
    this._breaksAreDirty = true;
  }
  /**
   * Gets the view matrix corresponding to a given cascade
   * @param cascadeNum cascade to retrieve the view matrix from
   * @returns the cascade view matrix
   */
  getCascadeViewMatrix(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._viewMatrices[cascadeNum] : null;
  }
  /**
   * Gets the projection matrix corresponding to a given cascade
   * @param cascadeNum cascade to retrieve the projection matrix from
   * @returns the cascade projection matrix
   */
  getCascadeProjectionMatrix(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._projectionMatrices[cascadeNum] : null;
  }
  /**
   * Gets the transformation matrix corresponding to a given cascade
   * @param cascadeNum cascade to retrieve the transformation matrix from
   * @returns the cascade transformation matrix
   */
  getCascadeTransformMatrix(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._transformMatrices[cascadeNum] : null;
  }
  /**
   * Sets the depth renderer to use when autoCalcDepthBounds is enabled.
   *
   * Note that if no depth renderer is set, a new one will be automatically created internally when necessary.
   *
   * You should call this function if you already have a depth renderer enabled in your scene, to avoid
   * doing multiple depth rendering each frame. If you provide your own depth renderer, make sure it stores linear depth!
   * @param depthRenderer The depth renderer to use when autoCalcDepthBounds is enabled. If you pass null or don't call this function at all, a depth renderer will be automatically created
   */
  setDepthRenderer(depthRenderer) {
    this._depthRenderer = depthRenderer;
    if (this._depthReducer) {
      this._depthReducer.setDepthRenderer(this._depthRenderer);
    }
  }
  /**
   * Gets or sets the autoCalcDepthBounds property.
   *
   * When enabled, a depth rendering pass is first performed (with an internally created depth renderer or with the one
   * you provide by calling setDepthRenderer). Then, a min/max reducing is applied on the depth map to compute the
   * minimal and maximal depth of the map and those values are used as inputs for the setMinMaxDistance() function.
   * It can greatly enhance the shadow quality, at the expense of more GPU works.
   * When using this option, you should increase the value of the lambda parameter, and even set it to 1 for best results.
   */
  get autoCalcDepthBounds() {
    return this._autoCalcDepthBounds;
  }
  set autoCalcDepthBounds(value) {
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    this._autoCalcDepthBounds = value;
    if (!value) {
      if (this._depthReducer) {
        this._depthReducer.deactivate();
      }
      this.setMinMaxDistance(0, 1);
      return;
    }
    if (!this._depthReducer) {
      this._depthReducer = new DepthReducer(camera);
      this._depthReducer.onAfterReductionPerformed.add((minmax) => {
        let min = minmax.min, max = minmax.max;
        if (min >= max) {
          min = 0;
          max = 1;
        }
        if (min != this._minDistance || max != this._maxDistance) {
          this.setMinMaxDistance(min, max);
        }
      });
      this._depthReducer.setDepthRenderer(this._depthRenderer);
    }
    this._depthReducer.activate();
  }
  /**
   * Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true
   * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
   * Note that if you provided your own depth renderer through a call to setDepthRenderer, you are responsible
   * for setting the refresh rate on the renderer yourself!
   */
  get autoCalcDepthBoundsRefreshRate() {
    return this._depthReducer?.depthRenderer?.getDepthMap().refreshRate ?? -1;
  }
  set autoCalcDepthBoundsRefreshRate(value) {
    if (this._depthReducer?.depthRenderer) {
      this._depthReducer.depthRenderer.getDepthMap().refreshRate = value;
    }
  }
  /**
   * Create the cascade breaks according to the lambda, shadowMaxZ and min/max distance properties, as well as the camera near and far planes.
   * This function is automatically called when updating lambda, shadowMaxZ and min/max distances, however you should call it yourself if
   * you change the camera near/far planes!
   */
  splitFrustum() {
    this._breaksAreDirty = true;
  }
  _splitFrustum() {
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    const near = camera.minZ, far = camera.maxZ || this._shadowMaxZ, cameraRange = far - near, minDistance = this._minDistance, maxDistance = this._shadowMaxZ < far && this._shadowMaxZ >= near ? Math.min((this._shadowMaxZ - near) / (far - near), this._maxDistance) : this._maxDistance;
    const minZ = near + minDistance * cameraRange, maxZ = near + maxDistance * cameraRange;
    const range = maxZ - minZ, ratio = maxZ / minZ;
    for (let cascadeIndex = 0; cascadeIndex < this._cascades.length; ++cascadeIndex) {
      const p = (cascadeIndex + 1) / this._numCascades, log = minZ * ratio ** p, uniform = minZ + range * p;
      const d = this._lambda * (log - uniform) + uniform;
      this._cascades[cascadeIndex].prevBreakDistance = cascadeIndex === 0 ? minDistance : this._cascades[cascadeIndex - 1].breakDistance;
      this._cascades[cascadeIndex].breakDistance = (d - near) / cameraRange;
      this._viewSpaceFrustumsZ[cascadeIndex] = d;
      this._frustumLengths[cascadeIndex] = (this._cascades[cascadeIndex].breakDistance - this._cascades[cascadeIndex].prevBreakDistance) * cameraRange;
    }
    this._breaksAreDirty = false;
  }
  _computeMatrices() {
    const scene = this._scene;
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    Vector3.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection);
    if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1) {
      this._lightDirection.z = 1e-13;
    }
    this._cachedDirection.copyFrom(this._lightDirection);
    const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;
    for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
      this._computeFrustumInWorldSpace(cascadeIndex);
      this._computeCascadeFrustum(cascadeIndex);
      this._cascadeMaxExtents[cascadeIndex].subtractToRef(this._cascadeMinExtents[cascadeIndex], Tmpv1);
      this._frustumCenter[cascadeIndex].addToRef(this._lightDirection.scale(this._cascadeMinExtents[cascadeIndex].z), this._shadowCameraPos[cascadeIndex]);
      Matrix.LookAtLHToRef(this._shadowCameraPos[cascadeIndex], this._frustumCenter[cascadeIndex], UpDir, this._viewMatrices[cascadeIndex]);
      let viewMinZ = 0, viewMaxZ = Tmpv1.z;
      const boundingInfo = this._shadowCastersBoundingInfo;
      boundingInfo.update(this._viewMatrices[cascadeIndex]);
      const castersViewMinZ = boundingInfo.boundingBox.minimumWorld.z;
      const castersViewMaxZ = boundingInfo.boundingBox.maximumWorld.z;
      if (castersViewMinZ > viewMaxZ) {
      } else {
        if (!this._depthClamp || this.filter === ShadowGenerator.FILTER_PCSS) {
          viewMinZ = Math.min(viewMinZ, castersViewMinZ);
          if (this.filter !== ShadowGenerator.FILTER_PCSS) {
            viewMaxZ = Math.min(viewMaxZ, castersViewMaxZ);
          }
        } else {
          viewMaxZ = Math.min(viewMaxZ, castersViewMaxZ);
          viewMinZ = Math.max(viewMinZ, castersViewMinZ);
          viewMaxZ = Math.max(viewMinZ + 1, viewMaxZ);
        }
      }
      Matrix.OrthoOffCenterLHToRef(this._cascadeMinExtents[cascadeIndex].x, this._cascadeMaxExtents[cascadeIndex].x, this._cascadeMinExtents[cascadeIndex].y, this._cascadeMaxExtents[cascadeIndex].y, useReverseDepthBuffer ? viewMaxZ : viewMinZ, useReverseDepthBuffer ? viewMinZ : viewMaxZ, this._projectionMatrices[cascadeIndex], scene.getEngine().isNDCHalfZRange);
      this._cascadeMinExtents[cascadeIndex].z = viewMinZ;
      this._cascadeMaxExtents[cascadeIndex].z = viewMaxZ;
      this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);
      Vector3.TransformCoordinatesToRef(ZeroVec, this._transformMatrices[cascadeIndex], Tmpv1);
      Tmpv1.scaleInPlace(this._mapSize / 2);
      Tmpv2.copyFromFloats(Math.round(Tmpv1.x), Math.round(Tmpv1.y), Math.round(Tmpv1.z));
      Tmpv2.subtractInPlace(Tmpv1).scaleInPlace(2 / this._mapSize);
      Matrix.TranslationToRef(Tmpv2.x, Tmpv2.y, 0, TmpMatrix);
      this._projectionMatrices[cascadeIndex].multiplyToRef(TmpMatrix, this._projectionMatrices[cascadeIndex]);
      this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);
      this._transformMatrices[cascadeIndex].copyToArray(this._transformMatricesAsArray, cascadeIndex * 16);
    }
  }
  // Get the 8 points of the view frustum in world space
  _computeFrustumInWorldSpace(cascadeIndex) {
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    const prevSplitDist = this._cascades[cascadeIndex].prevBreakDistance, splitDist = this._cascades[cascadeIndex].breakDistance;
    const isNDCHalfZRange = this._scene.getEngine().isNDCHalfZRange;
    camera.getViewMatrix();
    const cameraInfiniteFarPlane = camera.maxZ === 0;
    const saveCameraMaxZ = camera.maxZ;
    if (cameraInfiniteFarPlane) {
      camera.maxZ = this._shadowMaxZ;
      camera.getProjectionMatrix(true);
    }
    const invViewProj = Matrix.Invert(camera.getTransformationMatrix());
    if (cameraInfiniteFarPlane) {
      camera.maxZ = saveCameraMaxZ;
      camera.getProjectionMatrix(true);
    }
    const cornerIndexOffset = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;
    for (let cornerIndex = 0; cornerIndex < _CascadedShadowGenerator._FrustumCornersNdcSpace.length; ++cornerIndex) {
      Tmpv1.copyFrom(_CascadedShadowGenerator._FrustumCornersNdcSpace[(cornerIndex + cornerIndexOffset) % _CascadedShadowGenerator._FrustumCornersNdcSpace.length]);
      if (isNDCHalfZRange && Tmpv1.z === -1) {
        Tmpv1.z = 0;
      }
      Vector3.TransformCoordinatesToRef(Tmpv1, invViewProj, this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
    }
    for (let cornerIndex = 0; cornerIndex < _CascadedShadowGenerator._FrustumCornersNdcSpace.length / 2; ++cornerIndex) {
      Tmpv1.copyFrom(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4]).subtractInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
      Tmpv2.copyFrom(Tmpv1).scaleInPlace(prevSplitDist);
      Tmpv1.scaleInPlace(splitDist);
      Tmpv1.addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
      this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4].copyFrom(Tmpv1);
      this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].addInPlace(Tmpv2);
    }
  }
  _computeCascadeFrustum(cascadeIndex) {
    this._cascadeMinExtents[cascadeIndex].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cascadeMaxExtents[cascadeIndex].copyFromFloats(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    this._frustumCenter[cascadeIndex].copyFromFloats(0, 0, 0);
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
      this._frustumCenter[cascadeIndex].addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
    }
    this._frustumCenter[cascadeIndex].scaleInPlace(1 / this._frustumCornersWorldSpace[cascadeIndex].length);
    if (this.stabilizeCascades) {
      let sphereRadius = 0;
      for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
        const dist = this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].subtractToRef(this._frustumCenter[cascadeIndex], Tmpv1).length();
        sphereRadius = Math.max(sphereRadius, dist);
      }
      sphereRadius = Math.ceil(sphereRadius * 16) / 16;
      this._cascadeMaxExtents[cascadeIndex].copyFromFloats(sphereRadius, sphereRadius, sphereRadius);
      this._cascadeMinExtents[cascadeIndex].copyFromFloats(-sphereRadius, -sphereRadius, -sphereRadius);
    } else {
      const lightCameraPos = this._frustumCenter[cascadeIndex];
      this._frustumCenter[cascadeIndex].addToRef(this._lightDirection, Tmpv1);
      Matrix.LookAtLHToRef(lightCameraPos, Tmpv1, UpDir, TmpMatrix);
      for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
        Vector3.TransformCoordinatesToRef(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex], TmpMatrix, Tmpv1);
        this._cascadeMinExtents[cascadeIndex].minimizeInPlace(Tmpv1);
        this._cascadeMaxExtents[cascadeIndex].maximizeInPlace(Tmpv1);
      }
    }
  }
  _recreateSceneUBOs() {
    this._disposeSceneUBOs();
    if (this._sceneUBOs) {
      for (let i = 0; i < this._numCascades; ++i) {
        this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${i})`));
      }
    }
  }
  /**
   *  Support test.
   */
  static get IsSupported() {
    const engine = EngineStore.LastCreatedEngine;
    if (!engine) {
      return false;
    }
    return engine._features.supportCSM;
  }
  /**
   * Creates a Cascaded Shadow Generator object.
   * A ShadowGenerator is the required tool to use the shadows.
   * Each directional light casting shadows needs to use its own ShadowGenerator.
   * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows
   * @param mapSize The size of the texture what stores the shadows. Example : 1024.
   * @param light The directional light object generating the shadows.
   * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
   * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it
   * @param useRedTextureType Forces the generator to use a Red instead of a RGBA type for the shadow map texture format (default: true)
   */
  constructor(mapSize, light, usefulFloatFirst, camera, useRedTextureType = true) {
    if (!_CascadedShadowGenerator.IsSupported) {
      Logger.Error("CascadedShadowMap is not supported by the current engine.");
      return;
    }
    super(mapSize, light, usefulFloatFirst, camera, useRedTextureType);
    this.usePercentageCloserFiltering = true;
  }
  _initializeGenerator() {
    this.penumbraDarkness = this.penumbraDarkness ?? 1;
    this._numCascades = this._numCascades ?? _CascadedShadowGenerator.DEFAULT_CASCADES_COUNT;
    this.stabilizeCascades = this.stabilizeCascades ?? false;
    this._freezeShadowCastersBoundingInfoObservable = this._freezeShadowCastersBoundingInfoObservable ?? null;
    this.freezeShadowCastersBoundingInfo = this.freezeShadowCastersBoundingInfo ?? false;
    this._scbiMin = this._scbiMin ?? new Vector3(0, 0, 0);
    this._scbiMax = this._scbiMax ?? new Vector3(0, 0, 0);
    this._shadowCastersBoundingInfo = this._shadowCastersBoundingInfo ?? new BoundingInfo(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    this._breaksAreDirty = this._breaksAreDirty ?? true;
    this._minDistance = this._minDistance ?? 0;
    this._maxDistance = this._maxDistance ?? 1;
    this._currentLayer = this._currentLayer ?? 0;
    this._shadowMaxZ = this._shadowMaxZ ?? this._getCamera()?.maxZ ?? 1e4;
    this._debug = this._debug ?? false;
    this._depthClamp = this._depthClamp ?? true;
    this._cascadeBlendPercentage = this._cascadeBlendPercentage ?? 0.1;
    this._lambda = this._lambda ?? 0.5;
    this._autoCalcDepthBounds = this._autoCalcDepthBounds ?? false;
    this._recreateSceneUBOs();
    super._initializeGenerator();
  }
  _createTargetRenderTexture() {
    const engine = this._scene.getEngine();
    this._shadowMap?.dispose();
    const size = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };
    this._shadowMap = new RenderTargetTexture(this._light.name + "_CSMShadowMap", size, this._scene, false, true, this._textureType, false, void 0, false, false, void 0, this._useRedTextureType ? 6 : 5);
    this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true, void 0, void 0, void 0, `DepthStencilForCSMShadowGenerator-${this._light.name}`);
    this._shadowMap.noPrePassRenderer = true;
  }
  _initializeShadowMap() {
    super._initializeShadowMap();
    if (this._shadowMap === null) {
      return;
    }
    this._transformMatricesAsArray = new Float32Array(this._numCascades * 16);
    this._tempTransformMatricesAsArray = new Float32Array(this._numCascades * 16);
    this._viewSpaceFrustumsZ = new Array(this._numCascades);
    this._frustumLengths = new Array(this._numCascades);
    this._lightSizeUVCorrection = new Array(this._numCascades * 2);
    this._depthCorrection = new Array(this._numCascades);
    this._cascades = [];
    this._viewMatrices = [];
    this._projectionMatrices = [];
    this._transformMatrices = [];
    this._cascadeMinExtents = [];
    this._cascadeMaxExtents = [];
    this._frustumCenter = [];
    this._shadowCameraPos = [];
    this._frustumCornersWorldSpace = [];
    for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
      this._cascades[cascadeIndex] = {
        prevBreakDistance: 0,
        breakDistance: 0
      };
      this._viewMatrices[cascadeIndex] = Matrix.Zero();
      this._projectionMatrices[cascadeIndex] = Matrix.Zero();
      this._transformMatrices[cascadeIndex] = Matrix.Zero();
      this._cascadeMinExtents[cascadeIndex] = new Vector3();
      this._cascadeMaxExtents[cascadeIndex] = new Vector3();
      this._frustumCenter[cascadeIndex] = new Vector3();
      this._shadowCameraPos[cascadeIndex] = new Vector3();
      this._frustumCornersWorldSpace[cascadeIndex] = new Array(_CascadedShadowGenerator._FrustumCornersNdcSpace.length);
      for (let i = 0; i < _CascadedShadowGenerator._FrustumCornersNdcSpace.length; ++i) {
        this._frustumCornersWorldSpace[cascadeIndex][i] = new Vector3();
      }
    }
    const engine = this._scene.getEngine();
    this._shadowMap.onBeforeBindObservable.clear();
    this._shadowMap.onBeforeRenderObservable.clear();
    this._shadowMap.onBeforeRenderObservable.add((layer) => {
      if (this._sceneUBOs) {
        this._scene.setSceneUniformBuffer(this._sceneUBOs[layer]);
      }
      this._currentLayer = layer;
      if (this._filter === ShadowGenerator.FILTER_PCF) {
        engine.setColorWrite(false);
      }
      FloatingOriginCurrentScene.eyeAtCamera = false;
      this._scene.setTransformMatrix(this.getCascadeViewMatrix(layer), this.getCascadeProjectionMatrix(layer));
      if (this._useUBO) {
        this._scene.getSceneUniformBuffer().unbindEffect();
        this._scene.finalizeSceneUbo();
      }
    });
    this._shadowMap.onBeforeBindObservable.add(() => {
      this._currentSceneUBO = this._scene.getSceneUniformBuffer();
      engine._debugPushGroup?.(`cascaded shadow map generation for pass id ${engine.currentRenderPassId}`, 1);
      if (this._breaksAreDirty) {
        this._splitFrustum();
      }
      this._computeMatrices();
    });
    this._splitFrustum();
  }
  _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect) {
    effect.setMatrix("viewProjection", this.getCascadeTransformMatrix(this._currentLayer));
  }
  _isReadyCustomDefines(defines) {
    defines.push("#define SM_DEPTHCLAMP " + (this._depthClamp && this._filter !== ShadowGenerator.FILTER_PCSS ? "1" : "0"));
  }
  /**
   * Prepare all the defines in a material relying on a shadow map at the specified light index.
   * @param defines Defines of the material we want to update
   * @param lightIndex Index of the light in the enabled light list of the material
   */
  prepareDefines(defines, lightIndex) {
    super.prepareDefines(defines, lightIndex);
    const scene = this._scene;
    const light = this._light;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    defines["SHADOWCSM" + lightIndex] = true;
    defines["SHADOWCSMDEBUG" + lightIndex] = this.debug;
    defines["SHADOWCSMNUM_CASCADES" + lightIndex] = this.numCascades;
    defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = scene.useRightHandedSystem;
    const camera = this._getCamera();
    if (camera && this._shadowMaxZ <= (camera.maxZ || this._shadowMaxZ)) {
      defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = true;
    }
    if (this.cascadeBlendPercentage === 0) {
      defines["SHADOWCSMNOBLEND" + lightIndex] = true;
    }
  }
  /**
   * Binds the shadow related information inside of an effect (information like near, far, darkness...
   * defined in the generator but impacting the effect).
   * @param lightIndex Index of the light in the enabled light list of the material owning the effect
   * @param effect The effect we are binfing the information for
   */
  bindShadowLight(lightIndex, effect) {
    const light = this._light;
    const scene = this._scene;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return;
    }
    const width = shadowMap.getSize().width;
    const transform = this._transformMatricesAsArray;
    const lightMatrix = scene.floatingOriginMode ? GetOffsetTransformMatrices(this._scene.floatingOriginOffset, this._viewMatrices, this._projectionMatrices, this._numCascades, this._tempTransformMatricesAsArray) : transform;
    effect.setMatrices("lightMatrix" + lightIndex, lightMatrix);
    effect.setArray("viewFrustumZ" + lightIndex, this._viewSpaceFrustumsZ);
    effect.setFloat("cascadeBlendFactor" + lightIndex, this.cascadeBlendPercentage === 0 ? 1e4 : 1 / this.cascadeBlendPercentage);
    effect.setArray("frustumLengths" + lightIndex, this._frustumLengths);
    if (this._filter === ShadowGenerator.FILTER_PCF) {
      effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMap);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);
    } else if (this._filter === ShadowGenerator.FILTER_PCSS) {
      for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
        this._lightSizeUVCorrection[cascadeIndex * 2 + 0] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[cascadeIndex].x - this._cascadeMinExtents[cascadeIndex].x);
        this._lightSizeUVCorrection[cascadeIndex * 2 + 1] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[cascadeIndex].y - this._cascadeMinExtents[cascadeIndex].y);
        this._depthCorrection[cascadeIndex] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[cascadeIndex].z - this._cascadeMinExtents[cascadeIndex].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);
      }
      effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMap);
      effect.setTexture("depthTexture" + lightIndex, shadowMap);
      effect.setArray2("lightSizeUVCorrection" + lightIndex, this._lightSizeUVCorrection);
      effect.setArray("depthCorrection" + lightIndex, this._depthCorrection);
      effect.setFloat("penumbraDarkness" + lightIndex, this.penumbraDarkness);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / width, this._contactHardeningLightSizeUVRatio * width, this.frustumEdgeFalloff, lightIndex);
    } else {
      effect.setTexture("shadowTexture" + lightIndex, shadowMap);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);
    }
    light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
  }
  /**
   * Gets the transformation matrix of the first cascade used to project the meshes into the map from the light point of view.
   * (eq to view projection * shadow projection matrices)
   * @returns The transform matrix used to create the shadow map
   */
  getTransformMatrix() {
    return this.getCascadeTransformMatrix(0);
  }
  /**
   * Disposes the ShadowGenerator.
   * Returns nothing.
   */
  dispose() {
    super.dispose();
    if (this._freezeShadowCastersBoundingInfoObservable) {
      this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);
      this._freezeShadowCastersBoundingInfoObservable = null;
    }
    if (this._depthReducer) {
      this._depthReducer.dispose();
      this._depthReducer = null;
    }
  }
  /**
   * Serializes the shadow generator setup to a json object.
   * @returns The serialized JSON object
   */
  serialize() {
    const serializationObject = super.serialize();
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return serializationObject;
    }
    serializationObject.numCascades = this._numCascades;
    serializationObject.debug = this._debug;
    serializationObject.stabilizeCascades = this.stabilizeCascades;
    serializationObject.lambda = this._lambda;
    serializationObject.cascadeBlendPercentage = this.cascadeBlendPercentage;
    serializationObject.depthClamp = this._depthClamp;
    serializationObject.autoCalcDepthBounds = this.autoCalcDepthBounds;
    serializationObject.shadowMaxZ = this._shadowMaxZ;
    serializationObject.penumbraDarkness = this.penumbraDarkness;
    serializationObject.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo;
    serializationObject.minDistance = this.minDistance;
    serializationObject.maxDistance = this.maxDistance;
    serializationObject.renderList = [];
    if (shadowMap.renderList) {
      for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
        const mesh = shadowMap.renderList[meshIndex];
        serializationObject.renderList.push(mesh.id);
      }
    }
    return serializationObject;
  }
  /**
   * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
   * @param parsedShadowGenerator The JSON object to parse
   * @param scene The scene to create the shadow map for
   * @returns The parsed shadow generator
   */
  static Parse(parsedShadowGenerator, scene) {
    const shadowGenerator = ShadowGenerator.Parse(parsedShadowGenerator, scene, (mapSize, light, camera) => new _CascadedShadowGenerator(mapSize, light, void 0, camera));
    if (parsedShadowGenerator.numCascades !== void 0) {
      shadowGenerator.numCascades = parsedShadowGenerator.numCascades;
    }
    if (parsedShadowGenerator.debug !== void 0) {
      shadowGenerator.debug = parsedShadowGenerator.debug;
    }
    if (parsedShadowGenerator.stabilizeCascades !== void 0) {
      shadowGenerator.stabilizeCascades = parsedShadowGenerator.stabilizeCascades;
    }
    if (parsedShadowGenerator.lambda !== void 0) {
      shadowGenerator.lambda = parsedShadowGenerator.lambda;
    }
    if (parsedShadowGenerator.cascadeBlendPercentage !== void 0) {
      shadowGenerator.cascadeBlendPercentage = parsedShadowGenerator.cascadeBlendPercentage;
    }
    if (parsedShadowGenerator.depthClamp !== void 0) {
      shadowGenerator.depthClamp = parsedShadowGenerator.depthClamp;
    }
    if (parsedShadowGenerator.autoCalcDepthBounds !== void 0) {
      shadowGenerator.autoCalcDepthBounds = parsedShadowGenerator.autoCalcDepthBounds;
    }
    if (parsedShadowGenerator.shadowMaxZ !== void 0) {
      shadowGenerator.shadowMaxZ = parsedShadowGenerator.shadowMaxZ;
    }
    if (parsedShadowGenerator.penumbraDarkness !== void 0) {
      shadowGenerator.penumbraDarkness = parsedShadowGenerator.penumbraDarkness;
    }
    if (parsedShadowGenerator.freezeShadowCastersBoundingInfo !== void 0) {
      shadowGenerator.freezeShadowCastersBoundingInfo = parsedShadowGenerator.freezeShadowCastersBoundingInfo;
    }
    if (parsedShadowGenerator.minDistance !== void 0 && parsedShadowGenerator.maxDistance !== void 0) {
      shadowGenerator.setMinMaxDistance(parsedShadowGenerator.minDistance, parsedShadowGenerator.maxDistance);
    }
    return shadowGenerator;
  }
};
CascadedShadowGenerator._FrustumCornersNdcSpace = [
  new Vector3(-1, 1, -1),
  new Vector3(1, 1, -1),
  new Vector3(1, -1, -1),
  new Vector3(-1, -1, -1),
  new Vector3(-1, 1, 1),
  new Vector3(1, 1, 1),
  new Vector3(1, -1, 1),
  new Vector3(-1, -1, 1)
];
CascadedShadowGenerator.CLASSNAME = "CascadedShadowGenerator";
CascadedShadowGenerator.DEFAULT_CASCADES_COUNT = 4;
CascadedShadowGenerator.MIN_CASCADES_COUNT = 2;
CascadedShadowGenerator.MAX_CASCADES_COUNT = 4;
CascadedShadowGenerator._SceneComponentInitialization = (_) => {
  throw _WarnImport("ShadowGeneratorSceneComponent");
};

// node_modules/@babylonjs/core/FrameGraph/Tasks/Rendering/shadowGeneratorTask.js
var FrameGraphShadowGeneratorTask = class extends FrameGraphTask {
  /**
   * The light to generate shadows from.
   */
  get light() {
    return this._light;
  }
  set light(value) {
    if (value === this._light) {
      return;
    }
    this._light = value;
    this._setupShadowGenerator();
  }
  /**
   * Gets or sets the camera used to generate the shadow generator.
   */
  get camera() {
    return this._camera;
  }
  set camera(camera) {
    this._camera = camera;
    this._setupShadowGenerator();
  }
  /**
   * The size of the shadow map.
   */
  get mapSize() {
    return this._mapSize;
  }
  set mapSize(value) {
    if (value === this._mapSize) {
      return;
    }
    this._mapSize = value;
    this._setupShadowGenerator();
  }
  /**
   * If true, the shadow map will use a 32 bits float texture type (else, 16 bits float is used if supported).
   */
  get useFloat32TextureType() {
    return this._useFloat32TextureType;
  }
  set useFloat32TextureType(value) {
    if (value === this._useFloat32TextureType) {
      return;
    }
    this._useFloat32TextureType = value;
    this._setupShadowGenerator();
  }
  /**
   * If true, the shadow map will use a red texture format (else, a RGBA format is used).
   */
  get useRedTextureFormat() {
    return this._useRedTextureFormat;
  }
  set useRedTextureFormat(value) {
    if (value === this._useRedTextureFormat) {
      return;
    }
    this._useRedTextureFormat = value;
    this._setupShadowGenerator();
  }
  /**
   * The bias to apply to the shadow map.
   */
  get bias() {
    return this._bias;
  }
  set bias(value) {
    if (value === this._bias) {
      return;
    }
    this._bias = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.bias = value;
    }
  }
  /**
   * The normal bias to apply to the shadow map.
   */
  get normalBias() {
    return this._normalBias;
  }
  set normalBias(value) {
    if (value === this._normalBias) {
      return;
    }
    this._normalBias = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.normalBias = value;
    }
  }
  /**
   * The darkness of the shadows.
   */
  get darkness() {
    return this._darkness;
  }
  set darkness(value) {
    if (value === this._darkness) {
      return;
    }
    this._darkness = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.darkness = value;
    }
  }
  /**
   * Gets or sets the ability to have transparent shadow
   */
  get transparencyShadow() {
    return this._transparencyShadow;
  }
  set transparencyShadow(value) {
    if (value === this._transparencyShadow) {
      return;
    }
    this._transparencyShadow = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.transparencyShadow = value;
    }
  }
  /**
   * Enables or disables shadows with varying strength based on the transparency
   */
  get enableSoftTransparentShadow() {
    return this._enableSoftTransparentShadow;
  }
  set enableSoftTransparentShadow(value) {
    if (value === this._enableSoftTransparentShadow) {
      return;
    }
    this._enableSoftTransparentShadow = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.enableSoftTransparentShadow = value;
    }
  }
  /**
   * If this is true, use the opacity texture's alpha channel for transparent shadows instead of the diffuse one
   */
  get useOpacityTextureForTransparentShadow() {
    return this._useOpacityTextureForTransparentShadow;
  }
  set useOpacityTextureForTransparentShadow(value) {
    if (value === this._useOpacityTextureForTransparentShadow) {
      return;
    }
    this._useOpacityTextureForTransparentShadow = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.useOpacityTextureForTransparentShadow = value;
    }
  }
  /**
   * The filter to apply to the shadow map.
   */
  get filter() {
    return this._filter;
  }
  set filter(value) {
    if (value === this._filter) {
      return;
    }
    this._filter = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.filter = value;
    }
  }
  /**
   * The filtering quality to apply to the filter.
   */
  get filteringQuality() {
    return this._filteringQuality;
  }
  set filteringQuality(value) {
    if (value === this._filteringQuality) {
      return;
    }
    this._filteringQuality = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.filteringQuality = value;
    }
  }
  _createShadowGenerator() {
    this._shadowGenerator = new ShadowGenerator(this._mapSize, this._light, this._useFloat32TextureType, void 0, this._useRedTextureFormat);
  }
  _setupShadowGenerator() {
    this._shadowGenerator?.dispose();
    this._shadowGenerator = void 0;
    if (this._light !== void 0) {
      this._createShadowGenerator();
      const shadowGenerator = this._shadowGenerator;
      if (shadowGenerator === void 0) {
        return;
      }
      shadowGenerator.bias = this._bias;
      shadowGenerator.normalBias = this._normalBias;
      shadowGenerator.darkness = this._darkness;
      shadowGenerator.transparencyShadow = this._transparencyShadow;
      shadowGenerator.enableSoftTransparentShadow = this._enableSoftTransparentShadow;
      shadowGenerator.useOpacityTextureForTransparentShadow = this._useOpacityTextureForTransparentShadow;
      shadowGenerator.filter = this._filter;
      shadowGenerator.filteringQuality = this._filteringQuality;
      const shadowMap = shadowGenerator.getShadowMap();
      shadowMap._disableEngineStages = true;
      shadowMap.cameraForLOD = this._camera;
      this.shadowGenerator = shadowGenerator;
    }
  }
  isReady() {
    return !!this._shadowGenerator && !!this._shadowGenerator.getShadowMap()?.isReadyForRendering();
  }
  /**
   * Creates a new shadow generator task.
   * @param name The name of the task.
   * @param frameGraph The frame graph the task belongs to.
   */
  constructor(name, frameGraph) {
    super(name, frameGraph);
    this._mapSize = 1024;
    this._useFloat32TextureType = false;
    this._useRedTextureFormat = true;
    this._bias = 0.01;
    this._normalBias = 0;
    this._darkness = 0;
    this._transparencyShadow = false;
    this._enableSoftTransparentShadow = false;
    this._useOpacityTextureForTransparentShadow = false;
    this._filter = ShadowGenerator.FILTER_PCF;
    this._filteringQuality = ShadowGenerator.QUALITY_HIGH;
    this.outputTexture = this._frameGraph.textureManager.createDanglingHandle();
  }
  getClassName() {
    return "FrameGraphShadowGeneratorTask";
  }
  record() {
    if (this.light === void 0 || this.objectList === void 0 || this.camera === void 0) {
      throw new Error(`FrameGraphShadowGeneratorTask ${this.name}: light, objectList and camera are required`);
    }
    const shadowMap = this._shadowGenerator.getShadowMap();
    shadowMap.renderList = this.objectList.meshes;
    shadowMap.particleSystemList = this.objectList.particleSystems;
    const shadowTextureHandle = this._frameGraph.textureManager.importTexture(`${this.name} shadowmap`, this._shadowGenerator.getShadowMap().getInternalTexture());
    this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture, shadowTextureHandle);
    const pass = this._frameGraph.addPass(this.name);
    pass.setExecuteFunc((context) => {
      if (!this.light.isEnabled() || !this.light.shadowEnabled) {
        return;
      }
      const shadowMap2 = this._shadowGenerator.getShadowMap();
      shadowMap2.renderList = this.objectList.meshes;
      shadowMap2.particleSystemList = this.objectList.particleSystems;
      context.saveDepthStates();
      context.setDepthStates(true, true);
      context.renderUnmanaged(shadowMap2);
      context.restoreDepthStates();
    });
    const passDisabled = this._frameGraph.addPass(this.name + "_disabled", true);
    passDisabled.setExecuteFunc((_context) => {
    });
  }
  dispose() {
    this._shadowGenerator?.dispose();
    this._shadowGenerator = void 0;
  }
};

// node_modules/@babylonjs/core/Lights/shadowLight.js
var ShadowLight = class extends Light {
  constructor() {
    super(...arguments);
    this._needProjectionMatrixCompute = true;
    this._viewMatrix = Matrix.Identity();
    this._projectionMatrix = Matrix.Identity();
  }
  _setPosition(value) {
    this._position = value;
  }
  /**
   * Sets the position the shadow will be casted from. Also use as the light position for both
   * point and spot lights.
   */
  get position() {
    return this._position;
  }
  /**
   * Sets the position the shadow will be casted from. Also use as the light position for both
   * point and spot lights.
   */
  set position(value) {
    this._setPosition(value);
  }
  _setDirection(value) {
    this._direction = value;
  }
  /**
   * In 2d mode (needCube being false), gets the direction used to cast the shadow.
   * Also use as the light direction on spot and directional lights.
   */
  get direction() {
    return this._direction;
  }
  /**
   * In 2d mode (needCube being false), sets the direction used to cast the shadow.
   * Also use as the light direction on spot and directional lights.
   */
  set direction(value) {
    this._setDirection(value);
  }
  /**
   * Gets the shadow projection clipping minimum z value.
   */
  get shadowMinZ() {
    return this._shadowMinZ;
  }
  /**
   * Sets the shadow projection clipping minimum z value.
   */
  set shadowMinZ(value) {
    this._shadowMinZ = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Sets the shadow projection clipping maximum z value.
   */
  get shadowMaxZ() {
    return this._shadowMaxZ;
  }
  /**
   * Gets the shadow projection clipping maximum z value.
   */
  set shadowMaxZ(value) {
    this._shadowMaxZ = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
   * @returns true if the information has been computed, false if it does not need to (no parenting)
   */
  computeTransformedInformation() {
    if (this.parent && this.parent.getWorldMatrix) {
      if (!this.transformedPosition) {
        this.transformedPosition = Vector3.Zero();
      }
      Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);
      if (this.direction) {
        if (!this.transformedDirection) {
          this.transformedDirection = Vector3.Zero();
        }
        Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);
      }
      return true;
    }
    return false;
  }
  /**
   * Return the depth scale used for the shadow map.
   * @returns the depth scale.
   */
  getDepthScale() {
    return 50;
  }
  /**
   * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.
   * @param faceIndex The index of the face we are computed the direction to generate shadow
   * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getShadowDirection(faceIndex) {
    return this.transformedDirection ? this.transformedDirection : this.direction;
  }
  /**
   * If computeTransformedInformation has been called, returns the ShadowLight absolute position in the world. Otherwise, returns the local position.
   * @returns the position vector in world space
   */
  getAbsolutePosition() {
    return this.transformedPosition ? this.transformedPosition : this.position;
  }
  /**
   * Sets the ShadowLight direction toward the passed target.
   * @param target The point to target in local space
   * @returns the updated ShadowLight direction
   */
  setDirectionToTarget(target) {
    this.direction = Vector3.Normalize(target.subtract(this.position));
    return this.direction;
  }
  /**
   * Returns the light rotation in euler definition.
   * @returns the x y z rotation in local space.
   */
  getRotation() {
    this.direction.normalize();
    const xaxis = Vector3.Cross(this.direction, Axis.Y);
    const yaxis = Vector3.Cross(xaxis, this.direction);
    return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);
  }
  /**
   * Returns whether or not the shadow generation require a cube texture or a 2d texture.
   * @returns true if a cube texture needs to be use
   */
  needCube() {
    return false;
  }
  /**
   * Detects if the projection matrix requires to be recomputed this frame.
   * @returns true if it requires to be recomputed otherwise, false.
   */
  needProjectionMatrixCompute() {
    return this._needProjectionMatrixCompute;
  }
  /**
   * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
   */
  forceProjectionMatrixCompute() {
    this._needProjectionMatrixCompute = true;
  }
  /** @internal */
  _initCache() {
    super._initCache();
    this._cache.position = Vector3.Zero();
  }
  /** @internal */
  _isSynchronized() {
    if (!this._cache.position.equals(this.position)) {
      return false;
    }
    return true;
  }
  /**
   * Computes the world matrix of the node
   * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
   * @returns the world matrix
   */
  computeWorldMatrix(force) {
    if (!force && this.isSynchronized()) {
      this._currentRenderId = this.getScene().getRenderId();
      return this._worldMatrix;
    }
    this._updateCache();
    this._cache.position.copyFrom(this.position);
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);
    if (this.parent && this.parent.getWorldMatrix) {
      this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);
      this._markSyncedWithParent();
    }
    this._worldMatrixDeterminantIsDirty = true;
    return this._worldMatrix;
  }
  /**
   * Gets the minZ used for shadow according to both the scene and the light.
   * @param activeCamera The camera we are returning the min for
   * @returns the depth min z
   */
  getDepthMinZ(activeCamera) {
    return this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera?.minZ || 0;
  }
  /**
   * Gets the maxZ used for shadow according to both the scene and the light.
   * @param activeCamera The camera we are returning the max for
   * @returns the depth max z
   */
  getDepthMaxZ(activeCamera) {
    return this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera?.maxZ || 1e4;
  }
  /**
   * Sets the shadow projection matrix in parameter to the generated projection matrix.
   * @param matrix The matrix to updated with the projection information
   * @param viewMatrix The transform matrix of the light
   * @param renderList The list of mesh to render in the map
   * @returns The current light
   */
  setShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    if (this.customProjectionMatrixBuilder) {
      this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);
    } else {
      this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);
    }
    return this;
  }
  /** @internal */
  _syncParentEnabledState() {
    super._syncParentEnabledState();
    if (!this.parent || !this.parent.getWorldMatrix) {
      this.transformedPosition = null;
      this.transformedDirection = null;
    }
  }
  /**
   * Returns the view matrix.
   * @param faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.
   * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getViewMatrix(faceIndex) {
    const lightDirection = TmpVectors.Vector3[0];
    let lightPosition = this.position;
    if (this.computeTransformedInformation()) {
      lightPosition = this.transformedPosition;
    }
    Vector3.NormalizeToRef(this.getShadowDirection(faceIndex), lightDirection);
    if (Math.abs(Vector3.Dot(lightDirection, Vector3.Up())) === 1) {
      lightDirection.z = 1e-13;
    }
    const lightTarget = TmpVectors.Vector3[1];
    lightPosition.addToRef(lightDirection, lightTarget);
    Matrix.LookAtLHToRef(lightPosition, lightTarget, Vector3.Up(), this._viewMatrix);
    return this._viewMatrix;
  }
  /**
   * Returns the projection matrix.
   * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).
   * @param viewMatrix The view transform matrix of the light (optional).
   * @param renderList The list of meshes to take into account when calculating the projection matrix (optional).
   * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getProjectionMatrix(viewMatrix, renderList) {
    this.setShadowProjectionMatrix(this._projectionMatrix, viewMatrix ?? this._viewMatrix, renderList ?? []);
    return this._projectionMatrix;
  }
};
__decorate([
  serializeAsVector3()
], ShadowLight.prototype, "position", null);
__decorate([
  serializeAsVector3()
], ShadowLight.prototype, "direction", null);
__decorate([
  serialize()
], ShadowLight.prototype, "shadowMinZ", null);
__decorate([
  serialize()
], ShadowLight.prototype, "shadowMaxZ", null);

// node_modules/@babylonjs/core/Lights/directionalLight.js
Node.AddNodeConstructor("Light_Type_1", (name, scene) => {
  return () => new DirectionalLight(name, Vector3.Zero(), scene);
});
var DirectionalLight = class extends ShadowLight {
  /**
   * Fix frustum size for the shadow generation. This is disabled if the value is 0.
   */
  get shadowFrustumSize() {
    return this._shadowFrustumSize;
  }
  /**
   * Specifies a fix frustum size for the shadow generation.
   */
  set shadowFrustumSize(value) {
    this._shadowFrustumSize = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Gets the shadow projection scale against the optimal computed one.
   * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
   * This does not impact in fixed frustum size (shadowFrustumSize being set)
   */
  get shadowOrthoScale() {
    return this._shadowOrthoScale;
  }
  /**
   * Sets the shadow projection scale against the optimal computed one.
   * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
   * This does not impact in fixed frustum size (shadowFrustumSize being set)
   */
  set shadowOrthoScale(value) {
    this._shadowOrthoScale = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Gets or sets the orthoLeft property used to build the light frustum
   */
  get orthoLeft() {
    return this._orthoLeft;
  }
  set orthoLeft(left) {
    this._orthoLeft = left;
  }
  /**
   * Gets or sets the orthoRight property used to build the light frustum
   */
  get orthoRight() {
    return this._orthoRight;
  }
  set orthoRight(right) {
    this._orthoRight = right;
  }
  /**
   * Gets or sets the orthoTop property used to build the light frustum
   */
  get orthoTop() {
    return this._orthoTop;
  }
  set orthoTop(top) {
    this._orthoTop = top;
  }
  /**
   * Gets or sets the orthoBottom property used to build the light frustum
   */
  get orthoBottom() {
    return this._orthoBottom;
  }
  set orthoBottom(bottom) {
    this._orthoBottom = bottom;
  }
  /**
   * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).
   * The directional light is emitted from everywhere in the given direction.
   * It can cast shadows.
   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
   * @param name The friendly name of the light
   * @param direction The direction of the light
   * @param scene The scene the light belongs to
   */
  constructor(name, direction, scene) {
    super(name, scene);
    this._shadowFrustumSize = 0;
    this._shadowOrthoScale = 0.1;
    this.autoUpdateExtends = true;
    this.autoCalcShadowZBounds = false;
    this._orthoLeft = Number.MAX_VALUE;
    this._orthoRight = Number.MIN_VALUE;
    this._orthoTop = Number.MIN_VALUE;
    this._orthoBottom = Number.MAX_VALUE;
    this.position = direction.scale(-1);
    this.direction = direction;
  }
  /**
   * Returns the string "DirectionalLight".
   * @returns The class name
   */
  getClassName() {
    return "DirectionalLight";
  }
  /**
   * Returns the integer 1.
   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getTypeID() {
    return Light.LIGHTTYPEID_DIRECTIONALLIGHT;
  }
  /**
   * Sets the passed matrix "matrix" as projection matrix for the shadows cast by the light according to the passed view matrix.
   * Returns the DirectionalLight Shadow projection matrix.
   * @param matrix
   * @param viewMatrix
   * @param renderList
   */
  _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    if (this.shadowFrustumSize > 0) {
      this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);
    } else {
      this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);
    }
  }
  /**
   * Sets the passed matrix "matrix" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.
   * Returns the DirectionalLight Shadow projection matrix.
   * @param matrix
   */
  _setDefaultFixedFrustumShadowProjectionMatrix(matrix) {
    const activeCamera = this.getScene().activeCamera;
    Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera ? activeCamera.minZ : 0, this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera ? activeCamera.maxZ : 1e4, matrix, this.getScene().getEngine().isNDCHalfZRange);
  }
  /**
   * Sets the passed matrix "matrix" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.
   * Returns the DirectionalLight Shadow projection matrix.
   * @param matrix
   * @param viewMatrix
   * @param renderList
   */
  _setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    const activeCamera = this.getScene().activeCamera;
    if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
      const tempVector3 = Vector3.Zero();
      this._orthoLeft = Number.MAX_VALUE;
      this._orthoRight = -Number.MAX_VALUE;
      this._orthoTop = -Number.MAX_VALUE;
      this._orthoBottom = Number.MAX_VALUE;
      let shadowMinZ = Number.MAX_VALUE;
      let shadowMaxZ = -Number.MAX_VALUE;
      for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
        const mesh = renderList[meshIndex];
        if (!mesh) {
          continue;
        }
        const boundingInfo = mesh.getBoundingInfo();
        const boundingBox = boundingInfo.boundingBox;
        for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {
          Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);
          if (tempVector3.x < this._orthoLeft) {
            this._orthoLeft = tempVector3.x;
          }
          if (tempVector3.y < this._orthoBottom) {
            this._orthoBottom = tempVector3.y;
          }
          if (tempVector3.x > this._orthoRight) {
            this._orthoRight = tempVector3.x;
          }
          if (tempVector3.y > this._orthoTop) {
            this._orthoTop = tempVector3.y;
          }
          if (this.autoCalcShadowZBounds) {
            if (tempVector3.z < shadowMinZ) {
              shadowMinZ = tempVector3.z;
            }
            if (tempVector3.z > shadowMaxZ) {
              shadowMaxZ = tempVector3.z;
            }
          }
        }
      }
      if (this.autoCalcShadowZBounds) {
        this._shadowMinZ = shadowMinZ;
        this._shadowMaxZ = shadowMaxZ;
      }
    }
    const xOffset = this._orthoRight - this._orthoLeft;
    const yOffset = this._orthoTop - this._orthoBottom;
    const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera?.minZ || 0;
    const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera?.maxZ || 1e4;
    const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
    Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  }
  /**
   * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.
   * @param effect The effect to update
   * @param lightIndex The index of the light in the effect to update
   * @returns The directional light
   */
  transferToEffect(effect, lightIndex) {
    if (this.computeTransformedInformation()) {
      this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);
      return this;
    }
    this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);
    return this;
  }
  transferToNodeMaterialEffect(effect, lightDataUniformName) {
    if (this.computeTransformedInformation()) {
      effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);
      return this;
    }
    effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);
    return this;
  }
  /**
   * Gets the minZ used for shadow according to both the scene and the light.
   *
   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
   * (when not using reverse depth buffer / NDC half Z range)
   * @param _activeCamera The camera we are returning the min for (not used)
   * @returns the depth min z
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getDepthMinZ(_activeCamera) {
    const engine = this._scene.getEngine();
    return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
  }
  /**
   * Gets the maxZ used for shadow according to both the scene and the light.
   *
   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
   * (when not using reverse depth buffer / NDC half Z range)
   * @param _activeCamera The camera we are returning the max for
   * @returns the depth max z
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getDepthMaxZ(_activeCamera) {
    const engine = this._scene.getEngine();
    return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
  }
  /**
   * Prepares the list of defines specific to the light type.
   * @param defines the list of defines
   * @param lightIndex defines the index of the light for the effect
   */
  prepareLightSpecificDefines(defines, lightIndex) {
    defines["DIRLIGHT" + lightIndex] = true;
  }
};
__decorate([
  serialize()
], DirectionalLight.prototype, "shadowFrustumSize", null);
__decorate([
  serialize()
], DirectionalLight.prototype, "shadowOrthoScale", null);
__decorate([
  serialize()
], DirectionalLight.prototype, "autoUpdateExtends", void 0);
__decorate([
  serialize()
], DirectionalLight.prototype, "autoCalcShadowZBounds", void 0);
__decorate([
  serialize("orthoLeft")
], DirectionalLight.prototype, "_orthoLeft", void 0);
__decorate([
  serialize("orthoRight")
], DirectionalLight.prototype, "_orthoRight", void 0);
__decorate([
  serialize("orthoTop")
], DirectionalLight.prototype, "_orthoTop", void 0);
__decorate([
  serialize("orthoBottom")
], DirectionalLight.prototype, "_orthoBottom", void 0);
RegisterClass("BABYLON.DirectionalLight", DirectionalLight);

// node_modules/@babylonjs/core/FrameGraph/Tasks/PostProcesses/postProcessTask.js
var FrameGraphPostProcessTask = class extends FrameGraphTask {
  /**
   * The draw wrapper used by the post process
   */
  get drawWrapper() {
    return this._postProcessDrawWrapper;
  }
  /**
   * Constructs a new post process task.
   * @param name Name of the task.
   * @param frameGraph The frame graph this task is associated with.
   * @param postProcess The post process to apply.
   */
  constructor(name, frameGraph, postProcess) {
    super(name, frameGraph);
    this.sourceSamplingMode = 2;
    this.depthReadOnly = false;
    this.stencilReadOnly = false;
    this.disableColorWrite = false;
    this.drawBackFace = false;
    this.depthTest = true;
    this.postProcess = postProcess;
    this._postProcessDrawWrapper = this.postProcess.drawWrapper;
    this.outputTexture = this._frameGraph.textureManager.createDanglingHandle();
    this.outputDepthAttachmentTexture = this._frameGraph.textureManager.createDanglingHandle();
  }
  isReady() {
    return this.postProcess.isReady();
  }
  getClassName() {
    return "FrameGraphPostProcessTask";
  }
  record(skipCreationOfDisabledPasses = false, additionalExecute, additionalBindings) {
    if (this.sourceTexture === void 0 && this.targetTexture === void 0) {
      throw new Error(`FrameGraphPostProcessTask "${this.name}": sourceTexture or targetTexture is required`);
    }
    const sourceTextureCreationOptions = this.sourceTexture !== void 0 ? this._frameGraph.textureManager.getTextureCreationOptions(this.sourceTexture) : void 0;
    if (sourceTextureCreationOptions) {
      sourceTextureCreationOptions.options.samples = 1;
    }
    this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture, this.targetTexture, this.name, sourceTextureCreationOptions);
    if (this.depthAttachmentTexture !== void 0) {
      this._frameGraph.textureManager.resolveDanglingHandle(this.outputDepthAttachmentTexture, this.depthAttachmentTexture);
    }
    if (sourceTextureCreationOptions) {
      const sourceSize = this._frameGraph.textureManager.getTextureAbsoluteDimensions(sourceTextureCreationOptions);
      this._sourceWidth = sourceSize.width;
      this._sourceHeight = sourceSize.height;
    }
    const outputTextureDescription = this._frameGraph.textureManager.getTextureDescription(this.outputTexture);
    this._outputWidth = outputTextureDescription.size.width;
    this._outputHeight = outputTextureDescription.size.height;
    const pass = this._frameGraph.addRenderPass(this.name);
    pass.depthReadOnly = this.depthReadOnly;
    pass.stencilReadOnly = this.stencilReadOnly;
    pass.addDependencies(this.sourceTexture);
    pass.setRenderTarget(this.outputTexture);
    pass.setRenderTargetDepth(this.depthAttachmentTexture);
    pass.setExecuteFunc((context) => {
      if (this.sourceTexture !== void 0) {
        context.setTextureSamplingMode(this.sourceTexture, this.sourceSamplingMode);
      }
      additionalExecute?.(context);
      if (this.viewport) {
        context.setViewport(this.viewport);
      }
      context.applyFullScreenEffect(this._postProcessDrawWrapper, () => {
        if (this.sourceTexture !== void 0) {
          context.bindTextureHandle(this._postProcessDrawWrapper.effect, "textureSampler", this.sourceTexture);
        }
        additionalBindings?.(context);
        this.postProcess.bind();
      }, this.stencilState, this.disableColorWrite, this.drawBackFace, this.depthTest, this.viewport !== void 0);
    });
    if (!skipCreationOfDisabledPasses) {
      const passDisabled = this._frameGraph.addRenderPass(this.name + "_disabled", true);
      passDisabled.depthReadOnly = this.depthReadOnly;
      passDisabled.stencilReadOnly = this.stencilReadOnly;
      passDisabled.addDependencies(this.sourceTexture);
      passDisabled.setRenderTarget(this.outputTexture);
      passDisabled.setRenderTargetDepth(this.depthAttachmentTexture);
      passDisabled.setExecuteFunc((context) => {
        if (this.sourceTexture !== void 0) {
          if (this.viewport) {
            context.setViewport(this.viewport);
          }
          context.copyTexture(this.sourceTexture, void 0, this.viewport !== void 0);
        }
      });
    }
    return pass;
  }
  dispose() {
    this.postProcess.dispose();
    super.dispose();
  }
};

// node_modules/@babylonjs/core/Materials/Textures/textureCreationOptions.js
function textureSizeIsObject(size) {
  return size.width !== void 0;
}
function getDimensionsFromTextureSize(size) {
  if (textureSizeIsObject(size)) {
    return { width: size.width, height: size.height };
  }
  return { width: size, height: size };
}

// node_modules/@babylonjs/core/FrameGraph/Tasks/Rendering/csmShadowGeneratorTask.js
var FrameGraphCascadedShadowGeneratorTask = class extends FrameGraphShadowGeneratorTask {
  /**
   * Checks if a shadow generator task is a cascaded shadow generator task.
   * @param task The task to check.
   * @returns True if the task is a cascaded shadow generator task, else false.
   */
  static IsCascadedShadowGenerator(task) {
    return task.numCascades !== void 0;
  }
  /**
   * The number of cascades.
   */
  get numCascades() {
    return this._numCascades;
  }
  set numCascades(value) {
    if (value === this._numCascades) {
      return;
    }
    this._numCascades = value;
    this._setupShadowGenerator();
  }
  /**
   * Gets or sets a value indicating whether the shadow generator should display the cascades.
   */
  get debug() {
    return this._debug;
  }
  set debug(value) {
    if (value === this._debug) {
      return;
    }
    this._debug = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.debug = value;
    }
  }
  /**
   * Gets or sets a value indicating whether the shadow generator should stabilize the cascades.
   */
  get stabilizeCascades() {
    return this._stabilizeCascades;
  }
  set stabilizeCascades(value) {
    if (value === this._stabilizeCascades) {
      return;
    }
    this._stabilizeCascades = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.stabilizeCascades = value;
    }
  }
  /**
   * Gets or sets the lambda parameter of the shadow generator.
   */
  get lambda() {
    return this._lambda;
  }
  set lambda(value) {
    if (value === this._lambda) {
      return;
    }
    this._lambda = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.lambda = value;
    }
  }
  /**
   * Gets or sets the cascade blend percentage.
   */
  get cascadeBlendPercentage() {
    return this._cascadeBlendPercentage;
  }
  set cascadeBlendPercentage(value) {
    if (value === this._cascadeBlendPercentage) {
      return;
    }
    this._cascadeBlendPercentage = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.cascadeBlendPercentage = value;
    }
  }
  /**
   * Gets or sets a value indicating whether the shadow generator should use depth clamping.
   */
  get depthClamp() {
    return this._depthClamp;
  }
  set depthClamp(value) {
    if (value === this._depthClamp) {
      return;
    }
    this._depthClamp = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.depthClamp = value;
    }
  }
  /**
   * Gets or sets a value indicating whether the shadow generator should automatically calculate the depth bounds.
   */
  get autoCalcDepthBounds() {
    return this._autoCalcDepthBounds;
  }
  set autoCalcDepthBounds(value) {
    if (value === this._autoCalcDepthBounds) {
      return;
    }
    this._autoCalcDepthBounds = value;
    this._currentAutoCalcDepthBoundsCounter = this._autoCalcDepthBoundsRefreshRate;
    if (!value) {
      this._shadowGenerator?.setMinMaxDistance(0, 1);
    }
    const passes = this.passes;
    for (let i = 0; i < passes.length - 1; ++i) {
      passes[i].disabled = !value;
    }
  }
  /**
   * Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true
   * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
   */
  get autoCalcDepthBoundsRefreshRate() {
    return this._autoCalcDepthBoundsRefreshRate;
  }
  set autoCalcDepthBoundsRefreshRate(value) {
    this._autoCalcDepthBoundsRefreshRate = value;
    this._currentAutoCalcDepthBoundsCounter = this._autoCalcDepthBoundsRefreshRate;
  }
  /**
   * Gets or sets the maximum shadow Z value.
   */
  get shadowMaxZ() {
    return this._shadowMaxZ;
  }
  set shadowMaxZ(value) {
    if (value === this._shadowMaxZ) {
      return;
    }
    this._shadowMaxZ = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.shadowMaxZ = value;
    }
  }
  /**
   * Creates a new shadow generator task.
   * @param name The name of the task.
   * @param frameGraph The frame graph the task belongs to.
   */
  constructor(name, frameGraph) {
    super(name, frameGraph);
    this.depthTextureType = 0;
    this._numCascades = CascadedShadowGenerator.DEFAULT_CASCADES_COUNT;
    this._debug = false;
    this._stabilizeCascades = false;
    this._lambda = 0.5;
    this._cascadeBlendPercentage = 0.1;
    this._depthClamp = true;
    this._autoCalcDepthBounds = false;
    this._currentAutoCalcDepthBoundsCounter = 0;
    this._autoCalcDepthBoundsRefreshRate = 1;
    this._shadowMaxZ = 1e4;
    this._thinMinMaxReducer = new ThinMinMaxReducer(frameGraph.scene);
    this._thinMinMaxReducer.onAfterReductionPerformed.add((minmax) => {
      if (!this._shadowGenerator) {
        return;
      }
      const camera = this.camera;
      let min = minmax.min, max = minmax.max;
      if (min >= max) {
        min = 0;
        max = 1;
      } else if (camera && this.depthTextureType !== 0) {
        if (this.depthTextureType === 2) {
          const engine = this._frameGraph.engine;
          const projectionMatrix = camera.getProjectionMatrix();
          const p2z = projectionMatrix.m[10];
          const p3z = projectionMatrix.m[14];
          if (!engine.isNDCHalfZRange) {
            min = min * 2 - 1;
            max = max * 2 - 1;
          }
          min = p3z / (min - p2z);
          max = p3z / (max - p2z);
        }
        const zNear = camera.minZ;
        const zFar = camera.maxZ;
        min = (min - zNear) / (zFar - zNear);
        max = (max - zNear) / (zFar - zNear);
      }
      if (min !== this._shadowGenerator.minDistance || max !== this._shadowGenerator.maxDistance) {
        this._shadowGenerator.setMinMaxDistance(min, max);
      }
    });
  }
  _createShadowGenerator() {
    if (!(this.light instanceof DirectionalLight)) {
      throw new Error(`FrameGraphCascadedShadowGeneratorTask ${this.name}: the CSM shadow generator only supports directional lights.`);
    }
    this._shadowGenerator = new CascadedShadowGenerator(this.mapSize, this.light, this.useFloat32TextureType, this.camera, this.useRedTextureFormat);
    this._shadowGenerator.numCascades = this._numCascades;
  }
  _setupShadowGenerator() {
    super._setupShadowGenerator();
    const shadowGenerator = this._shadowGenerator;
    if (shadowGenerator === void 0) {
      return;
    }
    shadowGenerator.debug = this._debug;
    shadowGenerator.stabilizeCascades = this._stabilizeCascades;
    shadowGenerator.lambda = this._lambda;
    shadowGenerator.cascadeBlendPercentage = this._cascadeBlendPercentage;
    shadowGenerator.depthClamp = this._depthClamp;
    shadowGenerator.shadowMaxZ = this._shadowMaxZ;
  }
  getClassName() {
    return "FrameGraphCascadedShadowGeneratorTask";
  }
  record() {
    if (this.light === void 0 || this.objectList === void 0 || this.camera === void 0) {
      throw new Error(`FrameGraphCascadedShadowGeneratorTask ${this.name}: light, objectList and camera are required`);
    }
    if (this.depthTexture !== void 0) {
      const depthTextureCreationOptions = this._frameGraph.textureManager.getTextureCreationOptions(this.depthTexture);
      const size = !depthTextureCreationOptions.sizeIsPercentage ? textureSizeIsObject(depthTextureCreationOptions.size) ? depthTextureCreationOptions.size : { width: depthTextureCreationOptions.size, height: depthTextureCreationOptions.size } : this._frameGraph.textureManager.getAbsoluteDimensions(depthTextureCreationOptions.size);
      const width = size.width;
      const height = size.height;
      depthTextureCreationOptions.sizeIsPercentage = false;
      depthTextureCreationOptions.options.formats = [7];
      depthTextureCreationOptions.options.samples = 1;
      this._thinMinMaxReducer.setTextureDimensions(width, height, this.depthTextureType);
      const reductionSteps = this._thinMinMaxReducer.reductionSteps;
      let targetTexture;
      this._frameGraph.addPass(`${this.name} Before Min Max Reduction`).setExecuteFunc((context) => {
        context.pushDebugGroup(`Min Max Reduction`);
      });
      for (let i = 0; i < reductionSteps.length - 1; ++i) {
        const reductionStep = reductionSteps[i];
        depthTextureCreationOptions.size = { width: reductionSteps[i + 1].textureWidth, height: reductionSteps[i + 1].textureHeight };
        const postProcess = new FrameGraphPostProcessTask(reductionStep.name, this._frameGraph, reductionStep);
        postProcess.sourceTexture = i == 0 ? this.depthTexture : targetTexture;
        postProcess.sourceSamplingMode = 1;
        postProcess.targetTexture = this._frameGraph.textureManager.createRenderTargetTexture(`${this.name} ${reductionStep.name}`, depthTextureCreationOptions);
        postProcess.record(true);
        targetTexture = postProcess.outputTexture;
      }
      this._frameGraph.addPass(`${this.name} After Min Max Reduction`).setExecuteFunc((context) => {
        context.popDebugGroup();
        if (this._autoCalcDepthBounds && this._currentAutoCalcDepthBoundsCounter >= 0) {
          if (++this._currentAutoCalcDepthBoundsCounter >= this._autoCalcDepthBoundsRefreshRate) {
            const minMaxTexture = context.getTextureFromHandle(targetTexture);
            if (minMaxTexture) {
              this._thinMinMaxReducer.readMinMax(minMaxTexture);
            }
          }
          this._currentAutoCalcDepthBoundsCounter %= this._autoCalcDepthBoundsRefreshRate;
          if (this._autoCalcDepthBoundsRefreshRate === 0) {
            this._currentAutoCalcDepthBoundsCounter = -1;
          }
        }
      });
    }
    super.record();
  }
  dispose() {
    super.dispose();
    this._thinMinMaxReducer.dispose();
  }
};

// node_modules/@babylonjs/core/Materials/Textures/multiRenderTarget.js
var MultiRenderTarget = class extends RenderTargetTexture {
  /**
   * Get if draw buffers (render textures) are currently supported by the used hardware and browser.
   */
  get isSupported() {
    return this._engine?.getCaps().drawBuffersExtension ?? false;
  }
  /**
   * Get the list of textures generated by the multi render target.
   */
  get textures() {
    return this._textures;
  }
  /**
   * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.
   */
  get count() {
    return this._count;
  }
  /**
   * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set
   */
  get depthTexture() {
    return this._textures[this._textures.length - 1];
  }
  /**
   * Set the wrapping mode on U of all the textures we are rendering to.
   * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
   */
  set wrapU(wrap) {
    if (this._textures) {
      for (let i = 0; i < this._textures.length; i++) {
        this._textures[i].wrapU = wrap;
      }
    }
  }
  /**
   * Set the wrapping mode on V of all the textures we are rendering to.
   * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
   */
  set wrapV(wrap) {
    if (this._textures) {
      for (let i = 0; i < this._textures.length; i++) {
        this._textures[i].wrapV = wrap;
      }
    }
  }
  /**
   * Instantiate a new multi render target texture.
   * A multi render target, like a render target provides the ability to render to a texture.
   * Unlike the render target, it can render to several draw buffers (render textures) in one draw.
   * This is specially interesting in deferred rendering or for any effects requiring more than
   * just one color from a single pass.
   * @param name Define the name of the texture
   * @param size Define the size of the buffers to render to
   * @param count Define the number of target we are rendering into
   * @param scene Define the scene the texture belongs to
   * @param options Define the options used to create the multi render target
   * @param textureNames Define the names to set to the textures (if count \> 0 - optional)
   */
  constructor(name, size, count, scene, options, textureNames) {
    const generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;
    const generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;
    const depthTextureFormat = options && options.depthTextureFormat ? options.depthTextureFormat : 15;
    const doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === void 0 ? true : options.doNotChangeAspectRatio;
    const drawOnlyOnFirstAttachmentByDefault = options && options.drawOnlyOnFirstAttachmentByDefault ? options.drawOnlyOnFirstAttachmentByDefault : false;
    super(name, size, scene, generateMipMaps, doNotChangeAspectRatio, void 0, void 0, void 0, void 0, void 0, void 0, void 0, true);
    if (!this.isSupported) {
      this.dispose();
      return;
    }
    this._textureNames = textureNames;
    const types = [];
    const samplingModes = [];
    const useSRGBBuffers = [];
    const formats = [];
    const targetTypes = [];
    const faceIndex = [];
    const layerIndex = [];
    const layerCounts = [];
    this._initTypes(count, types, samplingModes, useSRGBBuffers, formats, targetTypes, faceIndex, layerIndex, layerCounts, options);
    const generateDepthBuffer = !options || options.generateDepthBuffer === void 0 ? true : options.generateDepthBuffer;
    const generateStencilBuffer = !options || options.generateStencilBuffer === void 0 ? false : options.generateStencilBuffer;
    const samples = options && options.samples ? options.samples : 1;
    this._multiRenderTargetOptions = {
      samplingModes,
      generateMipMaps,
      generateDepthBuffer,
      generateStencilBuffer,
      generateDepthTexture,
      depthTextureFormat,
      types,
      textureCount: count,
      useSRGBBuffers,
      samples,
      formats,
      targetTypes,
      faceIndex,
      layerIndex,
      layerCounts,
      labels: textureNames,
      label: name
    };
    this._count = count;
    this._drawOnlyOnFirstAttachmentByDefault = drawOnlyOnFirstAttachmentByDefault;
    if (count > 0) {
      this._createInternalTextures();
      this._createTextures(textureNames);
    }
  }
  _initTypes(count, types, samplingModes, useSRGBBuffers, formats, targets, faceIndex, layerIndex, layerCounts, options) {
    for (let i = 0; i < count; i++) {
      if (options && options.types && options.types[i] !== void 0) {
        types.push(options.types[i]);
      } else {
        types.push(options && options.defaultType ? options.defaultType : 0);
      }
      if (options && options.samplingModes && options.samplingModes[i] !== void 0) {
        samplingModes.push(options.samplingModes[i]);
      } else {
        samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);
      }
      if (options && options.useSRGBBuffers && options.useSRGBBuffers[i] !== void 0) {
        useSRGBBuffers.push(options.useSRGBBuffers[i]);
      } else {
        useSRGBBuffers.push(false);
      }
      if (options && options.formats && options.formats[i] !== void 0) {
        formats.push(options.formats[i]);
      } else {
        formats.push(5);
      }
      if (options && options.targetTypes && options.targetTypes[i] !== void 0) {
        targets.push(options.targetTypes[i]);
      } else {
        targets.push(3553);
      }
      if (options && options.faceIndex && options.faceIndex[i] !== void 0) {
        faceIndex.push(options.faceIndex[i]);
      } else {
        faceIndex.push(0);
      }
      if (options && options.layerIndex && options.layerIndex[i] !== void 0) {
        layerIndex.push(options.layerIndex[i]);
      } else {
        layerIndex.push(0);
      }
      if (options && options.layerCounts && options.layerCounts[i] !== void 0) {
        layerCounts.push(options.layerCounts[i]);
      } else {
        layerCounts.push(1);
      }
    }
  }
  _createInternaTextureIndexMapping() {
    const mapMainInternalTexture2Index = {};
    const mapInternalTexture2MainIndex = [];
    if (!this._renderTarget) {
      return mapInternalTexture2MainIndex;
    }
    const internalTextures = this._renderTarget.textures;
    for (let i = 0; i < internalTextures.length; i++) {
      const texture = internalTextures[i];
      if (!texture) {
        continue;
      }
      const mainIndex = mapMainInternalTexture2Index[texture.uniqueId];
      if (mainIndex !== void 0) {
        mapInternalTexture2MainIndex[i] = mainIndex;
      } else {
        mapMainInternalTexture2Index[texture.uniqueId] = i;
      }
    }
    return mapInternalTexture2MainIndex;
  }
  /**
   * @internal
   */
  _rebuild(fromContextLost = false, forceFullRebuild = false, textureNames) {
    if (this._count < 1 || fromContextLost) {
      return;
    }
    const mapInternalTexture2MainIndex = this._createInternaTextureIndexMapping();
    this.releaseInternalTextures();
    this._createInternalTextures();
    if (forceFullRebuild) {
      this._releaseTextures();
      this._createTextures(textureNames);
    }
    const internalTextures = this._renderTarget.textures;
    for (let i = 0; i < internalTextures.length; i++) {
      const texture = this._textures[i];
      if (mapInternalTexture2MainIndex[i] !== void 0) {
        this._renderTarget.setTexture(internalTextures[mapInternalTexture2MainIndex[i]], i);
      }
      texture._texture = internalTextures[i];
      if (texture._texture) {
        texture._noMipmap = !texture._texture.useMipMaps;
        texture._useSRGBBuffer = texture._texture._useSRGBBuffer;
      }
    }
    if (this.samples !== 1) {
      this._renderTarget.setSamples(this.samples, !this._drawOnlyOnFirstAttachmentByDefault, true);
    }
  }
  _createInternalTextures() {
    this._renderTarget = this._getEngine().createMultipleRenderTarget(this._size, this._multiRenderTargetOptions, !this._drawOnlyOnFirstAttachmentByDefault);
    this._texture = this._renderTarget.texture;
  }
  _releaseTextures() {
    if (this._textures) {
      for (let i = 0; i < this._textures.length; i++) {
        this._textures[i]._texture = null;
        this._textures[i].dispose();
      }
    }
  }
  _createTextures(textureNames) {
    const internalTextures = this._renderTarget.textures;
    this._textures = [];
    for (let i = 0; i < internalTextures.length; i++) {
      const texture = new Texture(null, this.getScene());
      if (textureNames?.[i]) {
        texture.name = textureNames[i];
      }
      texture._texture = internalTextures[i];
      if (texture._texture) {
        texture._noMipmap = !texture._texture.useMipMaps;
        texture._useSRGBBuffer = texture._texture._useSRGBBuffer;
      }
      this._textures.push(texture);
    }
  }
  /**
   * Replaces an internal texture within the MRT. Useful to share textures between MultiRenderTarget.
   * @param texture The new texture to set in the MRT
   * @param index The index of the texture to replace
   * @param disposePrevious Set to true if the previous internal texture should be disposed
   */
  setInternalTexture(texture, index, disposePrevious = true) {
    if (!this.renderTarget) {
      return;
    }
    if (index === 0) {
      this._texture = texture;
    }
    this.renderTarget.setTexture(texture, index, disposePrevious);
    if (!this.textures[index]) {
      this.textures[index] = new Texture(null, this.getScene());
      this.textures[index].name = this._textureNames?.[index] ?? this.textures[index].name;
    }
    this.textures[index]._texture = texture;
    this.textures[index]._noMipmap = !texture.useMipMaps;
    this.textures[index]._useSRGBBuffer = texture._useSRGBBuffer;
    this._count = this.renderTarget.textures ? this.renderTarget.textures.length : 0;
    if (this._multiRenderTargetOptions.types) {
      this._multiRenderTargetOptions.types[index] = texture.type;
    }
    if (this._multiRenderTargetOptions.samplingModes) {
      this._multiRenderTargetOptions.samplingModes[index] = texture.samplingMode;
    }
    if (this._multiRenderTargetOptions.useSRGBBuffers) {
      this._multiRenderTargetOptions.useSRGBBuffers[index] = texture._useSRGBBuffer;
    }
    if (this._multiRenderTargetOptions.targetTypes && this._multiRenderTargetOptions.targetTypes[index] !== -1) {
      let target = 0;
      if (texture.is2DArray) {
        target = 35866;
      } else if (texture.isCube) {
        target = 34067;
      } else if (texture.is3D) {
        target = 32879;
      } else {
        target = 3553;
      }
      this._multiRenderTargetOptions.targetTypes[index] = target;
    }
  }
  /**
   * Changes an attached texture's face index or layer.
   * @param index The index of the texture to modify the attachment of
   * @param layerIndex The layer index of the texture to be attached to the framebuffer
   * @param faceIndex The face index of the texture to be attached to the framebuffer
   */
  setLayerAndFaceIndex(index, layerIndex = -1, faceIndex = -1) {
    if (!this.textures[index] || !this.renderTarget) {
      return;
    }
    if (this._multiRenderTargetOptions.layerIndex) {
      this._multiRenderTargetOptions.layerIndex[index] = layerIndex;
    }
    if (this._multiRenderTargetOptions.faceIndex) {
      this._multiRenderTargetOptions.faceIndex[index] = faceIndex;
    }
    this.renderTarget.setLayerAndFaceIndex(index, layerIndex, faceIndex);
  }
  /**
   * Changes every attached texture's face index or layer.
   * @param layerIndices The layer indices of the texture to be attached to the framebuffer
   * @param faceIndices The face indices of the texture to be attached to the framebuffer
   */
  setLayerAndFaceIndices(layerIndices, faceIndices) {
    if (!this.renderTarget) {
      return;
    }
    this._multiRenderTargetOptions.layerIndex = layerIndices;
    this._multiRenderTargetOptions.faceIndex = faceIndices;
    this.renderTarget.setLayerAndFaceIndices(layerIndices, faceIndices);
  }
  /**
   * Define the number of samples used if MSAA is enabled.
   */
  get samples() {
    return this._samples;
  }
  set samples(value) {
    if (this._renderTarget) {
      this._samples = this._renderTarget.setSamples(value);
    } else {
      this._samples = value;
    }
  }
  /**
   * Resize all the textures in the multi render target.
   * Be careful as it will recreate all the data in the new texture.
   * @param size Define the new size
   */
  resize(size) {
    this._processSizeParameter(size);
    this._rebuild(false, void 0, this._textureNames);
  }
  /**
   * Changes the number of render targets in this MRT
   * Be careful as it will recreate all the data in the new texture.
   * @param count new texture count
   * @param options Specifies texture types and sampling modes for new textures
   * @param textureNames Specifies the names of the textures (optional)
   */
  updateCount(count, options, textureNames) {
    this._multiRenderTargetOptions.textureCount = count;
    this._count = count;
    const types = [];
    const samplingModes = [];
    const useSRGBBuffers = [];
    const formats = [];
    const targetTypes = [];
    const faceIndex = [];
    const layerIndex = [];
    const layerCounts = [];
    this._textureNames = textureNames;
    this._initTypes(count, types, samplingModes, useSRGBBuffers, formats, targetTypes, faceIndex, layerIndex, layerCounts, options);
    this._multiRenderTargetOptions.types = types;
    this._multiRenderTargetOptions.samplingModes = samplingModes;
    this._multiRenderTargetOptions.useSRGBBuffers = useSRGBBuffers;
    this._multiRenderTargetOptions.formats = formats;
    this._multiRenderTargetOptions.targetTypes = targetTypes;
    this._multiRenderTargetOptions.faceIndex = faceIndex;
    this._multiRenderTargetOptions.layerIndex = layerIndex;
    this._multiRenderTargetOptions.layerCounts = layerCounts;
    this._multiRenderTargetOptions.labels = textureNames;
    this._rebuild(false, true, textureNames);
  }
  _unbindFrameBuffer(engine, faceIndex) {
    if (this._renderTarget) {
      engine.unBindMultiColorAttachmentFramebuffer(this._renderTarget, this.isCube, () => {
        this.onAfterRenderObservable.notifyObservers(faceIndex);
      });
    }
  }
  /**
   * Dispose the render targets and their associated resources
   * @param doNotDisposeInternalTextures if set to true, internal textures won't be disposed (default: false).
   */
  dispose(doNotDisposeInternalTextures = false) {
    this._releaseTextures();
    if (!doNotDisposeInternalTextures) {
      this.releaseInternalTextures();
    } else {
      this._texture = null;
    }
    super.dispose();
  }
  /**
   * Release all the underlying texture used as draw buffers (render textures).
   */
  releaseInternalTextures() {
    const internalTextures = this._renderTarget?.textures;
    if (!internalTextures) {
      return;
    }
    for (let i = internalTextures.length - 1; i >= 0; i--) {
      this._textures[i]._texture = null;
    }
    this._renderTarget?.dispose();
    this._renderTarget = null;
  }
};

// node_modules/@babylonjs/core/Materials/materialStencilState.js
var MaterialStencilState = class {
  /**
   * Creates a material stencil state instance
   */
  constructor() {
    this.reset();
  }
  /**
   * Resets all the stencil states to default values
   */
  reset() {
    this.enabled = false;
    this.mask = 255;
    this.funcRef = 1;
    this.funcMask = 255;
    this.func = 519;
    this.opStencilFail = 7680;
    this.opDepthFail = 7680;
    this.opStencilDepthPass = 7681;
    this.backFunc = 519;
    this.backOpStencilFail = 7680;
    this.backOpDepthFail = 7680;
    this.backOpStencilDepthPass = 7681;
  }
  /**
   * Gets or sets the stencil function
   */
  get func() {
    return this._func;
  }
  set func(value) {
    this._func = value;
  }
  /**
   * Gets or sets the stencil back function
   */
  get backFunc() {
    return this._backFunc;
  }
  set backFunc(value) {
    this._backFunc = value;
  }
  /**
   * Gets or sets the stencil function reference
   */
  get funcRef() {
    return this._funcRef;
  }
  set funcRef(value) {
    this._funcRef = value;
  }
  /**
   * Gets or sets the stencil function mask
   */
  get funcMask() {
    return this._funcMask;
  }
  set funcMask(value) {
    this._funcMask = value;
  }
  /**
   * Gets or sets the operation when the stencil test fails
   */
  get opStencilFail() {
    return this._opStencilFail;
  }
  set opStencilFail(value) {
    this._opStencilFail = value;
  }
  /**
   * Gets or sets the operation when the depth test fails
   */
  get opDepthFail() {
    return this._opDepthFail;
  }
  set opDepthFail(value) {
    this._opDepthFail = value;
  }
  /**
   * Gets or sets the operation when the stencil+depth test succeeds
   */
  get opStencilDepthPass() {
    return this._opStencilDepthPass;
  }
  set opStencilDepthPass(value) {
    this._opStencilDepthPass = value;
  }
  /**
   * Gets or sets the operation when the back stencil test fails
   */
  get backOpStencilFail() {
    return this._backOpStencilFail;
  }
  set backOpStencilFail(value) {
    this._backOpStencilFail = value;
  }
  /**
   * Gets or sets the operation when the back depth test fails
   */
  get backOpDepthFail() {
    return this._backOpDepthFail;
  }
  set backOpDepthFail(value) {
    this._backOpDepthFail = value;
  }
  /**
   * Gets or sets the operation when the back stencil+depth test succeeds
   */
  get backOpStencilDepthPass() {
    return this._backOpStencilDepthPass;
  }
  set backOpStencilDepthPass(value) {
    this._backOpStencilDepthPass = value;
  }
  /**
   * Gets or sets the stencil mask
   */
  get mask() {
    return this._mask;
  }
  set mask(value) {
    this._mask = value;
  }
  /**
   * Enables or disables the stencil test
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  /**
   * Get the current class name, useful for serialization or dynamic coding.
   * @returns "MaterialStencilState"
   */
  getClassName() {
    return "MaterialStencilState";
  }
  /**
   * Makes a duplicate of the current configuration into another one.
   * @param stencilState defines stencil state where to copy the info
   */
  copyTo(stencilState) {
    SerializationHelper.Clone(() => stencilState, this);
  }
  /**
   * Serializes this stencil configuration.
   * @returns - An object with the serialized config.
   */
  serialize() {
    return SerializationHelper.Serialize(this);
  }
  /**
   * Parses a stencil state configuration from a serialized object.
   * @param source - Serialized object.
   * @param scene Defines the scene we are parsing for
   * @param rootUrl Defines the rootUrl to load from
   */
  parse(source, scene, rootUrl) {
    SerializationHelper.Parse(() => this, source, scene, rootUrl);
  }
};
__decorate([
  serialize()
], MaterialStencilState.prototype, "func", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "backFunc", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "funcRef", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "funcMask", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "opStencilFail", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "opDepthFail", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "opStencilDepthPass", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "backOpStencilFail", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "backOpDepthFail", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "backOpStencilDepthPass", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "mask", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "enabled", null);

// node_modules/@babylonjs/core/Materials/material.js
var Material = class _Material {
  /**
   * Tells the engine to draw geometry using vertex pulling instead of index drawing. This will automatically
   * set the vertex buffers as storage buffers and make them accessible to the vertex shader (WebGPU only).
   */
  get useVertexPulling() {
    return this._useVertexPulling;
  }
  set useVertexPulling(value) {
    if (this._useVertexPulling === value) {
      return;
    }
    this._useVertexPulling = value;
    this.markAsDirty(_Material.MiscDirtyFlag);
  }
  /** @internal */
  get _supportGlowLayer() {
    return false;
  }
  /** @internal */
  set _glowModeEnabled(value) {
  }
  /**
   * Gets the shader language used in this material.
   */
  get shaderLanguage() {
    return this._shaderLanguage;
  }
  /**
   * If the material can be rendered to several textures with MRT extension
   */
  get canRenderToMRT() {
    return false;
  }
  /**
   * Sets the alpha value of the material
   */
  set alpha(value) {
    if (this._alpha === value) {
      return;
    }
    const oldValue = this._alpha;
    this._alpha = value;
    if (oldValue === 1 || value === 1) {
      this.markAsDirty(_Material.MiscDirtyFlag + _Material.PrePassDirtyFlag);
    }
  }
  /**
   * Gets the alpha value of the material
   */
  get alpha() {
    return this._alpha;
  }
  /**
   * Sets the culling state (true to enable culling, false to disable)
   */
  set backFaceCulling(value) {
    if (this._backFaceCulling === value) {
      return;
    }
    this._backFaceCulling = value;
    this.markAsDirty(_Material.TextureDirtyFlag);
  }
  /**
   * Gets the culling state
   */
  get backFaceCulling() {
    return this._backFaceCulling;
  }
  /**
   * Sets the type of faces that should be culled (true for back faces, false for front faces)
   */
  set cullBackFaces(value) {
    if (this._cullBackFaces === value) {
      return;
    }
    this._cullBackFaces = value;
    this.markAsDirty(_Material.TextureDirtyFlag);
  }
  /**
   * Gets the type of faces that should be culled
   */
  get cullBackFaces() {
    return this._cullBackFaces;
  }
  /**
   * Block the dirty-mechanism for this specific material
   * When set to false after being true the material will be marked as dirty.
   */
  get blockDirtyMechanism() {
    return this._blockDirtyMechanism;
  }
  set blockDirtyMechanism(value) {
    if (this._blockDirtyMechanism === value) {
      return;
    }
    this._blockDirtyMechanism = value;
    if (!value) {
      this.markDirty();
    }
  }
  /**
   * This allows you to modify the material without marking it as dirty after every change.
   * This function should be used if you need to make more than one dirty-enabling change to the material - adding a texture, setting a new fill mode and so on.
   * The callback will pass the material as an argument, so you can make your changes to it.
   * @param callback the callback to be executed that will update the material
   */
  atomicMaterialsUpdate(callback) {
    this.blockDirtyMechanism = true;
    try {
      callback(this);
    } finally {
      this.blockDirtyMechanism = false;
    }
  }
  /**
   * Gets a boolean indicating that current material needs to register RTT
   */
  get hasRenderTargetTextures() {
    this._eventInfo.hasRenderTargetTextures = false;
    this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
    return this._eventInfo.hasRenderTargetTextures;
  }
  /**
   * Called during a dispose event
   */
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  /**
   * An event triggered when the material is bound
   */
  get onBindObservable() {
    if (!this._onBindObservable) {
      this._onBindObservable = new Observable();
    }
    return this._onBindObservable;
  }
  /**
   * Called during a bind event
   */
  set onBind(callback) {
    if (this._onBindObserver) {
      this.onBindObservable.remove(this._onBindObserver);
    }
    this._onBindObserver = this.onBindObservable.add(callback);
  }
  /**
   * An event triggered when the material is unbound
   */
  get onUnBindObservable() {
    if (!this._onUnBindObservable) {
      this._onUnBindObservable = new Observable();
    }
    return this._onUnBindObservable;
  }
  /**
   * An event triggered when the effect is (re)created
   */
  get onEffectCreatedObservable() {
    if (!this._onEffectCreatedObservable) {
      this._onEffectCreatedObservable = new Observable();
    }
    return this._onEffectCreatedObservable;
  }
  /**
   * Sets the value of the alpha mode.
   *
   * | Value | Type | Description |
   * | --- | --- | --- |
   * | 0 | ALPHA_DISABLE |  |
   * | 1 | ALPHA_ADD | Defines that alpha blending is COLOR=SRC_ALPHA * SRC + DEST, ALPHA=DEST_ALPHA |
   * | 2 | ALPHA_COMBINE | Defines that alpha blending is COLOR=SRC_ALPHA * SRC + (1 - SRC_ALPHA) * DEST, ALPHA=SRC_ALPHA + DEST_ALPHA |
   * | 3 | ALPHA_SUBTRACT | Defines that alpha blending is COLOR=(1 - SRC) * DEST, ALPHA=SRC_ALPHA - DEST_ALPHA |
   * | 4 | ALPHA_MULTIPLY | Defines that alpha blending is COLOR=DEST * SRC, ALPHA=SRC_ALPHA + DEST_ALPHA |
   * | 5 | ALPHA_MAXIMIZED | Defines that alpha blending is COLOR=SRC_ALPHA * SRC + (1 - SRC) * DEST, ALPHA=SRC_ALPHA + DEST_ALPHA |
   * | 6 | ALPHA_ONEONE | Defines that alpha blending is COLOR=SRC + DEST, ALPHA=DEST_ALPHA |
   * | 7 | ALPHA_PREMULTIPLIED | Defines that alpha blending is COLOR=SRC + (1 - SRC_ALPHA) * DEST, ALPHA=SRC_ALPHA + DEST_ALPHA |
   * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF | Defines that alpha blending is COLOR=SRC + (1 - SRC_ALPHA) * DEST, ALPHA=SRC_ALPHA + (1 - SRC_ALPHA) * DEST_ALPHA |
   * | 9 | ALPHA_INTERPOLATE | Defines that alpha blending is COLOR=CST * SRC + (1 - CST) * DEST, ALPHA=CST_ALPHA * SRC + (1 - CST_ALPHA) * DEST_ALPHA |
   * | 10 | ALPHA_SCREENMODE | Defines that alpha blending is COLOR=SRC + (1 - SRC) * DEST, ALPHA=SRC_ALPHA + (1 - SRC_ALPHA) * DEST_ALPHA |
   * | 11 | ALPHA_ONEONE_ONEONE | Defines that alpha blending is COLOR=SRC + DST, ALPHA=SRC_ALPHA + DEST_ALPHA |
   * | 12 | ALPHA_ALPHATOCOLOR | Defines that alpha blending is COLOR=DEST_ALPHA * SRC + DST, ALPHA=0 |
   * | 13 | ALPHA_REVERSEONEMINUS | Defines that alpha blending is COLOR=(1 - DEST) * SRC + (1 - SRC) * DEST, ALPHA=(1 - DEST_ALPHA) * SRC_ALPHA + (1 - SRC_ALPHA) * DEST_ALPHA |
   * | 14 | ALPHA_SRC_DSTONEMINUSSRCALPHA | Defines that alpha blending is ALPHA=SRC + (1 - SRC ALPHA) * DEST, ALPHA=SRC_ALPHA + (1 - SRC ALPHA) * DEST_ALPHA |
   * | 15 | ALPHA_ONEONE_ONEZERO | Defines that alpha blending is COLOR=SRC + DST, ALPHA=SRC_ALPHA |
   * | 16 | ALPHA_EXCLUSION | Defines that alpha blending is COLOR=(1 - DEST) * SRC + (1 - SRC) * DEST, ALPHA=DEST_ALPHA |
   * | 17 | ALPHA_LAYER_ACCUMULATE | Defines that alpha blending is COLOR=SRC_ALPHA * SRC + (1 - SRC ALPHA) * DEST, ALPHA=SRC_ALPHA + (1 - SRC_ALPHA) * DEST_ALPHA |
   * | 18 | ALPHA_MIN | Defines that alpha blending is COLOR=MIN(SRC, DEST), ALPHA=MIN(SRC_ALPHA, DEST_ALPHA) |
   * | 19 | ALPHA_MAX | Defines that alpha blending is COLOR=MAX(SRC, DEST), ALPHA=MAX(SRC_ALPHA, DEST_ALPHA) |
   * | 20 | ALPHA_DUAL_SRC0_ADD_SRC1xDST | Defines that alpha blending uses dual source blending and is COLOR=SRC + SRC1 * DEST, ALPHA=DST_ALPHA |
   *
   */
  set alphaMode(value) {
    if (this._alphaMode[0] === value) {
      return;
    }
    this._alphaMode[0] = value;
    this.markAsDirty(_Material.TextureDirtyFlag);
  }
  /**
   * Gets the value of the alpha mode
   */
  get alphaMode() {
    return this._alphaMode[0];
  }
  /**
   * Gets the list of alpha modes (length greater than 1 for multi-targets)
   */
  get alphaModes() {
    return this._alphaMode;
  }
  /**
   * Sets the value of the alpha mode for a specific target index.
   * @param value The alpha mode value to set.
   * @param targetIndex The index of the target to set the alpha mode for. Defaults to 0.
   */
  setAlphaMode(value, targetIndex = 0) {
    if (this._alphaMode[targetIndex] === value) {
      return;
    }
    this._alphaMode[targetIndex] = value;
    this.markAsDirty(_Material.TextureDirtyFlag);
  }
  /**
   * Sets the need depth pre-pass value
   */
  set needDepthPrePass(value) {
    if (this._needDepthPrePass === value) {
      return;
    }
    this._needDepthPrePass = value;
    if (this._needDepthPrePass) {
      this.checkReadyOnEveryCall = true;
    }
  }
  /**
   * Gets the depth pre-pass value
   */
  get needDepthPrePass() {
    return this._needDepthPrePass;
  }
  /**
   * Can this material render to prepass
   */
  get isPrePassCapable() {
    return false;
  }
  /**
   * Sets the state for enabling fog
   */
  set fogEnabled(value) {
    if (this._fogEnabled === value) {
      return;
    }
    this._fogEnabled = value;
    this.markAsDirty(_Material.MiscDirtyFlag);
  }
  /**
   * Gets the value of the fog enabled state
   */
  get fogEnabled() {
    return this._fogEnabled;
  }
  get wireframe() {
    switch (this._fillMode) {
      case _Material.WireFrameFillMode:
      case _Material.LineListDrawMode:
      case _Material.LineLoopDrawMode:
      case _Material.LineStripDrawMode:
        return true;
    }
    return this._scene.forceWireframe;
  }
  /**
   * Sets the state of wireframe mode
   */
  set wireframe(value) {
    this.fillMode = value ? _Material.WireFrameFillMode : _Material.TriangleFillMode;
  }
  /**
   * Gets the value specifying if point clouds are enabled
   */
  get pointsCloud() {
    switch (this._fillMode) {
      case _Material.PointFillMode:
      case _Material.PointListDrawMode:
        return true;
    }
    return this._scene.forcePointsCloud;
  }
  /**
   * Sets the state of point cloud mode
   */
  set pointsCloud(value) {
    this.fillMode = value ? _Material.PointFillMode : _Material.TriangleFillMode;
  }
  /**
   * Gets the material fill mode
   */
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Sets the material fill mode
   */
  set fillMode(value) {
    if (this._fillMode === value) {
      return;
    }
    this._fillMode = value;
    this.markAsDirty(_Material.MiscDirtyFlag);
  }
  /**
   * In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)
   * You can try switching to logarithmic depth.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/logarithmicDepthBuffer
   */
  get useLogarithmicDepth() {
    return this._useLogarithmicDepth;
  }
  set useLogarithmicDepth(value) {
    const fragmentDepthSupported = this.getScene().getEngine().getCaps().fragmentDepthSupported;
    if (value && !fragmentDepthSupported) {
      Logger.Warn("Logarithmic depth has been requested for a material on a device that doesn't support it.");
    }
    this._useLogarithmicDepth = value && fragmentDepthSupported;
    this._markAllSubMeshesAsMiscDirty();
  }
  /**
   * Gets or sets the vertex output invariant state
   * Setting this property to true will force the shader compiler to disable some optimization to make sure the vertex output is always calculated
   * the same way across different compilation units.
   * You may need to enable this option if you are seeing some depth artifacts when using a depth pre-pass, for e.g.
   * Note that this may have an impact on performance, so leave this option disabled if not needed.
   */
  get isVertexOutputInvariant() {
    return this._isVertexOutputInvariant;
  }
  set isVertexOutputInvariant(value) {
    if (this._isVertexOutputInvariant === value) {
      return;
    }
    this._isVertexOutputInvariant = value;
    this._markAllSubMeshesAsMiscDirty();
  }
  /** @internal */
  _getDrawWrapper() {
    return this._drawWrapper;
  }
  /**
   * @internal
   */
  _setDrawWrapper(drawWrapper) {
    this._drawWrapper = drawWrapper;
  }
  /**
   * Creates a material instance
   * @param name defines the name of the material
   * @param scene defines the scene to reference
   * @param doNotAdd specifies if the material should be added to the scene
   * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
   */
  constructor(name, scene, doNotAdd, forceGLSL = false) {
    this.shadowDepthWrapper = null;
    this.allowShaderHotSwapping = true;
    this._shaderLanguage = 0;
    this._forceGLSL = false;
    this._useVertexPulling = false;
    this.metadata = null;
    this.reservedDataStore = null;
    this.checkReadyOnEveryCall = false;
    this.checkReadyOnlyOnce = false;
    this.state = "";
    this._alpha = 1;
    this._backFaceCulling = true;
    this._cullBackFaces = true;
    this._blockDirtyMechanism = false;
    this.sideOrientation = null;
    this.onCompiled = null;
    this.onError = null;
    this.getRenderTargetTextures = null;
    this.doNotSerialize = false;
    this._storeEffectOnSubMeshes = false;
    this.animations = null;
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this._onUnBindObservable = null;
    this._onBindObserver = null;
    this._alphaMode = [2];
    this._needDepthPrePass = false;
    this.disableDepthWrite = false;
    this.disableColorWrite = false;
    this.forceDepthWrite = false;
    this.depthFunction = 0;
    this.separateCullingPass = false;
    this._fogEnabled = true;
    this.pointSize = 1;
    this.zOffset = 0;
    this.zOffsetUnits = 0;
    this.stencil = new MaterialStencilState();
    this._isVertexOutputInvariant = _Material.ForceVertexOutputInvariant;
    this._useUBO = false;
    this._fillMode = _Material.TriangleFillMode;
    this._cachedDepthWriteState = false;
    this._cachedColorWriteState = false;
    this._cachedDepthFunctionState = 0;
    this._indexInSceneMaterialArray = -1;
    this.meshMap = null;
    this._parentContainer = null;
    this._uniformBufferLayoutBuilt = false;
    this._eventInfo = {};
    this._callbackPluginEventGeneric = () => void 0;
    this._callbackPluginEventIsReadyForSubMesh = () => void 0;
    this._callbackPluginEventPrepareDefines = () => void 0;
    this._callbackPluginEventPrepareDefinesBeforeAttributes = () => void 0;
    this._callbackPluginEventHardBindForSubMesh = () => void 0;
    this._callbackPluginEventBindForSubMesh = () => void 0;
    this._callbackPluginEventHasRenderTargetTextures = () => void 0;
    this._callbackPluginEventFillRenderTargetTextures = () => void 0;
    this._transparencyMode = null;
    this.name = name;
    const setScene = scene || EngineStore.LastCreatedScene;
    if (!setScene) {
      return;
    }
    this._scene = setScene;
    this._dirtyCallbacks = {};
    this._forceGLSL = forceGLSL;
    this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this);
    this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this);
    this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this);
    this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this);
    this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this);
    this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this);
    this._dirtyCallbacks[127] = this._markAllSubMeshesAsAllDirty.bind(this);
    this.id = name || Tools.RandomId();
    this.uniqueId = this._scene.getUniqueId();
    this._materialContext = this._scene.getEngine().createMaterialContext();
    this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);
    this._drawWrapper.materialContext = this._materialContext;
    this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), void 0, void 0, name);
    this._useUBO = this.getScene().getEngine().supportsUniformBuffers;
    this._createUniformBuffer();
    if (!doNotAdd) {
      this._scene.addMaterial(this);
    }
    if (this._scene.useMaterialMeshMap) {
      this.meshMap = {};
    }
    _Material.OnEventObservable.notifyObservers(
      this,
      1
      /* MaterialPluginEvent.Created */
    );
  }
  /** @internal */
  _createUniformBuffer() {
    const engine = this.getScene().getEngine();
    this._uniformBuffer?.dispose();
    if (engine.isWebGPU && !this._forceGLSL) {
      this._uniformBuffer = new UniformBuffer(engine, void 0, void 0, this.name, true);
      this._shaderLanguage = 1;
    } else {
      this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), void 0, void 0, this.name);
    }
    this._uniformBufferLayoutBuilt = false;
  }
  /**
   * Returns a string representation of the current material
   * @param fullDetails defines a boolean indicating which levels of logging is desired
   * @returns a string with material information
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  toString(fullDetails) {
    const ret = "Name: " + this.name;
    return ret;
  }
  /**
   * Gets the class name of the material
   * @returns a string with the class name of the material
   */
  getClassName() {
    return "Material";
  }
  /** @internal */
  get _isMaterial() {
    return true;
  }
  /**
   * Specifies if updates for the material been locked
   */
  get isFrozen() {
    return this.checkReadyOnlyOnce;
  }
  /**
   * Locks updates for the material
   */
  freeze() {
    this.markDirty();
    this.checkReadyOnlyOnce = true;
  }
  /**
   * Unlocks updates for the material
   */
  unfreeze() {
    this.markDirty();
    this.checkReadyOnlyOnce = false;
  }
  /**
   * Specifies if the material is ready to be used
   * @param mesh defines the mesh to check
   * @param useInstances specifies if instances should be used
   * @returns a boolean indicating if the material is ready to be used
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isReady(mesh, useInstances) {
    return true;
  }
  /**
   * Specifies that the submesh is ready to be used
   * @param mesh defines the mesh to check
   * @param subMesh defines which submesh to check
   * @param useInstances specifies that instances should be used
   * @returns a boolean indicating that the submesh is ready or not
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const defines = subMesh.materialDefines;
    if (!defines) {
      return false;
    }
    this._eventInfo.isReadyForSubMesh = true;
    this._eventInfo.defines = defines;
    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
    return this._eventInfo.isReadyForSubMesh;
  }
  /**
   * Returns the material effect
   * @returns the effect associated with the material
   */
  getEffect() {
    return this._drawWrapper.effect;
  }
  /**
   * Returns the current scene
   * @returns a Scene
   */
  getScene() {
    return this._scene;
  }
  /** @internal */
  _getEffectiveOrientation(mesh) {
    return this.sideOrientation !== null ? this.sideOrientation : mesh.sideOrientation;
  }
  /**
   * Gets the current transparency mode.
   */
  get transparencyMode() {
    return this._transparencyMode;
  }
  /**
   * Sets the transparency mode of the material.
   *
   * | Value | Type                                | Description |
   * | ----- | ----------------------------------- | ----------- |
   * | 0     | OPAQUE                              |             |
   * | 1     | ALPHATEST                           |             |
   * | 2     | ALPHABLEND                          |             |
   * | 3     | ALPHATESTANDBLEND                   |             |
   *
   */
  set transparencyMode(value) {
    if (this._transparencyMode === value) {
      return;
    }
    this._transparencyMode = value;
    this._markAllSubMeshesAsTexturesAndMiscDirty();
  }
  get _hasTransparencyMode() {
    return this._transparencyMode != null;
  }
  get _transparencyModeIsBlend() {
    return this._transparencyMode === _Material.MATERIAL_ALPHABLEND || this._transparencyMode === _Material.MATERIAL_ALPHATESTANDBLEND;
  }
  get _transparencyModeIsTest() {
    return this._transparencyMode === _Material.MATERIAL_ALPHATEST || this._transparencyMode === _Material.MATERIAL_ALPHATESTANDBLEND;
  }
  /**
   * Returns true if alpha blending should be disabled.
   */
  get _disableAlphaBlending() {
    return this._transparencyMode === _Material.MATERIAL_OPAQUE || this._transparencyMode === _Material.MATERIAL_ALPHATEST;
  }
  /**
   * Specifies whether or not this material should be rendered in alpha blend mode.
   * @returns a boolean specifying if alpha blending is needed
   * @deprecated Please use needAlphaBlendingForMesh instead
   */
  needAlphaBlending() {
    if (this._hasTransparencyMode) {
      return this._transparencyModeIsBlend;
    }
    if (this._disableAlphaBlending) {
      return false;
    }
    return this.alpha < 1;
  }
  /**
   * Specifies if the mesh will require alpha blending
   * @param mesh defines the mesh to check
   * @returns a boolean specifying if alpha blending is needed for the mesh
   */
  needAlphaBlendingForMesh(mesh) {
    if (this._hasTransparencyMode) {
      return this._transparencyModeIsBlend;
    }
    if (mesh.visibility < 1) {
      return true;
    }
    if (this._disableAlphaBlending) {
      return false;
    }
    return mesh.hasVertexAlpha || this.needAlphaBlending();
  }
  /**
   * Specifies whether or not this material should be rendered in alpha test mode.
   * @returns a boolean specifying if an alpha test is needed.
   * @deprecated Please use needAlphaTestingForMesh instead
   */
  needAlphaTesting() {
    if (this._hasTransparencyMode) {
      return this._transparencyModeIsTest;
    }
    return false;
  }
  /**
   * Specifies if material alpha testing should be turned on for the mesh
   * @param mesh defines the mesh to check
   * @returns a boolean specifying if alpha testing should be turned on for the mesh
   */
  needAlphaTestingForMesh(mesh) {
    if (this._hasTransparencyMode) {
      return this._transparencyModeIsTest;
    }
    return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();
  }
  /**
   * Gets the texture used for the alpha test
   * @returns the texture to use for alpha testing
   */
  getAlphaTestTexture() {
    return null;
  }
  /**
   * Marks the material to indicate that it needs to be re-calculated
   * @param forceMaterialDirty - Forces the material to be marked as dirty for all components (same as this.markAsDirty(Material.AllDirtyFlag)). You should use this flag if the material is frozen and you want to force a recompilation.
   */
  markDirty(forceMaterialDirty = false) {
    const meshes = this.getScene().meshes;
    for (const mesh of meshes) {
      if (!mesh.subMeshes) {
        continue;
      }
      for (const subMesh of mesh.subMeshes) {
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        for (const drawWrapper of subMesh._drawWrappers) {
          if (!drawWrapper) {
            continue;
          }
          if (this._materialContext === drawWrapper.materialContext) {
            drawWrapper._wasPreviouslyReady = false;
            drawWrapper._wasPreviouslyUsingInstances = null;
            drawWrapper._forceRebindOnNextCall = forceMaterialDirty;
          }
        }
      }
    }
    if (forceMaterialDirty) {
      this.markAsDirty(_Material.AllDirtyFlag);
    }
  }
  /**
   * @internal
   */
  _preBind(effect, overrideOrientation = null) {
    const engine = this._scene.getEngine();
    const orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;
    const reverse = orientation === _Material.ClockWiseSideOrientation;
    const effectiveDrawWrapper = effect ? effect : this._getDrawWrapper();
    if (IsWrapper(effectiveDrawWrapper) && effectiveDrawWrapper.materialContext) {
      effectiveDrawWrapper.materialContext.useVertexPulling = this.useVertexPulling;
    }
    engine.enableEffect(effectiveDrawWrapper);
    engine.setState(this.backFaceCulling, this.zOffset, false, reverse, this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces, this.stencil, this.zOffsetUnits);
    return reverse;
  }
  /**
   * Binds the material to the mesh
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh to bind the material to
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  bind(world, mesh) {
  }
  /**
   * Initializes the uniform buffer layout for the shader.
   */
  buildUniformLayout() {
    const ubo = this._uniformBuffer;
    this._eventInfo.ubo = ubo;
    this._callbackPluginEventGeneric(8, this._eventInfo);
    ubo.create();
    this._uniformBufferLayoutBuilt = true;
  }
  /**
   * Binds the submesh to the material
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh containing the submesh
   * @param subMesh defines the submesh to bind the material to
   */
  bindForSubMesh(world, mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventBindForSubMesh(this._eventInfo);
    drawWrapper._forceRebindOnNextCall = false;
  }
  /**
   * Binds the world matrix to the material
   * @param world defines the world transformation matrix
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  bindOnlyWorldMatrix(world) {
  }
  /**
   * Binds the view matrix to the effect
   * @param effect defines the effect to bind the view matrix to
   */
  bindView(effect) {
    if (!this._useUBO) {
      effect.setMatrix("view", this.getScene().getViewMatrix());
    } else {
      this._needToBindSceneUbo = true;
    }
  }
  /**
   * Binds the view projection and projection matrices to the effect
   * @param effect defines the effect to bind the view projection and projection matrices to
   */
  bindViewProjection(effect) {
    if (!this._useUBO) {
      effect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
      effect.setMatrix("projection", this.getScene().getProjectionMatrix());
    } else {
      this._needToBindSceneUbo = true;
    }
  }
  /**
   * Binds the view matrix to the effect
   * @param effect defines the effect to bind the view matrix to
   * @param variableName name of the shader variable that will hold the eye position
   */
  bindEyePosition(effect, variableName) {
    if (!this._useUBO) {
      this._scene.bindEyePosition(effect, variableName);
    } else {
      this._needToBindSceneUbo = true;
    }
  }
  /**
   * Processes to execute after binding the material to a mesh
   * @param mesh defines the rendered mesh
   * @param effect defines the effect used to bind the material
   * @param _subMesh defines the subMesh that the material has been bound for
   */
  _afterBind(mesh, effect = null, _subMesh) {
    this._scene._cachedMaterial = this;
    if (this._needToBindSceneUbo) {
      if (effect) {
        this._needToBindSceneUbo = false;
        BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());
        this._scene.finalizeSceneUbo();
      }
    }
    if (mesh) {
      this._scene._cachedVisibility = mesh.visibility;
    } else {
      this._scene._cachedVisibility = 1;
    }
    if (this._onBindObservable && mesh) {
      this._onBindObservable.notifyObservers(mesh);
    }
    if (this.disableDepthWrite) {
      const engine = this._scene.getEngine();
      this._cachedDepthWriteState = engine.getDepthWrite();
      engine.setDepthWrite(false);
    }
    if (this.disableColorWrite) {
      const engine = this._scene.getEngine();
      this._cachedColorWriteState = engine.getColorWrite();
      engine.setColorWrite(false);
    }
    if (this.depthFunction !== 0) {
      const engine = this._scene.getEngine();
      this._cachedDepthFunctionState = engine.getDepthFunction() || 0;
      engine.setDepthFunction(this.depthFunction);
    }
  }
  /**
   * Unbinds the material from the mesh
   */
  unbind() {
    this._scene.getSceneUniformBuffer().unbindEffect();
    if (this._onUnBindObservable) {
      this._onUnBindObservable.notifyObservers(this);
    }
    if (this.depthFunction !== 0) {
      const engine = this._scene.getEngine();
      engine.setDepthFunction(this._cachedDepthFunctionState);
    }
    if (this.disableDepthWrite) {
      const engine = this._scene.getEngine();
      engine.setDepthWrite(this._cachedDepthWriteState);
    }
    if (this.disableColorWrite) {
      const engine = this._scene.getEngine();
      engine.setColorWrite(this._cachedColorWriteState);
    }
  }
  /**
   * Returns the animatable textures.
   * @returns - Array of animatable textures.
   */
  getAnimatables() {
    this._eventInfo.animatables = [];
    this._callbackPluginEventGeneric(256, this._eventInfo);
    return this._eventInfo.animatables;
  }
  /**
   * Gets the active textures from the material
   * @returns an array of textures
   */
  getActiveTextures() {
    this._eventInfo.activeTextures = [];
    this._callbackPluginEventGeneric(512, this._eventInfo);
    return this._eventInfo.activeTextures;
  }
  /**
   * Specifies if the material uses a texture
   * @param texture defines the texture to check against the material
   * @returns a boolean specifying if the material uses the texture
   */
  hasTexture(texture) {
    this._eventInfo.hasTexture = false;
    this._eventInfo.texture = texture;
    this._callbackPluginEventGeneric(1024, this._eventInfo);
    return this._eventInfo.hasTexture;
  }
  /**
   * Makes a duplicate of the material, and gives it a new name
   * @param name defines the new name for the duplicated material
   * @returns the cloned material
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  clone(name) {
    return null;
  }
  _clonePlugins(targetMaterial, rootUrl) {
    const serializationObject = {};
    this._serializePlugins(serializationObject);
    _Material._ParsePlugins(serializationObject, targetMaterial, this._scene, rootUrl);
    if (this.pluginManager) {
      for (const plugin of this.pluginManager._plugins) {
        const targetPlugin = targetMaterial.pluginManager.getPlugin(plugin.name);
        if (targetPlugin) {
          plugin.copyTo(targetPlugin);
        }
      }
    }
  }
  /**
   * Gets the meshes bound to the material
   * @returns an array of meshes bound to the material
   */
  getBindedMeshes() {
    if (this.meshMap) {
      const result = [];
      for (const meshId in this.meshMap) {
        const mesh = this.meshMap[meshId];
        if (mesh) {
          result.push(mesh);
        }
      }
      return result;
    } else {
      const meshes = this._scene.meshes;
      return meshes.filter((mesh) => mesh.material === this);
    }
  }
  /**
   * Force shader compilation
   * @param mesh defines the mesh associated with this material
   * @param onCompiled defines a function to execute once the material is compiled
   * @param options defines the options to configure the compilation
   * @param onError defines a function to execute if the material fails compiling
   */
  forceCompilation(mesh, onCompiled, options, onError) {
    const localOptions = {
      clipPlane: false,
      useInstances: false,
      ...options
    };
    const scene = this.getScene();
    const currentHotSwapingState = this.allowShaderHotSwapping;
    this.allowShaderHotSwapping = false;
    const checkReady = () => {
      if (!this._scene || !this._scene.getEngine()) {
        return;
      }
      const clipPlaneState = scene.clipPlane;
      if (localOptions.clipPlane) {
        scene.clipPlane = new Plane(0, 0, 0, 1);
      }
      if (this._storeEffectOnSubMeshes) {
        let allDone = true, lastError = null;
        if (mesh.subMeshes) {
          const tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, void 0, false, false);
          if (tempSubMesh.materialDefines) {
            tempSubMesh.materialDefines._renderId = -1;
          }
          if (!this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {
            if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {
              lastError = tempSubMesh.effect.getCompilationError();
            } else {
              allDone = false;
              setTimeout(checkReady, 16);
            }
          }
        }
        if (allDone) {
          this.allowShaderHotSwapping = currentHotSwapingState;
          if (lastError) {
            if (onError) {
              onError(lastError);
            }
          }
          if (onCompiled) {
            onCompiled(this);
          }
        }
      } else {
        if (this.isReady()) {
          this.allowShaderHotSwapping = currentHotSwapingState;
          if (onCompiled) {
            onCompiled(this);
          }
        } else {
          setTimeout(checkReady, 16);
        }
      }
      if (localOptions.clipPlane) {
        scene.clipPlane = clipPlaneState;
      }
    };
    checkReady();
  }
  /**
   * Force shader compilation
   * @param mesh defines the mesh that will use this material
   * @param options defines additional options for compiling the shaders
   * @returns a promise that resolves when the compilation completes
   */
  async forceCompilationAsync(mesh, options) {
    return await new Promise((resolve, reject) => {
      this.forceCompilation(mesh, () => {
        resolve();
      }, options, (reason) => {
        reject(reason);
      });
    });
  }
  /**
   * Marks a define in the material to indicate that it needs to be re-computed
   * @param flag defines a flag used to determine which parts of the material have to be marked as dirty
   */
  markAsDirty(flag) {
    if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {
      return;
    }
    _Material._DirtyCallbackArray.length = 0;
    if (flag & _Material.ImageProcessingDirtyFlag) {
      _Material._DirtyCallbackArray.push(_Material._ImageProcessingDirtyCallBack);
    }
    if (flag & _Material.TextureDirtyFlag) {
      _Material._DirtyCallbackArray.push(_Material._TextureDirtyCallBack);
    }
    if (flag & _Material.LightDirtyFlag) {
      _Material._DirtyCallbackArray.push(_Material._LightsDirtyCallBack);
    }
    if (flag & _Material.FresnelDirtyFlag) {
      _Material._DirtyCallbackArray.push(_Material._FresnelDirtyCallBack);
    }
    if (flag & _Material.AttributesDirtyFlag) {
      _Material._DirtyCallbackArray.push(_Material._AttributeDirtyCallBack);
    }
    if (flag & _Material.MiscDirtyFlag) {
      _Material._DirtyCallbackArray.push(_Material._MiscDirtyCallBack);
    }
    if (flag & _Material.PrePassDirtyFlag) {
      _Material._DirtyCallbackArray.push(_Material._PrePassDirtyCallBack);
    }
    if (_Material._DirtyCallbackArray.length) {
      this._markAllSubMeshesAsDirty(_Material._RunDirtyCallBacks);
    }
    this.getScene().resetCachedMaterial();
  }
  /**
   * Resets the draw wrappers cache for all submeshes that are using this material
   */
  resetDrawCache() {
    const meshes = this.getScene().meshes;
    for (const mesh of meshes) {
      if (!mesh.subMeshes) {
        continue;
      }
      for (const subMesh of mesh.subMeshes) {
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        subMesh.resetDrawCache();
      }
    }
  }
  /**
   * Marks all submeshes of a material to indicate that their material defines need to be re-calculated
   * @param func defines a function which checks material defines against the submeshes
   */
  _markAllSubMeshesAsDirty(func) {
    const scene = this.getScene();
    if (scene.blockMaterialDirtyMechanism || this._blockDirtyMechanism) {
      return;
    }
    const meshes = scene.meshes;
    for (const mesh of meshes) {
      if (!mesh.subMeshes) {
        continue;
      }
      for (const subMesh of mesh.subMeshes) {
        const material = subMesh.getMaterial() || (scene._hasDefaultMaterial ? scene.defaultMaterial : null);
        if (material !== this) {
          continue;
        }
        for (const drawWrapper of subMesh._drawWrappers) {
          if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {
            continue;
          }
          if (this._materialContext === drawWrapper.materialContext) {
            func(drawWrapper.defines);
          }
        }
      }
    }
  }
  /**
   * Indicates that the scene should check if the rendering now needs a prepass
   */
  _markScenePrePassDirty() {
    if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {
      return;
    }
    const prePassRenderer = this.getScene().enablePrePassRenderer();
    if (prePassRenderer) {
      prePassRenderer.markAsDirty();
    }
  }
  /**
   * Indicates that we need to re-calculated for all submeshes
   */
  _markAllSubMeshesAsAllDirty() {
    this._markAllSubMeshesAsDirty(_Material._AllDirtyCallBack);
  }
  /**
   * Indicates that image processing needs to be re-calculated for all submeshes
   */
  _markAllSubMeshesAsImageProcessingDirty() {
    this._markAllSubMeshesAsDirty(_Material._ImageProcessingDirtyCallBack);
  }
  /**
   * Indicates that textures need to be re-calculated for all submeshes
   */
  _markAllSubMeshesAsTexturesDirty() {
    this._markAllSubMeshesAsDirty(_Material._TextureDirtyCallBack);
  }
  /**
   * Indicates that fresnel needs to be re-calculated for all submeshes
   */
  _markAllSubMeshesAsFresnelDirty() {
    this._markAllSubMeshesAsDirty(_Material._FresnelDirtyCallBack);
  }
  /**
   * Indicates that fresnel and misc need to be re-calculated for all submeshes
   */
  _markAllSubMeshesAsFresnelAndMiscDirty() {
    this._markAllSubMeshesAsDirty(_Material._FresnelAndMiscDirtyCallBack);
  }
  /**
   * Indicates that lights need to be re-calculated for all submeshes
   */
  _markAllSubMeshesAsLightsDirty() {
    this._markAllSubMeshesAsDirty(_Material._LightsDirtyCallBack);
  }
  /**
   * Indicates that attributes need to be re-calculated for all submeshes
   */
  _markAllSubMeshesAsAttributesDirty() {
    this._markAllSubMeshesAsDirty(_Material._AttributeDirtyCallBack);
  }
  /**
   * Indicates that misc needs to be re-calculated for all submeshes
   */
  _markAllSubMeshesAsMiscDirty() {
    this._markAllSubMeshesAsDirty(_Material._MiscDirtyCallBack);
  }
  /**
   * Indicates that prepass needs to be re-calculated for all submeshes
   */
  _markAllSubMeshesAsPrePassDirty() {
    this._markAllSubMeshesAsDirty(_Material._PrePassDirtyCallBack);
  }
  /**
   * Indicates that textures and misc need to be re-calculated for all submeshes
   */
  _markAllSubMeshesAsTexturesAndMiscDirty() {
    this._markAllSubMeshesAsDirty(_Material._TextureAndMiscDirtyCallBack);
  }
  _checkScenePerformancePriority() {
    if (this._scene.performancePriority !== 0) {
      this.checkReadyOnlyOnce = true;
      const observer = this._scene.onScenePerformancePriorityChangedObservable.addOnce(() => {
        this.checkReadyOnlyOnce = false;
      });
      this.onDisposeObservable.add(() => {
        this._scene.onScenePerformancePriorityChangedObservable.remove(observer);
      });
    }
  }
  /**
   * Sets the required values to the prepass renderer.
   * @param prePassRenderer defines the prepass renderer to setup.
   * @returns true if the pre pass is needed.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setPrePassRenderer(prePassRenderer) {
    return false;
  }
  /**
   * Disposes the material
   * @param _forceDisposeEffect kept for backward compat. We reference count the effect now.
   * @param forceDisposeTextures specifies if textures should be forcefully disposed
   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
   */
  dispose(_forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    const scene = this.getScene();
    scene.stopAnimation(this);
    scene.freeProcessedMaterials();
    scene.removeMaterial(this);
    this._eventInfo.forceDisposeTextures = forceDisposeTextures;
    this._callbackPluginEventGeneric(2, this._eventInfo);
    if (this._parentContainer) {
      const index = this._parentContainer.materials.indexOf(this);
      if (index > -1) {
        this._parentContainer.materials.splice(index, 1);
      }
      this._parentContainer = null;
    }
    if (notBoundToMesh !== true) {
      if (this.meshMap) {
        for (const meshId in this.meshMap) {
          const mesh = this.meshMap[meshId];
          this._disposeMeshResources(mesh);
        }
      } else {
        const meshes = scene.meshes;
        for (const mesh of meshes) {
          this._disposeMeshResources(mesh);
        }
      }
    }
    this._uniformBuffer.dispose();
    if (this._drawWrapper.effect) {
      if (!this._storeEffectOnSubMeshes) {
        this._drawWrapper.effect.dispose();
      }
      this._drawWrapper.effect = null;
    }
    this.metadata = null;
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    if (this._onBindObservable) {
      this._onBindObservable.clear();
    }
    if (this._onUnBindObservable) {
      this._onUnBindObservable.clear();
    }
    if (this._onEffectCreatedObservable) {
      this._onEffectCreatedObservable.clear();
    }
    if (this._eventInfo) {
      this._eventInfo = {};
    }
  }
  _disposeMeshResources(mesh) {
    if (!mesh) {
      return;
    }
    const geometry = mesh.geometry;
    const materialForRenderPass = mesh._internalAbstractMeshDataInfo._materialForRenderPass;
    if (this._storeEffectOnSubMeshes) {
      if (mesh.subMeshes && materialForRenderPass) {
        for (const subMesh of mesh.subMeshes) {
          const drawWrappers = subMesh._drawWrappers;
          for (let renderPassIndex = 0; renderPassIndex < drawWrappers.length; renderPassIndex++) {
            const effect = drawWrappers[renderPassIndex]?.effect;
            if (!effect) {
              continue;
            }
            const material = materialForRenderPass[renderPassIndex];
            if (material === this) {
              geometry?._releaseVertexArrayObject(effect);
              subMesh._removeDrawWrapper(renderPassIndex, true, true);
            }
          }
        }
      }
    } else {
      geometry?._releaseVertexArrayObject(this._drawWrapper.effect);
    }
    if (mesh.material === this && !mesh.sourceMesh) {
      mesh.material = null;
    }
  }
  /**
   * Serializes this material
   * @returns the serialized material object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.stencil = this.stencil.serialize();
    serializationObject.uniqueId = this.uniqueId;
    this._serializePlugins(serializationObject);
    return serializationObject;
  }
  _serializePlugins(serializationObject) {
    serializationObject.plugins = {};
    if (this.pluginManager) {
      for (const plugin of this.pluginManager._plugins) {
        if (!plugin.doNotSerialize) {
          serializationObject.plugins[plugin.getClassName()] = plugin.serialize();
        }
      }
    }
  }
  /**
   * Parses the alpha mode from the material data to parse
   * @param parsedMaterial defines the material data to parse
   * @param material defines the material to update
   */
  static ParseAlphaMode(parsedMaterial, material) {
    if (parsedMaterial._alphaMode !== void 0) {
      material._alphaMode = Array.isArray(parsedMaterial._alphaMode) ? parsedMaterial._alphaMode : [parsedMaterial._alphaMode];
    } else if (parsedMaterial.alphaMode !== void 0) {
      material._alphaMode = Array.isArray(parsedMaterial.alphaMode) ? parsedMaterial.alphaMode : [parsedMaterial.alphaMode];
    } else {
      material._alphaMode = [2];
    }
  }
  /**
   * Creates a material from parsed material data
   * @param parsedMaterial defines parsed material data
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures
   * @returns a new material
   */
  static Parse(parsedMaterial, scene, rootUrl) {
    if (!parsedMaterial.customType) {
      parsedMaterial.customType = "BABYLON.StandardMaterial";
    } else if (parsedMaterial.customType === "BABYLON.PBRMaterial" && parsedMaterial.overloadedAlbedo) {
      parsedMaterial.customType = "BABYLON.LegacyPBRMaterial";
      if (!BABYLON.LegacyPBRMaterial) {
        Logger.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.");
        return null;
      }
    }
    const materialType = Tools.Instantiate(parsedMaterial.customType);
    const material = materialType.Parse(parsedMaterial, scene, rootUrl);
    material._loadedUniqueId = parsedMaterial.uniqueId;
    _Material.ParseAlphaMode(parsedMaterial, material);
    return material;
  }
  static _ParsePlugins(serializationObject, material, scene, rootUrl) {
    if (!serializationObject.plugins) {
      return;
    }
    for (const pluginClassName in serializationObject.plugins) {
      const pluginData = serializationObject.plugins[pluginClassName];
      let plugin = material.pluginManager?.getPlugin(pluginData.name);
      if (!plugin) {
        const pluginClassType = Tools.Instantiate("BABYLON." + pluginClassName);
        if (pluginClassType) {
          plugin = new pluginClassType(material);
        }
      }
      plugin?.parse(pluginData, scene, rootUrl);
    }
  }
};
Material.TriangleFillMode = 0;
Material.WireFrameFillMode = 1;
Material.PointFillMode = 2;
Material.PointListDrawMode = 3;
Material.LineListDrawMode = 4;
Material.LineLoopDrawMode = 5;
Material.LineStripDrawMode = 6;
Material.TriangleStripDrawMode = 7;
Material.TriangleFanDrawMode = 8;
Material.ClockWiseSideOrientation = 0;
Material.CounterClockWiseSideOrientation = 1;
Material.ImageProcessingDirtyFlag = 64;
Material.TextureDirtyFlag = 1;
Material.LightDirtyFlag = 2;
Material.FresnelDirtyFlag = 4;
Material.AttributesDirtyFlag = 8;
Material.MiscDirtyFlag = 16;
Material.PrePassDirtyFlag = 32;
Material.AllDirtyFlag = 127;
Material.MATERIAL_OPAQUE = 0;
Material.MATERIAL_ALPHATEST = 1;
Material.MATERIAL_ALPHABLEND = 2;
Material.MATERIAL_ALPHATESTANDBLEND = 3;
Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;
Material.MATERIAL_NORMALBLENDMETHOD_RNM = 1;
Material.LIGHTFALLOFF_PHYSICAL = 0;
Material.LIGHTFALLOFF_GLTF = 1;
Material.LIGHTFALLOFF_STANDARD = 2;
Material.OnEventObservable = new Observable();
Material.ForceVertexOutputInvariant = false;
Material._AllDirtyCallBack = (defines) => defines.markAllAsDirty();
Material._ImageProcessingDirtyCallBack = (defines) => defines.markAsImageProcessingDirty();
Material._TextureDirtyCallBack = (defines) => defines.markAsTexturesDirty();
Material._FresnelDirtyCallBack = (defines) => defines.markAsFresnelDirty();
Material._MiscDirtyCallBack = (defines) => defines.markAsMiscDirty();
Material._PrePassDirtyCallBack = (defines) => defines.markAsPrePassDirty();
Material._LightsDirtyCallBack = (defines) => defines.markAsLightDirty();
Material._AttributeDirtyCallBack = (defines) => defines.markAsAttributesDirty();
Material._FresnelAndMiscDirtyCallBack = (defines) => {
  Material._FresnelDirtyCallBack(defines);
  Material._MiscDirtyCallBack(defines);
};
Material._TextureAndMiscDirtyCallBack = (defines) => {
  Material._TextureDirtyCallBack(defines);
  Material._MiscDirtyCallBack(defines);
};
Material._DirtyCallbackArray = [];
Material._RunDirtyCallBacks = (defines) => {
  for (const cb of Material._DirtyCallbackArray) {
    cb(defines);
  }
};
__decorate([
  serialize()
], Material.prototype, "id", void 0);
__decorate([
  serialize()
], Material.prototype, "uniqueId", void 0);
__decorate([
  serialize()
], Material.prototype, "name", void 0);
__decorate([
  serialize()
], Material.prototype, "metadata", void 0);
__decorate([
  serialize()
], Material.prototype, "checkReadyOnEveryCall", void 0);
__decorate([
  serialize()
], Material.prototype, "checkReadyOnlyOnce", void 0);
__decorate([
  serialize()
], Material.prototype, "state", void 0);
__decorate([
  serialize("alpha")
], Material.prototype, "_alpha", void 0);
__decorate([
  serialize("backFaceCulling")
], Material.prototype, "_backFaceCulling", void 0);
__decorate([
  serialize("cullBackFaces")
], Material.prototype, "_cullBackFaces", void 0);
__decorate([
  serialize()
], Material.prototype, "sideOrientation", void 0);
__decorate([
  serialize()
], Material.prototype, "_alphaMode", void 0);
__decorate([
  serialize()
], Material.prototype, "_needDepthPrePass", void 0);
__decorate([
  serialize()
], Material.prototype, "disableDepthWrite", void 0);
__decorate([
  serialize()
], Material.prototype, "disableColorWrite", void 0);
__decorate([
  serialize()
], Material.prototype, "forceDepthWrite", void 0);
__decorate([
  serialize()
], Material.prototype, "depthFunction", void 0);
__decorate([
  serialize()
], Material.prototype, "separateCullingPass", void 0);
__decorate([
  serialize("fogEnabled")
], Material.prototype, "_fogEnabled", void 0);
__decorate([
  serialize()
], Material.prototype, "pointSize", void 0);
__decorate([
  serialize()
], Material.prototype, "zOffset", void 0);
__decorate([
  serialize()
], Material.prototype, "zOffsetUnits", void 0);
__decorate([
  serialize()
], Material.prototype, "pointsCloud", null);
__decorate([
  serialize()
], Material.prototype, "fillMode", null);
__decorate([
  serialize()
], Material.prototype, "useLogarithmicDepth", null);
__decorate([
  serialize()
], Material.prototype, "_isVertexOutputInvariant", void 0);
__decorate([
  serialize()
], Material.prototype, "transparencyMode", null);

// node_modules/@babylonjs/core/Rendering/thinDepthPeelingRenderer.js
var ThinDepthPeelingRenderer = class _ThinDepthPeelingRenderer {
  /**
   * Number of depth peeling passes. As we are using dual depth peeling, each pass two levels of transparency are processed.
   */
  get passCount() {
    return this._passCount;
  }
  set passCount(count) {
    if (this._passCount === count) {
      return;
    }
    this._passCount = count;
    this._createRenderPassIds();
  }
  /**
   * Instructs the renderer to use render passes. It is an optimization that makes the rendering faster for some engines (like WebGPU) but that consumes more memory, so it is disabled by default.
   */
  get useRenderPasses() {
    return this._useRenderPasses;
  }
  set useRenderPasses(usePasses) {
    if (this._useRenderPasses === usePasses) {
      return;
    }
    this._useRenderPasses = usePasses;
    this._createRenderPassIds();
  }
  /**
   * Add a mesh in the exclusion list to prevent it to be handled by the depth peeling renderer
   * @param mesh The mesh to exclude from the depth peeling renderer
   */
  addExcludedMesh(mesh) {
    if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {
      this._excludedMeshes.push(mesh.uniqueId);
    }
  }
  /**
   * Remove a mesh from the exclusion list of the depth peeling renderer
   * @param mesh The mesh to remove
   */
  removeExcludedMesh(mesh) {
    const index = this._excludedMeshes.indexOf(mesh.uniqueId);
    if (index !== -1) {
      this._excludedMeshes.splice(index, 1);
    }
  }
  /**
   * Gets the shader language used in this renderer
   */
  get shaderLanguage() {
    return this._shaderLanguage;
  }
  /**
   * Sets the render target wrapper we will blend the transparent objects onto
   */
  get blendOutput() {
    return this._blendOutput;
  }
  set blendOutput(blendOutput) {
    this._blendOutput = blendOutput;
    this._disposeTextures();
    if (blendOutput) {
      this._createTextures();
    }
  }
  /**
   * Instanciates the depth peeling renderer
   * @param scene Scene to attach to
   * @param passCount Number of depth layers to peel
   * @returns The depth peeling renderer
   */
  constructor(scene, passCount = 5) {
    this._depthMrts = [];
    this._thinTextures = [];
    this._colorMrts = [];
    this._currentPingPongState = 0;
    this._layoutCacheFormat = [[true], [true, true], [true, true, true]];
    this._layoutCache = [];
    this._candidateSubMeshes = new SmartArray(10);
    this._excludedSubMeshes = new SmartArray(10);
    this._excludedMeshes = [];
    this._colorCache = [
      new Color4(_ThinDepthPeelingRenderer._DEPTH_CLEAR_VALUE, _ThinDepthPeelingRenderer._DEPTH_CLEAR_VALUE, 0, 0),
      new Color4(-_ThinDepthPeelingRenderer._MIN_DEPTH, _ThinDepthPeelingRenderer._MAX_DEPTH, 0, 0),
      new Color4(0, 0, 0, 0)
    ];
    this._shaderLanguage = 0;
    this._scene = scene;
    this._engine = scene.getEngine();
    this._passCount = passCount;
    for (let i = 0; i < this._layoutCacheFormat.length; ++i) {
      this._layoutCache[i] = this._engine.buildTextureLayout(this._layoutCacheFormat[i]);
    }
    this._renderPassIds = [];
    this.useRenderPasses = false;
    if (this._engine.isWebGPU) {
      this._shaderLanguage = 1;
    }
    this._createEffects("oitFinalSimpleBlend", ["uFrontColor"]);
  }
  _createRenderPassIds() {
    this._releaseRenderPassIds();
    if (this._useRenderPasses) {
      for (let i = 0; i < this._passCount + 1; ++i) {
        if (!this._renderPassIds[i]) {
          this._renderPassIds[i] = this._engine.createRenderPassId(`DepthPeelingRenderer - pass #${i}`);
        }
      }
    }
  }
  _releaseRenderPassIds() {
    for (let i = 0; i < this._renderPassIds.length; ++i) {
      this._engine.releaseRenderPassId(this._renderPassIds[i]);
    }
    this._renderPassIds = [];
  }
  _getTextureSize() {
    if (this._blendOutput) {
      return {
        width: this._blendOutput.width,
        height: this._blendOutput.height
      };
    }
    return { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() };
  }
  _createTextures() {
    const size = this._getTextureSize();
    this._depthMrts = [
      new MultiRenderTarget("depthPeelingDepth0MRT", size, 3, this._scene, void 0, [
        "depthPeelingDepth0MRT_depth",
        "depthPeelingDepth0MRT_frontColor",
        "depthPeelingDepth0MRT_backColor"
      ]),
      new MultiRenderTarget("depthPeelingDepth1MRT", size, 3, this._scene, void 0, [
        "depthPeelingDepth1MRT_depth",
        "depthPeelingDepth1MRT_frontColor",
        "depthPeelingDepth1MRT_backColor"
      ])
    ];
    this._colorMrts = [
      new MultiRenderTarget("depthPeelingColor0MRT", size, 2, this._scene, { generateDepthBuffer: false }, [
        "depthPeelingColor0MRT_frontColor",
        "depthPeelingColor0MRT_backColor"
      ]),
      new MultiRenderTarget("depthPeelingColor1MRT", size, 2, this._scene, { generateDepthBuffer: false }, [
        "depthPeelingColor1MRT_frontColor",
        "depthPeelingColor1MRT_backColor"
      ])
    ];
    this._blendBackMrt = new MultiRenderTarget("depthPeelingBackMRT", size, 1, this._scene, { generateDepthBuffer: false }, ["depthPeelingBackMRT_blendBack"]);
    if (this._blendOutput) {
      this._blendBackMrt.setInternalTexture(this._blendOutput.texture, 0);
    }
    const optionsArray = [
      {
        format: 7,
        samplingMode: 1,
        type: this._engine.getCaps().textureFloatLinearFiltering ? 1 : 2,
        label: "DepthPeelingRenderer-DepthTexture"
      },
      {
        format: 5,
        samplingMode: 1,
        type: 2,
        label: "DepthPeelingRenderer-ColorTexture"
      }
    ];
    for (let i = 0; i < 2; i++) {
      const depthTexture = this._engine._createInternalTexture(size, optionsArray[0], false);
      const frontColorTexture = this._engine._createInternalTexture(size, optionsArray[1], false);
      const backColorTexture = this._engine._createInternalTexture(size, optionsArray[1], false);
      this._depthMrts[i].setInternalTexture(depthTexture, 0);
      this._depthMrts[i].setInternalTexture(frontColorTexture, 1);
      this._depthMrts[i].setInternalTexture(backColorTexture, 2);
      this._colorMrts[i].setInternalTexture(frontColorTexture, 0);
      this._colorMrts[i].setInternalTexture(backColorTexture, 1);
      this._thinTextures.push(new ThinTexture(depthTexture), new ThinTexture(frontColorTexture), new ThinTexture(backColorTexture));
    }
    if (this._blendOutput) {
      this._blendOutput.shareDepth(this._depthMrts[0].renderTarget);
    }
  }
  _disposeTextures() {
    for (let i = 0; i < this._thinTextures.length; i++) {
      this._thinTextures[i].dispose();
    }
    for (let i = 0; i < this._depthMrts.length; i++) {
      this._depthMrts[i].dispose(true);
      this._colorMrts[i].dispose(true);
      this._blendBackMrt.dispose(true);
    }
    this._thinTextures = [];
    this._colorMrts = [];
    this._depthMrts = [];
  }
  _createEffects(finalEffectFragmentShaderName, finalEffectSamplerNames) {
    this._blendBackEffectWrapper = new EffectWrapper({
      fragmentShader: "oitBackBlend",
      useShaderStore: true,
      engine: this._engine,
      samplerNames: ["uBackColor"],
      uniformNames: [],
      shaderLanguage: this._shaderLanguage,
      extraInitializationsAsync: async () => {
        if (this._shaderLanguage === 1) {
          await import("./oitBackBlend.fragment-3JOS2L5P.js");
        } else {
          await import("./oitBackBlend.fragment-5OGXIY55.js");
        }
      }
    });
    this._blendBackEffectWrapperPingPong = new EffectWrapper({
      fragmentShader: "oitBackBlend",
      useShaderStore: true,
      engine: this._engine,
      samplerNames: ["uBackColor"],
      uniformNames: [],
      shaderLanguage: this._shaderLanguage,
      extraInitializationsAsync: async () => {
        if (this._shaderLanguage === 1) {
          await import("./oitBackBlend.fragment-3JOS2L5P.js");
        } else {
          await import("./oitBackBlend.fragment-5OGXIY55.js");
        }
      }
    });
    this._finalEffectWrapper = new EffectWrapper({
      fragmentShader: finalEffectFragmentShaderName,
      useShaderStore: true,
      engine: this._engine,
      samplerNames: finalEffectSamplerNames,
      uniformNames: [],
      shaderLanguage: this._shaderLanguage,
      extraInitializationsAsync: async () => {
        if (this._shaderLanguage === 1) {
          await import("./oitFinalSimpleBlend.fragment-AP2YL6XH.js");
        } else {
          await import("./oitFinalSimpleBlend.fragment-DVYWNBZG.js");
        }
      }
    });
    this._effectRenderer = new EffectRenderer(this._engine);
  }
  /**
   * Links to the prepass renderer
   * @param _prePassRenderer The scene PrePassRenderer
   */
  setPrePassRenderer(_prePassRenderer) {
  }
  /**
   * Binds depth peeling textures on an effect
   * @param effect The effect to bind textures on
   */
  bind(effect) {
    effect.setTexture("oitDepthSampler", this._thinTextures[this._currentPingPongState * 3]);
    effect.setTexture("oitFrontColorSampler", this._thinTextures[this._currentPingPongState * 3 + 1]);
  }
  _renderSubMeshes(transparentSubMeshes) {
    let mapMaterialContext;
    if (this._useRenderPasses) {
      mapMaterialContext = {};
    }
    for (let j = 0; j < transparentSubMeshes.length; j++) {
      const material = transparentSubMeshes.data[j].getMaterial();
      let previousShaderHotSwapping = true;
      let previousBFC = false;
      const subMesh = transparentSubMeshes.data[j];
      let drawWrapper;
      let firstDraw = false;
      if (this._useRenderPasses) {
        drawWrapper = subMesh._getDrawWrapper();
        firstDraw = !drawWrapper;
      }
      if (material) {
        previousShaderHotSwapping = material.allowShaderHotSwapping;
        previousBFC = material.backFaceCulling;
        material.allowShaderHotSwapping = false;
        material.backFaceCulling = false;
      }
      subMesh.render(false);
      if (firstDraw) {
        drawWrapper = subMesh._getDrawWrapper();
        if (drawWrapper.materialContext) {
          let newMaterialContext = mapMaterialContext[drawWrapper.materialContext.uniqueId];
          if (!newMaterialContext) {
            newMaterialContext = mapMaterialContext[drawWrapper.materialContext.uniqueId] = this._engine.createMaterialContext();
          }
          subMesh._getDrawWrapper().materialContext = newMaterialContext;
        }
      }
      if (material) {
        material.allowShaderHotSwapping = previousShaderHotSwapping;
        material.backFaceCulling = previousBFC;
      }
    }
  }
  _finalCompose(writeId) {
    this._engine.bindFramebuffer(this._blendOutput);
    this._engine.setAlphaMode(7);
    this._engine.depthCullingState.depthMask = false;
    this._engine.depthCullingState.depthTest = false;
    this._engine.applyStates();
    this._engine.enableEffect(this._finalEffectWrapper.drawWrapper);
    this._finalEffectWrapper.effect.setTexture("uFrontColor", this._thinTextures[writeId * 3 + 1]);
    this._effectRenderer.render(this._finalEffectWrapper);
  }
  /**
   * Checks if the depth peeling renderer is ready to render transparent meshes
   * @returns true if the depth peeling renderer is ready to render the transparent meshes
   */
  isReady() {
    return this._blendBackEffectWrapper.effect.isReady() && this._blendBackEffectWrapperPingPong.effect.isReady() && this._finalEffectWrapper.effect.isReady();
  }
  _beforeRender() {
  }
  _afterRender() {
  }
  /**
   * Renders transparent submeshes with depth peeling
   * @param transparentSubMeshes List of transparent meshes to render
   * @returns The array of submeshes that could not be handled by this renderer
   */
  render(transparentSubMeshes) {
    this._candidateSubMeshes.length = 0;
    this._excludedSubMeshes.length = 0;
    if (!this.isReady()) {
      return this._excludedSubMeshes;
    }
    if (this._scene.activeCamera) {
      this._engine.setViewport(this._scene.activeCamera.viewport);
    }
    for (let i = 0; i < transparentSubMeshes.length; i++) {
      const subMesh = transparentSubMeshes.data[i];
      const material = subMesh.getMaterial();
      const fillMode = material && subMesh.getRenderingMesh()._getRenderingFillMode(material.fillMode);
      if (material && (fillMode === Material.TriangleFanDrawMode || fillMode === Material.TriangleFillMode || fillMode === Material.TriangleStripDrawMode) && this._excludedMeshes.indexOf(subMesh.getMesh().uniqueId) === -1) {
        this._candidateSubMeshes.push(subMesh);
      } else {
        this._excludedSubMeshes.push(subMesh);
      }
    }
    if (!this._candidateSubMeshes.length) {
      return this._excludedSubMeshes;
    }
    const currentRenderPassId = this._engine.currentRenderPassId;
    this._beforeRender();
    if (this._useRenderPasses) {
      this._engine.currentRenderPassId = this._renderPassIds[0];
    }
    this._engine.bindFramebuffer(this._depthMrts[0].renderTarget);
    this._engine.bindAttachments(this._layoutCache[0]);
    this._engine.clear(this._colorCache[0], true, false, false);
    this._engine.unBindFramebuffer(this._depthMrts[0].renderTarget);
    this._engine.bindFramebuffer(this._depthMrts[1].renderTarget);
    this._engine.bindAttachments(this._layoutCache[0]);
    this._engine.clear(this._colorCache[1], true, false, false);
    this._engine.unBindFramebuffer(this._depthMrts[1].renderTarget);
    this._engine.bindFramebuffer(this._colorMrts[0].renderTarget);
    this._engine.bindAttachments(this._layoutCache[1]);
    this._engine.clear(this._colorCache[2], true, false, false);
    this._engine.unBindFramebuffer(this._colorMrts[0].renderTarget);
    this._engine.bindFramebuffer(this._colorMrts[1].renderTarget);
    this._engine.bindAttachments(this._layoutCache[1]);
    this._engine.clear(this._colorCache[2], true, false, false);
    this._engine.unBindFramebuffer(this._colorMrts[1].renderTarget);
    this._engine.bindFramebuffer(this._depthMrts[0].renderTarget);
    this._engine.bindAttachments(this._layoutCache[0]);
    this._engine.setAlphaMode(11);
    this._engine.setAlphaEquation(3);
    this._engine.depthCullingState.depthMask = false;
    this._engine.depthCullingState.depthTest = true;
    this._engine.applyStates();
    this._currentPingPongState = 1;
    this._renderSubMeshes(this._candidateSubMeshes);
    this._engine.unBindFramebuffer(this._depthMrts[0].renderTarget);
    this._scene.resetCachedMaterial();
    let readId = 0;
    let writeId = 0;
    for (let i = 0; i < this._passCount; i++) {
      readId = i % 2;
      writeId = 1 - readId;
      this._currentPingPongState = readId;
      if (this._useRenderPasses) {
        this._engine.currentRenderPassId = this._renderPassIds[i + 1];
      }
      if (this._scene.activeCamera) {
        this._engine.setViewport(this._scene.activeCamera.viewport);
      }
      this._engine.bindFramebuffer(this._depthMrts[writeId].renderTarget);
      this._engine.bindAttachments(this._layoutCache[0]);
      this._engine.clear(this._colorCache[0], true, false, false);
      this._engine.unBindFramebuffer(this._depthMrts[writeId].renderTarget);
      this._engine.bindFramebuffer(this._colorMrts[writeId].renderTarget);
      this._engine.bindAttachments(this._layoutCache[1]);
      this._engine.clear(this._colorCache[2], true, false, false);
      this._engine.unBindFramebuffer(this._colorMrts[writeId].renderTarget);
      this._engine.bindFramebuffer(this._depthMrts[writeId].renderTarget);
      this._engine.bindAttachments(this._layoutCache[2]);
      this._engine.setAlphaMode(11);
      this._engine.setAlphaEquation(3);
      this._engine.depthCullingState.depthTest = false;
      this._engine.applyStates();
      this._renderSubMeshes(this._candidateSubMeshes);
      this._engine.unBindFramebuffer(this._depthMrts[writeId].renderTarget);
      this._scene.resetCachedMaterial();
      this._engine.bindFramebuffer(this._blendBackMrt.renderTarget);
      this._engine.bindAttachments(this._layoutCache[0]);
      this._engine.setAlphaEquation(0);
      this._engine.setAlphaMode(17);
      this._engine.applyStates();
      const blendBackEffectWrapper = writeId === 0 || !this._useRenderPasses ? this._blendBackEffectWrapper : this._blendBackEffectWrapperPingPong;
      this._engine.enableEffect(blendBackEffectWrapper.drawWrapper);
      blendBackEffectWrapper.effect.setTexture("uBackColor", this._thinTextures[writeId * 3 + 2]);
      this._effectRenderer.render(blendBackEffectWrapper);
      this._engine.unBindFramebuffer(this._blendBackMrt.renderTarget);
    }
    this._engine.currentRenderPassId = currentRenderPassId;
    this._finalCompose(writeId);
    this._engine.setAlphaMode(0);
    this._engine.depthCullingState.depthMask = true;
    this._engine.depthCullingState.depthTest = true;
    this._afterRender();
    return this._excludedSubMeshes;
  }
  /**
   * Disposes the depth peeling renderer and associated resources
   */
  dispose() {
    this._disposeTextures();
    this._blendBackEffectWrapper.dispose();
    this._finalEffectWrapper.dispose();
    this._effectRenderer.dispose();
    this._releaseRenderPassIds();
  }
};
ThinDepthPeelingRenderer._DEPTH_CLEAR_VALUE = -99999;
ThinDepthPeelingRenderer._MIN_DEPTH = 0;
ThinDepthPeelingRenderer._MAX_DEPTH = 1;

// node_modules/@babylonjs/core/FrameGraph/frameGraphRenderTarget.js
var FrameGraphRenderTarget = class {
  constructor(name, textureManager, renderTargets, renderTargetDepth) {
    this._isBackBuffer = false;
    this.name = name;
    this._textureManager = textureManager;
    this._renderTargets = renderTargets === void 0 ? void 0 : Array.isArray(renderTargets) ? renderTargets : [renderTargets];
    this._renderTargetDepth = renderTargetDepth;
  }
  get renderTargetWrapper() {
    if (this._isBackBuffer) {
      return void 0;
    }
    if (!this._renderTargetWrapper) {
      const engine = this._textureManager.engine;
      const textureHandle = this._renderTargets === void 0 || this._renderTargets.length === 0 ? this._renderTargetDepth : this._renderTargets[0];
      if (this._textureManager.isBackbuffer(textureHandle)) {
        this._isBackBuffer = true;
        return void 0;
      }
      const textureDescription = this._textureManager.getTextureDescription(textureHandle);
      const creationOptionsForTexture = {
        textureCount: this._renderTargets?.length ?? 0,
        generateDepthBuffer: false,
        label: this.name,
        samples: textureDescription.options.samples ?? 1,
        dontCreateTextures: true
      };
      this._renderTargetWrapper = engine.createMultipleRenderTarget(textureDescription.size, creationOptionsForTexture, true);
      for (let i = 0; i < creationOptionsForTexture.textureCount; i++) {
        const handle = this._renderTargets[i];
        const texture = this._textureManager.getTextureFromHandle(handle);
        if (!texture) {
          throw new Error(`FrameGraphRenderTarget.renderTargetWrapper: Failed to get texture from handle. handle: ${handle}, name: ${this.name}, index: ${i}, renderTargets: ${this._renderTargets}`);
        }
        texture.incrementReferences();
        this._renderTargetWrapper.setTexture(texture, i, false);
      }
      if (this._renderTargetDepth !== void 0) {
        this._renderTargetWrapper.setDepthStencilTexture(this._textureManager.getTextureFromHandle(this._renderTargetDepth), false);
      }
    }
    return this._renderTargetWrapper;
  }
  equals(other) {
    const src = this._renderTargets;
    const dst = other._renderTargets;
    if (src !== void 0 && dst !== void 0) {
      if (src.length !== dst.length) {
        return false;
      }
      for (let i = 0; i < src.length; i++) {
        if (src[i] !== dst[i]) {
          return false;
        }
      }
    } else if (src === void 0 && dst !== void 0 || src !== void 0 && dst === void 0) {
      return false;
    }
    return this._renderTargetDepth === other._renderTargetDepth;
  }
  dispose() {
    this._renderTargetWrapper?.dispose();
  }
};

// node_modules/@babylonjs/core/FrameGraph/Tasks/Rendering/objectRendererTask.js
var FrameGraphObjectRendererTask = class extends FrameGraphTask {
  /**
   * Gets or sets the camera used to render the objects.
   */
  get camera() {
    return this._camera;
  }
  set camera(camera) {
    this._camera = camera;
    this._renderer.activeCamera = this.camera;
  }
  /**
   * If image processing should be disabled (default is false).
   * false means that the default image processing configuration will be applied (the one from the scene)
   */
  get disableImageProcessing() {
    return this._disableImageProcessing;
  }
  set disableImageProcessing(value) {
    if (value === this._disableImageProcessing) {
      return;
    }
    this._disableImageProcessing = value;
    this._renderer.disableImageProcessing = value;
  }
  /**
   * Defines if meshes should be rendered (default is true).
   */
  get renderMeshes() {
    return this._renderMeshes;
  }
  set renderMeshes(value) {
    if (value === this._renderMeshes) {
      return;
    }
    this._renderMeshes = value;
    this._renderer.renderMeshes = value;
  }
  /**
   * Defines if depth only meshes should be rendered (default is true). Always subject to the renderMeshes property, though.
   */
  get renderDepthOnlyMeshes() {
    return this._renderDepthOnlyMeshes;
  }
  set renderDepthOnlyMeshes(value) {
    if (value === this._renderDepthOnlyMeshes) {
      return;
    }
    this._renderDepthOnlyMeshes = value;
    this._renderer.renderDepthOnlyMeshes = value;
  }
  /**
   * Defines if opaque meshes should be rendered (default is true). Always subject to the renderMeshes property, though.
   */
  get renderOpaqueMeshes() {
    return this._renderOpaqueMeshes;
  }
  set renderOpaqueMeshes(value) {
    if (value === this._renderOpaqueMeshes) {
      return;
    }
    this._renderOpaqueMeshes = value;
    this._renderer.renderOpaqueMeshes = value;
  }
  /**
   * Defines if alpha test meshes should be rendered (default is true). Always subject to the renderMeshes property, though.
   */
  get renderAlphaTestMeshes() {
    return this._renderAlphaTestMeshes;
  }
  set renderAlphaTestMeshes(value) {
    if (value === this._renderAlphaTestMeshes) {
      return;
    }
    this._renderAlphaTestMeshes = value;
    this._renderer.renderAlphaTestMeshes = value;
  }
  /**
   * Defines if transparent meshes should be rendered (default is true). Always subject to the renderMeshes property, though.
   */
  get renderTransparentMeshes() {
    return this._renderTransparentMeshes;
  }
  set renderTransparentMeshes(value) {
    if (value === this._renderTransparentMeshes) {
      return;
    }
    this._renderTransparentMeshes = value;
    this._renderer.renderTransparentMeshes = value;
  }
  /**
   * Defines if Order Independent Transparency should be used for transparent meshes (default is false).
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get useOITForTransparentMeshes() {
    return this._useOITForTransparentMeshes;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  set useOITForTransparentMeshes(value) {
    if (value === this._useOITForTransparentMeshes) {
      return;
    }
    this._useOITForTransparentMeshes = value;
    this._renderer.customRenderTransparentSubMeshes = this._useOITForTransparentMeshes ? this._renderTransparentMeshesWithOIT.bind(this) : void 0;
    this._oitRenderer.blendOutput = value && this._rtForOrderIndependentTransparency ? this._rtForOrderIndependentTransparency.renderTargetWrapper : null;
  }
  /**
   * Defines the number of passes to use for Order Independent Transparency (default is 5).
   */
  get oitPassCount() {
    return this._oitRenderer.passCount;
  }
  set oitPassCount(value) {
    if (value === this._oitRenderer.passCount) {
      return;
    }
    this._oitRenderer.passCount = value;
  }
  /**
   * Defines if particles should be rendered (default is true).
   */
  get renderParticles() {
    return this._renderParticles;
  }
  set renderParticles(value) {
    if (value === this._renderParticles) {
      return;
    }
    this._renderParticles = value;
    this._renderer.renderParticles = value;
  }
  /**
   * Defines if sprites should be rendered (default is true).
   */
  get renderSprites() {
    return this._renderSprites;
  }
  set renderSprites(value) {
    if (value === this._renderSprites) {
      return;
    }
    this._renderSprites = value;
    this._renderer.renderSprites = value;
  }
  /**
   * Forces checking the layerMask property even if a custom list of meshes is provided (ie. if renderList is not undefined). Default is true.
   */
  get forceLayerMaskCheck() {
    return this._forceLayerMaskCheck;
  }
  set forceLayerMaskCheck(value) {
    if (value === this._forceLayerMaskCheck) {
      return;
    }
    this._forceLayerMaskCheck = value;
    this._renderer.forceLayerMaskCheck = value;
  }
  /**
   * Enables the rendering of bounding boxes for meshes (still subject to Mesh.showBoundingBox or scene.forceShowBoundingBoxes). Default is true.
   */
  get enableBoundingBoxRendering() {
    return this._enableBoundingBoxRendering;
  }
  set enableBoundingBoxRendering(value) {
    if (value === this._enableBoundingBoxRendering) {
      return;
    }
    this._enableBoundingBoxRendering = value;
    this._renderer.enableBoundingBoxRendering = value;
  }
  /**
   * Enables the rendering of outlines/overlays for meshes (still subject to Mesh.renderOutline/Mesh.renderOverlay). Default is true.
   */
  get enableOutlineRendering() {
    return this._enableOutlineRendering;
  }
  set enableOutlineRendering(value) {
    if (value === this._enableOutlineRendering) {
      return;
    }
    this._enableOutlineRendering = value;
    this._renderer.enableOutlineRendering = value;
  }
  /**
   * The object renderer used to render the objects.
   */
  get objectRenderer() {
    return this._renderer;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    if (this._renderer) {
      this._renderer.name = value;
    }
  }
  /**
   * Constructs a new object renderer task.
   * @param name The name of the task.
   * @param frameGraph The frame graph the task belongs to.
   * @param scene The scene the frame graph is associated with.
   * @param options The options of the object renderer.
   * @param existingObjectRenderer An existing object renderer to use (optional). If provided, the options parameter will be ignored.
   */
  constructor(name, frameGraph, scene, options, existingObjectRenderer) {
    super(name, frameGraph);
    this.shadowGenerators = [];
    this.depthTest = true;
    this.depthWrite = true;
    this.disableShadows = false;
    this._disableImageProcessing = false;
    this.isMainObjectRenderer = false;
    this._renderMeshes = true;
    this._renderDepthOnlyMeshes = true;
    this._renderOpaqueMeshes = true;
    this._renderAlphaTestMeshes = true;
    this._renderTransparentMeshes = true;
    this._useOITForTransparentMeshes = false;
    this._renderParticles = true;
    this._renderSprites = true;
    this._forceLayerMaskCheck = true;
    this._enableBoundingBoxRendering = true;
    this._enableOutlineRendering = true;
    this.resolveMSAAColors = true;
    this.resolveMSAADepth = false;
    this._onBeforeRenderObservable = null;
    this._onAfterRenderObservable = null;
    this._externalObjectRenderer = false;
    this._scene = scene;
    this._engine = scene.getEngine();
    this._externalObjectRenderer = !!existingObjectRenderer;
    this._renderer = existingObjectRenderer ?? new ObjectRenderer(name, scene, options);
    this.name = name;
    this._renderer.disableImageProcessing = this._disableImageProcessing;
    this._renderer.renderParticles = this._renderParticles;
    this._renderer.renderSprites = this._renderSprites;
    this._renderer.enableBoundingBoxRendering = this._enableBoundingBoxRendering;
    this._renderer.forceLayerMaskCheck = this._forceLayerMaskCheck;
    if (!this._externalObjectRenderer) {
      this._renderer.onBeforeRenderingManagerRenderObservable.add(() => {
        if (!this._renderer.options.doNotChangeAspectRatio) {
          scene.updateTransformMatrix(true);
        }
      });
    }
    this._oitRenderer = new ThinDepthPeelingRenderer(scene);
    this._oitRenderer.useRenderPasses = true;
    this.outputTexture = this._frameGraph.textureManager.createDanglingHandle();
    this.outputDepthTexture = this._frameGraph.textureManager.createDanglingHandle();
  }
  isReady() {
    return this._renderer.isReadyForRendering(this._textureWidth, this._textureHeight);
  }
  getClassName() {
    return "FrameGraphObjectRendererTask";
  }
  record(skipCreationOfDisabledPasses = false, additionalExecute) {
    this._checkParameters();
    this._renderer.renderList = this.objectList.meshes;
    this._renderer.particleSystemList = this.objectList.particleSystems;
    const targetTextures = this._getTargetHandles();
    const depthEnabled = this._checkTextureCompatibility(targetTextures);
    this._resolveDanglingHandles(targetTextures);
    this._setLightsForShadow();
    this._rtForOrderIndependentTransparency?.dispose();
    const pass = this._frameGraph.addRenderPass(this.name);
    pass.setRenderTarget(targetTextures);
    pass.setRenderTargetDepth(this.depthTexture);
    pass.setInitializeFunc(() => {
      this._rtForOrderIndependentTransparency = new FrameGraphRenderTarget(this.name + "_oitRT", this._frameGraph.textureManager, this.targetTexture, this.depthTexture);
    });
    pass.setExecuteFunc((context) => {
      this._renderer.renderList = this.objectList.meshes;
      this._renderer.particleSystemList = this.objectList.particleSystems;
      const renderTargetWrapper = pass.frameGraphRenderTarget.renderTargetWrapper;
      if (renderTargetWrapper) {
        renderTargetWrapper.resolveMSAAColors = this.resolveMSAAColors;
        renderTargetWrapper.resolveMSAADepth = this.resolveMSAADepth;
      }
      if (this._useOITForTransparentMeshes && this._oitRenderer.blendOutput !== this._rtForOrderIndependentTransparency.renderTargetWrapper) {
        this._oitRenderer.blendOutput = this._rtForOrderIndependentTransparency.renderTargetWrapper;
      }
      const boundingBoxRenderer = this.getBoundingBoxRenderer?.();
      const currentBoundingBoxMeshList = boundingBoxRenderer && boundingBoxRenderer.renderList.length > 0 ? boundingBoxRenderer.renderList.data.slice() : [];
      if (boundingBoxRenderer) {
        currentBoundingBoxMeshList.length = boundingBoxRenderer.renderList.length;
      }
      this._prepareRendering(context, depthEnabled);
      const currentOITRenderer = this._scene.depthPeelingRenderer;
      this._scene._depthPeelingRenderer = this._oitRenderer;
      const camera = this._renderer.activeCamera;
      if (camera && camera.cameraRigMode !== 0 && !camera._renderingMultiview) {
        for (let index = 0; index < camera._rigCameras.length; index++) {
          const rigCamera = camera._rigCameras[index];
          rigCamera.rigParent = void 0;
          this._renderer.activeCamera = rigCamera;
          context.render(this._renderer, this._textureWidth, this._textureHeight);
          rigCamera.rigParent = camera;
        }
        this._renderer.activeCamera = camera;
      } else {
        context.render(this._renderer, this._textureWidth, this._textureHeight);
      }
      additionalExecute?.(context);
      this._scene._depthPeelingRenderer = currentOITRenderer;
      if (boundingBoxRenderer) {
        boundingBoxRenderer.renderList.data = currentBoundingBoxMeshList;
        boundingBoxRenderer.renderList.length = currentBoundingBoxMeshList.length;
      }
    });
    if (!skipCreationOfDisabledPasses) {
      const passDisabled = this._frameGraph.addRenderPass(this.name + "_disabled", true);
      passDisabled.setRenderTarget(targetTextures);
      passDisabled.setRenderTargetDepth(this.depthTexture);
      passDisabled.setExecuteFunc((_context) => {
      });
    }
    return pass;
  }
  dispose() {
    this._renderer.onBeforeRenderObservable.remove(this._onBeforeRenderObservable);
    this._renderer.onAfterRenderObservable.remove(this._onAfterRenderObservable);
    if (!this._externalObjectRenderer) {
      this._renderer.dispose();
    }
    this._oitRenderer.dispose();
    this._rtForOrderIndependentTransparency?.dispose();
    super.dispose();
  }
  _resolveDanglingHandles(targetTextures) {
    if (targetTextures.length > 0) {
      this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture, targetTextures[0]);
    }
    if (this.depthTexture !== void 0) {
      this._frameGraph.textureManager.resolveDanglingHandle(this.outputDepthTexture, this.depthTexture);
    }
  }
  _checkParameters() {
    if (this.targetTexture === void 0 || this.objectList === void 0 || this.camera === void 0) {
      throw new Error(`FrameGraphObjectRendererTask ${this.name}: targetTexture, objectList, and camera are required`);
    }
  }
  _checkTextureCompatibility(targetTextures) {
    const className = this.getClassName();
    let outputTextureDescription = targetTextures.length > 0 ? this._frameGraph.textureManager.getTextureDescription(targetTextures[0]) : null;
    let depthEnabled = false;
    if (this.depthTexture !== void 0) {
      if (outputTextureDescription && this.depthTexture !== backbufferDepthStencilTextureHandle && targetTextures[0] === backbufferColorTextureHandle) {
        throw new Error(`${className} ${this.name}: the back buffer depth/stencil texture is the only depth texture allowed when the target is the back buffer color`);
      }
      const depthTextureDescription = this._frameGraph.textureManager.getTextureDescription(this.depthTexture);
      if (!outputTextureDescription) {
        outputTextureDescription = depthTextureDescription;
      }
      if (depthTextureDescription.options.samples !== outputTextureDescription.options.samples) {
        throw new Error(`${className} ${this.name}: the depth texture "${depthTextureDescription.options.labels?.[0] ?? "noname"}" (${depthTextureDescription.options.samples} samples) and the output texture "${outputTextureDescription.options.labels?.[0] ?? "noname"}" (${outputTextureDescription.options.samples} samples) must have the same number of samples`);
      }
      if (depthTextureDescription.size.width !== outputTextureDescription.size.width || depthTextureDescription.size.height !== outputTextureDescription.size.height) {
        throw new Error(`${className} ${this.name}: the depth texture (size: ${depthTextureDescription.size.width}x${depthTextureDescription.size.height}) and the target texture (size: ${outputTextureDescription.size.width}x${outputTextureDescription.size.height}) must have the same dimensions.`);
      }
      depthEnabled = true;
    }
    this._textureWidth = outputTextureDescription?.size.width ?? 1;
    this._textureHeight = outputTextureDescription?.size.height ?? 1;
    return depthEnabled;
  }
  _getTargetHandles() {
    return Array.isArray(this.targetTexture) ? this.targetTexture : [this.targetTexture];
  }
  _prepareRendering(context, depthEnabled) {
    context.setDepthStates(this.depthTest && depthEnabled, this.depthWrite && depthEnabled);
  }
  _setLightsForShadow() {
    const lightsForShadow = /* @__PURE__ */ new Set();
    const shadowEnabled = /* @__PURE__ */ new Map();
    if (this.shadowGenerators) {
      for (const shadowGeneratorTask of this.shadowGenerators) {
        const shadowGenerator = shadowGeneratorTask.shadowGenerator;
        const light = shadowGenerator.getLight();
        if (light.isEnabled() && light.shadowEnabled) {
          lightsForShadow.add(light);
          if (FrameGraphCascadedShadowGeneratorTask.IsCascadedShadowGenerator(shadowGeneratorTask)) {
            light._shadowGenerators.set(shadowGeneratorTask.camera, shadowGenerator);
          } else {
            light._shadowGenerators.set(null, shadowGenerator);
          }
        }
      }
    }
    this._renderer.onBeforeRenderObservable.remove(this._onBeforeRenderObservable);
    this._onBeforeRenderObservable = this._renderer.onBeforeRenderObservable.add(() => {
      for (let i = 0; i < this._scene.lights.length; i++) {
        const light = this._scene.lights[i];
        if (!light.setShadowProjectionMatrix) {
          continue;
        }
        shadowEnabled.set(light, light.shadowEnabled);
        light.shadowEnabled = !this.disableShadows && lightsForShadow.has(light);
      }
    });
    this._renderer.onAfterRenderObservable.remove(this._onAfterRenderObservable);
    this._onAfterRenderObservable = this._renderer.onAfterRenderObservable.add(() => {
      for (let i = 0; i < this._scene.lights.length; i++) {
        const light = this._scene.lights[i];
        if (!light.setShadowProjectionMatrix) {
          continue;
        }
        light.shadowEnabled = shadowEnabled.get(light);
      }
    });
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  _renderTransparentMeshesWithOIT(transparentSubMeshes) {
    const renderingGroups = this._renderer.renderingManager.renderingGroups;
    const saveOIT = this._scene._useOrderIndependentTransparency;
    this._scene._useOrderIndependentTransparency = true;
    for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {
      const renderingGroup = renderingGroups[index];
      if (!renderingGroup || renderingGroup._empty) {
        continue;
      }
      const excludedMeshes = this._oitRenderer.render(transparentSubMeshes);
      if (excludedMeshes.length) {
        renderingGroup._renderTransparent(excludedMeshes);
      }
    }
    this._scene._useOrderIndependentTransparency = saveOIT;
  }
};

// node_modules/@babylonjs/core/import.helper.js
var _ImportHelper = class {
};
_ImportHelper._IsPickingAvailable = false;

// node_modules/@babylonjs/core/Inputs/scene.inputManager.js
var _ClickInfo = class {
  constructor() {
    this._singleClick = false;
    this._doubleClick = false;
    this._hasSwiped = false;
    this._ignore = false;
  }
  get singleClick() {
    return this._singleClick;
  }
  get doubleClick() {
    return this._doubleClick;
  }
  get hasSwiped() {
    return this._hasSwiped;
  }
  get ignore() {
    return this._ignore;
  }
  set singleClick(b) {
    this._singleClick = b;
  }
  set doubleClick(b) {
    this._doubleClick = b;
  }
  set hasSwiped(b) {
    this._hasSwiped = b;
  }
  set ignore(b) {
    this._ignore = b;
  }
};
var InputManager = class _InputManager {
  /**
   * Creates a new InputManager
   * @param scene - defines the hosting scene
   */
  constructor(scene) {
    this._alreadyAttached = false;
    this._meshPickProceed = false;
    this._currentPickResult = null;
    this._previousPickResult = null;
    this._activePointerIds = new Array();
    this._activePointerIdsCount = 0;
    this._doubleClickOccured = false;
    this._isSwiping = false;
    this._swipeButtonPressed = -1;
    this._skipPointerTap = false;
    this._isMultiTouchGesture = false;
    this._pointerX = 0;
    this._pointerY = 0;
    this._startingPointerPosition = new Vector2(0, 0);
    this._previousStartingPointerPosition = new Vector2(0, 0);
    this._startingPointerTime = 0;
    this._previousStartingPointerTime = 0;
    this._pointerCaptures = {};
    this._meshUnderPointerId = {};
    this._movePointerInfo = null;
    this._cameraObserverCount = 0;
    this._delayedClicks = [null, null, null, null, null];
    this._deviceSourceManager = null;
    this._scene = scene || EngineStore.LastCreatedScene;
    if (!this._scene) {
      return;
    }
  }
  /**
   * Gets the mesh that is currently under the pointer
   * @returns Mesh that the pointer is pointer is hovering over
   */
  get meshUnderPointer() {
    if (this._movePointerInfo) {
      this._movePointerInfo._generatePickInfo();
      this._movePointerInfo = null;
    }
    return this._pointerOverMesh;
  }
  /**
   * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer
   * @param pointerId - the pointer id to use
   * @returns The mesh under this pointer id or null if not found
   */
  getMeshUnderPointerByPointerId(pointerId) {
    return this._meshUnderPointerId[pointerId] || null;
  }
  /**
   * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)
   * @returns Vector with X/Y values directly from pointer event
   */
  get unTranslatedPointer() {
    return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);
  }
  /**
   * Gets or sets the current on-screen X position of the pointer
   * @returns Translated X with respect to screen
   */
  get pointerX() {
    return this._pointerX;
  }
  set pointerX(value) {
    this._pointerX = value;
  }
  /**
   * Gets or sets the current on-screen Y position of the pointer
   * @returns Translated Y with respect to screen
   */
  get pointerY() {
    return this._pointerY;
  }
  set pointerY(value) {
    this._pointerY = value;
  }
  _updatePointerPosition(evt) {
    const canvasRect = this._scene.getEngine().getInputElementClientRect();
    if (!canvasRect) {
      return;
    }
    this._pointerX = evt.clientX - canvasRect.left;
    this._pointerY = evt.clientY - canvasRect.top;
    this._unTranslatedPointerX = this._pointerX;
    this._unTranslatedPointerY = this._pointerY;
  }
  _processPointerMove(pickResult, evt) {
    const scene = this._scene;
    const engine = scene.getEngine();
    const canvas = engine.getInputElement();
    if (canvas) {
      canvas.tabIndex = engine.canvasTabIndex;
      if (!scene.doNotHandleCursors) {
        canvas.style.cursor = scene.defaultCursor;
      }
    }
    this._setCursorAndPointerOverMesh(pickResult, evt, scene);
    for (const step of scene._pointerMoveStage) {
      pickResult = pickResult || this._pickMove(evt);
      const isMeshPicked = pickResult?.pickedMesh ? true : false;
      pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);
    }
    const type = evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;
    if (scene.onPointerMove) {
      pickResult = pickResult || this._pickMove(evt);
      scene.onPointerMove(evt, pickResult, type);
    }
    let pointerInfo;
    if (pickResult) {
      pointerInfo = new PointerInfo(type, evt, pickResult);
      this._setRayOnPointerInfo(pickResult, evt);
    } else {
      pointerInfo = new PointerInfo(type, evt, null, this);
      this._movePointerInfo = pointerInfo;
    }
    if (scene.onPointerObservable.hasObservers()) {
      scene.onPointerObservable.notifyObservers(pointerInfo, type);
    }
  }
  // Pointers handling
  /** @internal */
  _setRayOnPointerInfo(pickInfo, event) {
    const scene = this._scene;
    if (pickInfo && _ImportHelper._IsPickingAvailable) {
      if (!pickInfo.ray) {
        pickInfo.ray = scene.createPickingRay(event.offsetX, event.offsetY, Matrix.Identity(), scene.activeCamera);
      }
    }
  }
  /** @internal */
  _addCameraPointerObserver(observer, mask) {
    this._cameraObserverCount++;
    return this._scene.onPointerObservable.add(observer, mask);
  }
  /** @internal */
  _removeCameraPointerObserver(observer) {
    this._cameraObserverCount--;
    return this._scene.onPointerObservable.remove(observer);
  }
  _checkForPicking() {
    return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick);
  }
  _checkPrePointerObservable(pickResult, evt, type) {
    const scene = this._scene;
    const pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);
    if (pickResult) {
      pi.originalPickingInfo = pickResult;
      pi.ray = pickResult.ray;
      if (evt.pointerType === "xr-near" && pickResult.originMesh) {
        pi.nearInteractionPickingInfo = pickResult;
      }
    }
    scene.onPrePointerObservable.notifyObservers(pi, type);
    if (pi.skipOnPointerObservable) {
      return true;
    } else {
      return false;
    }
  }
  /** @internal */
  _pickMove(evt) {
    const scene = this._scene;
    const pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerMovePredicate, scene.pointerMoveFastCheck, scene.cameraToUseForPointers, scene.pointerMoveTrianglePredicate);
    this._setCursorAndPointerOverMesh(pickResult, evt, scene);
    return pickResult;
  }
  _setCursorAndPointerOverMesh(pickResult, evt, scene) {
    const engine = scene.getEngine();
    const canvas = engine.getInputElement();
    if (pickResult?.pickedMesh) {
      this.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId, pickResult, evt);
      if (!scene.doNotHandleCursors && canvas && this._pointerOverMesh) {
        const actionManager = this._pointerOverMesh._getActionManagerForTrigger();
        if (actionManager && actionManager.hasPointerTriggers) {
          canvas.style.cursor = actionManager.hoverCursor || scene.hoverCursor;
        }
      }
    } else {
      this.setPointerOverMesh(null, evt.pointerId, pickResult, evt);
    }
  }
  /**
   * Use this method to simulate a pointer move on a mesh
   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
   * @param pickResult - pickingInfo of the object wished to simulate pointer event on
   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
   */
  simulatePointerMove(pickResult, pointerEventInit) {
    const evt = new PointerEvent("pointermove", pointerEventInit);
    evt.inputIndex = PointerInput.Move;
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {
      return;
    }
    this._processPointerMove(pickResult, evt);
  }
  /**
   * Use this method to simulate a pointer down on a mesh
   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
   * @param pickResult - pickingInfo of the object wished to simulate pointer event on
   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
   */
  simulatePointerDown(pickResult, pointerEventInit) {
    const evt = new PointerEvent("pointerdown", pointerEventInit);
    evt.inputIndex = evt.button + 2;
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {
      return;
    }
    this._processPointerDown(pickResult, evt);
  }
  _processPointerDown(pickResult, evt) {
    const scene = this._scene;
    if (pickResult?.pickedMesh) {
      this._pickedDownMesh = pickResult.pickedMesh;
      const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();
      if (actionManager) {
        if (actionManager.hasPickTriggers) {
          actionManager.processTrigger(5, new ActionEvent(pickResult.pickedMesh, scene.pointerX, scene.pointerY, pickResult.pickedMesh, evt, pickResult));
          switch (evt.button) {
            case 0:
              actionManager.processTrigger(2, new ActionEvent(pickResult.pickedMesh, scene.pointerX, scene.pointerY, pickResult.pickedMesh, evt, pickResult));
              break;
            case 1:
              actionManager.processTrigger(4, new ActionEvent(pickResult.pickedMesh, scene.pointerX, scene.pointerY, pickResult.pickedMesh, evt, pickResult));
              break;
            case 2:
              actionManager.processTrigger(3, new ActionEvent(pickResult.pickedMesh, scene.pointerX, scene.pointerY, pickResult.pickedMesh, evt, pickResult));
              break;
          }
        }
        if (actionManager.hasSpecificTrigger(8)) {
          window.setTimeout(() => {
            const pickResult2 = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, (mesh) => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh === this._pickedDownMesh, false, scene.cameraToUseForPointers);
            if (pickResult2?.pickedMesh && actionManager) {
              if (this._activePointerIdsCount !== 0 && Date.now() - this._startingPointerTime > _InputManager.LongPressDelay && !this._isPointerSwiping()) {
                this._startingPointerTime = 0;
                actionManager.processTrigger(8, ActionEvent.CreateNew(pickResult2.pickedMesh, evt));
              }
            }
          }, _InputManager.LongPressDelay);
        }
      }
    } else {
      for (const step of scene._pointerDownStage) {
        pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, false);
      }
    }
    let pointerInfo;
    const type = PointerEventTypes.POINTERDOWN;
    if (pickResult) {
      if (scene.onPointerDown) {
        scene.onPointerDown(evt, pickResult, type);
      }
      pointerInfo = new PointerInfo(type, evt, pickResult);
      this._setRayOnPointerInfo(pickResult, evt);
    } else {
      pointerInfo = new PointerInfo(type, evt, null, this);
    }
    if (scene.onPointerObservable.hasObservers()) {
      scene.onPointerObservable.notifyObservers(pointerInfo, type);
    }
  }
  /**
   * @internal
   * @internals Boolean if delta for pointer exceeds drag movement threshold
   */
  _isPointerSwiping() {
    return this._isSwiping;
  }
  /**
   * Use this method to simulate a pointer up on a mesh
   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
   * @param pickResult - pickingInfo of the object wished to simulate pointer event on
   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
   * @param doubleTap - indicates that the pointer up event should be considered as part of a double click (false by default)
   */
  simulatePointerUp(pickResult, pointerEventInit, doubleTap) {
    const evt = new PointerEvent("pointerup", pointerEventInit);
    evt.inputIndex = PointerInput.Move;
    const clickInfo = new _ClickInfo();
    if (doubleTap) {
      clickInfo.doubleClick = true;
    } else {
      clickInfo.singleClick = true;
    }
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {
      return;
    }
    this._processPointerUp(pickResult, evt, clickInfo);
  }
  _processPointerUp(pickResult, evt, clickInfo) {
    const scene = this._scene;
    if (pickResult?.pickedMesh) {
      this._pickedUpMesh = pickResult.pickedMesh;
      if (this._pickedDownMesh === this._pickedUpMesh) {
        if (scene.onPointerPick) {
          scene.onPointerPick(evt, pickResult);
        }
        if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.observers.length > this._cameraObserverCount) {
          const type = PointerEventTypes.POINTERPICK;
          const pi = new PointerInfo(type, evt, pickResult);
          this._setRayOnPointerInfo(pickResult, evt);
          scene.onPointerObservable.notifyObservers(pi, type);
        }
      }
      const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();
      if (actionManager && !clickInfo.ignore) {
        actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        if (!clickInfo.hasSwiped && clickInfo.singleClick) {
          actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        }
        const doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);
        if (clickInfo.doubleClick && doubleClickActionManager) {
          doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        }
      }
    } else {
      if (!clickInfo.ignore) {
        for (const step of scene._pointerUpStage) {
          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, clickInfo.doubleClick);
        }
      }
    }
    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {
      const pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);
      if (pickedDownActionManager) {
        pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));
      }
    }
    if (!clickInfo.ignore) {
      const pi = new PointerInfo(PointerEventTypes.POINTERUP, evt, pickResult);
      this._setRayOnPointerInfo(pickResult, evt);
      scene.onPointerObservable.notifyObservers(pi, PointerEventTypes.POINTERUP);
      if (scene.onPointerUp) {
        scene.onPointerUp(evt, pickResult, PointerEventTypes.POINTERUP);
      }
      if (!clickInfo.hasSwiped && !this._skipPointerTap && !this._isMultiTouchGesture) {
        let type = 0;
        if (clickInfo.singleClick) {
          type = PointerEventTypes.POINTERTAP;
        } else if (clickInfo.doubleClick) {
          type = PointerEventTypes.POINTERDOUBLETAP;
        }
        if (type) {
          const pi2 = new PointerInfo(type, evt, pickResult);
          if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {
            scene.onPointerObservable.notifyObservers(pi2, type);
          }
        }
      }
    }
  }
  /**
   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)
   * @param pointerId - defines the pointer id to use in a multi-touch scenario (0 by default)
   * @returns true if the pointer was captured
   */
  isPointerCaptured(pointerId = 0) {
    return this._pointerCaptures[pointerId];
  }
  /**
   * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp
   * @param attachUp - defines if you want to attach events to pointerup
   * @param attachDown - defines if you want to attach events to pointerdown
   * @param attachMove - defines if you want to attach events to pointermove
   * @param elementToAttachTo - defines the target DOM element to attach to (will use the canvas by default)
   */
  attachControl(attachUp = true, attachDown = true, attachMove = true, elementToAttachTo = null) {
    const scene = this._scene;
    const engine = scene.getEngine();
    if (!elementToAttachTo) {
      elementToAttachTo = engine.getInputElement();
    }
    if (this._alreadyAttached) {
      this.detachControl();
    }
    if (elementToAttachTo) {
      this._alreadyAttachedTo = elementToAttachTo;
    }
    this._deviceSourceManager = new DeviceSourceManager(engine);
    this._initActionManager = (act) => {
      if (!this._meshPickProceed) {
        const pickResult = scene.skipPointerUpPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerUp ? null : scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerUpPredicate, scene.pointerUpFastCheck, scene.cameraToUseForPointers, scene.pointerUpTrianglePredicate);
        this._currentPickResult = pickResult;
        if (pickResult) {
          act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;
        }
        this._meshPickProceed = true;
      }
      return act;
    };
    this._delayedSimpleClick = (btn, clickInfo, cb) => {
      if (Date.now() - this._previousStartingPointerTime > _InputManager.DoubleClickDelay && !this._doubleClickOccured || btn !== this._previousButtonPressed) {
        this._doubleClickOccured = false;
        clickInfo.singleClick = true;
        clickInfo.ignore = false;
        if (this._delayedClicks[btn]) {
          const evt = this._delayedClicks[btn].evt;
          const type = PointerEventTypes.POINTERTAP;
          const pi = new PointerInfo(type, evt, this._currentPickResult);
          if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {
            scene.onPointerObservable.notifyObservers(pi, type);
          }
          this._delayedClicks[btn] = null;
        }
      }
    };
    this._initClickEvent = (obs1, obs2, evt, cb) => {
      const clickInfo = new _ClickInfo();
      this._currentPickResult = null;
      let act = null;
      let checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
      if (!checkPicking && AbstractActionManager) {
        act = this._initActionManager(act, clickInfo);
        if (act) {
          checkPicking = act.hasPickTriggers;
        }
      }
      let needToIgnoreNext = false;
      checkPicking = checkPicking && !this._isMultiTouchGesture;
      if (checkPicking) {
        const btn = evt.button;
        clickInfo.hasSwiped = this._isPointerSwiping();
        if (!clickInfo.hasSwiped) {
          let checkSingleClickImmediately = !_InputManager.ExclusiveDoubleClickMode;
          if (!checkSingleClickImmediately) {
            checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
            if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {
              act = this._initActionManager(act, clickInfo);
              if (act) {
                checkSingleClickImmediately = !act.hasSpecificTrigger(6);
              }
            }
          }
          if (checkSingleClickImmediately) {
            if (Date.now() - this._previousStartingPointerTime > _InputManager.DoubleClickDelay || btn !== this._previousButtonPressed) {
              clickInfo.singleClick = true;
              cb(clickInfo, this._currentPickResult);
              needToIgnoreNext = true;
            }
          } else {
            const delayedClick = {
              evt,
              clickInfo,
              timeoutId: window.setTimeout(this._delayedSimpleClick.bind(this, btn, clickInfo, cb), _InputManager.DoubleClickDelay)
            };
            this._delayedClicks[btn] = delayedClick;
          }
          let checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
          if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {
            act = this._initActionManager(act, clickInfo);
            if (act) {
              checkDoubleClick = act.hasSpecificTrigger(6);
            }
          }
          if (checkDoubleClick) {
            if (btn === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < _InputManager.DoubleClickDelay && !this._doubleClickOccured) {
              if (!clickInfo.hasSwiped && !this._isPointerSwiping()) {
                this._previousStartingPointerTime = 0;
                this._doubleClickOccured = true;
                clickInfo.doubleClick = true;
                clickInfo.ignore = false;
                if (_InputManager.ExclusiveDoubleClickMode && this._delayedClicks[btn]) {
                  clearTimeout(this._delayedClicks[btn]?.timeoutId);
                  this._delayedClicks[btn] = null;
                }
                cb(clickInfo, this._currentPickResult);
              } else {
                this._doubleClickOccured = false;
                this._previousStartingPointerTime = this._startingPointerTime;
                this._previousStartingPointerPosition.x = this._startingPointerPosition.x;
                this._previousStartingPointerPosition.y = this._startingPointerPosition.y;
                this._previousButtonPressed = btn;
                if (_InputManager.ExclusiveDoubleClickMode) {
                  if (this._delayedClicks[btn]) {
                    clearTimeout(this._delayedClicks[btn]?.timeoutId);
                    this._delayedClicks[btn] = null;
                  }
                  cb(clickInfo, this._previousPickResult);
                } else {
                  cb(clickInfo, this._currentPickResult);
                }
              }
              needToIgnoreNext = true;
            } else {
              this._doubleClickOccured = false;
              this._previousStartingPointerTime = this._startingPointerTime;
              this._previousStartingPointerPosition.x = this._startingPointerPosition.x;
              this._previousStartingPointerPosition.y = this._startingPointerPosition.y;
              this._previousButtonPressed = btn;
            }
          }
        }
      }
      if (!needToIgnoreNext) {
        cb(clickInfo, this._currentPickResult);
      }
    };
    this._onPointerMove = (evt) => {
      this._updatePointerPosition(evt);
      if (!this._isSwiping && this._swipeButtonPressed !== -1) {
        this._isSwiping = Math.abs(this._startingPointerPosition.x - this._pointerX) > _InputManager.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > _InputManager.DragMovementThreshold;
      }
      if (engine.isPointerLock) {
        engine._verifyPointerLock();
      }
      if (this._checkPrePointerObservable(null, evt, evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {
        return;
      }
      if (!scene.cameraToUseForPointers && !scene.activeCamera) {
        return;
      }
      if (scene.skipPointerMovePicking) {
        this._processPointerMove(new PickingInfo(), evt);
        return;
      }
      if (!scene.pointerMovePredicate) {
        scene.pointerMovePredicate = (mesh) => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
      }
      const pickResult = scene._registeredActions > 0 || scene.constantlyUpdateMeshUnderPointer ? this._pickMove(evt) : null;
      this._processPointerMove(pickResult, evt);
    };
    this._onPointerDown = (evt) => {
      const freeIndex = this._activePointerIds.indexOf(-1);
      if (freeIndex === -1) {
        this._activePointerIds.push(evt.pointerId);
      } else {
        this._activePointerIds[freeIndex] = evt.pointerId;
      }
      this._activePointerIdsCount++;
      this._pickedDownMesh = null;
      this._meshPickProceed = false;
      if (_InputManager.ExclusiveDoubleClickMode) {
        for (let i = 0; i < this._delayedClicks.length; i++) {
          if (this._delayedClicks[i]) {
            if (evt.button === i) {
              clearTimeout(this._delayedClicks[i]?.timeoutId);
            } else {
              const clickInfo = this._delayedClicks[i].clickInfo;
              this._doubleClickOccured = false;
              clickInfo.singleClick = true;
              clickInfo.ignore = false;
              const prevEvt = this._delayedClicks[i].evt;
              const type = PointerEventTypes.POINTERTAP;
              const pi = new PointerInfo(type, prevEvt, this._currentPickResult);
              if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {
                scene.onPointerObservable.notifyObservers(pi, type);
              }
              this._delayedClicks[i] = null;
            }
          }
        }
      }
      this._updatePointerPosition(evt);
      if (this._swipeButtonPressed === -1) {
        this._swipeButtonPressed = evt.button;
      }
      if (scene.preventDefaultOnPointerDown && elementToAttachTo) {
        evt.preventDefault();
        elementToAttachTo.focus();
      }
      this._startingPointerPosition.x = this._pointerX;
      this._startingPointerPosition.y = this._pointerY;
      this._startingPointerTime = Date.now();
      if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {
        return;
      }
      if (!scene.cameraToUseForPointers && !scene.activeCamera) {
        return;
      }
      this._pointerCaptures[evt.pointerId] = true;
      if (!scene.pointerDownPredicate) {
        scene.pointerDownPredicate = (mesh) => {
          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
        };
      }
      this._pickedDownMesh = null;
      let pickResult;
      if (scene.skipPointerDownPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerDown) {
        pickResult = new PickingInfo();
      } else {
        pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerDownPredicate, scene.pointerDownFastCheck, scene.cameraToUseForPointers, scene.pointerDownTrianglePredicate);
      }
      this._processPointerDown(pickResult, evt);
    };
    this._onPointerUp = (evt) => {
      const pointerIdIndex = this._activePointerIds.indexOf(evt.pointerId);
      if (pointerIdIndex === -1) {
        return;
      }
      this._activePointerIds[pointerIdIndex] = -1;
      this._activePointerIdsCount--;
      this._pickedUpMesh = null;
      this._meshPickProceed = false;
      this._updatePointerPosition(evt);
      if (scene.preventDefaultOnPointerUp && elementToAttachTo) {
        evt.preventDefault();
        elementToAttachTo.focus();
      }
      this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, (clickInfo, pickResult) => {
        if (scene.onPrePointerObservable.hasObservers()) {
          this._skipPointerTap = false;
          if (!clickInfo.ignore) {
            if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {
              if (this._swipeButtonPressed === evt.button) {
                this._isSwiping = false;
                this._swipeButtonPressed = -1;
              }
              if (evt.buttons === 0) {
                this._pointerCaptures[evt.pointerId] = false;
              }
              return;
            }
            if (!clickInfo.hasSwiped) {
              if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {
                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {
                  this._skipPointerTap = true;
                }
              }
              if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {
                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {
                  this._skipPointerTap = true;
                }
              }
            }
          }
        }
        if (!this._pointerCaptures[evt.pointerId]) {
          if (this._swipeButtonPressed === evt.button) {
            this._isSwiping = false;
            this._swipeButtonPressed = -1;
          }
          return;
        }
        if (evt.buttons === 0) {
          this._pointerCaptures[evt.pointerId] = false;
        }
        if (!scene.cameraToUseForPointers && !scene.activeCamera) {
          return;
        }
        if (!scene.pointerUpPredicate) {
          scene.pointerUpPredicate = (mesh) => {
            return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
          };
        }
        if (!this._meshPickProceed && (AbstractActionManager && AbstractActionManager.HasTriggers || this._checkForPicking() || scene.onPointerUp)) {
          this._initActionManager(null, clickInfo);
        }
        if (!pickResult) {
          pickResult = this._currentPickResult;
        }
        this._processPointerUp(pickResult, evt, clickInfo);
        this._previousPickResult = this._currentPickResult;
        if (this._swipeButtonPressed === evt.button) {
          this._isSwiping = false;
          this._swipeButtonPressed = -1;
        }
      });
    };
    this._onKeyDown = (evt) => {
      const type = KeyboardEventTypes.KEYDOWN;
      if (scene.onPreKeyboardObservable.hasObservers()) {
        const pi = new KeyboardInfoPre(type, evt);
        scene.onPreKeyboardObservable.notifyObservers(pi, type);
        if (pi.skipOnKeyboardObservable) {
          return;
        }
      }
      if (scene.onKeyboardObservable.hasObservers()) {
        const pi = new KeyboardInfo(type, evt);
        scene.onKeyboardObservable.notifyObservers(pi, type);
      }
      if (scene.actionManager) {
        scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));
      }
    };
    this._onKeyUp = (evt) => {
      const type = KeyboardEventTypes.KEYUP;
      if (scene.onPreKeyboardObservable.hasObservers()) {
        const pi = new KeyboardInfoPre(type, evt);
        scene.onPreKeyboardObservable.notifyObservers(pi, type);
        if (pi.skipOnKeyboardObservable) {
          return;
        }
      }
      if (scene.onKeyboardObservable.hasObservers()) {
        const pi = new KeyboardInfo(type, evt);
        scene.onKeyboardObservable.notifyObservers(pi, type);
      }
      if (scene.actionManager) {
        scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));
      }
    };
    this._deviceSourceManager.onDeviceConnectedObservable.add((deviceSource) => {
      if (deviceSource.deviceType === DeviceType.Mouse) {
        deviceSource.onInputChangedObservable.add((eventData) => {
          this._originMouseEvent = eventData;
          if (eventData.inputIndex === PointerInput.LeftClick || eventData.inputIndex === PointerInput.MiddleClick || eventData.inputIndex === PointerInput.RightClick || eventData.inputIndex === PointerInput.BrowserBack || eventData.inputIndex === PointerInput.BrowserForward) {
            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {
              this._onPointerDown(eventData);
            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {
              this._onPointerUp(eventData);
            }
          } else if (attachMove) {
            if (eventData.inputIndex === PointerInput.Move) {
              this._onPointerMove(eventData);
            } else if (eventData.inputIndex === PointerInput.MouseWheelX || eventData.inputIndex === PointerInput.MouseWheelY || eventData.inputIndex === PointerInput.MouseWheelZ) {
              this._onPointerMove(eventData);
            }
          }
        });
      } else if (deviceSource.deviceType === DeviceType.Touch) {
        deviceSource.onInputChangedObservable.add((eventData) => {
          if (eventData.inputIndex === PointerInput.LeftClick) {
            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {
              this._onPointerDown(eventData);
              if (this._activePointerIdsCount > 1) {
                this._isMultiTouchGesture = true;
              }
            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {
              this._onPointerUp(eventData);
              if (this._activePointerIdsCount === 0) {
                this._isMultiTouchGesture = false;
              }
            }
          }
          if (attachMove && eventData.inputIndex === PointerInput.Move) {
            this._onPointerMove(eventData);
          }
        });
      } else if (deviceSource.deviceType === DeviceType.Keyboard) {
        deviceSource.onInputChangedObservable.add((eventData) => {
          if (eventData.type === "keydown") {
            this._onKeyDown(eventData);
          } else if (eventData.type === "keyup") {
            this._onKeyUp(eventData);
          }
        });
      }
    });
    this._alreadyAttached = true;
  }
  /**
   * Detaches all event handlers
   */
  detachControl() {
    if (this._alreadyAttached) {
      this._deviceSourceManager.dispose();
      this._deviceSourceManager = null;
      if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {
        this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;
      }
      this._alreadyAttached = false;
      this._alreadyAttachedTo = null;
    }
  }
  /**
   * Set the value of meshUnderPointer for a given pointerId
   * @param mesh - defines the mesh to use
   * @param pointerId - optional pointer id when using more than one pointer. Defaults to 0
   * @param pickResult - optional pickingInfo data used to find mesh
   * @param evt - optional pointer event
   */
  setPointerOverMesh(mesh, pointerId = 0, pickResult, evt) {
    if (this._meshUnderPointerId[pointerId] === mesh && (!mesh || !mesh._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting)) {
      return;
    }
    const underPointerMesh = this._meshUnderPointerId[pointerId];
    let actionManager;
    if (underPointerMesh) {
      actionManager = underPointerMesh._getActionManagerForTrigger(10);
      if (actionManager) {
        actionManager.processTrigger(10, new ActionEvent(underPointerMesh, this._pointerX, this._pointerY, mesh, evt, { pointerId }));
      }
    }
    if (mesh) {
      this._meshUnderPointerId[pointerId] = mesh;
      this._pointerOverMesh = mesh;
      actionManager = mesh._getActionManagerForTrigger(9);
      if (actionManager) {
        actionManager.processTrigger(9, new ActionEvent(mesh, this._pointerX, this._pointerY, mesh, evt, { pointerId, pickResult }));
      }
    } else {
      delete this._meshUnderPointerId[pointerId];
      this._pointerOverMesh = null;
    }
    if (this._scene.onMeshUnderPointerUpdatedObservable.hasObservers()) {
      this._scene.onMeshUnderPointerUpdatedObservable.notifyObservers({
        mesh,
        pointerId
      });
    }
  }
  /**
   * Gets the mesh under the pointer
   * @returns a Mesh or null if no mesh is under the pointer
   */
  getPointerOverMesh() {
    return this.meshUnderPointer;
  }
  /**
   * @param mesh - Mesh to invalidate
   * @internal
   */
  _invalidateMesh(mesh) {
    if (this._pointerOverMesh === mesh) {
      this._pointerOverMesh = null;
    }
    if (this._pickedDownMesh === mesh) {
      this._pickedDownMesh = null;
    }
    if (this._pickedUpMesh === mesh) {
      this._pickedUpMesh = null;
    }
    for (const pointerId in this._meshUnderPointerId) {
      if (this._meshUnderPointerId[pointerId] === mesh) {
        delete this._meshUnderPointerId[pointerId];
      }
    }
  }
};
InputManager.DragMovementThreshold = 10;
InputManager.LongPressDelay = 500;
InputManager.DoubleClickDelay = 300;
InputManager.ExclusiveDoubleClickMode = false;

// node_modules/@babylonjs/core/Inputs/pointerPickingConfiguration.js
var PointerPickingConfiguration = class {
  constructor() {
    this.pointerDownFastCheck = false;
    this.pointerUpFastCheck = false;
    this.pointerMoveFastCheck = false;
    this.skipPointerMovePicking = false;
    this.skipPointerDownPicking = false;
    this.skipPointerUpPicking = false;
  }
};

// node_modules/@babylonjs/core/scene.js
var TempVect1 = new Vector4();
var TempVect2 = new Vector4();
var ScenePerformancePriority;
(function(ScenePerformancePriority2) {
  ScenePerformancePriority2[ScenePerformancePriority2["BackwardCompatible"] = 0] = "BackwardCompatible";
  ScenePerformancePriority2[ScenePerformancePriority2["Intermediate"] = 1] = "Intermediate";
  ScenePerformancePriority2[ScenePerformancePriority2["Aggressive"] = 2] = "Aggressive";
})(ScenePerformancePriority || (ScenePerformancePriority = {}));
var Scene = class _Scene {
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Factory used to create the default material.
   * @param scene The scene to create the material for
   * @returns The default material
   */
  static DefaultMaterialFactory(scene) {
    throw _WarnImport("StandardMaterial");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Factory used to create the a collision coordinator.
   * @returns The collision coordinator
   */
  static CollisionCoordinatorFactory() {
    throw _WarnImport("DefaultCollisionCoordinator");
  }
  /**
   * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))
   */
  get clearColor() {
    return this._clearColor;
  }
  set clearColor(value) {
    if (value !== this._clearColor) {
      this._clearColor = value;
      this.onClearColorChangedObservable.notifyObservers(this._clearColor);
    }
  }
  /**
   * Default image processing configuration used either in the rendering
   * Forward main pass or through the imageProcessingPostProcess if present.
   * As in the majority of the scene they are the same (exception for multi camera),
   * this is easier to reference from here than from all the materials and post process.
   *
   * No setter as we it is a shared configuration, you can set the values instead.
   */
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  /**
   * Gets or sets a value indicating how to treat performance relatively to ease of use and backward compatibility
   */
  get performancePriority() {
    return this._performancePriority;
  }
  set performancePriority(value) {
    if (value === this._performancePriority) {
      return;
    }
    this._performancePriority = value;
    switch (value) {
      case 0:
        this.skipFrustumClipping = false;
        this._renderingManager.maintainStateBetweenFrames = false;
        this.skipPointerMovePicking = false;
        this.autoClear = true;
        break;
      case 1:
        this.skipFrustumClipping = false;
        this._renderingManager.maintainStateBetweenFrames = false;
        this.skipPointerMovePicking = true;
        this.autoClear = false;
        break;
      case 2:
        this.skipFrustumClipping = true;
        this._renderingManager.maintainStateBetweenFrames = true;
        this.skipPointerMovePicking = true;
        this.autoClear = false;
        break;
    }
    this.onScenePerformancePriorityChangedObservable.notifyObservers(value);
  }
  /**
   * Gets or sets a boolean indicating if all rendering must be done in wireframe
   */
  set forceWireframe(value) {
    if (this._forceWireframe === value) {
      return;
    }
    this._forceWireframe = value;
    this.markAllMaterialsAsDirty(16);
  }
  get forceWireframe() {
    return this._forceWireframe;
  }
  /**
   * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection
   */
  set skipFrustumClipping(value) {
    if (this._skipFrustumClipping === value) {
      return;
    }
    this._skipFrustumClipping = value;
  }
  get skipFrustumClipping() {
    return this._skipFrustumClipping;
  }
  /**
   * Gets or sets a boolean indicating if all rendering must be done in point cloud
   */
  set forcePointsCloud(value) {
    if (this._forcePointsCloud === value) {
      return;
    }
    this._forcePointsCloud = value;
    this.markAllMaterialsAsDirty(16);
  }
  get forcePointsCloud() {
    return this._forcePointsCloud;
  }
  /**
   * Texture used in all pbr material as the reflection texture.
   * As in the majority of the scene they are the same (exception for multi room and so on),
   * this is easier to reference from here than from all the materials.
   */
  get environmentTexture() {
    return this._environmentTexture;
  }
  /**
   * Texture used in all pbr material as the reflection texture.
   * As in the majority of the scene they are the same (exception for multi room and so on),
   * this is easier to set here than in all the materials.
   */
  set environmentTexture(value) {
    if (this._environmentTexture === value) {
      return;
    }
    this._environmentTexture = value;
    this.onEnvironmentTextureChangedObservable.notifyObservers(value);
    this.markAllMaterialsAsDirty(1);
  }
  /**
   * @returns all meshes, lights, cameras, transformNodes and bones
   */
  getNodes() {
    let nodes = [];
    nodes = nodes.concat(this.meshes);
    nodes = nodes.concat(this.lights);
    nodes = nodes.concat(this.cameras);
    nodes = nodes.concat(this.transformNodes);
    for (const skeleton of this.skeletons) {
      nodes = nodes.concat(skeleton.bones);
    }
    return nodes;
  }
  /**
   * Gets or sets the animation properties override
   */
  get animationPropertiesOverride() {
    return this._animationPropertiesOverride;
  }
  set animationPropertiesOverride(value) {
    this._animationPropertiesOverride = value;
  }
  /** Sets a function to be executed when this scene is disposed. */
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  /** Sets a function to be executed before rendering this scene */
  set beforeRender(callback) {
    if (this._onBeforeRenderObserver) {
      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
    }
    if (callback) {
      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
    }
  }
  /** Sets a function to be executed after rendering this scene */
  set afterRender(callback) {
    if (this._onAfterRenderObserver) {
      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
    }
    if (callback) {
      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
    }
  }
  /** Sets a function to be executed before rendering a camera*/
  set beforeCameraRender(callback) {
    if (this._onBeforeCameraRenderObserver) {
      this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
    }
    this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);
  }
  /** Sets a function to be executed after rendering a camera*/
  set afterCameraRender(callback) {
    if (this._onAfterCameraRenderObserver) {
      this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
    }
    this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);
  }
  /**
   * Gets or sets a predicate used to select candidate meshes for a pointer down event
   */
  get pointerDownPredicate() {
    return this._pointerPickingConfiguration.pointerDownPredicate;
  }
  set pointerDownPredicate(value) {
    this._pointerPickingConfiguration.pointerDownPredicate = value;
  }
  /**
   * Gets or sets a predicate used to select candidate meshes for a pointer up event
   */
  get pointerUpPredicate() {
    return this._pointerPickingConfiguration.pointerUpPredicate;
  }
  set pointerUpPredicate(value) {
    this._pointerPickingConfiguration.pointerUpPredicate = value;
  }
  /**
   * Gets or sets a predicate used to select candidate meshes for a pointer move event
   */
  get pointerMovePredicate() {
    return this._pointerPickingConfiguration.pointerMovePredicate;
  }
  set pointerMovePredicate(value) {
    this._pointerPickingConfiguration.pointerMovePredicate = value;
  }
  /**
   * Gets or sets a predicate used to select candidate meshes for a pointer down event
   */
  get pointerDownFastCheck() {
    return this._pointerPickingConfiguration.pointerDownFastCheck;
  }
  set pointerDownFastCheck(value) {
    this._pointerPickingConfiguration.pointerDownFastCheck = value;
  }
  /**
   * Gets or sets a predicate used to select candidate meshes for a pointer up event
   */
  get pointerUpFastCheck() {
    return this._pointerPickingConfiguration.pointerUpFastCheck;
  }
  set pointerUpFastCheck(value) {
    this._pointerPickingConfiguration.pointerUpFastCheck = value;
  }
  /**
   * Gets or sets a predicate used to select candidate meshes for a pointer move event
   */
  get pointerMoveFastCheck() {
    return this._pointerPickingConfiguration.pointerMoveFastCheck;
  }
  set pointerMoveFastCheck(value) {
    this._pointerPickingConfiguration.pointerMoveFastCheck = value;
  }
  /**
   * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer move event occurs.
   */
  get skipPointerMovePicking() {
    return this._pointerPickingConfiguration.skipPointerMovePicking;
  }
  set skipPointerMovePicking(value) {
    this._pointerPickingConfiguration.skipPointerMovePicking = value;
  }
  /**
   * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer down event occurs.
   */
  get skipPointerDownPicking() {
    return this._pointerPickingConfiguration.skipPointerDownPicking;
  }
  set skipPointerDownPicking(value) {
    this._pointerPickingConfiguration.skipPointerDownPicking = value;
  }
  /**
   * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer up event occurs.  Off by default.
   */
  get skipPointerUpPicking() {
    return this._pointerPickingConfiguration.skipPointerUpPicking;
  }
  set skipPointerUpPicking(value) {
    this._pointerPickingConfiguration.skipPointerUpPicking = value;
  }
  /**
   * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)
   */
  get unTranslatedPointer() {
    return this._inputManager.unTranslatedPointer;
  }
  /**
   * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels
   */
  static get DragMovementThreshold() {
    return InputManager.DragMovementThreshold;
  }
  static set DragMovementThreshold(value) {
    InputManager.DragMovementThreshold = value;
  }
  /**
   * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms
   */
  static get LongPressDelay() {
    return InputManager.LongPressDelay;
  }
  static set LongPressDelay(value) {
    InputManager.LongPressDelay = value;
  }
  /**
   * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms
   */
  static get DoubleClickDelay() {
    return InputManager.DoubleClickDelay;
  }
  static set DoubleClickDelay(value) {
    InputManager.DoubleClickDelay = value;
  }
  /** If you need to check double click without raising a single click at first click, enable this flag */
  static get ExclusiveDoubleClickMode() {
    return InputManager.ExclusiveDoubleClickMode;
  }
  static set ExclusiveDoubleClickMode(value) {
    InputManager.ExclusiveDoubleClickMode = value;
  }
  /**
   * Gets the current eye position in order of forcedViewPosition, activeCamera world position, Vector3.ZeroReadOnly
   */
  get _eyePosition() {
    return this._forcedViewPosition ?? this.activeCamera?.globalPosition ?? Vector3.ZeroReadOnly;
  }
  /**
   * Bind the current view position to an effect.
   * @param effect The effect to be bound
   * @param variableName name of the shader variable that will hold the eye position
   * @param isVector3 true to indicates that variableName is a Vector3 and not a Vector4
   * @returns the computed eye position in a temp vector, caller can copy values as needed
   */
  bindEyePosition(effect, variableName = "vEyePosition", isVector3 = false) {
    const eyePosition = this._eyePosition;
    const invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);
    const offset = this.floatingOriginOffset;
    const eyePos = TempVect1.set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);
    const offsetEyePos = eyePos.subtractFromFloatsToRef(offset.x, offset.y, offset.z, 0, TempVect2);
    if (effect) {
      if (isVector3) {
        effect.setFloat3(variableName, offsetEyePos.x, offsetEyePos.y, offsetEyePos.z);
      } else {
        effect.setVector4(variableName, offsetEyePos);
      }
    }
    return eyePos;
  }
  /**
   * Update the scene ubo before it can be used in rendering processing
   * @returns the scene UniformBuffer
   */
  finalizeSceneUbo() {
    const ubo = this.getSceneUniformBuffer();
    const eyePosition = this.bindEyePosition(null);
    const offset = this.floatingOriginOffset;
    ubo.updateFloat4("vEyePosition", eyePosition.x - offset.x, eyePosition.y - offset.y, eyePosition.z - offset.z, eyePosition.w);
    ubo.update();
    return ubo;
  }
  /**
   * Gets or sets a boolean indicating if the scene must use right-handed coordinates system
   */
  set useRightHandedSystem(value) {
    if (this._useRightHandedSystem === value) {
      return;
    }
    this._useRightHandedSystem = value;
    this.markAllMaterialsAsDirty(16);
  }
  get useRightHandedSystem() {
    return this._useRightHandedSystem;
  }
  /**
   * Sets the step Id used by deterministic lock step
   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep
   * @param newStepId defines the step Id
   */
  setStepId(newStepId) {
    this._currentStepId = newStepId;
  }
  /**
   * Gets the step Id used by deterministic lock step
   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep
   * @returns the step Id
   */
  getStepId() {
    return this._currentStepId;
  }
  /**
   * Gets the internal step used by deterministic lock step
   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep
   * @returns the internal step
   */
  getInternalStep() {
    return this._currentInternalStep;
  }
  /**
   * Gets or sets a boolean indicating if fog is enabled on this scene
   * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog
   * (Default is true)
   */
  set fogEnabled(value) {
    if (this._fogEnabled === value) {
      return;
    }
    this._fogEnabled = value;
    this.markAllMaterialsAsDirty(16);
  }
  get fogEnabled() {
    return this._fogEnabled;
  }
  /**
   * Gets or sets the fog mode to use
   * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog
   * | mode | value |
   * | --- | --- |
   * | FOGMODE_NONE | 0 |
   * | FOGMODE_EXP | 1 |
   * | FOGMODE_EXP2 | 2 |
   * | FOGMODE_LINEAR | 3 |
   */
  set fogMode(value) {
    if (this._fogMode === value) {
      return;
    }
    this._fogMode = value;
    this.markAllMaterialsAsDirty(16);
  }
  get fogMode() {
    return this._fogMode;
  }
  /**
   * Flag indicating that the frame buffer binding is handled by another component
   */
  get prePass() {
    return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;
  }
  /**
   * Gets or sets a boolean indicating if shadows are enabled on this scene
   */
  set shadowsEnabled(value) {
    if (this._shadowsEnabled === value) {
      return;
    }
    this._shadowsEnabled = value;
    this.markAllMaterialsAsDirty(2);
  }
  get shadowsEnabled() {
    return this._shadowsEnabled;
  }
  /**
   * Gets or sets a boolean indicating if lights are enabled on this scene
   */
  set lightsEnabled(value) {
    if (this._lightsEnabled === value) {
      return;
    }
    this._lightsEnabled = value;
    this.markAllMaterialsAsDirty(2);
  }
  get lightsEnabled() {
    return this._lightsEnabled;
  }
  /** All of the active cameras added to this scene. */
  get activeCameras() {
    return this._activeCameras;
  }
  set activeCameras(cameras) {
    if (this._unObserveActiveCameras) {
      this._unObserveActiveCameras();
      this._unObserveActiveCameras = null;
    }
    if (cameras) {
      this._unObserveActiveCameras = _ObserveArray(cameras, () => {
        this.onActiveCamerasChanged.notifyObservers(this);
      });
    }
    this._activeCameras = cameras;
  }
  /** Gets or sets the current active camera */
  get activeCamera() {
    return this._activeCamera;
  }
  set activeCamera(value) {
    if (value === this._activeCamera) {
      return;
    }
    this._activeCamera = value;
    this.onActiveCameraChanged.notifyObservers(this);
  }
  /** @internal */
  get _hasDefaultMaterial() {
    return _Scene.DefaultMaterialFactory !== _Scene._OriginalDefaultMaterialFactory;
  }
  /** The default material used on meshes when no material is affected */
  get defaultMaterial() {
    if (!this._defaultMaterial) {
      this._defaultMaterial = _Scene.DefaultMaterialFactory(this);
    }
    return this._defaultMaterial;
  }
  /** The default material used on meshes when no material is affected */
  set defaultMaterial(value) {
    this._defaultMaterial = value;
  }
  /**
   * Gets or sets a boolean indicating if textures are enabled on this scene
   */
  set texturesEnabled(value) {
    if (this._texturesEnabled === value) {
      return;
    }
    this._texturesEnabled = value;
    this.markAllMaterialsAsDirty(1);
  }
  get texturesEnabled() {
    return this._texturesEnabled;
  }
  /**
   * Gets or sets the frame graph used to render the scene. If set, the scene will use the frame graph to render the scene instead of the default render loop.
   */
  get frameGraph() {
    return this._frameGraph;
  }
  set frameGraph(value) {
    if (this._frameGraph) {
      this._frameGraph = value;
      if (!value) {
        this.customRenderFunction = this._currentCustomRenderFunction;
      }
      return;
    }
    this._frameGraph = value;
    if (value) {
      this._currentCustomRenderFunction = this.customRenderFunction;
      this.customRenderFunction = this._renderWithFrameGraph;
      this.activeCamera = null;
    }
  }
  /**
   * Gets or sets a boolean indicating if skeletons are enabled on this scene
   */
  set skeletonsEnabled(value) {
    if (this._skeletonsEnabled === value) {
      return;
    }
    this._skeletonsEnabled = value;
    this.markAllMaterialsAsDirty(8);
  }
  get skeletonsEnabled() {
    return this._skeletonsEnabled;
  }
  /** @internal */
  get collisionCoordinator() {
    if (!this._collisionCoordinator) {
      this._collisionCoordinator = _Scene.CollisionCoordinatorFactory();
      this._collisionCoordinator.init(this);
    }
    return this._collisionCoordinator;
  }
  /**
   * Gets the scene's rendering manager
   */
  get renderingManager() {
    return this._renderingManager;
  }
  /**
   * Gets the list of frustum planes (built from the active camera)
   */
  get frustumPlanes() {
    return this._frustumPlanes;
  }
  /**
   * Registers the transient components if needed.
   */
  _registerTransientComponents() {
    if (this._transientComponents.length > 0) {
      for (const component of this._transientComponents) {
        component.register();
      }
      this._transientComponents.length = 0;
    }
  }
  /**
   * @internal
   * Add a component to the scene.
   * Note that the ccomponent could be registered on th next frame if this is called after
   * the register component stage.
   * @param component Defines the component to add to the scene
   */
  _addComponent(component) {
    this._components.push(component);
    this._transientComponents.push(component);
    const serializableComponent = component;
    if (serializableComponent.addFromContainer && serializableComponent.serialize) {
      this._serializableComponents.push(serializableComponent);
    }
  }
  /**
   * @internal
   * Gets a component from the scene.
   * @param name defines the name of the component to retrieve
   * @returns the component or null if not present
   */
  _getComponent(name) {
    for (const component of this._components) {
      if (component.name === name) {
        return component;
      }
    }
    return null;
  }
  /**
   * Gets the unique id of the scene
   */
  get uniqueId() {
    return this._uniqueId;
  }
  /**
   * Creates a new Scene
   * @param engine defines the engine to use to render this scene
   * @param options defines the scene options
   */
  constructor(engine, options) {
    this._inputManager = new InputManager(this);
    this.cameraToUseForPointers = null;
    this._isScene = true;
    this._blockEntityCollection = false;
    this.autoClear = true;
    this.autoClearDepthAndStencil = true;
    this._clearColor = new Color4(0.2, 0.2, 0.3, 1);
    this.onClearColorChangedObservable = new Observable();
    this.ambientColor = new Color3(0, 0, 0);
    this.environmentIntensity = 1;
    this.iblIntensity = 1;
    this._performancePriority = 0;
    this.onScenePerformancePriorityChangedObservable = new Observable();
    this._forceWireframe = false;
    this._skipFrustumClipping = false;
    this._forcePointsCloud = false;
    this.rootNodes = [];
    this.cameras = [];
    this.lights = [];
    this.meshes = [];
    this.skeletons = [];
    this.particleSystems = [];
    this.animations = [];
    this.animationGroups = [];
    this.multiMaterials = [];
    this.materials = [];
    this.morphTargetManagers = [];
    this.geometries = [];
    this.transformNodes = [];
    this.actionManagers = [];
    this.objectRenderers = [];
    this.textures = [];
    this._environmentTexture = null;
    this.postProcesses = [];
    this.effectLayers = [];
    this.sounds = null;
    this.layers = [];
    this.lensFlareSystems = [];
    this.proceduralTextures = [];
    this.animationsEnabled = true;
    this._animationPropertiesOverride = null;
    this.useConstantAnimationDeltaTime = false;
    this.constantlyUpdateMeshUnderPointer = false;
    this.hoverCursor = "pointer";
    this.defaultCursor = "";
    this.doNotHandleCursors = false;
    this.preventDefaultOnPointerDown = true;
    this.preventDefaultOnPointerUp = true;
    this.metadata = null;
    this.reservedDataStore = null;
    this.disableOfflineSupportExceptionRules = [];
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this.onBeforeRenderObservable = new Observable();
    this._onBeforeRenderObserver = null;
    this.onAfterRenderObservable = new Observable();
    this.onAfterRenderCameraObservable = new Observable();
    this._onAfterRenderObserver = null;
    this.onBeforeAnimationsObservable = new Observable();
    this.onAfterAnimationsObservable = new Observable();
    this.onBeforeDrawPhaseObservable = new Observable();
    this.onAfterDrawPhaseObservable = new Observable();
    this.onReadyObservable = new Observable();
    this.onBeforeCameraRenderObservable = new Observable();
    this._onBeforeCameraRenderObserver = null;
    this.onAfterCameraRenderObservable = new Observable();
    this._onAfterCameraRenderObserver = null;
    this.onBeforeActiveMeshesEvaluationObservable = new Observable();
    this.onAfterActiveMeshesEvaluationObservable = new Observable();
    this.onBeforeParticlesRenderingObservable = new Observable();
    this.onAfterParticlesRenderingObservable = new Observable();
    this.onDataLoadedObservable = new Observable();
    this.onNewCameraAddedObservable = new Observable();
    this.onCameraRemovedObservable = new Observable();
    this.onNewLightAddedObservable = new Observable();
    this.onLightRemovedObservable = new Observable();
    this.onNewGeometryAddedObservable = new Observable();
    this.onGeometryRemovedObservable = new Observable();
    this.onNewTransformNodeAddedObservable = new Observable();
    this.onTransformNodeRemovedObservable = new Observable();
    this.onNewMeshAddedObservable = new Observable();
    this.onMeshRemovedObservable = new Observable();
    this.onNewSkeletonAddedObservable = new Observable();
    this.onSkeletonRemovedObservable = new Observable();
    this.onNewParticleSystemAddedObservable = new Observable();
    this.onParticleSystemRemovedObservable = new Observable();
    this.onNewAnimationGroupAddedObservable = new Observable();
    this.onAnimationGroupRemovedObservable = new Observable();
    this.onNewMaterialAddedObservable = new Observable();
    this.onNewMultiMaterialAddedObservable = new Observable();
    this.onMaterialRemovedObservable = new Observable();
    this.onMultiMaterialRemovedObservable = new Observable();
    this.onNewTextureAddedObservable = new Observable();
    this.onTextureRemovedObservable = new Observable();
    this.onNewFrameGraphAddedObservable = new Observable();
    this.onFrameGraphRemovedObservable = new Observable();
    this.onNewObjectRendererAddedObservable = new Observable();
    this.onObjectRendererRemovedObservable = new Observable();
    this.onNewPostProcessAddedObservable = new Observable();
    this.onPostProcessRemovedObservable = new Observable();
    this.onNewEffectLayerAddedObservable = new Observable();
    this.onEffectLayerRemovedObservable = new Observable();
    this.onBeforeRenderTargetsRenderObservable = new Observable();
    this.onAfterRenderTargetsRenderObservable = new Observable();
    this.onBeforeStepObservable = new Observable();
    this.onAfterStepObservable = new Observable();
    this.onActiveCameraChanged = new Observable();
    this.onActiveCamerasChanged = new Observable();
    this.onBeforeRenderingGroupObservable = new Observable();
    this.onAfterRenderingGroupObservable = new Observable();
    this.onMeshImportedObservable = new Observable();
    this.onAnimationFileImportedObservable = new Observable();
    this.onEnvironmentTextureChangedObservable = new Observable();
    this.onMeshUnderPointerUpdatedObservable = new Observable();
    this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);
    this._pointerPickingConfiguration = new PointerPickingConfiguration();
    this.onPrePointerObservable = new Observable();
    this.onPointerObservable = new Observable();
    this.onPreKeyboardObservable = new Observable();
    this.onKeyboardObservable = new Observable();
    this._useRightHandedSystem = false;
    this._timeAccumulator = 0;
    this._currentStepId = 0;
    this._currentInternalStep = 0;
    this._fogEnabled = true;
    this._fogMode = _Scene.FOGMODE_NONE;
    this.fogColor = new Color3(0.2, 0.2, 0.3);
    this.fogDensity = 0.1;
    this.fogStart = 0;
    this.fogEnd = 1e3;
    this.needsPreviousWorldMatrices = false;
    this._shadowsEnabled = true;
    this._lightsEnabled = true;
    this._unObserveActiveCameras = null;
    this._texturesEnabled = true;
    this._frameGraph = null;
    this.frameGraphs = [];
    this.physicsEnabled = true;
    this.particlesEnabled = true;
    this.spritesEnabled = true;
    this._skeletonsEnabled = true;
    this.lensFlaresEnabled = true;
    this.collisionsEnabled = true;
    this.gravity = new Vector3(0, -9.807, 0);
    this.postProcessesEnabled = true;
    this.renderTargetsEnabled = true;
    this.dumpNextRenderTargets = false;
    this.customRenderTargets = [];
    this.importedMeshesFiles = [];
    this.probesEnabled = true;
    this._meshesForIntersections = new SmartArrayNoDuplicate(256);
    this.proceduralTexturesEnabled = true;
    this._totalVertices = new PerfCounter();
    this._activeIndices = new PerfCounter();
    this._activeParticles = new PerfCounter();
    this._activeBones = new PerfCounter();
    this._animationTime = 0;
    this.animationTimeScale = 1;
    this._renderId = 0;
    this._frameId = 0;
    this._executeWhenReadyTimeoutId = null;
    this._intermediateRendering = false;
    this._defaultFrameBufferCleared = false;
    this._viewUpdateFlag = -1;
    this._projectionUpdateFlag = -1;
    this._toBeDisposed = new Array(256);
    this._activeRequests = new Array();
    this._pendingData = [];
    this._isDisposed = false;
    this.dispatchAllSubMeshesOfActiveMeshes = false;
    this._activeMeshes = new SmartArray(256);
    this._processedMaterials = new SmartArray(256);
    this._renderTargets = new SmartArrayNoDuplicate(256);
    this._materialsRenderTargets = new SmartArrayNoDuplicate(256);
    this._activeParticleSystems = new SmartArray(256);
    this._activeSkeletons = new SmartArrayNoDuplicate(32);
    this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);
    this._activeAnimatables = new Array();
    this._transformMatrix = Matrix.Zero();
    this.requireLightSorting = false;
    this._components = [];
    this._serializableComponents = [];
    this._transientComponents = [];
    this._beforeCameraUpdateStage = Stage.Create();
    this._beforeClearStage = Stage.Create();
    this._beforeRenderTargetClearStage = Stage.Create();
    this._gatherRenderTargetsStage = Stage.Create();
    this._gatherActiveCameraRenderTargetsStage = Stage.Create();
    this._isReadyForMeshStage = Stage.Create();
    this._beforeEvaluateActiveMeshStage = Stage.Create();
    this._evaluateSubMeshStage = Stage.Create();
    this._preActiveMeshStage = Stage.Create();
    this._cameraDrawRenderTargetStage = Stage.Create();
    this._beforeCameraDrawStage = Stage.Create();
    this._beforeRenderTargetDrawStage = Stage.Create();
    this._beforeRenderingGroupDrawStage = Stage.Create();
    this._beforeRenderingMeshStage = Stage.Create();
    this._afterRenderingMeshStage = Stage.Create();
    this._afterRenderingGroupDrawStage = Stage.Create();
    this._afterCameraDrawStage = Stage.Create();
    this._afterCameraPostProcessStage = Stage.Create();
    this._afterRenderTargetDrawStage = Stage.Create();
    this._afterRenderTargetPostProcessStage = Stage.Create();
    this._afterRenderStage = Stage.Create();
    this._pointerMoveStage = Stage.Create();
    this._pointerDownStage = Stage.Create();
    this._pointerUpStage = Stage.Create();
    this._geometriesByUniqueId = null;
    this._uniqueId = 0;
    this._defaultMeshCandidates = {
      data: [],
      length: 0
    };
    this._defaultSubMeshCandidates = {
      data: [],
      length: 0
    };
    this._floatingOriginScene = void 0;
    this._preventFreeActiveMeshesAndRenderingGroups = false;
    this._activeMeshesFrozen = false;
    this._activeMeshesFrozenButKeepClipping = false;
    this._skipEvaluateActiveMeshesCompletely = false;
    this._freezeActiveMeshesCancel = null;
    this._useCurrentFrameBuffer = false;
    this._allowPostProcessClearColor = true;
    this.getDeterministicFrameTime = () => {
      return this._engine.getTimeStep();
    };
    this._getFloatingOriginScene = () => {
      return this._floatingOriginScene;
    };
    this._registeredActions = 0;
    this._blockMaterialDirtyMechanism = false;
    this._perfCollector = null;
    this.activeCameras = [];
    this._uniqueId = this.getUniqueId();
    const fullOptions = {
      useGeometryUniqueIdsMap: true,
      useMaterialMeshMap: true,
      useClonedMeshMap: true,
      virtual: false,
      ...options
    };
    engine = this._engine = engine || EngineStore.LastCreatedEngine;
    if (fullOptions.virtual) {
      engine._virtualScenes.push(this);
    } else {
      EngineStore._LastCreatedScene = this;
      engine.scenes.push(this);
    }
    if (engine.getCreationOptions().useLargeWorldRendering || options?.useFloatingOrigin) {
      OverrideMatrixFunctions();
      this._floatingOriginScene = this;
    }
    this._uid = null;
    this._renderingManager = new RenderingManager(this);
    if (PostProcessManager) {
      this.postProcessManager = new PostProcessManager(this);
    }
    if (IsWindowObjectExist()) {
      this.attachControl();
    }
    this._createUbo();
    if (ImageProcessingConfiguration) {
      this._imageProcessingConfiguration = new ImageProcessingConfiguration();
    }
    this.setDefaultCandidateProviders();
    if (fullOptions.useGeometryUniqueIdsMap) {
      this._geometriesByUniqueId = {};
    }
    this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;
    this.useClonedMeshMap = fullOptions.useClonedMeshMap;
    if (!options || !options.virtual) {
      engine.onNewSceneAddedObservable.notifyObservers(this);
    }
  }
  /**
   * Gets a string identifying the name of the class
   * @returns "Scene" string
   */
  getClassName() {
    return "Scene";
  }
  /**
   * @internal
   */
  _getDefaultMeshCandidates() {
    this._defaultMeshCandidates.data = this.meshes;
    this._defaultMeshCandidates.length = this.meshes.length;
    return this._defaultMeshCandidates;
  }
  /**
   * @internal
   */
  _getDefaultSubMeshCandidates(mesh) {
    this._defaultSubMeshCandidates.data = mesh.subMeshes;
    this._defaultSubMeshCandidates.length = mesh.subMeshes.length;
    return this._defaultSubMeshCandidates;
  }
  /**
   * Sets the default candidate providers for the scene.
   * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates
   * and getCollidingSubMeshCandidates to their default function
   */
  setDefaultCandidateProviders() {
    this.getActiveMeshCandidates = () => this._getDefaultMeshCandidates();
    this.getActiveSubMeshCandidates = (mesh) => this._getDefaultSubMeshCandidates(mesh);
    this.getIntersectingSubMeshCandidates = (mesh, localRay) => this._getDefaultSubMeshCandidates(mesh);
    this.getCollidingSubMeshCandidates = (mesh, collider) => this._getDefaultSubMeshCandidates(mesh);
  }
  /**
   * Gets the mesh that is currently under the pointer
   */
  get meshUnderPointer() {
    return this._inputManager.meshUnderPointer;
  }
  /**
   * Gets or sets the current on-screen X position of the pointer
   */
  get pointerX() {
    return this._inputManager.pointerX;
  }
  set pointerX(value) {
    this._inputManager.pointerX = value;
  }
  /**
   * Gets or sets the current on-screen Y position of the pointer
   */
  get pointerY() {
    return this._inputManager.pointerY;
  }
  set pointerY(value) {
    this._inputManager.pointerY = value;
  }
  /**
   * Gets the cached material (ie. the latest rendered one)
   * @returns the cached material
   */
  getCachedMaterial() {
    return this._cachedMaterial;
  }
  /**
   * Gets the cached effect (ie. the latest rendered one)
   * @returns the cached effect
   */
  getCachedEffect() {
    return this._cachedEffect;
  }
  /**
   * Gets the cached visibility state (ie. the latest rendered one)
   * @returns the cached visibility state
   */
  getCachedVisibility() {
    return this._cachedVisibility;
  }
  /**
   * Gets a boolean indicating if the current material / effect / visibility must be bind again
   * @param material defines the current material
   * @param effect defines the current effect
   * @param visibility defines the current visibility state
   * @returns true if one parameter is not cached
   */
  isCachedMaterialInvalid(material, effect, visibility = 1) {
    return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;
  }
  /**
   * Gets the engine associated with the scene
   * @returns an Engine
   */
  getEngine() {
    return this._engine;
  }
  /**
   * Gets the total number of vertices rendered per frame
   * @returns the total number of vertices rendered per frame
   */
  getTotalVertices() {
    return this._totalVertices.current;
  }
  /**
   * Gets the performance counter for total vertices
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation
   */
  get totalVerticesPerfCounter() {
    return this._totalVertices;
  }
  /**
   * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)
   * @returns the total number of active indices rendered per frame
   */
  getActiveIndices() {
    return this._activeIndices.current;
  }
  /**
   * Gets the performance counter for active indices
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation
   */
  get totalActiveIndicesPerfCounter() {
    return this._activeIndices;
  }
  /**
   * Gets the total number of active particles rendered per frame
   * @returns the total number of active particles rendered per frame
   */
  getActiveParticles() {
    return this._activeParticles.current;
  }
  /**
   * Gets the performance counter for active particles
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation
   */
  get activeParticlesPerfCounter() {
    return this._activeParticles;
  }
  /**
   * Gets the total number of active bones rendered per frame
   * @returns the total number of active bones rendered per frame
   */
  getActiveBones() {
    return this._activeBones.current;
  }
  /**
   * Gets the performance counter for active bones
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation
   */
  get activeBonesPerfCounter() {
    return this._activeBones;
  }
  /**
   * Gets the array of active meshes
   * @returns an array of AbstractMesh
   */
  getActiveMeshes() {
    return this._activeMeshes;
  }
  /**
   * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)
   * @returns a number
   */
  getAnimationRatio() {
    return this._animationRatio !== void 0 ? this._animationRatio : 1;
  }
  /**
   * Gets an unique Id for the current render phase
   * @returns a number
   */
  getRenderId() {
    return this._renderId;
  }
  /**
   * Gets an unique Id for the current frame
   * @returns a number
   */
  getFrameId() {
    return this._frameId;
  }
  /** Call this function if you want to manually increment the render Id*/
  incrementRenderId() {
    this._renderId++;
  }
  _createUbo() {
    this.setSceneUniformBuffer(this.createSceneUniformBuffer());
  }
  /**
   * Use this method to simulate a pointer move on a mesh
   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
   * @param pickResult pickingInfo of the object wished to simulate pointer event on
   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
   * @returns the current scene
   */
  simulatePointerMove(pickResult, pointerEventInit) {
    this._inputManager.simulatePointerMove(pickResult, pointerEventInit);
    return this;
  }
  /**
   * Use this method to simulate a pointer down on a mesh
   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
   * @param pickResult pickingInfo of the object wished to simulate pointer event on
   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
   * @returns the current scene
   */
  simulatePointerDown(pickResult, pointerEventInit) {
    this._inputManager.simulatePointerDown(pickResult, pointerEventInit);
    return this;
  }
  /**
   * Use this method to simulate a pointer up on a mesh
   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
   * @param pickResult pickingInfo of the object wished to simulate pointer event on
   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
   * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)
   * @returns the current scene
   */
  simulatePointerUp(pickResult, pointerEventInit, doubleTap) {
    this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);
    return this;
  }
  /**
   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)
   * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)
   * @returns true if the pointer was captured
   */
  isPointerCaptured(pointerId = 0) {
    return this._inputManager.isPointerCaptured(pointerId);
  }
  /**
   * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp
   * @param attachUp defines if you want to attach events to pointerup
   * @param attachDown defines if you want to attach events to pointerdown
   * @param attachMove defines if you want to attach events to pointermove
   */
  attachControl(attachUp = true, attachDown = true, attachMove = true) {
    this._inputManager.attachControl(attachUp, attachDown, attachMove);
  }
  /** Detaches all event handlers*/
  detachControl() {
    this._inputManager.detachControl();
  }
  /**
   * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)
   * Delay loaded resources are not taking in account
   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: true)
   * @returns true if all required resources are ready
   */
  isReady(checkRenderTargets = true) {
    if (this._isDisposed) {
      return false;
    }
    let index;
    const engine = this.getEngine();
    const currentRenderPassId = engine.currentRenderPassId;
    engine.currentRenderPassId = this.activeCamera?.renderPassId ?? currentRenderPassId;
    let isReady = true;
    if (this._pendingData.length > 0) {
      isReady = false;
    }
    this.prePassRenderer?.update();
    if (this.useOrderIndependentTransparency && this.depthPeelingRenderer) {
      isReady && (isReady = this.depthPeelingRenderer.isReady());
    }
    if (checkRenderTargets) {
      this._processedMaterials.reset();
      this._materialsRenderTargets.reset();
    }
    for (index = 0; index < this.meshes.length; index++) {
      const mesh = this.meshes[index];
      if (!mesh.subMeshes || mesh.subMeshes.length === 0) {
        continue;
      }
      if (!mesh.isReady(true)) {
        isReady = false;
        continue;
      }
      const hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === "InstancedMesh" || mesh.getClassName() === "InstancedLinesMesh" || engine.getCaps().instancedArrays && mesh.instances.length > 0;
      for (const step of this._isReadyForMeshStage) {
        if (!step.action(mesh, hardwareInstancedRendering)) {
          isReady = false;
        }
      }
      if (!checkRenderTargets) {
        continue;
      }
      const mat = mesh.material || this.defaultMaterial;
      if (mat) {
        if (mat._storeEffectOnSubMeshes) {
          for (const subMesh of mesh.subMeshes) {
            const material = subMesh.getMaterial();
            if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
              if (this._processedMaterials.indexOf(material) === -1) {
                this._processedMaterials.push(material);
                this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
              }
            }
          }
        } else {
          if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {
            if (this._processedMaterials.indexOf(mat) === -1) {
              this._processedMaterials.push(mat);
              this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures());
            }
          }
        }
      }
    }
    if (checkRenderTargets) {
      for (index = 0; index < this._materialsRenderTargets.length; ++index) {
        const rtt = this._materialsRenderTargets.data[index];
        if (!rtt.isReadyForRendering()) {
          isReady = false;
        }
      }
    }
    for (index = 0; index < this.geometries.length; index++) {
      const geometry = this.geometries[index];
      if (geometry.delayLoadState === 2) {
        isReady = false;
      }
    }
    if (this.activeCameras && this.activeCameras.length > 0) {
      for (const camera of this.activeCameras) {
        if (!camera.isReady(true)) {
          isReady = false;
        }
      }
    } else if (this.activeCamera) {
      if (!this.activeCamera.isReady(true)) {
        isReady = false;
      }
    }
    for (const particleSystem of this.particleSystems) {
      if (!particleSystem.isReady()) {
        isReady = false;
      }
    }
    if (this.layers) {
      for (const layer of this.layers) {
        if (!layer.isReady()) {
          isReady = false;
        }
      }
    }
    if (this.effectLayers) {
      for (const effectLayer of this.effectLayers) {
        if (!effectLayer.isLayerReady()) {
          isReady = false;
        }
      }
    }
    if (!engine.areAllEffectsReady()) {
      isReady = false;
    }
    engine.currentRenderPassId = currentRenderPassId;
    return isReady;
  }
  /** Resets all cached information relative to material (including effect and visibility) */
  resetCachedMaterial() {
    this._cachedMaterial = null;
    this._cachedEffect = null;
    this._cachedVisibility = null;
  }
  /**
   * Registers a function to be called before every frame render
   * @param func defines the function to register
   */
  registerBeforeRender(func) {
    this.onBeforeRenderObservable.add(func);
  }
  /**
   * Unregisters a function called before every frame render
   * @param func defines the function to unregister
   */
  unregisterBeforeRender(func) {
    this.onBeforeRenderObservable.removeCallback(func);
  }
  /**
   * Registers a function to be called after every frame render
   * @param func defines the function to register
   */
  registerAfterRender(func) {
    this.onAfterRenderObservable.add(func);
  }
  /**
   * Unregisters a function called after every frame render
   * @param func defines the function to unregister
   */
  unregisterAfterRender(func) {
    this.onAfterRenderObservable.removeCallback(func);
  }
  _executeOnceBeforeRender(func) {
    const execFunc = () => {
      func();
      setTimeout(() => {
        this.unregisterBeforeRender(execFunc);
      });
    };
    this.registerBeforeRender(execFunc);
  }
  /**
   * The provided function will run before render once and will be disposed afterwards.
   * A timeout delay can be provided so that the function will be executed in N ms.
   * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.
   * @param func The function to be executed.
   * @param timeout optional delay in ms
   */
  executeOnceBeforeRender(func, timeout) {
    if (timeout !== void 0) {
      setTimeout(() => {
        this._executeOnceBeforeRender(func);
      }, timeout);
    } else {
      this._executeOnceBeforeRender(func);
    }
  }
  /**
   * This function can help adding any object to the list of data awaited to be ready in order to check for a complete scene loading.
   * @param data defines the object to wait for
   */
  addPendingData(data) {
    this._pendingData.push(data);
  }
  /**
   * Remove a pending data from the loading list which has previously been added with addPendingData.
   * @param data defines the object to remove from the pending list
   */
  removePendingData(data) {
    const wasLoading = this.isLoading;
    const index = this._pendingData.indexOf(data);
    if (index !== -1) {
      this._pendingData.splice(index, 1);
    }
    if (wasLoading && !this.isLoading) {
      this.onDataLoadedObservable.notifyObservers(this);
    }
  }
  /**
   * Returns the number of items waiting to be loaded
   * @returns the number of items waiting to be loaded
   */
  getWaitingItemsCount() {
    return this._pendingData.length;
  }
  /**
   * Returns a boolean indicating if the scene is still loading data
   */
  get isLoading() {
    return this._pendingData.length > 0;
  }
  /**
   * Registers a function to be executed when the scene is ready
   * @param func - the function to be executed
   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)
   */
  executeWhenReady(func, checkRenderTargets = false) {
    this.onReadyObservable.addOnce(func);
    if (this._executeWhenReadyTimeoutId !== null) {
      return;
    }
    this._checkIsReady(checkRenderTargets);
  }
  /**
   * Returns a promise that resolves when the scene is ready
   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)
   * @returns A promise that resolves when the scene is ready
   */
  async whenReadyAsync(checkRenderTargets = false) {
    return await new Promise((resolve) => {
      this.executeWhenReady(() => {
        resolve();
      }, checkRenderTargets);
    });
  }
  /**
   * @internal
   */
  _checkIsReady(checkRenderTargets = false) {
    this._registerTransientComponents();
    if (this.isReady(checkRenderTargets)) {
      this.onReadyObservable.notifyObservers(this);
      this.onReadyObservable.clear();
      this._executeWhenReadyTimeoutId = null;
      return;
    }
    if (this._isDisposed) {
      this.onReadyObservable.clear();
      this._executeWhenReadyTimeoutId = null;
      return;
    }
    this._executeWhenReadyTimeoutId = setTimeout(() => {
      this.incrementRenderId();
      this._checkIsReady(checkRenderTargets);
    }, 100);
  }
  /**
   * Gets all animatable attached to the scene
   */
  get animatables() {
    return this._activeAnimatables;
  }
  /**
   * Resets the last animation time frame.
   * Useful to override when animations start running when loading a scene for the first time.
   */
  resetLastAnimationTimeFrame() {
    this._animationTimeLast = PrecisionDate.Now;
  }
  // Matrix
  /**
   * Gets the current view matrix
   * @returns a Matrix
   */
  getViewMatrix() {
    return this._viewMatrix;
  }
  /**
   * Gets the current projection matrix
   * @returns a Matrix
   */
  getProjectionMatrix() {
    return this._projectionMatrix;
  }
  /**
   * Gets the current transform matrix
   * @returns a Matrix made of View * Projection
   */
  getTransformMatrix() {
    return this._transformMatrix;
  }
  /**
   * Sets the current transform matrix
   * @param viewL defines the View matrix to use
   * @param projectionL defines the Projection matrix to use
   * @param viewR defines the right View matrix to use (if provided)
   * @param projectionR defines the right Projection matrix to use (if provided)
   */
  setTransformMatrix(viewL, projectionL, viewR, projectionR) {
    if (!viewR && !projectionR && this._multiviewSceneUbo) {
      this._multiviewSceneUbo.dispose();
      this._multiviewSceneUbo = null;
    }
    if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {
      return;
    }
    this._viewUpdateFlag = viewL.updateFlag;
    this._projectionUpdateFlag = projectionL.updateFlag;
    this._viewMatrix = viewL;
    this._projectionMatrix = projectionL;
    this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    if (!this._frustumPlanes) {
      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
    } else {
      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
    }
    if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {
      this._updateMultiviewUbo(viewR, projectionR);
    } else if (this._sceneUbo.useUbo) {
      this._sceneUbo.updateMatrix("viewProjection", this._transformMatrix);
      this._sceneUbo.updateMatrix("view", this._viewMatrix);
      this._sceneUbo.updateMatrix("projection", this._projectionMatrix);
    }
  }
  /**
   * Gets the uniform buffer used to store scene data
   * @returns a UniformBuffer
   */
  getSceneUniformBuffer() {
    return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;
  }
  /**
   * Creates a scene UBO
   * @param name name of the uniform buffer (optional, for debugging purpose only)
   * @param trackUBOsInFrame define if the UBOs should be tracked in the frame (default: undefined - will use the value from Engine._features.trackUbosInFrame)
   * @returns a new ubo
   */
  createSceneUniformBuffer(name, trackUBOsInFrame) {
    const sceneUbo = new UniformBuffer(this._engine, void 0, false, name ?? "scene", void 0, trackUBOsInFrame);
    sceneUbo.addUniform("viewProjection", 16);
    sceneUbo.addUniform("view", 16);
    sceneUbo.addUniform("projection", 16);
    sceneUbo.addUniform("vEyePosition", 4);
    return sceneUbo;
  }
  /**
   * Sets the scene ubo
   * @param ubo the ubo to set for the scene
   */
  setSceneUniformBuffer(ubo) {
    this._sceneUbo = ubo;
    this._viewUpdateFlag = -1;
    this._projectionUpdateFlag = -1;
  }
  /**
   * @experimental
   * True if floatingOriginMode was passed to engine or this scene creation otions.
   * This mode avoids floating point imprecision in huge coordinate system by offsetting uniform values before passing to shader, centering camera at origin and displacing rest of scene by camera position
   */
  get floatingOriginMode() {
    return this._floatingOriginScene !== void 0;
  }
  /**
   * @experimental
   * When floatingOriginMode is enabled, offset is equal to the eye position. Default to ZeroReadonly when mode is disabled.
   */
  get floatingOriginOffset() {
    return this.floatingOriginMode ? this._eyePosition : Vector3.ZeroReadOnly;
  }
  /**
   * Gets an unique (relatively to the current scene) Id
   * @returns an unique number for the scene
   */
  getUniqueId() {
    return UniqueIdGenerator.UniqueId;
  }
  /**
   * Add a mesh to the list of scene's meshes
   * @param newMesh defines the mesh to add
   * @param recursive if all child meshes should also be added to the scene
   */
  addMesh(newMesh, recursive = false) {
    if (this._blockEntityCollection) {
      return;
    }
    this.meshes.push(newMesh);
    newMesh._resyncLightSources();
    if (!newMesh.parent) {
      newMesh._addToSceneRootNodes();
    }
    Tools.SetImmediate(() => {
      this.onNewMeshAddedObservable.notifyObservers(newMesh);
    });
    if (recursive) {
      const children = newMesh.getChildMeshes();
      for (const m of children) {
        this.addMesh(m);
      }
    }
  }
  /**
   * Remove a mesh for the list of scene's meshes
   * @param toRemove defines the mesh to remove
   * @param recursive if all child meshes should also be removed from the scene
   * @returns the index where the mesh was in the mesh list
   */
  removeMesh(toRemove, recursive = false) {
    const index = this.meshes.indexOf(toRemove);
    if (index !== -1) {
      this.meshes.splice(index, 1);
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this._inputManager._invalidateMesh(toRemove);
    this.onMeshRemovedObservable.notifyObservers(toRemove);
    if (recursive) {
      const children = toRemove.getChildMeshes();
      for (const m of children) {
        this.removeMesh(m);
      }
    }
    return index;
  }
  /**
   * Add a transform node to the list of scene's transform nodes
   * @param newTransformNode defines the transform node to add
   */
  addTransformNode(newTransformNode) {
    if (this._blockEntityCollection) {
      return;
    }
    if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {
      return;
    }
    newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;
    this.transformNodes.push(newTransformNode);
    if (!newTransformNode.parent) {
      newTransformNode._addToSceneRootNodes();
    }
    this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);
  }
  /**
   * Remove a transform node for the list of scene's transform nodes
   * @param toRemove defines the transform node to remove
   * @returns the index where the transform node was in the transform node list
   */
  removeTransformNode(toRemove) {
    const index = toRemove._indexInSceneTransformNodesArray;
    if (index !== -1) {
      if (index !== this.transformNodes.length - 1) {
        const lastNode = this.transformNodes[this.transformNodes.length - 1];
        this.transformNodes[index] = lastNode;
        lastNode._indexInSceneTransformNodesArray = index;
      }
      toRemove._indexInSceneTransformNodesArray = -1;
      this.transformNodes.pop();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this.onTransformNodeRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Remove a skeleton for the list of scene's skeletons
   * @param toRemove defines the skeleton to remove
   * @returns the index where the skeleton was in the skeleton list
   */
  removeSkeleton(toRemove) {
    const index = this.skeletons.indexOf(toRemove);
    if (index !== -1) {
      this.skeletons.splice(index, 1);
      this.onSkeletonRemovedObservable.notifyObservers(toRemove);
      this._executeActiveContainerCleanup(this._activeSkeletons);
    }
    return index;
  }
  /**
   * Remove a morph target for the list of scene's morph targets
   * @param toRemove defines the morph target to remove
   * @returns the index where the morph target was in the morph target list
   */
  removeMorphTargetManager(toRemove) {
    const index = this.morphTargetManagers.indexOf(toRemove);
    if (index !== -1) {
      this.morphTargetManagers.splice(index, 1);
    }
    return index;
  }
  /**
   * Remove a light for the list of scene's lights
   * @param toRemove defines the light to remove
   * @returns the index where the light was in the light list
   */
  removeLight(toRemove) {
    const index = this.lights.indexOf(toRemove);
    if (index !== -1) {
      for (const mesh of this.meshes) {
        mesh._removeLightSource(toRemove, false);
      }
      this.lights.splice(index, 1);
      this.sortLightsByPriority();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this.onLightRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Remove a camera for the list of scene's cameras
   * @param toRemove defines the camera to remove
   * @returns the index where the camera was in the camera list
   */
  removeCamera(toRemove) {
    const index = this.cameras.indexOf(toRemove);
    if (index !== -1) {
      this.cameras.splice(index, 1);
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    if (this.activeCameras) {
      const index2 = this.activeCameras.indexOf(toRemove);
      if (index2 !== -1) {
        this.activeCameras.splice(index2, 1);
      }
    }
    if (this.activeCamera === toRemove) {
      if (this.cameras.length > 0) {
        this.activeCamera = this.cameras[0];
      } else {
        this.activeCamera = null;
      }
    }
    this.onCameraRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Remove a particle system for the list of scene's particle systems
   * @param toRemove defines the particle system to remove
   * @returns the index where the particle system was in the particle system list
   */
  removeParticleSystem(toRemove) {
    const index = this.particleSystems.indexOf(toRemove);
    if (index !== -1) {
      this.particleSystems.splice(index, 1);
      this._executeActiveContainerCleanup(this._activeParticleSystems);
    }
    this.onParticleSystemRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Remove a animation for the list of scene's animations
   * @param toRemove defines the animation to remove
   * @returns the index where the animation was in the animation list
   */
  removeAnimation(toRemove) {
    const index = this.animations.indexOf(toRemove);
    if (index !== -1) {
      this.animations.splice(index, 1);
    }
    return index;
  }
  /**
   * Will stop the animation of the given target
   * @param target - the target
   * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)
   * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)
   */
  stopAnimation(target, animationName, targetMask) {
  }
  /**
   * Removes the given animation group from this scene.
   * @param toRemove The animation group to remove
   * @returns The index of the removed animation group
   */
  removeAnimationGroup(toRemove) {
    const index = this.animationGroups.indexOf(toRemove);
    if (index !== -1) {
      this.animationGroups.splice(index, 1);
    }
    this.onAnimationGroupRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Removes the given multi-material from this scene.
   * @param toRemove The multi-material to remove
   * @returns The index of the removed multi-material
   */
  removeMultiMaterial(toRemove) {
    const index = this.multiMaterials.indexOf(toRemove);
    if (index !== -1) {
      this.multiMaterials.splice(index, 1);
    }
    this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Removes the given material from this scene.
   * @param toRemove The material to remove
   * @returns The index of the removed material
   */
  removeMaterial(toRemove) {
    const index = toRemove._indexInSceneMaterialArray;
    if (index !== -1 && index < this.materials.length) {
      if (index !== this.materials.length - 1) {
        const lastMaterial = this.materials[this.materials.length - 1];
        this.materials[index] = lastMaterial;
        lastMaterial._indexInSceneMaterialArray = index;
      }
      toRemove._indexInSceneMaterialArray = -1;
      this.materials.pop();
    }
    this.onMaterialRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Removes the given action manager from this scene.
   * @deprecated
   * @param toRemove The action manager to remove
   * @returns The index of the removed action manager
   */
  removeActionManager(toRemove) {
    const index = this.actionManagers.indexOf(toRemove);
    if (index !== -1) {
      this.actionManagers.splice(index, 1);
    }
    return index;
  }
  /**
   * Removes the given texture from this scene.
   * @param toRemove The texture to remove
   * @returns The index of the removed texture
   */
  removeTexture(toRemove) {
    const index = this.textures.indexOf(toRemove);
    if (index !== -1) {
      this.textures.splice(index, 1);
    }
    this.onTextureRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Removes the given frame graph from this scene.
   * @param toRemove The frame graph to remove
   * @returns The index of the removed frame graph
   */
  removeFrameGraph(toRemove) {
    const index = this.frameGraphs.indexOf(toRemove);
    if (index !== -1) {
      this.frameGraphs.splice(index, 1);
    }
    this.onFrameGraphRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Removes the given object renderer from this scene.
   * @param toRemove The object renderer to remove
   * @returns The index of the removed object renderer
   */
  removeObjectRenderer(toRemove) {
    const index = this.objectRenderers.indexOf(toRemove);
    if (index !== -1) {
      this.objectRenderers.splice(index, 1);
    }
    this.onObjectRendererRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Removes the given post-process from this scene.
   * @param toRemove The post-process to remove
   * @returns The index of the removed post-process
   */
  removePostProcess(toRemove) {
    const index = this.postProcesses.indexOf(toRemove);
    if (index !== -1) {
      this.postProcesses.splice(index, 1);
    }
    this.onPostProcessRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Removes the given layer from this scene.
   * @param toRemove The layer to remove
   * @returns The index of the removed layer
   */
  removeEffectLayer(toRemove) {
    const index = this.effectLayers.indexOf(toRemove);
    if (index !== -1) {
      this.effectLayers.splice(index, 1);
    }
    this.onEffectLayerRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Adds the given light to this scene
   * @param newLight The light to add
   */
  addLight(newLight) {
    if (this._blockEntityCollection) {
      return;
    }
    this.lights.push(newLight);
    this.sortLightsByPriority();
    if (!newLight.parent) {
      newLight._addToSceneRootNodes();
    }
    for (const mesh of this.meshes) {
      if (mesh.lightSources.indexOf(newLight) === -1) {
        mesh.lightSources.push(newLight);
        mesh._resyncLightSources();
      }
    }
    Tools.SetImmediate(() => {
      this.onNewLightAddedObservable.notifyObservers(newLight);
    });
  }
  /**
   * Sorts the list list based on light priorities
   */
  sortLightsByPriority() {
    if (this.requireLightSorting) {
      this.lights.sort(LightConstants.CompareLightsPriority);
    }
  }
  /**
   * Adds the given camera to this scene
   * @param newCamera The camera to add
   */
  addCamera(newCamera) {
    if (this._blockEntityCollection) {
      return;
    }
    this.cameras.push(newCamera);
    Tools.SetImmediate(() => {
      this.onNewCameraAddedObservable.notifyObservers(newCamera);
    });
    if (!newCamera.parent) {
      newCamera._addToSceneRootNodes();
    }
  }
  /**
   * Adds the given skeleton to this scene
   * @param newSkeleton The skeleton to add
   */
  addSkeleton(newSkeleton) {
    if (this._blockEntityCollection) {
      return;
    }
    this.skeletons.push(newSkeleton);
    Tools.SetImmediate(() => {
      this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);
    });
  }
  /**
   * Adds the given particle system to this scene
   * @param newParticleSystem The particle system to add
   */
  addParticleSystem(newParticleSystem) {
    if (this._blockEntityCollection) {
      return;
    }
    this.particleSystems.push(newParticleSystem);
    Tools.SetImmediate(() => {
      this.onNewParticleSystemAddedObservable.notifyObservers(newParticleSystem);
    });
  }
  /**
   * Adds the given animation to this scene
   * @param newAnimation The animation to add
   */
  addAnimation(newAnimation) {
    if (this._blockEntityCollection) {
      return;
    }
    this.animations.push(newAnimation);
  }
  /**
   * Adds the given animation group to this scene.
   * @param newAnimationGroup The animation group to add
   */
  addAnimationGroup(newAnimationGroup) {
    if (this._blockEntityCollection) {
      return;
    }
    this.animationGroups.push(newAnimationGroup);
    Tools.SetImmediate(() => {
      this.onNewAnimationGroupAddedObservable.notifyObservers(newAnimationGroup);
    });
  }
  /**
   * Adds the given multi-material to this scene
   * @param newMultiMaterial The multi-material to add
   */
  addMultiMaterial(newMultiMaterial) {
    if (this._blockEntityCollection) {
      return;
    }
    this.multiMaterials.push(newMultiMaterial);
    Tools.SetImmediate(() => {
      this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);
    });
  }
  /**
   * Adds the given material to this scene
   * @param newMaterial The material to add
   */
  addMaterial(newMaterial) {
    if (this._blockEntityCollection) {
      return;
    }
    if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {
      return;
    }
    newMaterial._indexInSceneMaterialArray = this.materials.length;
    this.materials.push(newMaterial);
    Tools.SetImmediate(() => {
      this.onNewMaterialAddedObservable.notifyObservers(newMaterial);
    });
  }
  /**
   * Adds the given morph target to this scene
   * @param newMorphTargetManager The morph target to add
   */
  addMorphTargetManager(newMorphTargetManager) {
    if (this._blockEntityCollection) {
      return;
    }
    this.morphTargetManagers.push(newMorphTargetManager);
  }
  /**
   * Adds the given geometry to this scene
   * @param newGeometry The geometry to add
   */
  addGeometry(newGeometry) {
    if (this._blockEntityCollection) {
      return;
    }
    if (this._geometriesByUniqueId) {
      this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;
    }
    this.geometries.push(newGeometry);
  }
  /**
   * Adds the given action manager to this scene
   * @deprecated
   * @param newActionManager The action manager to add
   */
  addActionManager(newActionManager) {
    this.actionManagers.push(newActionManager);
  }
  /**
   * Adds the given texture to this scene.
   * @param newTexture The texture to add
   */
  addTexture(newTexture) {
    if (this._blockEntityCollection) {
      return;
    }
    this.textures.push(newTexture);
    this.onNewTextureAddedObservable.notifyObservers(newTexture);
  }
  /**
   * Adds the given frame graph to this scene.
   * @param newFrameGraph The frame graph to add
   */
  addFrameGraph(newFrameGraph) {
    this.frameGraphs.push(newFrameGraph);
    Tools.SetImmediate(() => {
      this.onNewFrameGraphAddedObservable.notifyObservers(newFrameGraph);
    });
  }
  /**
   * Adds the given object renderer to this scene.
   * @param objectRenderer The object renderer to add
   */
  addObjectRenderer(objectRenderer) {
    this.objectRenderers.push(objectRenderer);
    Tools.SetImmediate(() => {
      this.onNewObjectRendererAddedObservable.notifyObservers(objectRenderer);
    });
  }
  /**
   * Adds the given post process to this scene.
   * @param newPostProcess The post process to add
   */
  addPostProcess(newPostProcess) {
    if (this._blockEntityCollection) {
      return;
    }
    this.postProcesses.push(newPostProcess);
    Tools.SetImmediate(() => {
      this.onNewPostProcessAddedObservable.notifyObservers(newPostProcess);
    });
  }
  /**
   * Adds the given effect layer to this scene.
   * @param newEffectLayer The effect layer to add
   */
  addEffectLayer(newEffectLayer) {
    if (this._blockEntityCollection) {
      return;
    }
    this.effectLayers.push(newEffectLayer);
    Tools.SetImmediate(() => {
      this.onNewEffectLayerAddedObservable.notifyObservers(newEffectLayer);
    });
  }
  /**
   * Switch active camera
   * @param newCamera defines the new active camera
   * @param attachControl defines if attachControl must be called for the new active camera (default: true)
   */
  switchActiveCamera(newCamera, attachControl = true) {
    const canvas = this._engine.getInputElement();
    if (!canvas) {
      return;
    }
    if (this.activeCamera) {
      this.activeCamera.detachControl();
    }
    this.activeCamera = newCamera;
    if (attachControl) {
      newCamera.attachControl();
    }
  }
  /**
   * sets the active camera of the scene using its Id
   * @param id defines the camera's Id
   * @returns the new active camera or null if none found.
   */
  setActiveCameraById(id) {
    const camera = this.getCameraById(id);
    if (camera) {
      this.activeCamera = camera;
      return camera;
    }
    return null;
  }
  /**
   * sets the active camera of the scene using its name
   * @param name defines the camera's name
   * @returns the new active camera or null if none found.
   */
  setActiveCameraByName(name) {
    const camera = this.getCameraByName(name);
    if (camera) {
      this.activeCamera = camera;
      return camera;
    }
    return null;
  }
  /**
   * get an animation group using its name
   * @param name defines the material's name
   * @returns the animation group or null if none found.
   */
  getAnimationGroupByName(name) {
    for (let index = 0; index < this.animationGroups.length; index++) {
      if (this.animationGroups[index].name === name) {
        return this.animationGroups[index];
      }
    }
    return null;
  }
  _getMaterial(allowMultiMaterials, predicate) {
    for (let index = 0; index < this.materials.length; index++) {
      const material = this.materials[index];
      if (predicate(material)) {
        return material;
      }
    }
    if (allowMultiMaterials) {
      for (let index = 0; index < this.multiMaterials.length; index++) {
        const material = this.multiMaterials[index];
        if (predicate(material)) {
          return material;
        }
      }
    }
    return null;
  }
  /**
   * Get a material using its unique id
   * @param uniqueId defines the material's unique id
   * @param allowMultiMaterials determines whether multimaterials should be considered
   * @returns the material or null if none found.
   * @deprecated Please use getMaterialByUniqueId instead.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getMaterialByUniqueID(uniqueId, allowMultiMaterials = false) {
    return this.getMaterialByUniqueId(uniqueId, allowMultiMaterials);
  }
  /**
   * Get a material using its unique id
   * @param uniqueId defines the material's unique id
   * @param allowMultiMaterials determines whether multimaterials should be considered
   * @returns the material or null if none found.
   */
  getMaterialByUniqueId(uniqueId, allowMultiMaterials = false) {
    return this._getMaterial(allowMultiMaterials, (m) => m.uniqueId === uniqueId);
  }
  /**
   * get a material using its id
   * @param id defines the material's Id
   * @param allowMultiMaterials determines whether multimaterials should be considered
   * @returns the material or null if none found.
   */
  getMaterialById(id, allowMultiMaterials = false) {
    return this._getMaterial(allowMultiMaterials, (m) => m.id === id);
  }
  /**
   * Gets a material using its name
   * @param name defines the material's name
   * @param allowMultiMaterials determines whether multimaterials should be considered
   * @returns the material or null if none found.
   */
  getMaterialByName(name, allowMultiMaterials = false) {
    return this._getMaterial(allowMultiMaterials, (m) => m.name === name);
  }
  /**
   * Gets a last added material using a given id
   * @param id defines the material's id
   * @param allowMultiMaterials determines whether multimaterials should be considered
   * @returns the last material with the given id or null if none found.
   */
  getLastMaterialById(id, allowMultiMaterials = false) {
    for (let index = this.materials.length - 1; index >= 0; index--) {
      if (this.materials[index].id === id) {
        return this.materials[index];
      }
    }
    if (allowMultiMaterials) {
      for (let index = this.multiMaterials.length - 1; index >= 0; index--) {
        if (this.multiMaterials[index].id === id) {
          return this.multiMaterials[index];
        }
      }
    }
    return null;
  }
  /**
   * Get a texture using its unique id
   * @param uniqueId defines the texture's unique id
   * @returns the texture or null if none found.
   */
  getTextureByUniqueId(uniqueId) {
    for (let index = 0; index < this.textures.length; index++) {
      if (this.textures[index].uniqueId === uniqueId) {
        return this.textures[index];
      }
    }
    return null;
  }
  /**
   * Gets a texture using its name
   * @param name defines the texture's name
   * @returns the texture or null if none found.
   */
  getTextureByName(name) {
    for (let index = 0; index < this.textures.length; index++) {
      if (this.textures[index].name === name) {
        return this.textures[index];
      }
    }
    return null;
  }
  /**
   * Gets a camera using its Id
   * @param id defines the Id to look for
   * @returns the camera or null if not found
   */
  getCameraById(id) {
    for (let index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].id === id) {
        return this.cameras[index];
      }
    }
    return null;
  }
  /**
   * Gets a camera using its unique Id
   * @param uniqueId defines the unique Id to look for
   * @returns the camera or null if not found
   */
  getCameraByUniqueId(uniqueId) {
    for (let index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].uniqueId === uniqueId) {
        return this.cameras[index];
      }
    }
    return null;
  }
  /**
   * Gets a camera using its name
   * @param name defines the camera's name
   * @returns the camera or null if none found.
   */
  getCameraByName(name) {
    for (let index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].name === name) {
        return this.cameras[index];
      }
    }
    return null;
  }
  /**
   * Gets a bone using its Id
   * @param id defines the bone's Id
   * @returns the bone or null if not found
   */
  getBoneById(id) {
    for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
      const skeleton = this.skeletons[skeletonIndex];
      for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
        if (skeleton.bones[boneIndex].id === id) {
          return skeleton.bones[boneIndex];
        }
      }
    }
    return null;
  }
  /**
   * Gets a bone using its id
   * @param name defines the bone's name
   * @returns the bone or null if not found
   */
  getBoneByName(name) {
    for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
      const skeleton = this.skeletons[skeletonIndex];
      for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
        if (skeleton.bones[boneIndex].name === name) {
          return skeleton.bones[boneIndex];
        }
      }
    }
    return null;
  }
  /**
   * Gets a light node using its name
   * @param name defines the light's name
   * @returns the light or null if none found.
   */
  getLightByName(name) {
    for (let index = 0; index < this.lights.length; index++) {
      if (this.lights[index].name === name) {
        return this.lights[index];
      }
    }
    return null;
  }
  /**
   * Gets a light node using its Id
   * @param id defines the light's Id
   * @returns the light or null if none found.
   */
  getLightById(id) {
    for (let index = 0; index < this.lights.length; index++) {
      if (this.lights[index].id === id) {
        return this.lights[index];
      }
    }
    return null;
  }
  /**
   * Gets a light node using its scene-generated unique Id
   * @param uniqueId defines the light's unique Id
   * @returns the light or null if none found.
   */
  getLightByUniqueId(uniqueId) {
    for (let index = 0; index < this.lights.length; index++) {
      if (this.lights[index].uniqueId === uniqueId) {
        return this.lights[index];
      }
    }
    return null;
  }
  /**
   * Gets a particle system by Id
   * @param id defines the particle system Id
   * @returns the corresponding system or null if none found
   */
  getParticleSystemById(id) {
    for (let index = 0; index < this.particleSystems.length; index++) {
      if (this.particleSystems[index].id === id) {
        return this.particleSystems[index];
      }
    }
    return null;
  }
  /**
   * Gets a geometry using its Id
   * @param id defines the geometry's Id
   * @returns the geometry or null if none found.
   */
  getGeometryById(id) {
    for (let index = 0; index < this.geometries.length; index++) {
      if (this.geometries[index].id === id) {
        return this.geometries[index];
      }
    }
    return null;
  }
  _getGeometryByUniqueId(uniqueId) {
    if (this._geometriesByUniqueId) {
      const index = this._geometriesByUniqueId[uniqueId];
      if (index !== void 0) {
        return this.geometries[index];
      }
    } else {
      for (let index = 0; index < this.geometries.length; index++) {
        if (this.geometries[index].uniqueId === uniqueId) {
          return this.geometries[index];
        }
      }
    }
    return null;
  }
  /**
   * Gets a frame graph using its name
   * @param name defines the frame graph's name
   * @returns the frame graph or null if none found.
   */
  getFrameGraphByName(name) {
    for (let index = 0; index < this.frameGraphs.length; index++) {
      if (this.frameGraphs[index].name === name) {
        return this.frameGraphs[index];
      }
    }
    return null;
  }
  /**
   * Add a new geometry to this scene
   * @param geometry defines the geometry to be added to the scene.
   * @param force defines if the geometry must be pushed even if a geometry with this id already exists
   * @returns a boolean defining if the geometry was added or not
   */
  pushGeometry(geometry, force) {
    if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {
      return false;
    }
    this.addGeometry(geometry);
    Tools.SetImmediate(() => {
      this.onNewGeometryAddedObservable.notifyObservers(geometry);
    });
    return true;
  }
  /**
   * Removes an existing geometry
   * @param geometry defines the geometry to be removed from the scene
   * @returns a boolean defining if the geometry was removed or not
   */
  removeGeometry(geometry) {
    let index;
    if (this._geometriesByUniqueId) {
      index = this._geometriesByUniqueId[geometry.uniqueId];
      if (index === void 0) {
        return false;
      }
    } else {
      index = this.geometries.indexOf(geometry);
      if (index < 0) {
        return false;
      }
    }
    if (index !== this.geometries.length - 1) {
      const lastGeometry = this.geometries[this.geometries.length - 1];
      if (lastGeometry) {
        this.geometries[index] = lastGeometry;
        if (this._geometriesByUniqueId) {
          this._geometriesByUniqueId[lastGeometry.uniqueId] = index;
        }
      }
    }
    if (this._geometriesByUniqueId) {
      this._geometriesByUniqueId[geometry.uniqueId] = void 0;
    }
    this.geometries.pop();
    this.onGeometryRemovedObservable.notifyObservers(geometry);
    return true;
  }
  /**
   * Gets the list of geometries attached to the scene
   * @returns an array of Geometry
   */
  getGeometries() {
    return this.geometries;
  }
  /**
   * Gets the first added mesh found of a given Id
   * @param id defines the Id to search for
   * @returns the mesh found or null if not found at all
   */
  getMeshById(id) {
    for (let index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    return null;
  }
  /**
   * Gets a list of meshes using their Id
   * @param id defines the Id to search for
   * @returns a list of meshes
   */
  getMeshesById(id) {
    return this.meshes.filter(function(m) {
      return m.id === id;
    });
  }
  /**
   * Gets the first added transform node found of a given Id
   * @param id defines the Id to search for
   * @returns the found transform node or null if not found at all.
   */
  getTransformNodeById(id) {
    for (let index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].id === id) {
        return this.transformNodes[index];
      }
    }
    return null;
  }
  /**
   * Gets a transform node with its auto-generated unique Id
   * @param uniqueId defines the unique Id to search for
   * @returns the found transform node or null if not found at all.
   */
  getTransformNodeByUniqueId(uniqueId) {
    for (let index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].uniqueId === uniqueId) {
        return this.transformNodes[index];
      }
    }
    return null;
  }
  /**
   * Gets a list of transform nodes using their Id
   * @param id defines the Id to search for
   * @returns a list of transform nodes
   */
  getTransformNodesById(id) {
    return this.transformNodes.filter(function(m) {
      return m.id === id;
    });
  }
  /**
   * Gets a mesh with its auto-generated unique Id
   * @param uniqueId defines the unique Id to search for
   * @returns the found mesh or null if not found at all.
   */
  getMeshByUniqueId(uniqueId) {
    for (let index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].uniqueId === uniqueId) {
        return this.meshes[index];
      }
    }
    return null;
  }
  /**
   * Gets a the last added mesh using a given Id
   * @param id defines the Id to search for
   * @returns the found mesh or null if not found at all.
   */
  getLastMeshById(id) {
    for (let index = this.meshes.length - 1; index >= 0; index--) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    return null;
  }
  /**
   * Gets a the last transform node using a given Id
   * @param id defines the Id to search for
   * @returns the found mesh or null if not found at all.
   */
  getLastTransformNodeById(id) {
    for (let index = this.transformNodes.length - 1; index >= 0; index--) {
      if (this.transformNodes[index].id === id) {
        return this.transformNodes[index];
      }
    }
    return null;
  }
  /**
   * Gets a the last added node (Mesh, Camera, Light) using a given Id
   * @param id defines the Id to search for
   * @returns the found node or null if not found at all
   */
  getLastEntryById(id) {
    let index;
    for (index = this.meshes.length - 1; index >= 0; index--) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    for (index = this.transformNodes.length - 1; index >= 0; index--) {
      if (this.transformNodes[index].id === id) {
        return this.transformNodes[index];
      }
    }
    for (index = this.cameras.length - 1; index >= 0; index--) {
      if (this.cameras[index].id === id) {
        return this.cameras[index];
      }
    }
    for (index = this.lights.length - 1; index >= 0; index--) {
      if (this.lights[index].id === id) {
        return this.lights[index];
      }
    }
    return null;
  }
  /**
   * Gets a node (Mesh, Camera, Light) using a given Id
   * @param id defines the Id to search for
   * @returns the found node or null if not found at all
   */
  getNodeById(id) {
    const mesh = this.getMeshById(id);
    if (mesh) {
      return mesh;
    }
    const transformNode = this.getTransformNodeById(id);
    if (transformNode) {
      return transformNode;
    }
    const light = this.getLightById(id);
    if (light) {
      return light;
    }
    const camera = this.getCameraById(id);
    if (camera) {
      return camera;
    }
    const bone = this.getBoneById(id);
    if (bone) {
      return bone;
    }
    return null;
  }
  /**
   * Gets a node (Mesh, Camera, Light) using a given name
   * @param name defines the name to search for
   * @returns the found node or null if not found at all.
   */
  getNodeByName(name) {
    const mesh = this.getMeshByName(name);
    if (mesh) {
      return mesh;
    }
    const transformNode = this.getTransformNodeByName(name);
    if (transformNode) {
      return transformNode;
    }
    const light = this.getLightByName(name);
    if (light) {
      return light;
    }
    const camera = this.getCameraByName(name);
    if (camera) {
      return camera;
    }
    const bone = this.getBoneByName(name);
    if (bone) {
      return bone;
    }
    return null;
  }
  /**
   * Gets a mesh using a given name
   * @param name defines the name to search for
   * @returns the found mesh or null if not found at all.
   */
  getMeshByName(name) {
    for (let index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].name === name) {
        return this.meshes[index];
      }
    }
    return null;
  }
  /**
   * Gets a transform node using a given name
   * @param name defines the name to search for
   * @returns the found transform node or null if not found at all.
   */
  getTransformNodeByName(name) {
    for (let index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].name === name) {
        return this.transformNodes[index];
      }
    }
    return null;
  }
  /**
   * Gets a skeleton using a given Id (if many are found, this function will pick the last one)
   * @param id defines the Id to search for
   * @returns the found skeleton or null if not found at all.
   */
  getLastSkeletonById(id) {
    for (let index = this.skeletons.length - 1; index >= 0; index--) {
      if (this.skeletons[index].id === id) {
        return this.skeletons[index];
      }
    }
    return null;
  }
  /**
   * Gets a skeleton using a given auto generated unique id
   * @param  uniqueId defines the unique id to search for
   * @returns the found skeleton or null if not found at all.
   */
  getSkeletonByUniqueId(uniqueId) {
    for (let index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].uniqueId === uniqueId) {
        return this.skeletons[index];
      }
    }
    return null;
  }
  /**
   * Gets a skeleton using a given id (if many are found, this function will pick the first one)
   * @param id defines the id to search for
   * @returns the found skeleton or null if not found at all.
   */
  getSkeletonById(id) {
    for (let index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].id === id) {
        return this.skeletons[index];
      }
    }
    return null;
  }
  /**
   * Gets a skeleton using a given name
   * @param name defines the name to search for
   * @returns the found skeleton or null if not found at all.
   */
  getSkeletonByName(name) {
    for (let index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].name === name) {
        return this.skeletons[index];
      }
    }
    return null;
  }
  /**
   * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)
   * @param id defines the id to search for
   * @returns the found morph target manager or null if not found at all.
   */
  getMorphTargetManagerById(id) {
    for (let index = 0; index < this.morphTargetManagers.length; index++) {
      if (this.morphTargetManagers[index].uniqueId === id) {
        return this.morphTargetManagers[index];
      }
    }
    return null;
  }
  /**
   * Gets a morph target using a given id (if many are found, this function will pick the first one)
   * @param id defines the id to search for
   * @returns the found morph target or null if not found at all.
   */
  getMorphTargetById(id) {
    for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
      const morphTargetManager = this.morphTargetManagers[managerIndex];
      for (let index = 0; index < morphTargetManager.numTargets; ++index) {
        const target = morphTargetManager.getTarget(index);
        if (target.id === id) {
          return target;
        }
      }
    }
    return null;
  }
  /**
   * Gets a morph target using a given name (if many are found, this function will pick the first one)
   * @param name defines the name to search for
   * @returns the found morph target or null if not found at all.
   */
  getMorphTargetByName(name) {
    for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
      const morphTargetManager = this.morphTargetManagers[managerIndex];
      for (let index = 0; index < morphTargetManager.numTargets; ++index) {
        const target = morphTargetManager.getTarget(index);
        if (target.name === name) {
          return target;
        }
      }
    }
    return null;
  }
  /**
   * Gets a post process using a given name (if many are found, this function will pick the first one)
   * @param name defines the name to search for
   * @returns the found post process or null if not found at all.
   */
  getPostProcessByName(name) {
    for (let postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {
      const postProcess = this.postProcesses[postProcessIndex];
      if (postProcess.name === name) {
        return postProcess;
      }
    }
    return null;
  }
  /**
   * Gets a boolean indicating if the given mesh is active
   * @param mesh defines the mesh to look for
   * @returns true if the mesh is in the active list
   */
  isActiveMesh(mesh) {
    return this._activeMeshes.indexOf(mesh) !== -1;
  }
  /**
   * Return a unique id as a string which can serve as an identifier for the scene
   */
  get uid() {
    if (!this._uid) {
      this._uid = Tools.RandomId();
    }
    return this._uid;
  }
  /**
   * Add an externally attached data from its key.
   * This method call will fail and return false, if such key already exists.
   * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.
   * @param key the unique key that identifies the data
   * @param data the data object to associate to the key for this Engine instance
   * @returns true if no such key were already present and the data was added successfully, false otherwise
   */
  addExternalData(key, data) {
    if (!this._externalData) {
      this._externalData = new StringDictionary();
    }
    return this._externalData.add(key, data);
  }
  /**
   * Get an externally attached data from its key
   * @param key the unique key that identifies the data
   * @returns the associated data, if present (can be null), or undefined if not present
   */
  getExternalData(key) {
    if (!this._externalData) {
      return null;
    }
    return this._externalData.get(key);
  }
  /**
   * Get an externally attached data from its key, create it using a factory if it's not already present
   * @param key the unique key that identifies the data
   * @param factory the factory that will be called to create the instance if and only if it doesn't exists
   * @returns the associated data, can be null if the factory returned null.
   */
  getOrAddExternalDataWithFactory(key, factory) {
    if (!this._externalData) {
      this._externalData = new StringDictionary();
    }
    return this._externalData.getOrAddWithFactory(key, factory);
  }
  /**
   * Remove an externally attached data from the Engine instance
   * @param key the unique key that identifies the data
   * @returns true if the data was successfully removed, false if it doesn't exist
   */
  removeExternalData(key) {
    return this._externalData.remove(key);
  }
  _evaluateSubMesh(subMesh, mesh, initialMesh, forcePush) {
    if (forcePush || subMesh.isInFrustum(this._frustumPlanes)) {
      for (const step of this._evaluateSubMeshStage) {
        step.action(mesh, subMesh);
      }
      const material = subMesh.getMaterial();
      if (material !== null && material !== void 0) {
        if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
          if (this._processedMaterials.indexOf(material) === -1) {
            this._processedMaterials.push(material);
            this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
          }
        }
        this._renderingManager.dispatch(subMesh, mesh, material);
      }
    }
  }
  /**
   * Clear the processed materials smart array preventing retention point in material dispose.
   */
  freeProcessedMaterials() {
    this._processedMaterials.dispose();
  }
  /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups
   * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance
   * when disposing several meshes in a row or a hierarchy of meshes.
   * When used, it is the responsibility of the user to blockfreeActiveMeshesAndRenderingGroups back to false.
   */
  get blockfreeActiveMeshesAndRenderingGroups() {
    return this._preventFreeActiveMeshesAndRenderingGroups;
  }
  set blockfreeActiveMeshesAndRenderingGroups(value) {
    if (this._preventFreeActiveMeshesAndRenderingGroups === value) {
      return;
    }
    if (value) {
      this.freeActiveMeshes();
      this.freeRenderingGroups();
    }
    this._preventFreeActiveMeshesAndRenderingGroups = value;
  }
  /**
   * Clear the active meshes smart array preventing retention point in mesh dispose.
   */
  freeActiveMeshes() {
    if (this.blockfreeActiveMeshesAndRenderingGroups) {
      return;
    }
    this._activeMeshes.dispose();
    if (this.activeCamera && this.activeCamera._activeMeshes) {
      this.activeCamera._activeMeshes.dispose();
    }
    if (this.activeCameras) {
      for (let i = 0; i < this.activeCameras.length; i++) {
        const activeCamera = this.activeCameras[i];
        if (activeCamera && activeCamera._activeMeshes) {
          activeCamera._activeMeshes.dispose();
        }
      }
    }
  }
  /**
   * Clear the info related to rendering groups preventing retention points during dispose.
   */
  freeRenderingGroups() {
    if (this.blockfreeActiveMeshesAndRenderingGroups) {
      return;
    }
    if (this._renderingManager) {
      this._renderingManager.freeRenderingGroups();
    }
    if (this.textures) {
      for (let i = 0; i < this.textures.length; i++) {
        const texture = this.textures[i];
        if (texture && texture.renderList) {
          texture.freeRenderingGroups();
        }
      }
    }
  }
  /** @internal */
  _isInIntermediateRendering() {
    return this._intermediateRendering;
  }
  /**
   * Use this function to stop evaluating active meshes. The current list will be keep alive between frames
   * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped
   * @param onSuccess optional success callback
   * @param onError optional error callback
   * @param freezeMeshes defines if meshes should be frozen (true by default)
   * @param keepFrustumCulling defines if you want to keep running the frustum clipping (false by default)
   * @returns the current scene
   */
  freezeActiveMeshes(skipEvaluateActiveMeshes = false, onSuccess, onError, freezeMeshes = true, keepFrustumCulling = false) {
    if (this.frameGraph) {
      this._renderWithFrameGraph(true, false, true);
      const objectRendererTasks = this.frameGraph.getTasksByType(FrameGraphObjectRendererTask);
      for (const task of objectRendererTasks) {
        task.objectRenderer._freezeActiveMeshes(freezeMeshes);
      }
      this._freezeActiveMeshesCancel = _RetryWithInterval(() => {
        let ok = true;
        let notCancelled = true;
        for (const task of objectRendererTasks) {
          ok && (ok = task.objectRenderer._isFrozen);
          notCancelled && (notCancelled = task.objectRenderer._freezeActiveMeshesCancel !== null);
        }
        if (ok) {
          return true;
        } else if (!notCancelled) {
          throw new Error("Freezing active meshes was cancelled");
        }
        return false;
      }, () => {
        this._freezeActiveMeshesCancel = null;
        this._activeMeshesFrozen = true;
        this._activeMeshesFrozenButKeepClipping = keepFrustumCulling;
        this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;
        onSuccess?.();
      }, (err, isTimeout) => {
        this._freezeActiveMeshesCancel = null;
        this.unfreezeActiveMeshes();
        if (!isTimeout) {
          const errMsg = "Scene: An unexpected error occurred while trying to freeze active meshes.";
          if (onError) {
            onError(errMsg);
          } else {
            Logger.Error(errMsg);
            if (err) {
              Logger.Error(err);
              if (err.stack) {
                Logger.Error(err.stack);
              }
            }
          }
        } else {
          const errMsg = "Scene: Timeout while waiting for meshes to be frozen.";
          if (onError) {
            onError(errMsg);
          } else {
            Logger.Error(errMsg);
            if (err) {
              Logger.Error(err);
            }
          }
        }
      });
      return this;
    }
    this.executeWhenReady(() => {
      if (!this.activeCamera) {
        if (onError) {
          onError("No active camera found");
        }
        return;
      }
      if (!this._frustumPlanes) {
        this.updateTransformMatrix();
      }
      this._evaluateActiveMeshes();
      this._activeMeshesFrozen = true;
      this._activeMeshesFrozenButKeepClipping = keepFrustumCulling;
      this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;
      if (freezeMeshes) {
        for (let index = 0; index < this._activeMeshes.length; index++) {
          this._activeMeshes.data[index]._freeze();
        }
      }
      if (onSuccess) {
        onSuccess();
      }
    });
    return this;
  }
  /**
   * Use this function to restart evaluating active meshes on every frame
   * @returns the current scene
   */
  unfreezeActiveMeshes() {
    for (let index = 0; index < this.meshes.length; index++) {
      const mesh = this.meshes[index];
      if (mesh._internalAbstractMeshDataInfo) {
        mesh._internalAbstractMeshDataInfo._isActive = false;
      }
    }
    this._freezeActiveMeshesCancel?.();
    this._freezeActiveMeshesCancel = null;
    if (this.frameGraph) {
      const objectRendererTasks = this.frameGraph.getTasksByType(FrameGraphObjectRendererTask);
      for (const task of objectRendererTasks) {
        task.objectRenderer._unfreezeActiveMeshes();
      }
    } else {
      for (let index = 0; index < this._activeMeshes.length; index++) {
        this._activeMeshes.data[index]._unFreeze();
      }
    }
    this._activeMeshesFrozen = false;
    return this;
  }
  _executeActiveContainerCleanup(container) {
    const isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;
    if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {
      return;
    }
    this.onBeforeRenderObservable.addOnce(() => container.dispose());
  }
  _evaluateActiveMeshes() {
    if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {
      if (this._activeMeshes.length > 0) {
        this.activeCamera?._activeMeshes.reset();
        this._activeMeshes.reset();
        this._renderingManager.reset();
        this._processedMaterials.reset();
        this._activeParticleSystems.reset();
        this._activeSkeletons.reset();
        this._softwareSkinnedMeshes.reset();
      }
      return;
    }
    if (this._activeMeshesFrozen && this._activeMeshes.length) {
      if (!this._skipEvaluateActiveMeshesCompletely) {
        const len2 = this._activeMeshes.length;
        for (let i = 0; i < len2; i++) {
          const mesh = this._activeMeshes.data[i];
          mesh.computeWorldMatrix();
        }
      }
      if (this._activeParticleSystems) {
        const psLength = this._activeParticleSystems.length;
        for (let i = 0; i < psLength; i++) {
          this._activeParticleSystems.data[i].animate();
        }
      }
      this._renderingManager.resetSprites();
      return;
    }
    if (!this.activeCamera) {
      return;
    }
    this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);
    this.activeCamera._activeMeshes.reset();
    this._activeMeshes.reset();
    this._renderingManager.reset();
    this._processedMaterials.reset();
    this._activeParticleSystems.reset();
    this._activeSkeletons.reset();
    this._softwareSkinnedMeshes.reset();
    this._materialsRenderTargets.reset();
    for (const step of this._beforeEvaluateActiveMeshStage) {
      step.action();
    }
    const meshes = this.getActiveMeshCandidates();
    const len = meshes.length;
    for (let i = 0; i < len; i++) {
      const mesh = meshes.data[i];
      let currentLOD = mesh._internalAbstractMeshDataInfo._currentLOD.get(this.activeCamera);
      if (currentLOD) {
        currentLOD[1] = -1;
      } else {
        currentLOD = [mesh, -1];
        mesh._internalAbstractMeshDataInfo._currentLOD.set(this.activeCamera, currentLOD);
      }
      if (mesh.isBlocked) {
        continue;
      }
      this._totalVertices.addCount(mesh.getTotalVertices(), false);
      if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {
        continue;
      }
      mesh.computeWorldMatrix();
      if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {
        this._meshesForIntersections.pushNoDuplicate(mesh);
      }
      let meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);
      currentLOD[0] = meshToRender;
      currentLOD[1] = this._frameId;
      if (meshToRender === void 0 || meshToRender === null) {
        continue;
      }
      if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {
        meshToRender.computeWorldMatrix();
      }
      mesh._preActivate();
      if (mesh.isVisible && mesh.visibility > 0 && (mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {
        this._activeMeshes.push(mesh);
        this.activeCamera._activeMeshes.push(mesh);
        if (meshToRender !== mesh) {
          meshToRender._activate(this._renderId, false);
        }
        for (const step of this._preActiveMeshStage) {
          step.action(mesh);
        }
        if (mesh._activate(this._renderId, false)) {
          if (!mesh.isAnInstance) {
            meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;
          } else {
            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
              meshToRender = mesh;
            }
          }
          meshToRender._internalAbstractMeshDataInfo._isActive = true;
          this._activeMesh(mesh, meshToRender);
        }
        mesh._postActivate();
      }
    }
    this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);
    if (this.particlesEnabled) {
      this.onBeforeParticlesRenderingObservable.notifyObservers(this);
      for (let particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {
        const particleSystem = this.particleSystems[particleIndex];
        if (!particleSystem.isStarted() || !particleSystem.emitter) {
          continue;
        }
        const emitter = particleSystem.emitter;
        if (!emitter.position || emitter.isEnabled()) {
          this._activeParticleSystems.push(particleSystem);
          particleSystem.animate();
          this._renderingManager.dispatchParticles(particleSystem);
        }
      }
      this.onAfterParticlesRenderingObservable.notifyObservers(this);
    }
  }
  /** @internal */
  _prepareSkeleton(mesh) {
    if (!this._skeletonsEnabled || !mesh.skeleton) {
      return;
    }
    if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {
      mesh.skeleton.prepare();
      this._activeBones.addCount(mesh.skeleton.bones.length, false);
    }
    if (!mesh.computeBonesUsingShaders) {
      if (this._softwareSkinnedMeshes.pushNoDuplicate(mesh) && this.frameGraph) {
        mesh.applySkeleton(mesh.skeleton);
      }
    }
  }
  _activeMesh(sourceMesh, mesh) {
    this._prepareSkeleton(mesh);
    let forcePush = sourceMesh.hasInstances || sourceMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh;
    if (mesh && mesh.subMeshes && mesh.subMeshes.length > 0) {
      const subMeshes = this.getActiveSubMeshCandidates(mesh);
      const len = subMeshes.length;
      forcePush = forcePush || len === 1;
      for (let i = 0; i < len; i++) {
        const subMesh = subMeshes.data[i];
        this._evaluateSubMesh(subMesh, mesh, sourceMesh, forcePush);
      }
    }
  }
  /**
   * Update the transform matrix to update from the current active camera
   * @param force defines a boolean used to force the update even if cache is up to date
   */
  updateTransformMatrix(force) {
    const activeCamera = this.activeCamera;
    if (!activeCamera) {
      return;
    }
    if (activeCamera._renderingMultiview) {
      const leftCamera = activeCamera._rigCameras[0];
      const rightCamera = activeCamera._rigCameras[1];
      this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));
    } else {
      this.setTransformMatrix(activeCamera.getViewMatrix(), activeCamera.getProjectionMatrix(force));
    }
  }
  _bindFrameBuffer(camera, clear = true) {
    if (!this._useCurrentFrameBuffer) {
      if (camera && camera._multiviewTexture) {
        camera._multiviewTexture._bindFrameBuffer();
      } else if (camera && camera.outputRenderTarget) {
        camera.outputRenderTarget._bindFrameBuffer();
      } else {
        if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {
          this._engine.restoreDefaultFramebuffer();
        }
      }
    }
    if (clear) {
      this._clearFrameBuffer(camera);
    }
  }
  _clearFrameBuffer(camera) {
    if (camera && camera._multiviewTexture) {
    } else if (camera && camera.outputRenderTarget && !camera._renderingMultiview) {
      const rtt = camera.outputRenderTarget;
      if (rtt.onClearObservable.hasObservers()) {
        rtt.onClearObservable.notifyObservers(this._engine);
      } else if (!rtt.skipInitialClear && !camera.isRightCamera) {
        if (this.autoClear) {
          this._engine.clear(rtt.clearColor || this._clearColor, !rtt._cleared, true, true);
        }
        rtt._cleared = true;
      }
    } else {
      if (!this._defaultFrameBufferCleared) {
        this._defaultFrameBufferCleared = true;
        this._clear();
      } else {
        this._engine.clear(null, false, true, true);
      }
    }
  }
  /**
   * @internal
   */
  _renderForCamera(camera, rigParent, bindFrameBuffer = true) {
    if (camera && camera._skipRendering) {
      return;
    }
    const engine = this._engine;
    this._activeCamera = camera;
    if (!this.activeCamera) {
      throw new Error("Active camera not set");
    }
    engine.setViewport(this.activeCamera.viewport);
    this.resetCachedMaterial();
    this._renderId++;
    if (!this.prePass && bindFrameBuffer) {
      let skipInitialClear = true;
      if (camera._renderingMultiview && camera.outputRenderTarget) {
        skipInitialClear = camera.outputRenderTarget.skipInitialClear;
        if (this.autoClear) {
          this._defaultFrameBufferCleared = false;
          camera.outputRenderTarget.skipInitialClear = false;
        }
      }
      this._bindFrameBuffer(this._activeCamera);
      if (camera._renderingMultiview && camera.outputRenderTarget) {
        camera.outputRenderTarget.skipInitialClear = skipInitialClear;
      }
    }
    this.updateTransformMatrix();
    this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);
    this._evaluateActiveMeshes();
    for (let softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {
      const mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];
      mesh.applySkeleton(mesh.skeleton);
    }
    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
    this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);
    if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {
      this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);
    }
    if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {
      this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);
    }
    if (this.environmentTexture && this.environmentTexture.isRenderTarget) {
      this._renderTargets.pushNoDuplicate(this.environmentTexture);
    }
    for (const step of this._gatherActiveCameraRenderTargetsStage) {
      step.action(this._renderTargets);
    }
    let needRebind = false;
    if (this.renderTargetsEnabled) {
      this._intermediateRendering = true;
      if (this._renderTargets.length > 0) {
        Tools.StartPerformanceCounter("Render targets", this._renderTargets.length > 0);
        const boundingBoxRenderer = this.getBoundingBoxRenderer?.();
        let currentBoundingBoxMeshList;
        for (let renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {
          const renderTarget = this._renderTargets.data[renderIndex];
          if (renderTarget._shouldRender()) {
            this._renderId++;
            const hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;
            if (boundingBoxRenderer && !currentBoundingBoxMeshList) {
              currentBoundingBoxMeshList = boundingBoxRenderer.renderList.length > 0 ? boundingBoxRenderer.renderList.data.slice() : [];
              currentBoundingBoxMeshList.length = boundingBoxRenderer.renderList.length;
            }
            renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);
            needRebind = true;
          }
        }
        if (boundingBoxRenderer && currentBoundingBoxMeshList) {
          boundingBoxRenderer.renderList.data = currentBoundingBoxMeshList;
          boundingBoxRenderer.renderList.length = currentBoundingBoxMeshList.length;
        }
        Tools.EndPerformanceCounter("Render targets", this._renderTargets.length > 0);
        this._renderId++;
      }
      for (const step of this._cameraDrawRenderTargetStage) {
        needRebind = step.action(this.activeCamera) || needRebind;
      }
      this._intermediateRendering = false;
    }
    this._engine.currentRenderPassId = camera.outputRenderTarget?.renderPassId ?? camera.renderPassId ?? 0;
    if (needRebind && !this.prePass) {
      this._bindFrameBuffer(this._activeCamera, false);
      this.updateTransformMatrix();
    }
    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
    if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {
      this.postProcessManager._prepareFrame();
    }
    for (const step of this._beforeCameraDrawStage) {
      step.action(this.activeCamera);
    }
    this.onBeforeDrawPhaseObservable.notifyObservers(this);
    const fastSnapshotMode = engine.snapshotRendering && engine.snapshotRenderingMode === 1;
    if (fastSnapshotMode) {
      this.finalizeSceneUbo();
    }
    this._renderingManager.render(null, null, true, !fastSnapshotMode);
    this.onAfterDrawPhaseObservable.notifyObservers(this);
    for (const step of this._afterCameraDrawStage) {
      step.action(this.activeCamera);
    }
    if (this.postProcessManager && !camera._multiviewTexture) {
      const texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget : void 0;
      this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);
    }
    for (const step of this._afterCameraPostProcessStage) {
      step.action(this.activeCamera);
    }
    this._renderTargets.reset();
    this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);
  }
  _processSubCameras(camera, bindFrameBuffer = true) {
    if (camera.cameraRigMode === 0 || camera._renderingMultiview) {
      if (camera._renderingMultiview && !this._multiviewSceneUbo) {
        this._createMultiviewUbo();
      }
      this._renderForCamera(camera, void 0, bindFrameBuffer);
      this.onAfterRenderCameraObservable.notifyObservers(camera);
      return;
    }
    if (camera._useMultiviewToSingleView) {
      this._renderMultiviewToSingleView(camera);
    } else {
      this.onBeforeCameraRenderObservable.notifyObservers(camera);
      for (let index = 0; index < camera._rigCameras.length; index++) {
        this._renderForCamera(camera._rigCameras[index], camera);
      }
    }
    this._activeCamera = camera;
    this.updateTransformMatrix();
    this.onAfterRenderCameraObservable.notifyObservers(camera);
  }
  _checkIntersections() {
    for (let index = 0; index < this._meshesForIntersections.length; index++) {
      const sourceMesh = this._meshesForIntersections.data[index];
      if (!sourceMesh.actionManager) {
        continue;
      }
      for (let actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {
        const action = sourceMesh.actionManager.actions[actionIndex];
        if (action.trigger === 12 || action.trigger === 13) {
          const parameters = action.getTriggerParameter();
          const otherMesh = parameters.mesh ? parameters.mesh : parameters;
          const areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);
          const currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);
          if (areIntersecting && currentIntersectionInProgress === -1) {
            if (action.trigger === 12) {
              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh));
              sourceMesh._intersectionsInProgress.push(otherMesh);
            } else if (action.trigger === 13) {
              sourceMesh._intersectionsInProgress.push(otherMesh);
            }
          } else if (!areIntersecting && currentIntersectionInProgress > -1) {
            if (action.trigger === 13) {
              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh));
            }
            if (!sourceMesh.actionManager.hasSpecificTrigger(13, (parameter) => {
              const parameterMesh = parameter.mesh ? parameter.mesh : parameter;
              return otherMesh === parameterMesh;
            }) || action.trigger === 13) {
              sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);
            }
          }
        }
      }
    }
  }
  /**
   * @internal
   */
  _advancePhysicsEngineStep(step) {
  }
  /** @internal */
  _animate(customDeltaTime) {
  }
  /** Execute all animations (for a frame) */
  animate() {
    if (this._engine.isDeterministicLockStep()) {
      let deltaTime = Math.max(_Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), _Scene.MaxDeltaTime)) + this._timeAccumulator;
      const defaultFrameTime = this._engine.getTimeStep();
      const defaultFPS = 1e3 / defaultFrameTime / 1e3;
      let stepsTaken = 0;
      const maxSubSteps = this._engine.getLockstepMaxSteps();
      let internalSteps = Math.floor(deltaTime / defaultFrameTime);
      internalSteps = Math.min(internalSteps, maxSubSteps);
      while (deltaTime > 0 && stepsTaken < internalSteps) {
        this.onBeforeStepObservable.notifyObservers(this);
        this._animationRatio = defaultFrameTime * defaultFPS;
        this._animate(defaultFrameTime);
        this.onAfterAnimationsObservable.notifyObservers(this);
        if (this.physicsEnabled) {
          this._advancePhysicsEngineStep(defaultFrameTime);
        }
        this.onAfterStepObservable.notifyObservers(this);
        this._currentStepId++;
        stepsTaken++;
        deltaTime -= defaultFrameTime;
      }
      this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;
    } else {
      const deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(_Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), _Scene.MaxDeltaTime));
      this._animationRatio = deltaTime * (60 / 1e3);
      this._animate();
      this.onAfterAnimationsObservable.notifyObservers(this);
      if (this.physicsEnabled) {
        this._advancePhysicsEngineStep(deltaTime);
      }
    }
  }
  _clear() {
    if (this.autoClearDepthAndStencil || this.autoClear) {
      this._engine.clear(this._clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);
    }
  }
  _checkCameraRenderTarget(camera) {
    if (camera?.outputRenderTarget && !camera?.isRigCamera) {
      camera.outputRenderTarget._cleared = false;
    }
    if (camera?.rigCameras?.length) {
      for (let i = 0; i < camera.rigCameras.length; ++i) {
        const rtt = camera.rigCameras[i].outputRenderTarget;
        if (rtt) {
          rtt._cleared = false;
        }
      }
    }
  }
  /**
   * Resets the draw wrappers cache of all meshes
   * @param passId If provided, releases only the draw wrapper corresponding to this render pass id
   */
  resetDrawCache(passId) {
    if (!this.meshes) {
      return;
    }
    for (const mesh of this.meshes) {
      mesh.resetDrawCache(passId);
    }
  }
  _renderWithFrameGraph(updateCameras = true, _ignoreAnimations = false, forceUpdateWorldMatrix = false) {
    this.activeCamera = null;
    this.activeCameras = null;
    if (updateCameras) {
      for (const camera of this.cameras) {
        camera.update();
        if (camera.cameraRigMode !== 0) {
          for (let index = 0; index < camera._rigCameras.length; index++) {
            camera._rigCameras[index].update();
          }
        }
      }
    }
    this.onBeforeRenderObservable.notifyObservers(this);
    for (const step of this._beforeClearStage) {
      step.action();
    }
    if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {
      this._activeParticleSystems.reset();
      this._activeSkeletons.reset();
      this._softwareSkinnedMeshes.reset();
    } else {
      const meshes = this.getActiveMeshCandidates();
      const len = meshes.length;
      if (!this._activeMeshesFrozen) {
        this._activeParticleSystems.reset();
        this._activeSkeletons.reset();
        this._softwareSkinnedMeshes.reset();
        for (let i = 0; i < len; i++) {
          const mesh = meshes.data[i];
          mesh._internalAbstractMeshDataInfo._wasActiveLastFrame = false;
          if (mesh.isBlocked) {
            continue;
          }
          this._totalVertices.addCount(mesh.getTotalVertices(), false);
          if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {
            continue;
          }
          mesh.computeWorldMatrix(forceUpdateWorldMatrix);
          if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {
            this._meshesForIntersections.pushNoDuplicate(mesh);
          }
        }
        if (this.particlesEnabled) {
          for (let particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {
            const particleSystem = this.particleSystems[particleIndex];
            if (!particleSystem.isStarted() || !particleSystem.emitter) {
              continue;
            }
            const emitter = particleSystem.emitter;
            if (!emitter.position || emitter.isEnabled()) {
              this._activeParticleSystems.push(particleSystem);
              particleSystem.animate();
            }
          }
        }
      } else {
        if (!this._skipEvaluateActiveMeshesCompletely) {
          for (let i = 0; i < len; i++) {
            const mesh = meshes.data[i];
            if (mesh._internalAbstractMeshDataInfo._wasActiveLastFrame) {
              mesh.computeWorldMatrix();
            }
          }
        }
        if (this.particlesEnabled) {
          const psLength = this._activeParticleSystems.length;
          for (let i = 0; i < psLength; i++) {
            this._activeParticleSystems.data[i].animate();
          }
        }
      }
    }
    this.frameGraph?.execute();
  }
  /**
   * @internal
   */
  _renderRenderTarget(renderTarget, activeCamera, useCameraPostProcess = false, dumpForDebug = false) {
    this._intermediateRendering = true;
    if (renderTarget._shouldRender()) {
      this._renderId++;
      this.activeCamera = activeCamera;
      if (!this.activeCamera) {
        throw new Error("Active camera not set");
      }
      this._engine.setViewport(this.activeCamera.viewport);
      this.updateTransformMatrix();
      renderTarget.render(useCameraPostProcess, dumpForDebug);
    }
    this._intermediateRendering = false;
  }
  /**
   * Render the scene
   * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)
   * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)
   */
  render(updateCameras = true, ignoreAnimations = false) {
    if (this.isDisposed) {
      return;
    }
    if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {
      this._checkIsReady();
    }
    FloatingOriginCurrentScene.getScene = this._getFloatingOriginScene;
    this._frameId++;
    this._defaultFrameBufferCleared = false;
    this._checkCameraRenderTarget(this.activeCamera);
    if (this.activeCameras?.length) {
      for (const c of this.activeCameras) {
        this._checkCameraRenderTarget(c);
      }
    }
    this._registerTransientComponents();
    this._activeParticles.fetchNewFrame();
    this._totalVertices.fetchNewFrame();
    this._activeIndices.fetchNewFrame();
    this._activeBones.fetchNewFrame();
    this._meshesForIntersections.reset();
    this.resetCachedMaterial();
    this.onBeforeAnimationsObservable.notifyObservers(this);
    if (this.actionManager) {
      this.actionManager.processTrigger(11);
    }
    if (!ignoreAnimations) {
      this.animate();
    }
    for (const step of this._beforeCameraUpdateStage) {
      step.action();
    }
    if (updateCameras) {
      if (this.activeCameras && this.activeCameras.length > 0) {
        for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
          const camera = this.activeCameras[cameraIndex];
          camera.update();
          if (camera.cameraRigMode !== 0) {
            for (let index = 0; index < camera._rigCameras.length; index++) {
              camera._rigCameras[index].update();
            }
          }
        }
      } else if (this.activeCamera) {
        this.activeCamera.update();
        if (this.activeCamera.cameraRigMode !== 0) {
          for (let index = 0; index < this.activeCamera._rigCameras.length; index++) {
            this.activeCamera._rigCameras[index].update();
          }
        }
      }
    }
    if (this.customRenderFunction) {
      this._renderId++;
      this._engine.currentRenderPassId = 0;
      this.customRenderFunction(updateCameras, ignoreAnimations);
    } else {
      this.onBeforeRenderObservable.notifyObservers(this);
      this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
      const currentActiveCamera = this.activeCameras?.length ? this.activeCameras[0] : this.activeCamera;
      if (this.renderTargetsEnabled) {
        Tools.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
        for (let customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {
          const renderTarget = this.customRenderTargets[customIndex];
          const activeCamera = renderTarget.activeCamera || this.activeCamera;
          this._renderRenderTarget(renderTarget, activeCamera, currentActiveCamera !== activeCamera, this.dumpNextRenderTargets);
        }
        Tools.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
        this._renderId++;
      }
      this._engine.currentRenderPassId = currentActiveCamera?.renderPassId ?? 0;
      this.activeCamera = currentActiveCamera;
      if (this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass) {
        this._bindFrameBuffer(this._activeCamera, false);
      }
      this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
      for (const step of this._beforeClearStage) {
        step.action();
      }
      this._clearFrameBuffer(this.activeCamera);
      for (const step of this._gatherRenderTargetsStage) {
        step.action(this._renderTargets);
      }
      if (this.activeCameras && this.activeCameras.length > 0) {
        for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
          this._processSubCameras(this.activeCameras[cameraIndex], cameraIndex > 0);
        }
      } else {
        if (!this.activeCamera) {
          throw new Error("No camera defined");
        }
        this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);
      }
    }
    this._checkIntersections();
    for (const step of this._afterRenderStage) {
      step.action();
    }
    if (this.afterRender) {
      this.afterRender();
    }
    this.onAfterRenderObservable.notifyObservers(this);
    if (this._toBeDisposed.length) {
      for (let index = 0; index < this._toBeDisposed.length; index++) {
        const data = this._toBeDisposed[index];
        if (data) {
          data.dispose();
        }
      }
      this._toBeDisposed.length = 0;
    }
    if (this.dumpNextRenderTargets) {
      this.dumpNextRenderTargets = false;
    }
    this._activeBones.addCount(0, true);
    this._activeIndices.addCount(0, true);
    this._activeParticles.addCount(0, true);
    this._engine.restoreDefaultFramebuffer();
  }
  /**
   * Freeze all materials
   * A frozen material will not be updatable but should be faster to render
   * Note: multimaterials will not be frozen, but their submaterials will
   */
  freezeMaterials() {
    for (let i = 0; i < this.materials.length; i++) {
      this.materials[i].freeze();
    }
  }
  /**
   * Unfreeze all materials
   * A frozen material will not be updatable but should be faster to render
   */
  unfreezeMaterials() {
    for (let i = 0; i < this.materials.length; i++) {
      this.materials[i].unfreeze();
    }
  }
  /**
   * Releases all held resources
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.beforeRender = null;
    this.afterRender = null;
    this.metadata = null;
    this.skeletons.length = 0;
    this.morphTargetManagers.length = 0;
    this._transientComponents.length = 0;
    this._isReadyForMeshStage.clear();
    this._beforeEvaluateActiveMeshStage.clear();
    this._evaluateSubMeshStage.clear();
    this._preActiveMeshStage.clear();
    this._cameraDrawRenderTargetStage.clear();
    this._beforeCameraDrawStage.clear();
    this._beforeRenderTargetDrawStage.clear();
    this._beforeRenderingGroupDrawStage.clear();
    this._beforeRenderingMeshStage.clear();
    this._afterRenderingMeshStage.clear();
    this._afterRenderingGroupDrawStage.clear();
    this._afterCameraDrawStage.clear();
    this._afterRenderTargetDrawStage.clear();
    this._afterRenderStage.clear();
    this._beforeCameraUpdateStage.clear();
    this._beforeClearStage.clear();
    this._gatherRenderTargetsStage.clear();
    this._gatherActiveCameraRenderTargetsStage.clear();
    this._pointerMoveStage.clear();
    this._pointerDownStage.clear();
    this._pointerUpStage.clear();
    this.importedMeshesFiles = [];
    if (this._activeAnimatables && this.stopAllAnimations) {
      for (const animatable of this._activeAnimatables) {
        animatable.onAnimationEndObservable.clear();
        animatable.onAnimationEnd = null;
      }
      this.stopAllAnimations();
    }
    this.resetCachedMaterial();
    if (this.activeCamera) {
      this.activeCamera._activeMeshes.dispose();
      this.activeCamera = null;
    }
    this.activeCameras = null;
    this._activeMeshes.dispose();
    this._renderingManager.dispose();
    this._processedMaterials.dispose();
    this._activeParticleSystems.dispose();
    this._activeSkeletons.dispose();
    this._softwareSkinnedMeshes.dispose();
    this._renderTargets.dispose();
    this._materialsRenderTargets.dispose();
    this._registeredForLateAnimationBindings.dispose();
    this._meshesForIntersections.dispose();
    this._toBeDisposed.length = 0;
    const activeRequests = this._activeRequests.slice();
    for (const request of activeRequests) {
      request.abort();
    }
    this._activeRequests.length = 0;
    try {
      this.onDisposeObservable.notifyObservers(this);
    } catch (e) {
      Logger.Error("An error occurred while calling onDisposeObservable!", e);
    }
    this.detachControl();
    const canvas = this._engine.getInputElement();
    if (canvas) {
      for (let index2 = 0; index2 < this.cameras.length; index2++) {
        this.cameras[index2].detachControl();
      }
    }
    this._disposeList(this.animationGroups);
    this._disposeList(this.lights);
    if (this._defaultMaterial) {
      this._defaultMaterial.dispose();
    }
    this._disposeList(this.multiMaterials);
    this._disposeList(this.materials);
    this._disposeList(this.meshes, (item) => item.dispose(true));
    this._disposeList(this.transformNodes, (item) => item.dispose(true));
    const cameras = this.cameras;
    this._disposeList(cameras);
    this._disposeList(this.particleSystems);
    this._disposeList(this.postProcesses);
    this._disposeList(this.textures);
    this._disposeList(this.morphTargetManagers);
    this._disposeList(this.frameGraphs);
    this._sceneUbo.dispose();
    if (this._multiviewSceneUbo) {
      this._multiviewSceneUbo.dispose();
    }
    this.postProcessManager.dispose();
    this._disposeList(this._components);
    let index = this._engine.scenes.indexOf(this);
    if (index > -1) {
      this._engine.scenes.splice(index, 1);
    }
    this._floatingOriginScene = void 0;
    if (this._engine.scenes.length === 0) {
      ResetMatrixFunctions();
    }
    if (EngineStore._LastCreatedScene === this) {
      EngineStore._LastCreatedScene = null;
      let engineIndex = EngineStore.Instances.length - 1;
      while (engineIndex >= 0) {
        const engine = EngineStore.Instances[engineIndex];
        if (engine.scenes.length > 0) {
          EngineStore._LastCreatedScene = engine.scenes[this._engine.scenes.length - 1];
          break;
        }
        engineIndex--;
      }
    }
    index = this._engine._virtualScenes.indexOf(this);
    if (index > -1) {
      this._engine._virtualScenes.splice(index, 1);
    }
    this._engine.wipeCaches(true);
    this.onDisposeObservable.clear();
    this.onBeforeRenderObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onBeforeRenderTargetsRenderObservable.clear();
    this.onAfterRenderTargetsRenderObservable.clear();
    this.onAfterStepObservable.clear();
    this.onBeforeStepObservable.clear();
    this.onBeforeActiveMeshesEvaluationObservable.clear();
    this.onAfterActiveMeshesEvaluationObservable.clear();
    this.onBeforeParticlesRenderingObservable.clear();
    this.onAfterParticlesRenderingObservable.clear();
    this.onBeforeDrawPhaseObservable.clear();
    this.onAfterDrawPhaseObservable.clear();
    this.onBeforeAnimationsObservable.clear();
    this.onAfterAnimationsObservable.clear();
    this.onDataLoadedObservable.clear();
    this.onBeforeRenderingGroupObservable.clear();
    this.onAfterRenderingGroupObservable.clear();
    this.onMeshImportedObservable.clear();
    this.onBeforeCameraRenderObservable.clear();
    this.onAfterCameraRenderObservable.clear();
    this.onAfterRenderCameraObservable.clear();
    this.onReadyObservable.clear();
    this.onNewCameraAddedObservable.clear();
    this.onCameraRemovedObservable.clear();
    this.onNewLightAddedObservable.clear();
    this.onLightRemovedObservable.clear();
    this.onNewGeometryAddedObservable.clear();
    this.onGeometryRemovedObservable.clear();
    this.onNewTransformNodeAddedObservable.clear();
    this.onTransformNodeRemovedObservable.clear();
    this.onNewMeshAddedObservable.clear();
    this.onMeshRemovedObservable.clear();
    this.onNewSkeletonAddedObservable.clear();
    this.onSkeletonRemovedObservable.clear();
    this.onNewMaterialAddedObservable.clear();
    this.onNewMultiMaterialAddedObservable.clear();
    this.onMaterialRemovedObservable.clear();
    this.onMultiMaterialRemovedObservable.clear();
    this.onNewTextureAddedObservable.clear();
    this.onTextureRemovedObservable.clear();
    this.onNewFrameGraphAddedObservable.clear();
    this.onFrameGraphRemovedObservable.clear();
    this.onNewObjectRendererAddedObservable.clear();
    this.onObjectRendererRemovedObservable.clear();
    this.onPrePointerObservable.clear();
    this.onPointerObservable.clear();
    this.onPreKeyboardObservable.clear();
    this.onKeyboardObservable.clear();
    this.onActiveCameraChanged.clear();
    this.onScenePerformancePriorityChangedObservable.clear();
    this.onClearColorChangedObservable.clear();
    this.onEnvironmentTextureChangedObservable.clear();
    this.onMeshUnderPointerUpdatedObservable.clear();
    this._isDisposed = true;
  }
  _disposeList(items, callback) {
    const itemsCopy = items.slice(0);
    callback = callback ?? ((item) => item.dispose());
    for (const item of itemsCopy) {
      callback(item);
    }
    items.length = 0;
  }
  /**
   * Gets if the scene is already disposed
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Call this function to reduce memory footprint of the scene.
   * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)
   */
  clearCachedVertexData() {
    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
      const mesh = this.meshes[meshIndex];
      const geometry = mesh.geometry;
      if (geometry) {
        geometry.clearCachedData();
      }
    }
  }
  /**
   * This function will remove the local cached buffer data from texture.
   * It will save memory but will prevent the texture from being rebuilt
   */
  cleanCachedTextureBuffer() {
    for (const baseTexture of this.textures) {
      const buffer = baseTexture._buffer;
      if (buffer) {
        baseTexture._buffer = null;
      }
    }
  }
  /**
   * Get the world extend vectors with an optional filter
   *
   * @param filterPredicate the predicate - which meshes should be included when calculating the world size
   * @returns {{ min: Vector3; max: Vector3 }} min and max vectors
   */
  getWorldExtends(filterPredicate) {
    const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    filterPredicate = filterPredicate || (() => true);
    const meshes = this.meshes.filter(filterPredicate);
    for (const mesh of meshes) {
      mesh.computeWorldMatrix(true);
      if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {
        continue;
      }
      const boundingInfo = mesh.getBoundingInfo();
      const minBox = boundingInfo.boundingBox.minimumWorld;
      const maxBox = boundingInfo.boundingBox.maximumWorld;
      Vector3.CheckExtends(minBox, min, max);
      Vector3.CheckExtends(maxBox, min, max);
    }
    return min.x === Number.MAX_VALUE ? { min: Vector3.Zero(), max: Vector3.Zero() } : {
      min,
      max
    };
  }
  // Picking
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Creates a ray that can be used to pick in the scene
   * @param x defines the x coordinate of the origin (on-screen)
   * @param y defines the y coordinate of the origin (on-screen)
   * @param world defines the world matrix to use if you want to pick in object space (instead of world space)
   * @param camera defines the camera to use for the picking
   * @param cameraViewSpace defines if picking will be done in view space (false by default)
   * @returns a Ray
   */
  createPickingRay(x, y, world, camera, cameraViewSpace = false) {
    throw _WarnImport("Ray");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Creates a ray that can be used to pick in the scene
   * @param x defines the x coordinate of the origin (on-screen)
   * @param y defines the y coordinate of the origin (on-screen)
   * @param world defines the world matrix to use if you want to pick in object space (instead of world space)
   * @param result defines the ray where to store the picking ray
   * @param camera defines the camera to use for the picking
   * @param cameraViewSpace defines if picking will be done in view space (false by default)
   * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)
   * @returns the current scene
   */
  createPickingRayToRef(x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
    throw _WarnImport("Ray");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Creates a ray that can be used to pick in the scene
   * @param x defines the x coordinate of the origin (on-screen)
   * @param y defines the y coordinate of the origin (on-screen)
   * @param camera defines the camera to use for the picking
   * @returns a Ray
   */
  createPickingRayInCameraSpace(x, y, camera) {
    throw _WarnImport("Ray");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Creates a ray that can be used to pick in the scene
   * @param x defines the x coordinate of the origin (on-screen)
   * @param y defines the y coordinate of the origin (on-screen)
   * @param result defines the ray where to store the picking ray
   * @param camera defines the camera to use for the picking
   * @returns the current scene
   */
  createPickingRayInCameraSpaceToRef(x, y, result, camera) {
    throw _WarnImport("Ray");
  }
  /** Launch a ray to try to pick a mesh in the scene
   * @param x position on screen
   * @param y position on screen
   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @returns a PickingInfo
   */
  pick(x, y, predicate, fastCheck, camera, trianglePredicate) {
    const warn = _WarnImport("Ray", true);
    if (warn) {
      Logger.Warn(warn);
    }
    return new PickingInfo();
  }
  /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)
   * @param x position on screen
   * @param y position on screen
   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
   * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)
   */
  pickWithBoundingInfo(x, y, predicate, fastCheck, camera) {
    const warn = _WarnImport("Ray", true);
    if (warn) {
      Logger.Warn(warn);
    }
    return new PickingInfo();
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Use the given ray to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,
   * irrespective of orientation.
   * @param ray The ray to use to pick meshes
   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @returns a PickingInfo
   */
  pickWithRay(ray, predicate, fastCheck, trianglePredicate) {
    throw _WarnImport("Ray");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Launch a ray to try to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,
   * irrespective of orientation.
   * @param x X position on screen
   * @param y Y position on screen
   * @param predicate Predicate function used to determine eligible meshes and instances. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced
   * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @returns an array of PickingInfo
   */
  multiPick(x, y, predicate, camera, trianglePredicate) {
    throw _WarnImport("Ray");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Launch a ray to try to pick a mesh in the scene
   * @param ray Ray to use
   * @param predicate Predicate function used to determine eligible meshes and instances. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @returns an array of PickingInfo
   */
  multiPickWithRay(ray, predicate, trianglePredicate) {
    throw _WarnImport("Ray");
  }
  /**
   * Force the value of meshUnderPointer
   * @param mesh defines the mesh to use
   * @param pointerId optional pointer id when using more than one pointer
   * @param pickResult optional pickingInfo data used to find mesh
   */
  setPointerOverMesh(mesh, pointerId, pickResult) {
    this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);
  }
  /**
   * Gets the mesh under the pointer
   * @returns a Mesh or null if no mesh is under the pointer
   */
  getPointerOverMesh() {
    return this._inputManager.getPointerOverMesh();
  }
  // Misc.
  /** @internal */
  _rebuildGeometries() {
    for (const geometry of this.geometries) {
      geometry._rebuild();
    }
    for (const mesh of this.meshes) {
      mesh._rebuild();
    }
    if (this.postProcessManager) {
      this.postProcessManager._rebuild();
    }
    for (const component of this._components) {
      component.rebuild();
    }
    for (const system of this.particleSystems) {
      system.rebuild();
    }
    if (this.spriteManagers) {
      for (const spriteMgr of this.spriteManagers) {
        spriteMgr.rebuild();
      }
    }
  }
  /** @internal */
  _rebuildTextures() {
    for (const texture of this.textures) {
      texture._rebuild(true);
    }
    this.markAllMaterialsAsDirty(1);
  }
  /**
   * Get from a list of objects by tags
   * @param list the list of objects to use
   * @param tagsQuery the query to use
   * @param filter a predicate to filter for tags
   * @returns
   */
  _getByTags(list, tagsQuery, filter) {
    if (tagsQuery === void 0) {
      return list;
    }
    const listByTags = [];
    for (const i in list) {
      const item = list[i];
      if (Tags && Tags.MatchesQuery(item, tagsQuery) && (!filter || filter(item))) {
        listByTags.push(item);
      }
    }
    return listByTags;
  }
  /**
   * Get a list of meshes by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of Mesh
   */
  getMeshesByTags(tagsQuery, filter) {
    return this._getByTags(this.meshes, tagsQuery, filter);
  }
  /**
   * Get a list of cameras by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of Camera
   */
  getCamerasByTags(tagsQuery, filter) {
    return this._getByTags(this.cameras, tagsQuery, filter);
  }
  /**
   * Get a list of lights by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of Light
   */
  getLightsByTags(tagsQuery, filter) {
    return this._getByTags(this.lights, tagsQuery, filter);
  }
  /**
   * Get a list of materials by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of Material
   */
  getMaterialByTags(tagsQuery, filter) {
    return this._getByTags(this.materials, tagsQuery, filter).concat(this._getByTags(this.multiMaterials, tagsQuery, filter));
  }
  /**
   * Get a list of transform nodes by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of TransformNode
   */
  getTransformNodesByTags(tagsQuery, filter) {
    return this._getByTags(this.transformNodes, tagsQuery, filter);
  }
  /**
   * Overrides the default sort function applied in the rendering group to prepare the meshes.
   * This allowed control for front to back rendering or reversly depending of the special needs.
   *
   * @param renderingGroupId The rendering group id corresponding to its index
   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.
   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
   * @param transparentSortCompareFn The transparent queue comparison function use to sort.
   */
  setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
  }
  /**
   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
   *
   * @param renderingGroupId The rendering group id corresponding to its index
   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
   * @param depth Automatically clears depth between groups if true and autoClear is true.
   * @param stencil Automatically clears stencil between groups if true and autoClear is true.
   */
  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {
    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);
  }
  /**
   * Gets the current auto clear configuration for one rendering group of the rendering
   * manager.
   * @param index the rendering group index to get the information for
   * @returns The auto clear setup for the requested rendering group
   */
  getAutoClearDepthStencilSetup(index) {
    return this._renderingManager.getAutoClearDepthStencilSetup(index);
  }
  /** @internal */
  _forceBlockMaterialDirtyMechanism(value) {
    this._blockMaterialDirtyMechanism = value;
  }
  /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */
  get blockMaterialDirtyMechanism() {
    return this._blockMaterialDirtyMechanism;
  }
  set blockMaterialDirtyMechanism(value) {
    if (this._blockMaterialDirtyMechanism === value) {
      return;
    }
    this._blockMaterialDirtyMechanism = value;
    if (!value) {
      this.markAllMaterialsAsDirty(127);
    }
  }
  /**
   * Will flag all materials as dirty to trigger new shader compilation
   * @param flag defines the flag used to specify which material part must be marked as dirty
   * @param predicate If not null, it will be used to specify if a material has to be marked as dirty
   */
  markAllMaterialsAsDirty(flag, predicate) {
    if (this._blockMaterialDirtyMechanism) {
      return;
    }
    for (const material of this.materials) {
      if (predicate && !predicate(material)) {
        continue;
      }
      material.markAsDirty(flag);
    }
  }
  /**
   * @internal
   */
  _loadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
    const request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
    this._activeRequests.push(request);
    request.onCompleteObservable.add((request2) => {
      this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
    });
    return request;
  }
  /**
   * @internal
   */
  async _loadFileAsync(fileOrUrl, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
    return await new Promise((resolve, reject) => {
      this._loadFile(fileOrUrl, (data) => {
        resolve(data);
      }, onProgress, useOfflineSupport, useArrayBuffer, (request, exception) => {
        reject(exception);
      }, onOpened);
    });
  }
  /**
   * @internal
   */
  _requestFile(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
    const request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
    this._activeRequests.push(request);
    request.onCompleteObservable.add((request2) => {
      this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
    });
    return request;
  }
  /**
   * @internal
   */
  async _requestFileAsync(url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
    return await new Promise((resolve, reject) => {
      this._requestFile(url, (data) => {
        resolve(data);
      }, onProgress, useOfflineSupport, useArrayBuffer, (error) => {
        reject(error);
      }, onOpened);
    });
  }
  /**
   * @internal
   */
  _readFile(file, onSuccess, onProgress, useArrayBuffer, onError) {
    const request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
    this._activeRequests.push(request);
    request.onCompleteObservable.add((request2) => {
      this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
    });
    return request;
  }
  /**
   * @internal
   */
  async _readFileAsync(file, onProgress, useArrayBuffer) {
    return await new Promise((resolve, reject) => {
      this._readFile(file, (data) => {
        resolve(data);
      }, onProgress, useArrayBuffer, (error) => {
        reject(error);
      });
    });
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * This method gets the performance collector belonging to the scene, which is generally shared with the inspector.
   * @returns the perf collector belonging to the scene.
   */
  getPerfCollector() {
    throw _WarnImport("performanceViewerSceneExtension");
  }
  // deprecated
  /**
   * Sets the active camera of the scene using its Id
   * @param id defines the camera's Id
   * @returns the new active camera or null if none found.
   * @deprecated Please use setActiveCameraById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  setActiveCameraByID(id) {
    return this.setActiveCameraById(id);
  }
  /**
   * Get a material using its id
   * @param id defines the material's Id
   * @returns the material or null if none found.
   * @deprecated Please use getMaterialById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getMaterialByID(id) {
    return this.getMaterialById(id);
  }
  /**
   * Gets a the last added material using a given id
   * @param id defines the material's Id
   * @returns the last material with the given id or null if none found.
   * @deprecated Please use getLastMaterialById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getLastMaterialByID(id) {
    return this.getLastMaterialById(id);
  }
  /**
   * Get a texture using its unique id
   * @param uniqueId defines the texture's unique id
   * @returns the texture or null if none found.
   * @deprecated Please use getTextureByUniqueId instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getTextureByUniqueID(uniqueId) {
    return this.getTextureByUniqueId(uniqueId);
  }
  /**
   * Gets a camera using its Id
   * @param id defines the Id to look for
   * @returns the camera or null if not found
   * @deprecated Please use getCameraById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getCameraByID(id) {
    return this.getCameraById(id);
  }
  /**
   * Gets a camera using its unique Id
   * @param uniqueId defines the unique Id to look for
   * @returns the camera or null if not found
   * @deprecated Please use getCameraByUniqueId instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getCameraByUniqueID(uniqueId) {
    return this.getCameraByUniqueId(uniqueId);
  }
  /**
   * Gets a bone using its Id
   * @param id defines the bone's Id
   * @returns the bone or null if not found
   * @deprecated Please use getBoneById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getBoneByID(id) {
    return this.getBoneById(id);
  }
  /**
   * Gets a light node using its Id
   * @param id defines the light's Id
   * @returns the light or null if none found.
   * @deprecated Please use getLightById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getLightByID(id) {
    return this.getLightById(id);
  }
  /**
   * Gets a light node using its scene-generated unique Id
   * @param uniqueId defines the light's unique Id
   * @returns the light or null if none found.
   * @deprecated Please use getLightByUniqueId instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getLightByUniqueID(uniqueId) {
    return this.getLightByUniqueId(uniqueId);
  }
  /**
   * Gets a particle system by Id
   * @param id defines the particle system Id
   * @returns the corresponding system or null if none found
   * @deprecated Please use getParticleSystemById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getParticleSystemByID(id) {
    return this.getParticleSystemById(id);
  }
  /**
   * Gets a geometry using its Id
   * @param id defines the geometry's Id
   * @returns the geometry or null if none found.
   * @deprecated Please use getGeometryById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getGeometryByID(id) {
    return this.getGeometryById(id);
  }
  /**
   * Gets the first added mesh found of a given Id
   * @param id defines the Id to search for
   * @returns the mesh found or null if not found at all
   * @deprecated Please use getMeshById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getMeshByID(id) {
    return this.getMeshById(id);
  }
  /**
   * Gets a mesh with its auto-generated unique Id
   * @param uniqueId defines the unique Id to search for
   * @returns the found mesh or null if not found at all.
   * @deprecated Please use getMeshByUniqueId instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getMeshByUniqueID(uniqueId) {
    return this.getMeshByUniqueId(uniqueId);
  }
  /**
   * Gets a the last added mesh using a given Id
   * @param id defines the Id to search for
   * @returns the found mesh or null if not found at all.
   * @deprecated Please use getLastMeshById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getLastMeshByID(id) {
    return this.getLastMeshById(id);
  }
  /**
   * Gets a list of meshes using their Id
   * @param id defines the Id to search for
   * @returns a list of meshes
   * @deprecated Please use getMeshesById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getMeshesByID(id) {
    return this.getMeshesById(id);
  }
  /**
   * Gets the first added transform node found of a given Id
   * @param id defines the Id to search for
   * @returns the found transform node or null if not found at all.
   * @deprecated Please use getTransformNodeById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getTransformNodeByID(id) {
    return this.getTransformNodeById(id);
  }
  /**
   * Gets a transform node with its auto-generated unique Id
   * @param uniqueId defines the unique Id to search for
   * @returns the found transform node or null if not found at all.
   * @deprecated Please use getTransformNodeByUniqueId instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getTransformNodeByUniqueID(uniqueId) {
    return this.getTransformNodeByUniqueId(uniqueId);
  }
  /**
   * Gets a list of transform nodes using their Id
   * @param id defines the Id to search for
   * @returns a list of transform nodes
   * @deprecated Please use getTransformNodesById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getTransformNodesByID(id) {
    return this.getTransformNodesById(id);
  }
  /**
   * Gets a node (Mesh, Camera, Light) using a given Id
   * @param id defines the Id to search for
   * @returns the found node or null if not found at all
   * @deprecated Please use getNodeById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getNodeByID(id) {
    return this.getNodeById(id);
  }
  /**
   * Gets a the last added node (Mesh, Camera, Light) using a given Id
   * @param id defines the Id to search for
   * @returns the found node or null if not found at all
   * @deprecated Please use getLastEntryById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getLastEntryByID(id) {
    return this.getLastEntryById(id);
  }
  /**
   * Gets a skeleton using a given Id (if many are found, this function will pick the last one)
   * @param id defines the Id to search for
   * @returns the found skeleton or null if not found at all.
   * @deprecated Please use getLastSkeletonById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getLastSkeletonByID(id) {
    return this.getLastSkeletonById(id);
  }
};
Scene.FOGMODE_NONE = 0;
Scene.FOGMODE_EXP = 1;
Scene.FOGMODE_EXP2 = 2;
Scene.FOGMODE_LINEAR = 3;
Scene.MinDeltaTime = 1;
Scene.MaxDeltaTime = 1e3;
Scene._OriginalDefaultMaterialFactory = Scene.DefaultMaterialFactory;
RegisterClass("BABYLON.Scene", Scene);

export {
  AbstractActionManager,
  ActionEvent,
  StringDictionary,
  ColorCurves,
  PrepareUniformsForImageProcessing,
  PrepareSamplersForImageProcessing,
  ImageProcessingConfiguration,
  SceneComponentConstants,
  Stage,
  KeyboardEventTypes,
  KeyboardInfo,
  KeyboardInfoPre,
  DeviceType,
  PointerInput,
  NativePointerInput,
  DualShockInput,
  DualSenseInput,
  XboxInput,
  SwitchInput,
  DeviceInputEventType,
  EventConstants,
  DeviceSource,
  DeviceSourceManager,
  _ImportHelper,
  backbufferColorTextureHandle,
  backbufferDepthStencilTextureHandle,
  FrameGraphPass,
  FrameGraphObjectListPass,
  FrameGraphRenderPass,
  FrameGraphTask,
  Light,
  ThinBlurPostProcess,
  BlurPostProcess,
  EffectFallbacks,
  ShadowGenerator,
  Camera,
  DepthRenderer,
  MinMaxReducer,
  DepthReducer,
  CascadedShadowGenerator,
  FrameGraphShadowGeneratorTask,
  ShadowLight,
  DirectionalLight,
  FrameGraphPostProcessTask,
  textureSizeIsObject,
  getDimensionsFromTextureSize,
  FrameGraphCascadedShadowGeneratorTask,
  MultiRenderTarget,
  MaterialStencilState,
  Material,
  ThinDepthPeelingRenderer,
  FrameGraphRenderTarget,
  FrameGraphObjectRendererTask,
  ScenePerformancePriority,
  Scene
};
//# sourceMappingURL=chunk-MKXGUAMA.js.map
