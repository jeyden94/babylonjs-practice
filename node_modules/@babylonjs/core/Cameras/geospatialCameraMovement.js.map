{"version":3,"file":"geospatialCameraMovement.js","sourceRoot":"","sources":["../../../../dev/core/src/Cameras/geospatialCameraMovement.ts"],"names":[],"mappings":"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","sourcesContent":["import { CameraMovement } from \"./cameraMovement\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { GeospatialLimits } from \"./Limits/geospatialLimits\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { MeshPredicate } from \"../Culling/ray.core\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3Distance } from \"../Maths/math.vector.functions\";\r\nimport { Clamp } from \"../Maths/math.scalar.functions\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { InterpolatingBehavior } from \"../Behaviors/Cameras/interpolatingBehavior\";\r\nimport type { GeospatialCamera } from \"./geospatialCamera\";\r\n\r\n/**\r\n * @experimental\r\n * This class is subject to change as the geospatial camera evolves.\r\n *\r\n * Geospatial-specific camera movement system that extends the base movement with\r\n * raycasting and altitude-aware zoom constraints.\r\n *\r\n * This class encapsulates geospatial camera movement logic:\r\n * - Dragging in a way which keeps cursor anchored to globe\r\n * - Latitude-based pan speed dampening\r\n * - Zoom speed scaling based on distance to center\r\n * - Raycasting to determine zoom constraints based on terrain/globe\r\n * - Altitude-based zoom clamping\r\n * - Zoom direction calculation (towards cursor vs along look vector)\r\n */\r\nexport class GeospatialCameraMovement extends CameraMovement {\r\n    /** Predicate function to determine which meshes to pick against (e.g., globe mesh) */\r\n    public pickPredicate?: MeshPredicate;\r\n\r\n    /** World-space picked point under cursor for zoom-to-cursor behavior (may be undefined) */\r\n    public computedPerFrameZoomPickPoint?: Vector3;\r\n\r\n    public zoomToCursor: boolean = true;\r\n\r\n    /**\r\n     * Enables rotation around a specific point, instead of default rotation around center\r\n     * @internal\r\n     */\r\n    public alternateRotationPt?: Vector3;\r\n\r\n    private _tempPickingRay: Ray;\r\n    private _storedZoomPickDistance: number | undefined;\r\n\r\n    private _hitPointRadius?: number = undefined;\r\n    private _dragPlane: Plane = new Plane(0, 0, 0, 0);\r\n    private _dragPlaneNormal: Vector3 = Vector3.Zero();\r\n    private _dragPlaneOriginPointEcef: Vector3 = Vector3.Zero();\r\n    private _dragPlaneHitPointLocal: Vector3 = Vector3.Zero();\r\n    private _previousDragPlaneHitPointLocal: Vector3 = Vector3.Zero();\r\n\r\n    constructor(\r\n        scene: Scene,\r\n        public limits: GeospatialLimits,\r\n        cameraPosition: Vector3,\r\n        private _cameraCenter: Vector3,\r\n        private _cameraLookAt: Vector3,\r\n        pickPredicate?: MeshPredicate,\r\n        behavior?: InterpolatingBehavior<GeospatialCamera>\r\n    ) {\r\n        super(scene, cameraPosition, behavior);\r\n        this.pickPredicate = pickPredicate;\r\n        this._tempPickingRay = new Ray(this._cameraPosition, this._cameraLookAt);\r\n        this.panInertia = 0;\r\n        this.rotationInertia = 0;\r\n        this.rotationXSpeed = Math.PI / 500; // Move 1/500th of a half circle per pixel\r\n        this.rotationYSpeed = Math.PI / 500; // Move 1/500th of a half circle per pixel\r\n    }\r\n\r\n    public startDrag(pointerX: number, pointerY: number) {\r\n        const pickResult = this._scene.pick(pointerX, pointerY, this.pickPredicate);\r\n        if (pickResult.pickedPoint && pickResult.ray) {\r\n            // Store radius from earth center to pickedPoint, used when calculating drag plane\r\n            this._hitPointRadius = pickResult.pickedPoint.length();\r\n\r\n            this._recalculateDragPlaneHitPoint(this._hitPointRadius, pickResult.ray, TmpVectors.Matrix[0]);\r\n            this._previousDragPlaneHitPointLocal.copyFrom(this._dragPlaneHitPointLocal);\r\n        } else {\r\n            this._hitPointRadius = undefined; // can't drag without a hit on the globe\r\n        }\r\n    }\r\n\r\n    public stopDrag() {\r\n        this._hitPointRadius = undefined;\r\n    }\r\n\r\n    /**\r\n     * The previous drag plane hit point in local space is stored to compute the movement delta.\r\n     * As the drag movement occurs, we will continuously recalculate this point. The delta between the previous and current hit points is the delta we will apply to the camera's localtranslation\r\n     * @param hitPointRadius The distance between the world origin (center of globe) and the initial drag hit point\r\n     * @param ray The ray from the camera to the new cursor location\r\n     * @param localToEcefResult The matrix to convert from local to ECEF space\r\n     */\r\n    private _recalculateDragPlaneHitPoint(hitPointRadius: number, ray: Ray, localToEcefResult: Matrix): void {\r\n        // Use the camera's geocentric normal to find the dragPlaneOriginPoint which lives at hitPointRadius along the camera's geocentric normal\r\n        this._cameraPosition.normalizeToRef(this._dragPlaneNormal);\r\n        this._dragPlaneNormal.scaleToRef(hitPointRadius, this._dragPlaneOriginPointEcef);\r\n\r\n        // The dragPlaneOffsetVector will later be recalculated when drag occurs, and the delta between the offset vectors will be applied to localTranslation\r\n        ComputeLocalBasisToRefs(this._dragPlaneOriginPointEcef, TmpVectors.Vector3[0], TmpVectors.Vector3[1], TmpVectors.Vector3[2]);\r\n        const localToEcef = Matrix.FromXYZAxesToRef(TmpVectors.Vector3[0], TmpVectors.Vector3[1], TmpVectors.Vector3[2], localToEcefResult);\r\n        localToEcef.setTranslationFromFloats(this._dragPlaneOriginPointEcef.x, this._dragPlaneOriginPointEcef.y, this._dragPlaneOriginPointEcef.z);\r\n        const ecefToLocal = localToEcef.invertToRef(TmpVectors.Matrix[1]);\r\n\r\n        // Now create a plane at that point, perpendicular to the camera's geocentric normal\r\n        Plane.FromPositionAndNormalToRef(this._dragPlaneOriginPointEcef, this._dragPlaneNormal, this._dragPlane);\r\n\r\n        // Lastly, find the _dragPlaneHitPoint where the ray intersects the _dragPlane.\r\n        if (IntersectRayWithPlaneToRef(ray, this._dragPlane, this._dragPlaneHitPointLocal)) {\r\n            // If hit, convert the drag plane hit point into the local space.\r\n            Vector3.TransformCoordinatesToRef(this._dragPlaneHitPointLocal, ecefToLocal, this._dragPlaneHitPointLocal);\r\n        }\r\n    }\r\n\r\n    public handleDrag(pointerX: number, pointerY: number) {\r\n        if (this._hitPointRadius) {\r\n            const pickResult = this._scene.pick(pointerX, pointerY);\r\n            if (pickResult.ray) {\r\n                const localToEcef = TmpVectors.Matrix[0];\r\n                this._recalculateDragPlaneHitPoint(this._hitPointRadius, pickResult.ray, localToEcef);\r\n\r\n                const delta = this._dragPlaneHitPointLocal.subtractToRef(this._previousDragPlaneHitPointLocal, TmpVectors.Vector3[6]);\r\n                this._previousDragPlaneHitPointLocal.copyFrom(this._dragPlaneHitPointLocal);\r\n\r\n                Vector3.TransformNormalToRef(delta, localToEcef, delta);\r\n                this._dragPlaneOriginPointEcef.addInPlace(delta);\r\n\r\n                this.panAccumulatedPixels.subtractInPlace(delta);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @override */\r\n    public override computeCurrentFrameDeltas(): void {\r\n        const cameraCenter = this._cameraCenter;\r\n\r\n        // Slows down panning near the poles\r\n        if (this.panAccumulatedPixels.lengthSquared() > Epsilon) {\r\n            const centerRadius = cameraCenter.length(); // distance from planet origin to camera center\r\n            const currentRadius = this._cameraPosition.length();\r\n            // Dampen the pan speed based on latitude (slower near poles)\r\n            const sineOfSphericalLat = centerRadius === 0 ? 0 : cameraCenter.z / centerRadius;\r\n            const cosOfSphericalLat = Math.sqrt(1 - Math.min(1, sineOfSphericalLat * sineOfSphericalLat));\r\n            const latitudeDampening = Math.sqrt(Math.abs(cosOfSphericalLat)); // sqrt here reduces effect near equator\r\n\r\n            // Reduce the dampening effect near surface (so that at ground level, pan speed is not affected by latitude)\r\n            const height = Math.max(currentRadius - centerRadius, Epsilon);\r\n            const latitudeDampeningScale = Math.max(1, centerRadius / height);\r\n\r\n            this._panSpeedMultiplier = Clamp(latitudeDampeningScale * latitudeDampening, 0, 1);\r\n        } else {\r\n            this._panSpeedMultiplier = 1;\r\n        }\r\n\r\n        // If a pan drag is occurring, stop zooming.\r\n        if (this.isDragging) {\r\n            this._zoomSpeedMultiplier = 0;\r\n            this._zoomVelocity = 0;\r\n        } else {\r\n            // Scales zoom movement speed based on camera distance to origin (so long as no active pan is occurring)\r\n            this._zoomSpeedMultiplier = Vector3Distance(this._cameraPosition, cameraCenter) * 0.01;\r\n        }\r\n\r\n        // Before zero-ing out pixel deltas, capture if we have any active zoom in this frame (compared to zoom from inertia)\r\n        const activeZoom = Math.abs(this.zoomAccumulatedPixels) > 0;\r\n        super.computeCurrentFrameDeltas();\r\n\r\n        this._handleZoom(activeZoom);\r\n    }\r\n\r\n    public get isDragging() {\r\n        return this._hitPointRadius !== undefined;\r\n    }\r\n\r\n    private _handleZoom(activeZoom: boolean) {\r\n        if (Math.abs(this.zoomDeltaCurrentFrame) > Epsilon) {\r\n            let pickDistance: number | undefined;\r\n\r\n            if (!activeZoom) {\r\n                // During inertia, use the previously stored pick distance\r\n                // TODO fix this to work with raycasting\r\n                pickDistance = this._storedZoomPickDistance;\r\n            } else {\r\n                // Active zoom - pick and store the distance\r\n                const pickResult = this._scene.pick(this._scene.pointerX, this._scene.pointerY, this.pickPredicate);\r\n\r\n                if (pickResult.hit && pickResult.pickedPoint && pickResult.ray && this.zoomToCursor) {\r\n                    // Store both the zoom picked point and the pick distance for use during inertia\r\n                    pickDistance = pickResult.distance;\r\n                    this._storedZoomPickDistance = pickDistance;\r\n                    this.computedPerFrameZoomPickPoint = pickResult.pickedPoint;\r\n                } else {\r\n                    // If no hit under cursor, zoom along lookVector instead\r\n                    const lookPickResult = this.pickAlongVector(this._cameraLookAt);\r\n                    pickDistance = lookPickResult?.distance;\r\n                    this._storedZoomPickDistance = pickDistance;\r\n                    this.computedPerFrameZoomPickPoint = undefined;\r\n                }\r\n            }\r\n\r\n            // Clamp distance based on limits and update center\r\n            this._clampZoomDistance(this.zoomDeltaCurrentFrame, pickDistance);\r\n        }\r\n    }\r\n\r\n    private _clampZoomDistance(requestedDistance: number, pickResultDistance: number | undefined): number {\r\n        // If pickResult is defined\r\n        if (requestedDistance > 0) {\r\n            if (pickResultDistance !== undefined) {\r\n                // If there is a pick, allow movement up to pick - minAltitude\r\n                if (pickResultDistance - this.limits.altitudeMin < 0) {\r\n                    this.zoomDeltaCurrentFrame = 0;\r\n                }\r\n                this.zoomDeltaCurrentFrame = Math.min(requestedDistance, pickResultDistance - this.limits.altitudeMin);\r\n            } else {\r\n                this.zoomDeltaCurrentFrame = requestedDistance;\r\n            }\r\n        }\r\n\r\n        if (requestedDistance < 0) {\r\n            const maxZoomOut = this.limits.radiusMax ? this.limits.radiusMax - this._cameraPosition.length() : Number.POSITIVE_INFINITY;\r\n            this.zoomDeltaCurrentFrame = Math.max(requestedDistance, -maxZoomOut);\r\n        }\r\n\r\n        return this.zoomDeltaCurrentFrame;\r\n    }\r\n\r\n    public pickAlongVector(vector: Vector3): Nullable<PickingInfo> {\r\n        this._tempPickingRay.origin.copyFrom(this._cameraPosition);\r\n        this._tempPickingRay.direction.copyFrom(vector);\r\n        return this._scene.pickWithRay(this._tempPickingRay, this.pickPredicate);\r\n    }\r\n}\r\n\r\nexport function ClampCenterFromPolesInPlace(center: Vector3) {\r\n    const sineOfSphericalLatitudeLimit = 0.998749218; // ~90 degrees\r\n    const centerMagnitude = center.length(); // distance from planet origin\r\n    if (centerMagnitude > Epsilon) {\r\n        const sineSphericalLat = centerMagnitude === 0 ? 0 : center.z / centerMagnitude;\r\n        if (Math.abs(sineSphericalLat) > sineOfSphericalLatitudeLimit) {\r\n            // Clamp the spherical latitude (and derive longitude)\r\n            const sineOfClampedSphericalLat = Clamp(sineSphericalLat, -sineOfSphericalLatitudeLimit, sineOfSphericalLatitudeLimit);\r\n            const cosineOfClampedSphericalLat = Math.sqrt(1 - sineOfClampedSphericalLat * sineOfClampedSphericalLat);\r\n            const longitude = Math.atan2(center.y, center.x);\r\n\r\n            // Spherical to Cartesian\r\n            const newX = centerMagnitude * Math.cos(longitude) * cosineOfClampedSphericalLat;\r\n            const newY = centerMagnitude * Math.sin(longitude) * cosineOfClampedSphericalLat;\r\n            const newZ = centerMagnitude * sineOfClampedSphericalLat;\r\n\r\n            center.set(newX, newY, newZ);\r\n        }\r\n    }\r\n    return center;\r\n}\r\n\r\nfunction IntersectRayWithPlaneToRef(ray: Ray, plane: Plane, ref: Vector3): boolean {\r\n    // Distance along the ray to the plane; null if no hit\r\n    const dist = ray.intersectsPlane(plane);\r\n\r\n    if (dist !== null && dist >= 0) {\r\n        ray.origin.addToRef(ray.direction.scaleToRef(dist, TmpVectors.Vector3[0]), ref);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Helper to build east/north/up basis vectors at a world position.\r\n * @internal\r\n */\r\nexport function ComputeLocalBasisToRefs(worldPos: Vector3, refEast: Vector3, refNorth: Vector3, refUp: Vector3) {\r\n    // up = normalized position (geocentric normal)\r\n    refUp.copyFrom(worldPos).normalize();\r\n\r\n    // east = normalize(worldNorth × up)\r\n    // (cross product of Earth rotation axis with up gives east except near poles)\r\n    const worldNorth = Vector3.LeftHandedForwardReadOnly; // (0,0,1)\r\n    Vector3.CrossToRef(worldNorth, refUp, refEast);\r\n\r\n    // at poles, cross with worldRight instead\r\n    if (refEast.lengthSquared() < Epsilon) {\r\n        Vector3.CrossToRef(Vector3.Right(), refUp, refEast);\r\n    }\r\n    refEast.normalize();\r\n\r\n    // north = up × east (completes right-handed basis)\r\n    Vector3.CrossToRef(refUp, refEast, refNorth);\r\n    refNorth.normalize();\r\n}\r\n"]}