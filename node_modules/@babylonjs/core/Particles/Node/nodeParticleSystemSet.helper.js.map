{"version":3,"file":"nodeParticleSystemSet.helper.js","sourceRoot":"","sources":["../../../../../dev/core/src/Particles/Node/nodeParticleSystemSet.helper.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport type { Color4 } from \"core/Maths/math.color\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { ColorGradient, FactorGradient } from \"core/Misc\";\r\nimport type { ParticleSystem } from \"core/Particles/particleSystem\";\r\nimport type { IParticleSystem } from \"core/Particles/IParticleSystem\";\r\nimport type { BoxParticleEmitter } from \"core/Particles/EmitterTypes/boxParticleEmitter\";\r\nimport type { ConeDirectedParticleEmitter, ConeParticleEmitter } from \"core/Particles/EmitterTypes/coneParticleEmitter\";\r\nimport type { CustomParticleEmitter } from \"core/Particles/EmitterTypes/customParticleEmitter\";\r\nimport type { CylinderDirectedParticleEmitter, CylinderParticleEmitter } from \"core/Particles/EmitterTypes/cylinderParticleEmitter\";\r\nimport type { HemisphericParticleEmitter } from \"core/Particles/EmitterTypes/hemisphericParticleEmitter\";\r\nimport type { MeshParticleEmitter } from \"core/Particles/EmitterTypes/meshParticleEmitter\";\r\nimport type { PointParticleEmitter } from \"core/Particles/EmitterTypes/pointParticleEmitter\";\r\nimport type { SphereDirectedParticleEmitter, SphereParticleEmitter } from \"core/Particles/EmitterTypes/sphereParticleEmitter\";\r\nimport type { NodeParticleConnectionPoint } from \"core/Particles/Node/nodeParticleBlockConnectionPoint\";\r\nimport type { IShapeBlock } from \"core/Particles/Node/Blocks/Emitters/IShapeBlock\";\r\nimport type { NodeParticleBlockConnectionPointTypes } from \"core/Particles/Node/Enums/nodeParticleBlockConnectionPointTypes\";\r\n\r\nimport { Vector2, Vector3 } from \"core/Maths/math.vector\";\r\nimport { NodeParticleSystemSet } from \"./nodeParticleSystemSet\";\r\nimport { NodeParticleContextualSources } from \"./Enums/nodeParticleContextualSources\";\r\nimport { NodeParticleSystemSources } from \"./Enums/nodeParticleSystemSources\";\r\nimport { ParticleConverterBlock } from \"./Blocks/particleConverterBlock\";\r\nimport { ParticleFloatToIntBlock, ParticleFloatToIntBlockOperations } from \"./Blocks/particleFloatToIntBlock\";\r\nimport { ParticleGradientBlock } from \"./Blocks/particleGradientBlock\";\r\nimport { ParticleGradientValueBlock } from \"./Blocks/particleGradientValueBlock\";\r\nimport { ParticleInputBlock } from \"./Blocks/particleInputBlock\";\r\nimport { ParticleMathBlock, ParticleMathBlockOperations } from \"./Blocks/particleMathBlock\";\r\nimport { ParticleRandomBlock, ParticleRandomBlockLocks } from \"./Blocks/particleRandomBlock\";\r\nimport { ParticleTextureSourceBlock } from \"./Blocks/particleSourceTextureBlock\";\r\nimport { ParticleVectorLengthBlock } from \"./Blocks/particleVectorLengthBlock\";\r\nimport { SystemBlock } from \"./Blocks/systemBlock\";\r\nimport { ParticleConditionBlock, ParticleConditionBlockTests } from \"./Blocks/Conditions/particleConditionBlock\";\r\nimport { CreateParticleBlock } from \"./Blocks/Emitters/createParticleBlock\";\r\nimport { BoxShapeBlock } from \"./Blocks/Emitters/boxShapeBlock\";\r\nimport { ConeShapeBlock } from \"./Blocks/Emitters/coneShapeBlock\";\r\nimport { CylinderShapeBlock } from \"./Blocks/Emitters/cylinderShapeBlock\";\r\nimport { CustomShapeBlock } from \"./Blocks/Emitters/customShapeBlock\";\r\nimport { MeshShapeBlock } from \"./Blocks/Emitters/meshShapeBlock\";\r\nimport { PointShapeBlock } from \"./Blocks/Emitters/pointShapeBlock\";\r\nimport { SphereShapeBlock } from \"./Blocks/Emitters/sphereShapeBlock\";\r\nimport { UpdateAngleBlock } from \"./Blocks/Update/updateAngleBlock\";\r\nimport { UpdateColorBlock } from \"./Blocks/Update/updateColorBlock\";\r\nimport { UpdateDirectionBlock } from \"./Blocks/Update/updateDirectionBlock\";\r\nimport { UpdateNoiseBlock } from \"./Blocks/Update/updateNoiseBlock\";\r\nimport { UpdatePositionBlock } from \"./Blocks/Update/updatePositionBlock\";\r\nimport { UpdateSizeBlock } from \"./Blocks/Update/updateSizeBlock\";\r\n\r\n/** Represents blocks or groups of blocks that can be used in multiple places in the graph, so they are stored in this context to be reused */\r\ntype ConversionContext = {\r\n    targetStopDurationBlockOutput: NodeParticleConnectionPoint;\r\n    // Connections that represent calculated ratios values\r\n    timeToStopTimeRatioBlockGroupOutput: NodeParticleConnectionPoint;\r\n    ageToLifeTimeRatioBlockGroupOutput: NodeParticleConnectionPoint;\r\n    // Connections for the start value of a gradient. These are stored so they can be reused for the Creation phase and the Update phase of the particle\r\n    sizeGradientValue0Output: NodeParticleConnectionPoint;\r\n    colorGradientValue0Output: NodeParticleConnectionPoint;\r\n    // Updated scaled direction direction based on velocity and drag\r\n    scaledDirection: NodeParticleConnectionPoint;\r\n};\r\n\r\ntype RuntimeConversionContext = Partial<ConversionContext>;\r\n\r\n/**\r\n * Converts a ParticleSystem to a NodeParticleSystemSet.\r\n * @param name The name of the node particle system set.\r\n * @param particleSystemsList The particle systems to convert.\r\n * @returns The converted node particle system set or null if conversion failed.\r\n */\r\nexport async function ConvertToNodeParticleSystemSetAsync(name: string, particleSystemsList: ParticleSystem[]): Promise<Nullable<NodeParticleSystemSet>> {\r\n    if (!particleSystemsList || !particleSystemsList.length) {\r\n        return null;\r\n    }\r\n\r\n    const nodeParticleSystemSet = new NodeParticleSystemSet(name);\r\n    const promises: Promise<void>[] = [];\r\n\r\n    for (const particleSystem of particleSystemsList) {\r\n        promises.push(_ExtractDatafromParticleSystemAsync(nodeParticleSystemSet, particleSystem, {}));\r\n    }\r\n\r\n    await Promise.all(promises);\r\n    return nodeParticleSystemSet;\r\n}\r\n\r\nasync function _ExtractDatafromParticleSystemAsync(newSet: NodeParticleSystemSet, oldSystem: ParticleSystem, context: RuntimeConversionContext): Promise<void> {\r\n    // CreateParticle block group\r\n    const createParticleOutput = _CreateParticleBlockGroup(oldSystem, context);\r\n\r\n    // Emitter Shape block\r\n    const shapeOutput = _EmitterShapeBlock(oldSystem);\r\n    createParticleOutput.particle.connectTo(shapeOutput.particle);\r\n\r\n    // UpdateParticle block group\r\n    const updateParticleOutput = _UpdateParticleBlockGroup(shapeOutput.output, oldSystem, context);\r\n\r\n    // System block\r\n    const newSystem = _SystemBlockGroup(oldSystem, context);\r\n    updateParticleOutput.connectTo(newSystem.particle);\r\n\r\n    // Register\r\n    newSet.systemBlocks.push(newSystem);\r\n}\r\n\r\n// ------------- CREATE PARTICLE FUNCTIONS -------------\r\n\r\n// The creation of the different properties follows the order they are added to the CreationQueue in ThinParticleSystem:\r\n// Lifetime, Emit Power, Size, Scale/StartSize, Angle, Color, Noise, ColorDead, Ramp, Sheet\r\nfunction _CreateParticleBlockGroup(oldSystem: ParticleSystem, context: RuntimeConversionContext): CreateParticleBlock {\r\n    // Create particle block\r\n    const createParticleBlock = new CreateParticleBlock(\"Create Particle\");\r\n\r\n    _CreateParticleLifetimeBlockGroup(oldSystem, context).connectTo(createParticleBlock.lifeTime);\r\n    _CreateParticleEmitPowerBlockGroup(oldSystem).connectTo(createParticleBlock.emitPower);\r\n    _CreateParticleSizeBlockGroup(oldSystem, context).connectTo(createParticleBlock.size);\r\n    _CreateParticleScaleBlockGroup(oldSystem, context).connectTo(createParticleBlock.scale);\r\n    _CreateParticleAngleBlockGroup(oldSystem).connectTo(createParticleBlock.angle);\r\n    _CreateParticleColorBlockGroup(oldSystem, context).connectTo(createParticleBlock.color);\r\n\r\n    // Dead color\r\n    _CreateAndConnectInput(\"Dead Color\", oldSystem.colorDead, createParticleBlock.colorDead);\r\n\r\n    return createParticleBlock;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle lifetime\r\n * @param oldSystem The old particle system to convert\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle lifetime\r\n */\r\nfunction _CreateParticleLifetimeBlockGroup(oldSystem: ParticleSystem, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    if (oldSystem.targetStopDuration && oldSystem._lifeTimeGradients && oldSystem._lifeTimeGradients.length > 0) {\r\n        context.timeToStopTimeRatioBlockGroupOutput = _CreateTimeToStopTimeRatioBlockGroup(oldSystem, context);\r\n        const gradientBlockGroupOutput = _CreateGradientBlockGroup(\r\n            context.timeToStopTimeRatioBlockGroupOutput,\r\n            oldSystem._lifeTimeGradients,\r\n            ParticleRandomBlockLocks.PerParticle,\r\n            \"Lifetime\"\r\n        );\r\n        return gradientBlockGroupOutput;\r\n    } else {\r\n        const randomLifetimeBlock = new ParticleRandomBlock(\"Random Lifetime\");\r\n        _CreateAndConnectInput(\"Min Lifetime\", oldSystem.minLifeTime, randomLifetimeBlock.min);\r\n        _CreateAndConnectInput(\"Max Lifetime\", oldSystem.maxLifeTime, randomLifetimeBlock.max);\r\n        return randomLifetimeBlock.output;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle emit power\r\n * @param oldSystem The old particle system to convert\r\n * @returns The output of the group of blocks that represent the particle emit power\r\n */\r\nfunction _CreateParticleEmitPowerBlockGroup(oldSystem: ParticleSystem): NodeParticleConnectionPoint {\r\n    const randomEmitPowerBlock = new ParticleRandomBlock(\"Random Emit Power\");\r\n    _CreateAndConnectInput(\"Min Emit Power\", oldSystem.minEmitPower, randomEmitPowerBlock.min);\r\n    _CreateAndConnectInput(\"Max Emit Power\", oldSystem.maxEmitPower, randomEmitPowerBlock.max);\r\n    return randomEmitPowerBlock.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle size\r\n * @param oldSystem The old particle system to convert\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle size\r\n */\r\nfunction _CreateParticleSizeBlockGroup(oldSystem: ParticleSystem, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    if (oldSystem._sizeGradients && oldSystem._sizeGradients.length > 0) {\r\n        context.sizeGradientValue0Output = _CreateParticleInitialValueFromGradient(oldSystem._sizeGradients);\r\n        return context.sizeGradientValue0Output;\r\n    } else {\r\n        const randomSizeBlock = new ParticleRandomBlock(\"Random size\");\r\n        _CreateAndConnectInput(\"Min size\", oldSystem.minSize, randomSizeBlock.min);\r\n        _CreateAndConnectInput(\"Max size\", oldSystem.maxSize, randomSizeBlock.max);\r\n        return randomSizeBlock.output;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle scale\r\n * @param oldSystem The old particle system to convert\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle scale\r\n */\r\nfunction _CreateParticleScaleBlockGroup(oldSystem: ParticleSystem, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    // Create the random scale\r\n    const randomScaleBlock = new ParticleRandomBlock(\"Random Scale\");\r\n    _CreateAndConnectInput(\"Min Scale\", new Vector2(oldSystem.minScaleX, oldSystem.minScaleY), randomScaleBlock.min);\r\n    _CreateAndConnectInput(\"Max Scale\", new Vector2(oldSystem.maxScaleX, oldSystem.maxScaleY), randomScaleBlock.max);\r\n\r\n    if (oldSystem.targetStopDuration && oldSystem._startSizeGradients && oldSystem._startSizeGradients.length > 0) {\r\n        // Create the start size gradient\r\n        context.timeToStopTimeRatioBlockGroupOutput = _CreateTimeToStopTimeRatioBlockGroup(oldSystem, context);\r\n        const gradientBlockGroupOutput = _CreateGradientBlockGroup(\r\n            context.timeToStopTimeRatioBlockGroupOutput,\r\n            oldSystem._startSizeGradients,\r\n            ParticleRandomBlockLocks.PerParticle,\r\n            \"Start Size\"\r\n        );\r\n\r\n        // Multiply the initial random scale by the start size gradient\r\n        const multiplyScaleBlock = new ParticleMathBlock(\"Multiply Scale by Start Size Gradient\");\r\n        multiplyScaleBlock.operation = ParticleMathBlockOperations.Multiply;\r\n        randomScaleBlock.output.connectTo(multiplyScaleBlock.left);\r\n        gradientBlockGroupOutput.connectTo(multiplyScaleBlock.right);\r\n\r\n        return multiplyScaleBlock.output;\r\n    } else {\r\n        return randomScaleBlock.output;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle angle (rotation)\r\n * @param oldSystem The old particle system to convert\r\n * @returns The output of the group of blocks that represent the particle angle (rotation)\r\n */\r\nfunction _CreateParticleAngleBlockGroup(oldSystem: ParticleSystem): NodeParticleConnectionPoint {\r\n    const randomRotationBlock = new ParticleRandomBlock(\"Random Rotation\");\r\n    _CreateAndConnectInput(\"Min Rotation\", oldSystem.minInitialRotation, randomRotationBlock.min);\r\n    _CreateAndConnectInput(\"Max Rotation\", oldSystem.maxInitialRotation, randomRotationBlock.max);\r\n    return randomRotationBlock.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle color\r\n * @param oldSystem The old particle system to convert\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle color\r\n */\r\nfunction _CreateParticleColorBlockGroup(oldSystem: ParticleSystem, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    if (oldSystem._colorGradients && oldSystem._colorGradients.length > 0) {\r\n        context.colorGradientValue0Output = _CreateParticleInitialValueFromGradient(oldSystem._colorGradients);\r\n        return context.colorGradientValue0Output;\r\n    } else {\r\n        const randomColorBlock = new ParticleRandomBlock(\"Random color\");\r\n        _CreateAndConnectInput(\"Color 1\", oldSystem.color1, randomColorBlock.min);\r\n        _CreateAndConnectInput(\"Color 2\", oldSystem.color2, randomColorBlock.max);\r\n        return randomColorBlock.output;\r\n    }\r\n}\r\n\r\nfunction _CreateParticleInitialValueFromGradient(gradients: Array<FactorGradient> | Array<ColorGradient>): NodeParticleConnectionPoint {\r\n    if (gradients.length === 0) {\r\n        throw new Error(\"No gradients provided.\");\r\n    }\r\n\r\n    const gradientStep = gradients[0];\r\n    const value1 = (gradientStep as any).factor1 ?? (gradientStep as any).color1;\r\n    const value2 = (gradientStep as any).factor2 ?? (gradientStep as any).color2;\r\n\r\n    if (value2 !== undefined) {\r\n        // Create a random between value1 and value2\r\n        const randomBlock = new ParticleRandomBlock(\"Random Value 0\");\r\n        randomBlock.lockMode = ParticleRandomBlockLocks.OncePerParticle;\r\n        _CreateAndConnectInput(\"Value 1\", value1, randomBlock.min);\r\n        _CreateAndConnectInput(\"Value 2\", value2, randomBlock.max);\r\n        return randomBlock.output;\r\n    } else {\r\n        // Single value\r\n        const sizeBlock = new ParticleInputBlock(\"Value\");\r\n        sizeBlock.value = value1;\r\n        return sizeBlock.output;\r\n    }\r\n}\r\n\r\n// ------------- EMITTER SHAPE FUNCTIONS -------------\r\n\r\nfunction _EmitterShapeBlock(oldSystem: IParticleSystem): IShapeBlock {\r\n    const emitter = oldSystem.particleEmitterType;\r\n    if (!emitter) {\r\n        throw new Error(\"Particle system has no emitter type.\");\r\n    }\r\n\r\n    let shapeBlock: Nullable<IShapeBlock> = null;\r\n    switch (emitter.getClassName()) {\r\n        case \"BoxParticleEmitter\": {\r\n            const source = emitter as BoxParticleEmitter;\r\n            shapeBlock = new BoxShapeBlock(\"Box Shape\");\r\n\r\n            const target = shapeBlock as BoxShapeBlock;\r\n            _CreateAndConnectInput(\"Direction 1\", source.direction1, target.direction1);\r\n            _CreateAndConnectInput(\"Direction 2\", source.direction2, target.direction2);\r\n            _CreateAndConnectInput(\"Min Emit Box\", source.minEmitBox, target.minEmitBox);\r\n            _CreateAndConnectInput(\"Max Emit Box\", source.maxEmitBox, target.maxEmitBox);\r\n            break;\r\n        }\r\n        case \"ConeParticleEmitter\": {\r\n            const source = emitter as ConeParticleEmitter;\r\n            shapeBlock = new ConeShapeBlock(\"Cone Shape\");\r\n\r\n            const target = shapeBlock as ConeShapeBlock;\r\n            target.emitFromSpawnPointOnly = source.emitFromSpawnPointOnly;\r\n            _CreateAndConnectInput(\"Radius\", source.radius, target.radius);\r\n            _CreateAndConnectInput(\"Angle\", source.angle, target.angle);\r\n            _CreateAndConnectInput(\"Radius Range\", source.radiusRange, target.radiusRange);\r\n            _CreateAndConnectInput(\"Height Range\", source.heightRange, target.heightRange);\r\n            _CreateAndConnectInput(\"Direction Randomizer\", source.directionRandomizer, target.directionRandomizer);\r\n            break;\r\n        }\r\n        case \"ConeDirectedParticleEmitter\": {\r\n            const source = emitter as ConeDirectedParticleEmitter;\r\n            shapeBlock = new ConeShapeBlock(\"Cone Shape\");\r\n\r\n            const target = shapeBlock as ConeShapeBlock;\r\n            target.emitFromSpawnPointOnly = source.emitFromSpawnPointOnly;\r\n            _CreateAndConnectInput(\"Radius\", source.radius, target.radius);\r\n            _CreateAndConnectInput(\"Angle\", source.angle, target.angle);\r\n            _CreateAndConnectInput(\"Radius Range\", source.radiusRange, target.radiusRange);\r\n            _CreateAndConnectInput(\"Height Range\", source.heightRange, target.heightRange);\r\n            _CreateAndConnectInput(\"Direction 1\", source.direction1, target.direction1);\r\n            _CreateAndConnectInput(\"Direction 2\", source.direction2, target.direction2);\r\n            break;\r\n        }\r\n        case \"CustomParticleEmitter\": {\r\n            const source = emitter as CustomParticleEmitter;\r\n            shapeBlock = new CustomShapeBlock(\"Custom Shape\");\r\n\r\n            const target = shapeBlock as CustomShapeBlock;\r\n            target.particlePositionGenerator = source.particlePositionGenerator;\r\n            target.particleDestinationGenerator = source.particleDestinationGenerator;\r\n            target.particleDirectionGenerator = source.particleDirectionGenerator;\r\n            break;\r\n        }\r\n        case \"CylinderParticleEmitter\": {\r\n            const source = emitter as CylinderParticleEmitter;\r\n            shapeBlock = new CylinderShapeBlock(\"Cylinder Shape\");\r\n\r\n            const target = shapeBlock as CylinderShapeBlock;\r\n            _CreateAndConnectInput(\"Height\", source.height, target.height);\r\n            _CreateAndConnectInput(\"Radius\", source.radius, target.radius);\r\n            _CreateAndConnectInput(\"Radius Range\", source.radiusRange, target.radiusRange);\r\n            _CreateAndConnectInput(\"Direction Randomizer\", source.directionRandomizer, target.directionRandomizer);\r\n            break;\r\n        }\r\n        case \"CylinderDirectedParticleEmitter\": {\r\n            const source = emitter as CylinderDirectedParticleEmitter;\r\n            shapeBlock = new CylinderShapeBlock(\"Cylinder Shape\");\r\n\r\n            const target = shapeBlock as CylinderShapeBlock;\r\n            _CreateAndConnectInput(\"Height\", source.height, target.height);\r\n            _CreateAndConnectInput(\"Radius\", source.radius, target.radius);\r\n            _CreateAndConnectInput(\"Radius Range\", source.radiusRange, target.radiusRange);\r\n            _CreateAndConnectInput(\"Direction 1\", source.direction1, target.direction1);\r\n            _CreateAndConnectInput(\"Direction 2\", source.direction2, target.direction2);\r\n            break;\r\n        }\r\n        case \"HemisphericParticleEmitter\": {\r\n            const source = emitter as HemisphericParticleEmitter;\r\n            shapeBlock = new SphereShapeBlock(\"Sphere Shape\");\r\n\r\n            const target = shapeBlock as SphereShapeBlock;\r\n            target.isHemispheric = true;\r\n            _CreateAndConnectInput(\"Radius\", source.radius, target.radius);\r\n            _CreateAndConnectInput(\"Radius Range\", source.radiusRange, target.radiusRange);\r\n            _CreateAndConnectInput(\"Direction Randomizer\", source.directionRandomizer, target.directionRandomizer);\r\n            break;\r\n        }\r\n        case \"MeshParticleEmitter\": {\r\n            const source = emitter as MeshParticleEmitter;\r\n            shapeBlock = new MeshShapeBlock(\"Mesh Shape\");\r\n\r\n            const target = shapeBlock as MeshShapeBlock;\r\n            target.useMeshNormalsForDirection = source.useMeshNormalsForDirection;\r\n            _CreateAndConnectInput(\"Direction 1\", source.direction1, target.direction1);\r\n            _CreateAndConnectInput(\"Direction 2\", source.direction2, target.direction2);\r\n\r\n            target.mesh = source.mesh as Mesh;\r\n            break;\r\n        }\r\n        case \"PointParticleEmitter\": {\r\n            const source = emitter as PointParticleEmitter;\r\n            shapeBlock = new PointShapeBlock(\"Point Shape\");\r\n\r\n            const target = shapeBlock as PointShapeBlock;\r\n            _CreateAndConnectInput(\"Direction 1\", source.direction1, target.direction1);\r\n            _CreateAndConnectInput(\"Direction 2\", source.direction2, target.direction2);\r\n            break;\r\n        }\r\n        case \"SphereParticleEmitter\": {\r\n            const source = emitter as SphereParticleEmitter;\r\n            shapeBlock = new SphereShapeBlock(\"Sphere Shape\");\r\n\r\n            const target = shapeBlock as SphereShapeBlock;\r\n            _CreateAndConnectInput(\"Radius\", source.radius, target.radius);\r\n            _CreateAndConnectInput(\"Radius Range\", source.radiusRange, target.radiusRange);\r\n            _CreateAndConnectInput(\"Direction Randomizer\", source.directionRandomizer, target.directionRandomizer);\r\n            break;\r\n        }\r\n        case \"SphereDirectedParticleEmitter\": {\r\n            const source = emitter as SphereDirectedParticleEmitter;\r\n            shapeBlock = new SphereShapeBlock(\"Sphere Shape\");\r\n\r\n            const target = shapeBlock as SphereShapeBlock;\r\n            _CreateAndConnectInput(\"Radius\", source.radius, target.radius);\r\n            _CreateAndConnectInput(\"Radius Range\", source.radiusRange, target.radiusRange);\r\n            _CreateAndConnectInput(\"Direction1\", source.direction1, target.direction1);\r\n            _CreateAndConnectInput(\"Direction2\", source.direction2, target.direction2);\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!shapeBlock) {\r\n        throw new Error(`Unsupported particle emitter type: ${emitter.getClassName()}`);\r\n    }\r\n\r\n    return shapeBlock;\r\n}\r\n\r\n// ------------- UPDATE PARTICLE FUNCTIONS -------------\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle system update\r\n * The creation of the different properties follows the order they are added to the ProcessQueue in ThinParticleSystem:\r\n * Color, AngularSpeedGradients, AngularSpeed, VelocityGradients, Direction, LimitVelocityGradients, DragGradients, Position, Noise, SizeGradients, Gravity, RemapGradients\r\n * @param inputParticle The particle input connection point\r\n * @param oldSystem The old particle system to convert\r\n * @param context The runtime conversion context\r\n * @returns The output connection point after all updates have been applied\r\n */\r\nfunction _UpdateParticleBlockGroup(inputParticle: NodeParticleConnectionPoint, oldSystem: ParticleSystem, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    let updatedParticle: NodeParticleConnectionPoint = inputParticle;\r\n\r\n    updatedParticle = _UpdateParticleColorBlockGroup(updatedParticle, oldSystem._colorGradients, context);\r\n    updatedParticle = _UpdateParticleAngleBlockGroup(updatedParticle, oldSystem, context);\r\n\r\n    if (oldSystem._velocityGradients && oldSystem._velocityGradients.length > 0) {\r\n        context.scaledDirection = _UpdateParticleVelocityGradientBlockGroup(oldSystem._velocityGradients, context);\r\n    }\r\n\r\n    if (oldSystem._dragGradients && oldSystem._dragGradients.length > 0) {\r\n        context.scaledDirection = _UpdateParticleDragGradientBlockGroup(oldSystem._dragGradients, context);\r\n    }\r\n\r\n    updatedParticle = _UpdateParticlePositionBlockGroup(updatedParticle, oldSystem.isLocal, context);\r\n\r\n    if (oldSystem._limitVelocityGradients && oldSystem._limitVelocityGradients.length > 0 && oldSystem.limitVelocityDamping !== 0) {\r\n        updatedParticle = _UpdateParticleVelocityLimitGradientBlockGroup(updatedParticle, oldSystem._limitVelocityGradients, oldSystem.limitVelocityDamping, context);\r\n    }\r\n\r\n    if (oldSystem.noiseTexture && oldSystem.noiseStrength) {\r\n        updatedParticle = _UpdateParticleNoiseBlockGroup(updatedParticle, oldSystem.noiseTexture, oldSystem.noiseStrength);\r\n    }\r\n\r\n    if (oldSystem._sizeGradients && oldSystem._sizeGradients.length > 0) {\r\n        updatedParticle = _UpdateParticleSizeGradientBlockGroup(updatedParticle, oldSystem._sizeGradients, context);\r\n    }\r\n\r\n    if (oldSystem.gravity.equalsToFloats(0, 0, 0) === false) {\r\n        updatedParticle = _UpdateParticleGravityBlockGroup(updatedParticle, oldSystem.gravity);\r\n    }\r\n\r\n    return updatedParticle;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle color update\r\n * @param inputParticle The input particle to update\r\n * @param colorGradients The color gradients (if any)\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle color update\r\n */\r\nfunction _UpdateParticleColorBlockGroup(\r\n    inputParticle: NodeParticleConnectionPoint,\r\n    colorGradients: Nullable<Array<ColorGradient>>,\r\n    context: RuntimeConversionContext\r\n): NodeParticleConnectionPoint {\r\n    let colorCalculation: NodeParticleConnectionPoint | undefined = undefined;\r\n    if (colorGradients && colorGradients.length > 0) {\r\n        if (context.colorGradientValue0Output === undefined) {\r\n            throw new Error(\"Initial color gradient values not found in context.\");\r\n        }\r\n\r\n        context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);\r\n        colorCalculation = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, colorGradients, ParticleRandomBlockLocks.OncePerParticle, \"Color\", [\r\n            context.colorGradientValue0Output,\r\n        ]);\r\n    } else {\r\n        colorCalculation = _BasicColorUpdateBlockGroup();\r\n    }\r\n\r\n    // Create the color update block clamping alpha >= 0\r\n    const colorUpdateBlock = new UpdateColorBlock(\"Color update\");\r\n    inputParticle.connectTo(colorUpdateBlock.particle);\r\n    _ClampUpdateColorAlpha(colorCalculation).connectTo(colorUpdateBlock.color);\r\n\r\n    return colorUpdateBlock.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle angle update\r\n * @param inputParticle The input particle to update\r\n * @param oldSystem The old particle system to convert\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle color update\r\n */\r\nfunction _UpdateParticleAngleBlockGroup(inputParticle: NodeParticleConnectionPoint, oldSystem: ParticleSystem, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    // We will try to use gradients if they exist\r\n    // If not, we will try to use min/max angular speed\r\n    let angularSpeedCalculation = null;\r\n    if (oldSystem._angularSpeedGradients && oldSystem._angularSpeedGradients.length > 0) {\r\n        angularSpeedCalculation = _UpdateParticleAngularSpeedGradientBlockGroup(oldSystem._angularSpeedGradients, context);\r\n    } else if (oldSystem.minAngularSpeed !== 0 || oldSystem.maxAngularSpeed !== 0) {\r\n        angularSpeedCalculation = _UpdateParticleAngularSpeedBlockGroup(oldSystem.minAngularSpeed, oldSystem.maxAngularSpeed);\r\n    }\r\n\r\n    // If we have an angular speed calculation, then update the angle\r\n    if (angularSpeedCalculation) {\r\n        // Create the angular speed delta\r\n        const angleSpeedDeltaOutput = _CreateDeltaModifiedInput(\"Angular Speed\", angularSpeedCalculation);\r\n\r\n        // Add it to the angle\r\n        const addAngle = new ParticleMathBlock(\"Add Angular Speed to Angle\");\r\n        addAngle.operation = ParticleMathBlockOperations.Add;\r\n        _CreateAndConnectContextualSource(\"Angle\", NodeParticleContextualSources.Angle, addAngle.left);\r\n        angleSpeedDeltaOutput.connectTo(addAngle.right);\r\n\r\n        // Update the particle angle\r\n        const updateAngle = new UpdateAngleBlock(\"Angle Update with Angular Speed\");\r\n        inputParticle.connectTo(updateAngle.particle);\r\n        addAngle.output.connectTo(updateAngle.angle);\r\n\r\n        return updateAngle.output;\r\n    } else {\r\n        return inputParticle;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle velocity update\r\n * @param velocityGradients The velocity gradients\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle velocity update\r\n */\r\nfunction _UpdateParticleVelocityGradientBlockGroup(velocityGradients: Array<FactorGradient>, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);\r\n\r\n    // Generate the gradient\r\n    const velocityValueOutput = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, velocityGradients, ParticleRandomBlockLocks.OncePerParticle, \"Velocity\");\r\n\r\n    // Update the direction scale based on the velocity\r\n    const multiplyScaleByVelocity = new ParticleMathBlock(\"Multiply Direction Scale by Velocity\");\r\n    multiplyScaleByVelocity.operation = ParticleMathBlockOperations.Multiply;\r\n    velocityValueOutput.connectTo(multiplyScaleByVelocity.left);\r\n    _CreateAndConnectContextualSource(\"Direction Scale\", NodeParticleContextualSources.DirectionScale, multiplyScaleByVelocity.right);\r\n\r\n    // Update the particle direction scale\r\n    const multiplyDirection = new ParticleMathBlock(\"Scaled Direction\");\r\n    multiplyDirection.operation = ParticleMathBlockOperations.Multiply;\r\n    multiplyScaleByVelocity.output.connectTo(multiplyDirection.left);\r\n    _CreateAndConnectContextualSource(\"Direction\", NodeParticleContextualSources.Direction, multiplyDirection.right);\r\n\r\n    // Store the new calculation of the scaled direction in the context\r\n    context.scaledDirection = multiplyDirection.output;\r\n    return multiplyDirection.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle velocity limit update\r\n * @param inputParticle The input particle to update\r\n * @param velocityLimitGradients The velocity limit gradients\r\n * @param limitVelocityDamping The limit velocity damping factor\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle velocity limit update\r\n */\r\nfunction _UpdateParticleVelocityLimitGradientBlockGroup(\r\n    inputParticle: NodeParticleConnectionPoint,\r\n    velocityLimitGradients: Array<FactorGradient>,\r\n    limitVelocityDamping: number,\r\n    context: RuntimeConversionContext\r\n): NodeParticleConnectionPoint {\r\n    context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);\r\n\r\n    // Calculate the current speed\r\n    const currentSpeedBlock = new ParticleVectorLengthBlock(\"Current Speed\");\r\n    _CreateAndConnectContextualSource(\"Direction\", NodeParticleContextualSources.Direction, currentSpeedBlock.input);\r\n\r\n    // Calculate the velocity limit from the gradient\r\n    const velocityLimitValueOutput = _CreateGradientBlockGroup(\r\n        context.ageToLifeTimeRatioBlockGroupOutput,\r\n        velocityLimitGradients,\r\n        ParticleRandomBlockLocks.OncePerParticle,\r\n        \"Velocity Limit\"\r\n    );\r\n\r\n    // Blocks that will calculate the new velocity if over the limit\r\n    const damped = new ParticleMathBlock(\"Damped Speed\");\r\n    damped.operation = ParticleMathBlockOperations.Multiply;\r\n    _CreateAndConnectContextualSource(\"Direction\", NodeParticleContextualSources.Direction, damped.left);\r\n    _CreateAndConnectInput(\"Limit Velocity Damping\", limitVelocityDamping, damped.right);\r\n\r\n    // Compare current speed and limit\r\n    const compareSpeed = new ParticleConditionBlock(\"Compare Speed to Limit\");\r\n    compareSpeed.test = ParticleConditionBlockTests.GreaterThan;\r\n    currentSpeedBlock.output.connectTo(compareSpeed.left);\r\n    velocityLimitValueOutput.connectTo(compareSpeed.right);\r\n    damped.output.connectTo(compareSpeed.ifTrue);\r\n    _CreateAndConnectContextualSource(\"Direction\", NodeParticleContextualSources.Direction, compareSpeed.ifFalse);\r\n\r\n    // Update the direction based on the calculted value\r\n    const updateDirection = new UpdateDirectionBlock(\"Direction Update\");\r\n    inputParticle.connectTo(updateDirection.particle);\r\n    compareSpeed.output.connectTo(updateDirection.direction);\r\n\r\n    return updateDirection.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle noise update\r\n * @param inputParticle The particle to update\r\n * @param noiseTexture The noise texture\r\n * @param noiseStrength The strength of the noise\r\n * @returns The output of the group of blocks that represent the particle noise update\r\n */\r\nfunction _UpdateParticleNoiseBlockGroup(inputParticle: NodeParticleConnectionPoint, noiseTexture: ProceduralTexture, noiseStrength: Vector3): NodeParticleConnectionPoint {\r\n    const noiseUpdate = new UpdateNoiseBlock(\"Noise Update\");\r\n    inputParticle.connectTo(noiseUpdate.particle);\r\n    _CreateTextureBlock(noiseTexture).connectTo(noiseUpdate.noiseTexture);\r\n    _CreateAndConnectInput(\"Noise Strength\", noiseStrength, noiseUpdate.strength);\r\n    return noiseUpdate.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle drag update\r\n * @param dragGradients The drag gradients\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle drag update\r\n */\r\nfunction _UpdateParticleDragGradientBlockGroup(dragGradients: Array<FactorGradient>, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);\r\n\r\n    // Generate the gradient\r\n    const dragValueOutput = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, dragGradients, ParticleRandomBlockLocks.OncePerParticle, \"Drag\");\r\n\r\n    // Calculate drag factor\r\n    const oneMinusDragBlock = new ParticleMathBlock(\"1 - Drag\");\r\n    oneMinusDragBlock.operation = ParticleMathBlockOperations.Subtract;\r\n    _CreateAndConnectInput(\"One\", 1, oneMinusDragBlock.left);\r\n    dragValueOutput.connectTo(oneMinusDragBlock.right);\r\n\r\n    // Multiply the scaled direction by drag factor\r\n    const multiplyDirection = new ParticleMathBlock(\"Scaled Direction with Drag\");\r\n    multiplyDirection.operation = ParticleMathBlockOperations.Multiply;\r\n    oneMinusDragBlock.output.connectTo(multiplyDirection.left);\r\n    if (context.scaledDirection === undefined) {\r\n        _CreateAndConnectContextualSource(\"Scaled Direction\", NodeParticleContextualSources.ScaledDirection, multiplyDirection.right);\r\n    } else {\r\n        context.scaledDirection.connectTo(multiplyDirection.right);\r\n    }\r\n\r\n    // Store the new calculation of the scaled direction in the context\r\n    context.scaledDirection = multiplyDirection.output;\r\n    return multiplyDirection.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle position update\r\n * @param inputParticle The input particle to update\r\n * @param isLocal Whether the particle coordinate system is local or not\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle position update\r\n */\r\nfunction _UpdateParticlePositionBlockGroup(inputParticle: NodeParticleConnectionPoint, isLocal: boolean, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    // Update the particle position\r\n    const updatePosition = new UpdatePositionBlock(\"Position Update\");\r\n    inputParticle.connectTo(updatePosition.particle);\r\n\r\n    if (isLocal) {\r\n        _CreateAndConnectContextualSource(\"Local Position Updated\", NodeParticleContextualSources.LocalPositionUpdated, updatePosition.position);\r\n    } else {\r\n        // Calculate the new position\r\n        const addPositionBlock = new ParticleMathBlock(\"Add Position\");\r\n        addPositionBlock.operation = ParticleMathBlockOperations.Add;\r\n        _CreateAndConnectContextualSource(\"Position\", NodeParticleContextualSources.Position, addPositionBlock.left);\r\n        if (context.scaledDirection === undefined) {\r\n            _CreateAndConnectContextualSource(\"Scaled Direction\", NodeParticleContextualSources.ScaledDirection, addPositionBlock.right);\r\n        } else {\r\n            context.scaledDirection.connectTo(addPositionBlock.right);\r\n        }\r\n\r\n        addPositionBlock.output.connectTo(updatePosition.position);\r\n    }\r\n\r\n    return updatePosition.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle size update\r\n * @param inputParticle The input particle to update\r\n * @param sizeGradients The size gradients (if any)\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle size update\r\n */\r\nfunction _UpdateParticleSizeGradientBlockGroup(\r\n    inputParticle: NodeParticleConnectionPoint,\r\n    sizeGradients: Array<FactorGradient>,\r\n    context: RuntimeConversionContext\r\n): NodeParticleConnectionPoint {\r\n    if (context.sizeGradientValue0Output === undefined) {\r\n        throw new Error(\"Initial size gradient values not found in context.\");\r\n    }\r\n\r\n    context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);\r\n\r\n    // Generate the gradient\r\n    const sizeValueOutput = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, sizeGradients, ParticleRandomBlockLocks.OncePerParticle, \"Size\", [\r\n        context.sizeGradientValue0Output,\r\n    ]);\r\n\r\n    // Create the update size\r\n    const updateSizeBlock = new UpdateSizeBlock(\"Size Update\");\r\n    inputParticle.connectTo(updateSizeBlock.particle);\r\n    sizeValueOutput.connectTo(updateSizeBlock.size);\r\n\r\n    return updateSizeBlock.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle gravity update\r\n * @param inputParticle The input particle to update\r\n * @param gravity The gravity vector to apply\r\n * @returns The output of the group of blocks that represent the particle gravity update\r\n */\r\nfunction _UpdateParticleGravityBlockGroup(inputParticle: NodeParticleConnectionPoint, gravity: Vector3): NodeParticleConnectionPoint {\r\n    // Create the gravity delta\r\n    const gravityDeltaOutput = _CreateDeltaModifiedInput(\"Gravity\", gravity);\r\n\r\n    // Add it to the direction\r\n    const addDirectionBlock = new ParticleMathBlock(\"Add Gravity to Direction\");\r\n    addDirectionBlock.operation = ParticleMathBlockOperations.Add;\r\n    _CreateAndConnectContextualSource(\"Direction\", NodeParticleContextualSources.Direction, addDirectionBlock.left);\r\n    gravityDeltaOutput.connectTo(addDirectionBlock.right);\r\n\r\n    // Update the particle direction\r\n    const updateDirection = new UpdateDirectionBlock(\"Direction Update with Gravity\");\r\n    inputParticle.connectTo(updateDirection.particle);\r\n    addDirectionBlock.output.connectTo(updateDirection.direction);\r\n\r\n    return updateDirection.output;\r\n}\r\n\r\nfunction _UpdateParticleAngularSpeedGradientBlockGroup(angularSpeedGradients: Array<FactorGradient>, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);\r\n\r\n    // Generate the gradient\r\n    const angularSpeedValueOutput = _CreateGradientBlockGroup(\r\n        context.ageToLifeTimeRatioBlockGroupOutput,\r\n        angularSpeedGradients,\r\n        ParticleRandomBlockLocks.OncePerParticle,\r\n        \"Angular Speed\"\r\n    );\r\n    return angularSpeedValueOutput;\r\n}\r\n\r\nfunction _UpdateParticleAngularSpeedBlockGroup(minAngularSpeed: number, maxAngularSpeed: number): NodeParticleConnectionPoint {\r\n    // Random value between for the angular speed of the particle\r\n    const randomAngularSpeedBlock = new ParticleRandomBlock(\"Random Angular Speed\");\r\n    randomAngularSpeedBlock.lockMode = ParticleRandomBlockLocks.OncePerParticle;\r\n    _CreateAndConnectInput(\"Min Angular Speed\", minAngularSpeed, randomAngularSpeedBlock.min);\r\n    _CreateAndConnectInput(\"Max Angular Speed\", maxAngularSpeed, randomAngularSpeedBlock.max);\r\n    return randomAngularSpeedBlock.output;\r\n}\r\n\r\nfunction _BasicColorUpdateBlockGroup(): NodeParticleConnectionPoint {\r\n    const addColorBlock = new ParticleMathBlock(\"Add Color\");\r\n    addColorBlock.operation = ParticleMathBlockOperations.Add;\r\n    _CreateAndConnectContextualSource(\"Color\", NodeParticleContextualSources.Color, addColorBlock.left);\r\n    _CreateAndConnectContextualSource(\"Scaled Color Step\", NodeParticleContextualSources.ScaledColorStep, addColorBlock.right);\r\n    return addColorBlock.output;\r\n}\r\n\r\nfunction _ClampUpdateColorAlpha(colorCalculationOutput: NodeParticleConnectionPoint): NodeParticleConnectionPoint {\r\n    // Decompose color to clamp alpha\r\n    const decomposeColorBlock = new ParticleConverterBlock(\"Decompose Color\");\r\n    colorCalculationOutput.connectTo(decomposeColorBlock.colorIn);\r\n\r\n    // Clamp alpha to be >= 0\r\n    const maxAlphaBlock = new ParticleMathBlock(\"Alpha >= 0\");\r\n    maxAlphaBlock.operation = ParticleMathBlockOperations.Max;\r\n    decomposeColorBlock.wOut.connectTo(maxAlphaBlock.left);\r\n    _CreateAndConnectInput(\"Zero\", 0, maxAlphaBlock.right);\r\n\r\n    // Recompose color\r\n    const composeColorBlock = new ParticleConverterBlock(\"Compose Color\");\r\n    decomposeColorBlock.xyzOut.connectTo(composeColorBlock.xyzIn);\r\n    maxAlphaBlock.output.connectTo(composeColorBlock.wIn);\r\n\r\n    return composeColorBlock.colorOut;\r\n}\r\n\r\n// ------------- SYSTEM FUNCTIONS -------------\r\n\r\nfunction _SystemBlockGroup(oldSystem: ParticleSystem, context: RuntimeConversionContext): SystemBlock {\r\n    const newSystem = new SystemBlock(oldSystem.name);\r\n\r\n    newSystem.translationPivot.value = oldSystem.translationPivot;\r\n    newSystem.textureMask.value = oldSystem.textureMask;\r\n    newSystem.manualEmitCount = oldSystem.manualEmitCount;\r\n    newSystem.blendMode = oldSystem.blendMode;\r\n    newSystem.capacity = oldSystem.getCapacity();\r\n    newSystem.startDelay = oldSystem.startDelay;\r\n    newSystem.updateSpeed = oldSystem.updateSpeed;\r\n    newSystem.preWarmCycles = oldSystem.preWarmCycles;\r\n    newSystem.preWarmStepOffset = oldSystem.preWarmStepOffset;\r\n    newSystem.isBillboardBased = oldSystem.isBillboardBased;\r\n    newSystem.isLocal = oldSystem.isLocal;\r\n    newSystem.disposeOnStop = oldSystem.disposeOnStop;\r\n\r\n    _SystemEmitRateValue(oldSystem, newSystem, context);\r\n    _CreateTextureBlock(oldSystem.particleTexture).connectTo(newSystem.texture);\r\n    _SystemTargetStopDuration(oldSystem, newSystem, context);\r\n\r\n    return newSystem;\r\n}\r\n\r\nfunction _SystemEmitRateValue(oldSystem: ParticleSystem, newSystem: SystemBlock, context: RuntimeConversionContext): void {\r\n    const emitGradients = oldSystem.getEmitRateGradients();\r\n    if (emitGradients && emitGradients.length > 0 && oldSystem.targetStopDuration > 0) {\r\n        // Create the emit gradients\r\n        context.timeToStopTimeRatioBlockGroupOutput = _CreateTimeToStopTimeRatioBlockGroup(oldSystem, context);\r\n        const gradientValue = _CreateGradientBlockGroup(context.timeToStopTimeRatioBlockGroupOutput, emitGradients, ParticleRandomBlockLocks.PerSystem, \"Emit Rate\");\r\n\r\n        // Round the value to an int\r\n        const roundBlock = new ParticleFloatToIntBlock(\"Round to Int\");\r\n        roundBlock.operation = ParticleFloatToIntBlockOperations.Round;\r\n        gradientValue.connectTo(roundBlock.input);\r\n        roundBlock.output.connectTo(newSystem.emitRate);\r\n    } else {\r\n        newSystem.emitRate.value = oldSystem.emitRate;\r\n    }\r\n}\r\n\r\nfunction _SystemTargetStopDuration(oldSystem: ParticleSystem, newSystem: SystemBlock, context: RuntimeConversionContext): void {\r\n    // If something else uses the target stop duration (like a gradient),\r\n    // then the block is already created and stored in the context\r\n    if (context.targetStopDurationBlockOutput) {\r\n        context.targetStopDurationBlockOutput.connectTo(newSystem.targetStopDuration);\r\n    } else {\r\n        // If no one used it, do not create a block just set the value\r\n        newSystem.targetStopDuration.value = oldSystem.targetStopDuration;\r\n    }\r\n}\r\n\r\n// ------------- UTILITY FUNCTIONS -------------\r\n\r\nfunction _CreateDeltaModifiedInput(name: string, value: Vector3 | NodeParticleConnectionPoint): NodeParticleConnectionPoint {\r\n    const multiplyBlock = new ParticleMathBlock(\"Multiply by Delta\");\r\n    multiplyBlock.operation = ParticleMathBlockOperations.Multiply;\r\n    if (value instanceof Vector3) {\r\n        _CreateAndConnectInput(name, value, multiplyBlock.left);\r\n    } else {\r\n        value.connectTo(multiplyBlock.left);\r\n    }\r\n    _CreateAndConnectSystemSource(\"Delta\", NodeParticleSystemSources.Delta, multiplyBlock.right);\r\n\r\n    return multiplyBlock.output;\r\n}\r\n\r\nfunction _CreateAndConnectInput(\r\n    inputBlockName: string,\r\n    value: number | Vector2 | Vector3 | Color4,\r\n    targetToConnectTo: NodeParticleConnectionPoint,\r\n    inputType?: NodeParticleBlockConnectionPointTypes\r\n): void {\r\n    const input = new ParticleInputBlock(inputBlockName, inputType);\r\n    input.value = value;\r\n    input.output.connectTo(targetToConnectTo);\r\n}\r\n\r\nfunction _CreateAndConnectContextualSource(contextualBlockName: string, contextSource: NodeParticleContextualSources, targetToConnectTo: NodeParticleConnectionPoint): void {\r\n    const input = new ParticleInputBlock(contextualBlockName);\r\n    input.contextualValue = contextSource;\r\n    input.output.connectTo(targetToConnectTo);\r\n}\r\n\r\nfunction _CreateAndConnectSystemSource(systemBlockName: string, systemSource: NodeParticleSystemSources, targetToConnectTo: NodeParticleConnectionPoint): void {\r\n    const input = new ParticleInputBlock(systemBlockName);\r\n    input.systemSource = systemSource;\r\n    input.output.connectTo(targetToConnectTo);\r\n}\r\n\r\n/**\r\n * Creates the target stop duration input block, as it can be shared in multiple places\r\n * This block is stored in the context so the same block is shared in the graph\r\n * @param oldSystem The old particle system to convert\r\n * @param context The context of the current conversion\r\n * @returns\r\n */\r\nfunction _CreateTargetStopDurationInputBlock(oldSystem: ParticleSystem, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    // If we have already created the target stop duration input block, return it\r\n    if (context.targetStopDurationBlockOutput) {\r\n        return context.targetStopDurationBlockOutput;\r\n    }\r\n\r\n    // Create the target stop duration input block if not already created\r\n    const targetStopDurationInputBlock = new ParticleInputBlock(\"Target Stop Duration\");\r\n    targetStopDurationInputBlock.value = oldSystem.targetStopDuration;\r\n\r\n    // Save the output in our context to avoid regenerating it again\r\n    context.targetStopDurationBlockOutput = targetStopDurationInputBlock.output;\r\n    return context.targetStopDurationBlockOutput;\r\n}\r\n\r\n/**\r\n * Create a group of blocks that calculates the ratio between the actual frame and the target stop duration, clamped between 0 and 1.\r\n * This is used to simulate the behavior of the old particle system where several particle gradient values are affected by the target stop duration.\r\n * This block group is stored in the context so the same group is shared in the graph\r\n * @param oldSystem The old particle system to convert\r\n * @param context The context of the current conversion\r\n * @returns The ratio block output connection point\r\n */\r\nfunction _CreateTimeToStopTimeRatioBlockGroup(oldSystem: ParticleSystem, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    // If we have already generated this group, return it\r\n    if (context.timeToStopTimeRatioBlockGroupOutput) {\r\n        return context.timeToStopTimeRatioBlockGroupOutput;\r\n    }\r\n\r\n    context.targetStopDurationBlockOutput = _CreateTargetStopDurationInputBlock(oldSystem, context);\r\n\r\n    // Find the ratio between the actual frame and the target stop duration\r\n    const ratio = new ParticleMathBlock(\"Frame/Stop Ratio\");\r\n    ratio.operation = ParticleMathBlockOperations.Divide;\r\n    _CreateAndConnectSystemSource(\"Actual Frame\", NodeParticleSystemSources.Time, ratio.left);\r\n    context.targetStopDurationBlockOutput.connectTo(ratio.right);\r\n\r\n    // Make sure values is >=0\r\n    const clampMin = new ParticleMathBlock(\"Clamp Min 0\");\r\n    clampMin.operation = ParticleMathBlockOperations.Max;\r\n    _CreateAndConnectInput(\"Zero\", 0, clampMin.left);\r\n    ratio.output.connectTo(clampMin.right);\r\n\r\n    // Make sure values is <=1\r\n    const clampMax = new ParticleMathBlock(\"Clamp Max 1\");\r\n    clampMax.operation = ParticleMathBlockOperations.Min;\r\n    _CreateAndConnectInput(\"One\", 1, clampMax.left);\r\n    clampMin.output.connectTo(clampMax.right);\r\n\r\n    // Save the group output in our context to avoid regenerating it again\r\n    context.timeToStopTimeRatioBlockGroupOutput = clampMax.output;\r\n    return context.timeToStopTimeRatioBlockGroupOutput;\r\n}\r\n\r\nfunction _CreateAgeToLifeTimeRatioBlockGroup(context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    // If we have already generated this group, return it\r\n    if (context.ageToLifeTimeRatioBlockGroupOutput) {\r\n        return context.ageToLifeTimeRatioBlockGroupOutput;\r\n    }\r\n\r\n    // Find the ratio between the age and the lifetime\r\n    const ratio = new ParticleMathBlock(\"Age/LifeTime Ratio\");\r\n    ratio.operation = ParticleMathBlockOperations.Divide;\r\n    _CreateAndConnectContextualSource(\"Age\", NodeParticleContextualSources.Age, ratio.left);\r\n    _CreateAndConnectContextualSource(\"LifeTime\", NodeParticleContextualSources.Lifetime, ratio.right);\r\n\r\n    // Save the group output in our context to avoid regenerating it again\r\n    context.ageToLifeTimeRatioBlockGroupOutput = ratio.output;\r\n    return ratio.output;\r\n}\r\n\r\n/**\r\n * Creates the blocks that represent a gradient\r\n * @param gradientSelector The value that determines which gradient to use\r\n * @param gradientValues The list of gradient values\r\n * @param randomLockMode The type of random to use for the gradient values\r\n * @param prefix The prefix to use for naming the blocks\r\n * @param initialValues Optional initial values to connect to the gradient inputs that were calculated during other steps of the conversion\r\n * @returns The output connection point of the gradient block\r\n */\r\nfunction _CreateGradientBlockGroup(\r\n    gradientSelector: NodeParticleConnectionPoint,\r\n    gradientValues: Array<FactorGradient> | Array<ColorGradient>,\r\n    randomLockMode: ParticleRandomBlockLocks,\r\n    prefix: string,\r\n    initialValues: NodeParticleConnectionPoint[] = []\r\n): NodeParticleConnectionPoint {\r\n    // Create the gradient block and connect the value that controls the gradient selection\r\n    const gradientBlock = new ParticleGradientBlock(prefix + \" Gradient Block\");\r\n    gradientSelector.connectTo(gradientBlock.gradient);\r\n\r\n    // If initial values are provided, we use them instead of the values in the gradientValues array\r\n    // These means this values were already transformed into blocks on a previous step of the conversion and we must reuse them\r\n    for (let i = 0; i < initialValues.length; i++) {\r\n        const reference = i < gradientValues.length ? gradientValues[i].gradient : 1;\r\n        const gradientValueBlock = new ParticleGradientValueBlock(prefix + \" Gradient Value \" + i);\r\n        gradientValueBlock.reference = reference;\r\n        initialValues[i].connectTo(gradientValueBlock.value);\r\n        gradientValueBlock.output.connectTo(gradientBlock.inputs[i + 1]);\r\n    }\r\n\r\n    // Create the gradient values\r\n    for (let i = 0 + initialValues.length; i < gradientValues.length; i++) {\r\n        const gradientValueBlockGroupOutput = _CreateGradientValueBlockGroup(gradientValues[i], randomLockMode, prefix, i);\r\n        gradientValueBlockGroupOutput.connectTo(gradientBlock.inputs[i + 1]);\r\n    }\r\n\r\n    return gradientBlock.output;\r\n}\r\n\r\n/**\r\n * Creates the blocks that represent a gradient value\r\n * This can be either a single value or a random between two values\r\n * @param gradientStep The gradient step data\r\n * @param randomLockMode The lock mode to use for random values\r\n * @param prefix The prefix to use for naming the blocks\r\n * @param index The index of the gradient step\r\n * @returns The output connection point of the gradient value block\r\n */\r\nfunction _CreateGradientValueBlockGroup(\r\n    gradientStep: FactorGradient | ColorGradient,\r\n    randomLockMode: ParticleRandomBlockLocks,\r\n    prefix: string,\r\n    index: number\r\n): NodeParticleConnectionPoint {\r\n    const gradientValueBlock = new ParticleGradientValueBlock(prefix + \" Gradient Value \" + index);\r\n    gradientValueBlock.reference = gradientStep.gradient;\r\n\r\n    const value1 = (gradientStep as any).factor1 ?? (gradientStep as any).color1;\r\n    const value2 = (gradientStep as any).factor2 ?? (gradientStep as any).color2;\r\n\r\n    if (value2 !== undefined) {\r\n        // Create a random between value1 and value2\r\n        const randomBlock = new ParticleRandomBlock(\"Random Value \" + index);\r\n        randomBlock.lockMode = randomLockMode;\r\n        _CreateAndConnectInput(\"Value 1\", value1, randomBlock.min);\r\n        _CreateAndConnectInput(\"Value 2\", value2, randomBlock.max);\r\n        randomBlock.output.connectTo(gradientValueBlock.value);\r\n    } else {\r\n        // Single value\r\n        _CreateAndConnectInput(\"Value\", value1, gradientValueBlock.value);\r\n    }\r\n\r\n    return gradientValueBlock.output;\r\n}\r\n\r\nfunction _CreateTextureBlock(texture: Nullable<BaseTexture>): NodeParticleConnectionPoint {\r\n    // Texture\r\n    const textureBlock = new ParticleTextureSourceBlock(\"Texture\");\r\n    const url = (texture as Texture).url || \"\";\r\n    if (url) {\r\n        textureBlock.url = url;\r\n    } else {\r\n        textureBlock.sourceTexture = texture;\r\n    }\r\n\r\n    return textureBlock.texture;\r\n}\r\n"]}