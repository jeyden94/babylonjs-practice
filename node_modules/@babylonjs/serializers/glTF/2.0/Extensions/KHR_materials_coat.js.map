{"version":3,"file":"KHR_materials_coat.js","sourceRoot":"","sources":["../../../../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_coat.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IMaterial, IKHRMaterialsCoat } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\nimport { MergeTexturesAsync, CreateRGBAConfiguration, CreateTextureInput, CreateConstantInput } from \"core/Materials/Textures/textureMerger\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { InternalTexture } from \"core/Materials/Textures/internalTexture\";\r\n\r\nconst NAME = \"KHR_materials_coat\";\r\n\r\n// Convert OpenPBR anisotropy values to glTF-compatible values\r\nfunction OpenpbrAnisotropyStrengthToGltf(baseRoughness: number, anisotropy: number) {\r\n    const baseAlpha = baseRoughness * baseRoughness;\r\n    const roughnessT = baseAlpha * Math.sqrt(2.0 / (1.0 + (1 - anisotropy) * (1 - anisotropy)));\r\n    const roughnessB = (1 - anisotropy) * roughnessT;\r\n    const newBaseRoughness = Math.sqrt(roughnessB);\r\n    const newAnisotropyStrength = Math.min(Math.sqrt((roughnessT - baseAlpha) / Math.max(1.0 - baseAlpha, 0.0001)), 1.0);\r\n\r\n    return { newBaseRoughness, newAnisotropyStrength };\r\n}\r\n\r\n/**\r\n * Generate a unique ID for the merged anisotropy textures based on the internal texture data.\r\n * This is used for caching merged textures.\r\n * @param babylonMaterial Source OpenPBR material\r\n * @returns A unique ID string for the merged anisotropy textures\r\n * @internal\r\n */\r\nfunction GetAnisoTextureId(babylonMaterial: OpenPBRMaterial): string {\r\n    const anisoStrengthTexture: Nullable<BaseTexture> = babylonMaterial.coatRoughnessAnisotropyTexture;\r\n    const tangentTexture = babylonMaterial.geometryCoatTangentTexture;\r\n    const strengthId = anisoStrengthTexture && anisoStrengthTexture.getInternalTexture() ? anisoStrengthTexture!.getInternalTexture()!.uniqueId : \"NoStrength\";\r\n    const tangentId = tangentTexture && tangentTexture.getInternalTexture() ? tangentTexture!.getInternalTexture()!.uniqueId : \"NoTangent\";\r\n    return `${strengthId}_${tangentId}`;\r\n}\r\n\r\n/**\r\n * Generate a unique ID for the merged coat textures based on the internal texture data.\r\n * This is used for caching merged textures.\r\n * @param babylonMaterial Source OpenPBR material\r\n * @returns A unique ID string for the merged coat textures\r\n * @internal\r\n */\r\nfunction GetCoatTextureId(babylonMaterial: OpenPBRMaterial): string {\r\n    const coatTexture: Nullable<BaseTexture> = babylonMaterial.coatWeightTexture;\r\n    const coatId = coatTexture && coatTexture.getInternalTexture() ? coatTexture!.getInternalTexture()!.uniqueId : \"NoCoat\";\r\n    const coatRoughnessTexture: Nullable<BaseTexture> = babylonMaterial.coatRoughnessTexture;\r\n    const roughnessId = coatRoughnessTexture && coatRoughnessTexture.getInternalTexture() ? coatRoughnessTexture!.getInternalTexture()!.uniqueId : \"NoRoughness\";\r\n    return `${coatId}_${roughnessId}`;\r\n}\r\n\r\n/**\r\n * Creates a new texture with the anisotropy data merged together for export.\r\n * @param babylonMaterial The source OpenPBR material\r\n * @returns A new texture with the merged anisotropy data\r\n * @internal\r\n */\r\nasync function CreateMergedAnisotropyTexture(babylonMaterial: OpenPBRMaterial): Promise<Nullable<BaseTexture>> {\r\n    const scene = babylonMaterial.getScene();\r\n\r\n    const anisoStrengthTexture: Nullable<BaseTexture> = babylonMaterial.coatRoughnessAnisotropyTexture;\r\n    const tangentTexture = babylonMaterial.geometryCoatTangentTexture;\r\n\r\n    // If we don't have any textures, we don't need to generate anything.\r\n    if (!(anisoStrengthTexture || tangentTexture)) {\r\n        return null;\r\n    }\r\n\r\n    return await MergeTexturesAsync(\r\n        \"AnisotropyTexture\",\r\n        CreateRGBAConfiguration(\r\n            tangentTexture ? CreateTextureInput(tangentTexture, 0) : CreateConstantInput(1.0), // tangent x from red channel\r\n            tangentTexture ? CreateTextureInput(tangentTexture, 1) : CreateConstantInput(0.0), // tangent y from green channel\r\n            anisoStrengthTexture ? CreateTextureInput(anisoStrengthTexture, 0) : CreateConstantInput(1.0) // Anisotropy from red channel\r\n        ),\r\n        scene\r\n    );\r\n}\r\n\r\n/**\r\n * Using the coat weight and coat roughness textures, create a merged internal texture that can be used\r\n * for multiple textures (with potentially different transforms) on export.\r\n * @param babylonMaterial The source OpenPBR material\r\n * @returns A new, internal texture with the coat weight in the red channel and coat roughness in the green channel\r\n * @internal\r\n */\r\nasync function CreateMergedCoatInternalTextureAsync(babylonMaterial: OpenPBRMaterial): Promise<Nullable<InternalTexture>> {\r\n    const scene = babylonMaterial.getScene();\r\n    const coatTexture: Nullable<BaseTexture> = babylonMaterial.coatWeightTexture;\r\n    const coatRoughnessTexture: Nullable<BaseTexture> = babylonMaterial.coatRoughnessTexture;\r\n    // If we don't have any textures, we don't need to generate anything.\r\n    if (!(coatTexture || coatRoughnessTexture)) {\r\n        return null;\r\n    }\r\n\r\n    const texture = await MergeTexturesAsync(\r\n        \"CoatTexture\",\r\n        CreateRGBAConfiguration(\r\n            coatTexture ? CreateTextureInput(coatTexture, 0) : CreateConstantInput(1.0), // coat weight from red channel\r\n            // coat roughness goes in the green channel but may come from red or green channels in the source\r\n            coatRoughnessTexture ? CreateTextureInput(coatRoughnessTexture, babylonMaterial._useCoatRoughnessFromGreenChannel ? 1 : 0) : CreateConstantInput(1.0)\r\n        ),\r\n        scene\r\n    );\r\n\r\n    return texture.getInternalTexture();\r\n}\r\n\r\n/**\r\n * Creates a temporary texture based on the source texture.\r\n * @param internalTexture The source internal texture\r\n * @param sourceTexture The source of the new texture's name, and sampler info\r\n * @returns The new texture\r\n */\r\nfunction CreateTempTexture(internalTexture: InternalTexture, sourceTexture: BaseTexture): Texture {\r\n    const tempTexture = new Texture(sourceTexture.name, sourceTexture.getScene());\r\n    tempTexture._texture = internalTexture;\r\n    tempTexture.coordinatesIndex = sourceTexture.coordinatesIndex;\r\n    if (sourceTexture instanceof Texture) {\r\n        tempTexture.uOffset = sourceTexture.uOffset;\r\n        tempTexture.vOffset = sourceTexture.vOffset;\r\n        tempTexture.uScale = sourceTexture.uScale;\r\n        tempTexture.vScale = sourceTexture.vScale;\r\n        tempTexture.wAng = sourceTexture.wAng;\r\n    }\r\n    tempTexture.wrapU = sourceTexture.wrapU;\r\n    tempTexture.wrapV = sourceTexture.wrapV;\r\n    return tempTexture;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_coat implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /**\r\n     * Cache that holds temporary merged textures created during export\r\n     */\r\n    private _mergedTexturesMap: Record<string, BaseTexture> = {};\r\n\r\n    /**\r\n     * Cache that holds internal textures of merged textures created during export\r\n     */\r\n    private _cachedInternalTexturesMap: Record<string, InternalTexture> = {};\r\n\r\n    public dispose() {\r\n        for (const key of Object.keys(this._mergedTexturesMap)) {\r\n            const texture = this._mergedTexturesMap[key];\r\n            texture.dispose();\r\n        }\r\n        this._mergedTexturesMap = {};\r\n        for (const key of Object.keys(this._cachedInternalTexturesMap)) {\r\n            const internalTexture = this._cachedInternalTexturesMap[key];\r\n            internalTexture.dispose();\r\n        }\r\n        this._cachedInternalTexturesMap = {};\r\n    }\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.clearCoat.isEnabled) {\r\n                if (babylonMaterial.clearCoat.texture) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.texture);\r\n                }\r\n                if (!babylonMaterial.clearCoat.useRoughnessFromMainTexture && babylonMaterial.clearCoat.textureRoughness) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.textureRoughness);\r\n                }\r\n                if (babylonMaterial.clearCoat.bumpTexture) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.bumpTexture);\r\n                }\r\n                if (babylonMaterial.clearCoat.tintTexture) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.tintTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n            if (babylonMaterial.coatWeight > 0) {\r\n                // We will merge the coat_weight and coat_roughness textures, if needed.\r\n                // However, we want to retain the original texture's transforms and sampling info.\r\n                let coatNeedsMerge = false;\r\n                if (babylonMaterial.coatWeightTexture) {\r\n                    // If we don't have a coat_roughness texture or if the coat_weight and coat_roughness\r\n                    // textures are already merged, export them as-is.\r\n                    if (!babylonMaterial.coatRoughnessTexture) {\r\n                        additionalTextures.push(babylonMaterial.coatWeightTexture);\r\n                    } else if (\r\n                        babylonMaterial._useCoatRoughnessFromGreenChannel &&\r\n                        babylonMaterial.coatWeightTexture.getInternalTexture() === babylonMaterial.coatRoughnessTexture.getInternalTexture()\r\n                    ) {\r\n                        additionalTextures.push(babylonMaterial.coatWeightTexture);\r\n                        additionalTextures.push(babylonMaterial.coatRoughnessTexture);\r\n                    } else {\r\n                        coatNeedsMerge = true;\r\n                    }\r\n                } else if (babylonMaterial.coatRoughnessTexture) {\r\n                    if (babylonMaterial._useCoatRoughnessFromGreenChannel) {\r\n                        additionalTextures.push(babylonMaterial.coatRoughnessTexture);\r\n                    } else {\r\n                        coatNeedsMerge = true;\r\n                    }\r\n                }\r\n                if (coatNeedsMerge) {\r\n                    // Merge the two textures together but retain the transforms for each.\r\n                    // We do this by caching the internal texture that is created during the merge,\r\n                    // and then creating temporary textures that use that internal texture but\r\n                    // have the original texture's transforms/sampling info.\r\n                    const texId = GetCoatTextureId(babylonMaterial);\r\n                    if (!this._cachedInternalTexturesMap[texId]) {\r\n                        const internalTexture = await CreateMergedCoatInternalTextureAsync(babylonMaterial);\r\n                        if (internalTexture) {\r\n                            this._cachedInternalTexturesMap[texId] = internalTexture;\r\n                        }\r\n                    }\r\n                    if (this._cachedInternalTexturesMap[texId]) {\r\n                        if (babylonMaterial.coatWeightTexture) {\r\n                            this._mergedTexturesMap[babylonMaterial.coatWeightTexture.uniqueId] = CreateTempTexture(\r\n                                this._cachedInternalTexturesMap[texId],\r\n                                babylonMaterial.coatWeightTexture\r\n                            );\r\n                            additionalTextures.push(this._mergedTexturesMap[babylonMaterial.coatWeightTexture.uniqueId]);\r\n                        }\r\n                        if (babylonMaterial.coatRoughnessTexture) {\r\n                            this._mergedTexturesMap[babylonMaterial.coatRoughnessTexture.uniqueId] = CreateTempTexture(\r\n                                this._cachedInternalTexturesMap[texId],\r\n                                babylonMaterial.coatRoughnessTexture\r\n                            );\r\n                            additionalTextures.push(this._mergedTexturesMap[babylonMaterial.coatRoughnessTexture.uniqueId]);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (babylonMaterial.geometryCoatNormalTexture) {\r\n                    additionalTextures.push(babylonMaterial.geometryCoatNormalTexture);\r\n                }\r\n\r\n                if (babylonMaterial.coatColorTexture) {\r\n                    additionalTextures.push(babylonMaterial.coatColorTexture);\r\n                }\r\n                if (babylonMaterial.coatRoughnessAnisotropy > 0) {\r\n                    const texId = GetAnisoTextureId(babylonMaterial);\r\n                    if (this._mergedTexturesMap[texId]) {\r\n                        additionalTextures.push(this._mergedTexturesMap[texId]);\r\n                    } else {\r\n                        const anisoTexture = await CreateMergedAnisotropyTexture(babylonMaterial);\r\n                        if (anisoTexture) {\r\n                            additionalTextures.push(anisoTexture);\r\n                            this._mergedTexturesMap[texId] = anisoTexture;\r\n                        }\r\n                    }\r\n                    return additionalTextures;\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.clearCoat.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const coatTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.texture);\r\n                let coatTextureRoughnessInfo;\r\n                if (babylonMaterial.clearCoat.useRoughnessFromMainTexture) {\r\n                    coatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.texture);\r\n                } else {\r\n                    coatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.textureRoughness);\r\n                }\r\n\r\n                let coatColorTextureInfo;\r\n                if (babylonMaterial.clearCoat.isTintEnabled) {\r\n                    coatColorTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.tintTexture);\r\n                }\r\n\r\n                const coatNormalTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.bumpTexture);\r\n                const coatIor: number = babylonMaterial.clearCoat.indexOfRefraction;\r\n\r\n                const coatInfo: IKHRMaterialsCoat = {\r\n                    coatFactor: babylonMaterial.clearCoat.intensity,\r\n                    coatTexture: coatTextureInfo ?? undefined,\r\n                    coatRoughnessFactor: babylonMaterial.clearCoat.roughness,\r\n                    coatRoughnessTexture: coatTextureRoughnessInfo ?? undefined,\r\n                    coatNormalTexture: coatNormalTextureInfo ?? undefined,\r\n                    coatColorFactor: babylonMaterial.clearCoat.tintColor.asArray(),\r\n                    coatColorTexture: coatColorTextureInfo ?? undefined,\r\n                    coatIor: coatIor !== 1.5 ? coatIor : undefined,\r\n                };\r\n\r\n                if (coatInfo.coatTexture !== null || coatInfo.coatRoughnessTexture !== null || coatInfo.coatRoughnessTexture !== null || coatInfo.coatColorTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = coatInfo;\r\n            } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                if (babylonMaterial.coatWeight == 0.0) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                let coatWeightTexture: Nullable<BaseTexture> = null;\r\n                let coatTextureInfo;\r\n                if (babylonMaterial.coatWeightTexture) {\r\n                    if (this._mergedTexturesMap[babylonMaterial.coatWeightTexture.uniqueId]) {\r\n                        coatWeightTexture = this._mergedTexturesMap[babylonMaterial.coatWeightTexture.uniqueId];\r\n                    } else {\r\n                        coatWeightTexture = babylonMaterial.coatWeightTexture;\r\n                    }\r\n                    coatTextureInfo = this._exporter._materialExporter.getTextureInfo(coatWeightTexture);\r\n                }\r\n\r\n                let coatRoughnessTexture: Nullable<BaseTexture> = null;\r\n                let coatRoughnessTextureInfo;\r\n                if (babylonMaterial.coatRoughnessTexture) {\r\n                    if (this._mergedTexturesMap[babylonMaterial.coatRoughnessTexture.uniqueId]) {\r\n                        coatRoughnessTexture = this._mergedTexturesMap[babylonMaterial.coatRoughnessTexture.uniqueId];\r\n                    } else {\r\n                        coatRoughnessTexture = babylonMaterial.coatRoughnessTexture;\r\n                    }\r\n                    coatRoughnessTextureInfo = this._exporter._materialExporter.getTextureInfo(coatRoughnessTexture);\r\n                }\r\n\r\n                const coatNormalTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.geometryCoatNormalTexture);\r\n                const coatColorTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.coatColorTexture);\r\n                const coatIor: number = babylonMaterial.coatIor;\r\n                const coatDarkeningFactor = babylonMaterial.coatDarkening;\r\n\r\n                // Check if we can convert from OpenPBR anisotropy to glTF anisotropy\r\n                // Conversion involves both specular roughness and anisotropic roughness changes so,\r\n                // if there are textures for either, we can't reliably convert due to there potentially\r\n                // being different mappings between the textures.\r\n                const roughnessTexture: Nullable<BaseTexture> = babylonMaterial.coatRoughnessTexture;\r\n                const texId = GetAnisoTextureId(babylonMaterial);\r\n                const mergedAnisoTexture = this._mergedTexturesMap[texId];\r\n                let coatAnisotropyStrength = 0;\r\n                let coatAnisotropyRotation = 0;\r\n                let coatAnisotropyTexture = undefined;\r\n                if (babylonMaterial.coatRoughnessAnisotropy > 0.0) {\r\n                    // If no textures are being used, we'll always output glTF-style anisotropy.\r\n                    // If using OpenPBR anisotropy, convert the constants. Otherwise, just export what we have.\r\n                    if (!roughnessTexture && !mergedAnisoTexture) {\r\n                        // Convert constants\r\n                        let newBaseRoughness = babylonMaterial.coatRoughness;\r\n                        let newAnisotropyStrength = babylonMaterial.coatRoughnessAnisotropy;\r\n                        if (!babylonMaterial._useGltfStyleAnisotropy) {\r\n                            const newParams = OpenpbrAnisotropyStrengthToGltf(babylonMaterial.coatRoughness, babylonMaterial.coatRoughnessAnisotropy);\r\n                            newBaseRoughness = newParams.newBaseRoughness;\r\n                            newAnisotropyStrength = newParams.newAnisotropyStrength;\r\n                        }\r\n                        if (node.pbrMetallicRoughness) {\r\n                            node.pbrMetallicRoughness.roughnessFactor = newBaseRoughness;\r\n                        }\r\n                        coatAnisotropyStrength = newAnisotropyStrength;\r\n                        coatAnisotropyRotation = babylonMaterial.geometryCoatTangentAngle + Math.PI * 0.5;\r\n                        coatAnisotropyTexture = undefined;\r\n                    } else {\r\n                        const mergedAnisoTextureInfo = mergedAnisoTexture ? this._exporter._materialExporter.getTextureInfo(mergedAnisoTexture) : null;\r\n\r\n                        coatAnisotropyStrength = babylonMaterial.coatRoughnessAnisotropy;\r\n                        coatAnisotropyRotation = babylonMaterial.geometryCoatTangentAngle;\r\n                        coatAnisotropyTexture = mergedAnisoTextureInfo ? mergedAnisoTextureInfo : undefined;\r\n                    }\r\n\r\n                    if (!babylonMaterial._useGltfStyleAnisotropy) {\r\n                        // Enable OpenPBR extension on this material.\r\n                        node.extensions![\"KHR_materials_openpbr\"] = {};\r\n                        this._exporter._glTF.extensionsUsed ||= [];\r\n                        if (this._exporter._glTF.extensionsUsed.indexOf(\"KHR_materials_openpbr\") === -1) {\r\n                            this._exporter._glTF.extensionsUsed.push(\"KHR_materials_openpbr\");\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const coatInfo: IKHRMaterialsCoat = {\r\n                    coatFactor: babylonMaterial.coatWeight,\r\n                    coatTexture: coatTextureInfo ?? undefined,\r\n                    coatRoughnessFactor: babylonMaterial.coatRoughness,\r\n                    coatRoughnessTexture: coatRoughnessTextureInfo ?? undefined,\r\n                    coatNormalTexture: coatNormalTextureInfo ?? undefined,\r\n                    coatColorFactor: babylonMaterial.coatColor.asArray(),\r\n                    coatColorTexture: coatColorTextureInfo ?? undefined,\r\n                    coatIor: coatIor !== 1.5 ? coatIor : undefined,\r\n                    coatDarkeningFactor: coatDarkeningFactor !== 1.0 ? coatDarkeningFactor : undefined,\r\n                    coatAnisotropyRotation: coatAnisotropyRotation,\r\n                    coatAnisotropyStrength: coatAnisotropyStrength,\r\n                    coatAnisotropyTexture: coatAnisotropyTexture,\r\n                };\r\n\r\n                if (\r\n                    coatInfo.coatTexture !== null ||\r\n                    coatInfo.coatRoughnessTexture !== null ||\r\n                    coatInfo.coatRoughnessTexture !== null ||\r\n                    coatInfo.coatAnisotropyTexture !== null ||\r\n                    coatInfo.coatColorTexture !== null\r\n                ) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = coatInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_coat(exporter));\r\n"]}