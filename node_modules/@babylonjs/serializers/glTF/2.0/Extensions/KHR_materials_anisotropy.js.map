{"version":3,"file":"KHR_materials_anisotropy.js","sourceRoot":"","sources":["../../../../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,YAAY,EAAE,MAAM,iBAAiB,CAAC;AAG/C,OAAO,EAAE,eAAe,EAAE,yDAA2C;AAErE,OAAO,EAAE,eAAe,EAAE,yDAA2C;AAErE,OAAO,EAAE,kBAAkB,EAAE,uBAAuB,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,4DAA8C;AAE7I,MAAM,IAAI,GAAG,0BAA0B,CAAC;AAExC,8DAA8D;AAC9D,SAAS,+BAA+B,CAAC,aAAqB,EAAE,UAAkB;IAC9E,MAAM,SAAS,GAAG,aAAa,GAAG,aAAa,CAAC;IAChD,MAAM,UAAU,GAAG,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;IAC5F,MAAM,UAAU,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,GAAG,UAAU,CAAC;IACjD,MAAM,gBAAgB,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAC/C,MAAM,qBAAqB,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,UAAU,GAAG,SAAS,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,SAAS,EAAE,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;IAErH,OAAO,EAAE,gBAAgB,EAAE,qBAAqB,EAAE,CAAC;AACvD,CAAC;AAED;;;;;;GAMG;AACH,SAAS,iBAAiB,CAAC,eAAgC;IACvD,MAAM,oBAAoB,GAA0B,eAAe,CAAC,kCAAkC,CAAC;IACvG,MAAM,cAAc,GAAG,eAAe,CAAC,sBAAsB,CAAC;IAC9D,MAAM,UAAU,GAAG,oBAAoB,IAAI,oBAAoB,CAAC,kBAAkB,EAAE,CAAC,CAAC,CAAC,oBAAqB,CAAC,kBAAkB,EAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,YAAY,CAAC;IAC3J,MAAM,SAAS,GAAG,cAAc,IAAI,cAAc,CAAC,kBAAkB,EAAE,CAAC,CAAC,CAAC,cAAe,CAAC,kBAAkB,EAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,WAAW,CAAC;IACvI,OAAO,GAAG,UAAU,IAAI,SAAS,EAAE,CAAC;AACxC,CAAC;AAED,0CAA0C;AAC1C,KAAK,UAAU,6BAA6B,CAAC,eAAgC;IACzE,MAAM,KAAK,GAAG,eAAe,CAAC,QAAQ,EAAE,CAAC;IAEzC,MAAM,oBAAoB,GAA0B,eAAe,CAAC,kCAAkC,CAAC;IACvG,MAAM,cAAc,GAAG,eAAe,CAAC,sBAAsB,CAAC;IAE9D,qEAAqE;IACrE,IAAI,CAAC,CAAC,oBAAoB,IAAI,cAAc,CAAC,EAAE,CAAC;QAC5C,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,OAAO,MAAM,kBAAkB,CAC3B,mBAAmB,EACnB,uBAAuB,CACnB,cAAc,CAAC,CAAC,CAAC,kBAAkB,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,mBAAmB,CAAC,GAAG,CAAC,EAAE,6BAA6B;IAChH,cAAc,CAAC,CAAC,CAAC,kBAAkB,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,mBAAmB,CAAC,GAAG,CAAC,EAAE,+BAA+B;IAClH,oBAAoB,CAAC,CAAC,CAAC,kBAAkB,CAAC,oBAAoB,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,8BAA8B;KAC/H,EACD,KAAK,CACR,CAAC;AACN,CAAC;AAED;;GAEG;AACH,gEAAgE;AAChE,MAAM,OAAO,wBAAwB;IAgBjC,YAAY,QAAsB;QAflC,6BAA6B;QACb,SAAI,GAAG,IAAI,CAAC;QAE5B,gDAAgD;QACzC,YAAO,GAAG,IAAI,CAAC;QAEtB,iDAAiD;QAC1C,aAAQ,GAAG,KAAK,CAAC;QAIhB,aAAQ,GAAG,KAAK,CAAC;QAEjB,sBAAiB,GAAsC,EAAE,CAAC;QAG9D,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;IAC9B,CAAC;IAEM,OAAO,KAAI,CAAC;IAEnB,gBAAgB;IAChB,IAAW,OAAO;QACd,OAAO,IAAI,CAAC,QAAQ,CAAC;IACzB,CAAC;IAED;;;;;;OAMG;IACI,KAAK,CAAC,yCAAyC,CAAE,OAAe,EAAE,IAAe,EAAE,eAAyB;QAC/G,MAAM,kBAAkB,GAAkB,EAAE,CAAC;QAC7C,IAAI,eAAe,YAAY,eAAe,EAAE,CAAC;YAC7C,IAAI,eAAe,CAAC,UAAU,CAAC,SAAS,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;gBAC7E,IAAI,eAAe,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC;oBACrC,kBAAkB,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;gBAChE,CAAC;gBACD,OAAO,kBAAkB,CAAC;YAC9B,CAAC;QACL,CAAC;aAAM,IAAI,eAAe,YAAY,eAAe,EAAE,CAAC;YACpD,IAAI,eAAe,CAAC,2BAA2B,GAAG,CAAC,EAAE,CAAC;gBAClD,MAAM,KAAK,GAAG,iBAAiB,CAAC,eAAe,CAAC,CAAC;gBACjD,IAAI,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE,CAAC;oBAChC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC,CAAC;gBAC3D,CAAC;qBAAM,CAAC;oBACJ,MAAM,YAAY,GAAG,MAAM,6BAA6B,CAAC,eAAe,CAAC,CAAC;oBAC1E,IAAI,YAAY,EAAE,CAAC;wBACf,kBAAkB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;wBACtC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC;oBACjD,CAAC;gBACL,CAAC;gBACD,OAAO,kBAAkB,CAAC;YAC9B,CAAC;QACL,CAAC;QAED,OAAO,EAAE,CAAC;IACd,CAAC;IAED,gDAAgD;IACzC,uBAAuB,CAAE,OAAe,EAAE,IAAe,EAAE,eAAyB;QACvF,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;;YAC3B,IAAI,eAAe,YAAY,eAAe,EAAE,CAAC;gBAC7C,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,SAAS,IAAI,eAAe,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;oBAC7E,OAAO,CAAC,IAAI,CAAC,CAAC;oBACd,OAAO;gBACX,CAAC;gBAED,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;gBAErB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,IAAI,EAAE,CAAC;gBAExC,MAAM,qBAAqB,GAAG,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,cAAc,CAAC,eAAe,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;gBAElH,MAAM,cAAc,GAA4B;oBAC5C,kBAAkB,EAAE,eAAe,CAAC,UAAU,CAAC,SAAS;oBACxD,kBAAkB,EAAE,eAAe,CAAC,UAAU,CAAC,KAAK;oBACpD,iBAAiB,EAAE,qBAAqB,IAAI,SAAS;iBACxD,CAAC;gBAEF,IAAI,cAAc,CAAC,iBAAiB,KAAK,IAAI,EAAE,CAAC;oBAC5C,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;gBAC7D,CAAC;gBAED,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,cAAc,CAAC;YAC3C,CAAC;iBAAM,IAAI,eAAe,YAAY,eAAe,EAAE,CAAC;gBACpD,IAAI,eAAe,CAAC,2BAA2B,GAAG,CAAC,EAAE,CAAC;oBAClD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;oBAErB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,IAAI,EAAE,CAAC;oBAExC,qEAAqE;oBACrE,oFAAoF;oBACpF,uFAAuF;oBACvF,iDAAiD;oBACjD,IAAI,gBAAgB,GAA0B,eAAe,CAAC,wBAAwB,CAAC;oBACvF,IAAI,eAAe,CAAC,qCAAqC,EAAE,CAAC;wBACxD,gBAAgB,GAAG,eAAe,CAAC,oBAAoB,CAAC;oBAC5D,CAAC;oBACD,MAAM,kBAAkB,GAAG,IAAI,CAAC,iBAAiB,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC;oBAEtE,4EAA4E;oBAC5E,2FAA2F;oBAC3F,IAAI,CAAC,gBAAgB,IAAI,CAAC,kBAAkB,EAAE,CAAC;wBAC3C,oBAAoB;wBACpB,IAAI,gBAAgB,GAAG,eAAe,CAAC,iBAAiB,CAAC;wBACzD,IAAI,qBAAqB,GAAG,eAAe,CAAC,2BAA2B,CAAC;wBACxE,IAAI,CAAC,eAAe,CAAC,uBAAuB,EAAE,CAAC;4BAC3C,MAAM,SAAS,GAAG,+BAA+B,CAAC,eAAe,CAAC,iBAAiB,EAAE,eAAe,CAAC,2BAA2B,CAAC,CAAC;4BAClI,gBAAgB,GAAG,SAAS,CAAC,gBAAgB,CAAC;4BAC9C,qBAAqB,GAAG,SAAS,CAAC,qBAAqB,CAAC;wBAC5D,CAAC;wBACD,IAAI,IAAI,CAAC,oBAAoB,EAAE,CAAC;4BAC5B,IAAI,CAAC,oBAAoB,CAAC,eAAe,GAAG,gBAAgB,CAAC;wBACjE,CAAC;wBACD,MAAM,cAAc,GAA4B;4BAC5C,kBAAkB,EAAE,qBAAqB;4BACzC,kBAAkB,EAAE,eAAe,CAAC,oBAAoB,GAAG,IAAI,CAAC,EAAE,GAAG,GAAG;4BACxE,iBAAiB,EAAE,SAAS;yBAC/B,CAAC;wBACF,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,cAAc,CAAC;wBACvC,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC;oBACzB,CAAC;oBAED,MAAM,sBAAsB,GAAG,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,cAAc,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;oBAE/H,MAAM,cAAc,GAA4B;wBAC5C,kBAAkB,EAAE,eAAe,CAAC,2BAA2B;wBAC/D,kBAAkB,EAAE,eAAe,CAAC,oBAAoB;wBACxD,iBAAiB,EAAE,sBAAsB,CAAC,CAAC,CAAC,sBAAsB,CAAC,CAAC,CAAC,SAAS;wBAC9E,UAAU,EAAE,EAAE;qBACjB,CAAC;oBAEF,IAAI,CAAC,eAAe,CAAC,uBAAuB,EAAE,CAAC;wBAC3C,6CAA6C;wBAC7C,IAAI,CAAC,UAAW,CAAC,uBAAuB,CAAC,GAAG,EAAE,CAAC;wBAC/C,MAAA,IAAI,CAAC,SAAS,CAAC,KAAK,EAAC,cAAc,QAAd,cAAc,GAAK,EAAE,EAAC;wBAC3C,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,cAAc,CAAC,OAAO,CAAC,uBAAuB,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;4BAC9E,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC;wBACtE,CAAC;oBACL,CAAC;oBAED,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;oBAEzD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,cAAc,CAAC;gBAC3C,CAAC;YACL,CAAC;YACD,OAAO,CAAC,IAAI,CAAC,CAAC;QAClB,CAAC,CAAC,CAAC;IACP,CAAC;CACJ;AAED,YAAY,CAAC,iBAAiB,CAAC,IAAI,EAAE,CAAC,QAAQ,EAAE,EAAE,CAAC,IAAI,wBAAwB,CAAC,QAAQ,CAAC,CAAC,CAAC","sourcesContent":["import type { IMaterial, IKHRMaterialsAnisotropy } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\nimport type { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport { MergeTexturesAsync, CreateRGBAConfiguration, CreateTextureInput, CreateConstantInput } from \"core/Materials/Textures/textureMerger\";\r\n\r\nconst NAME = \"KHR_materials_anisotropy\";\r\n\r\n// Convert OpenPBR anisotropy values to glTF-compatible values\r\nfunction OpenpbrAnisotropyStrengthToGltf(baseRoughness: number, anisotropy: number) {\r\n    const baseAlpha = baseRoughness * baseRoughness;\r\n    const roughnessT = baseAlpha * Math.sqrt(2.0 / (1.0 + (1 - anisotropy) * (1 - anisotropy)));\r\n    const roughnessB = (1 - anisotropy) * roughnessT;\r\n    const newBaseRoughness = Math.sqrt(roughnessB);\r\n    const newAnisotropyStrength = Math.min(Math.sqrt((roughnessT - baseAlpha) / Math.max(1.0 - baseAlpha, 0.0001)), 1.0);\r\n\r\n    return { newBaseRoughness, newAnisotropyStrength };\r\n}\r\n\r\n/**\r\n * Generate a unique ID for the merged anisotropy textures based on the internal texture data.\r\n * This is used for caching merged textures.\r\n * @param babylonMaterial Source OpenPBR material\r\n * @returns A unique ID string for the merged anisotropy textures\r\n * @internal\r\n */\r\nfunction GetAnisoTextureId(babylonMaterial: OpenPBRMaterial): string {\r\n    const anisoStrengthTexture: Nullable<BaseTexture> = babylonMaterial.specularRoughnessAnisotropyTexture;\r\n    const tangentTexture = babylonMaterial.geometryTangentTexture;\r\n    const strengthId = anisoStrengthTexture && anisoStrengthTexture.getInternalTexture() ? anisoStrengthTexture!.getInternalTexture()!.uniqueId : \"NoStrength\";\r\n    const tangentId = tangentTexture && tangentTexture.getInternalTexture() ? tangentTexture!.getInternalTexture()!.uniqueId : \"NoTangent\";\r\n    return `${strengthId}_${tangentId}`;\r\n}\r\n\r\n// In your postExportMaterialAsync method:\r\nasync function CreateMergedAnisotropyTexture(babylonMaterial: OpenPBRMaterial): Promise<Nullable<ProceduralTexture>> {\r\n    const scene = babylonMaterial.getScene();\r\n\r\n    const anisoStrengthTexture: Nullable<BaseTexture> = babylonMaterial.specularRoughnessAnisotropyTexture;\r\n    const tangentTexture = babylonMaterial.geometryTangentTexture;\r\n\r\n    // If we don't have any textures, we don't need to generate anything.\r\n    if (!(anisoStrengthTexture || tangentTexture)) {\r\n        return null;\r\n    }\r\n\r\n    return await MergeTexturesAsync(\r\n        \"AnisotropyTexture\",\r\n        CreateRGBAConfiguration(\r\n            tangentTexture ? CreateTextureInput(tangentTexture, 0) : CreateConstantInput(1.0), // tangent x from red channel\r\n            tangentTexture ? CreateTextureInput(tangentTexture, 1) : CreateConstantInput(0.0), // tangent y from green channel\r\n            anisoStrengthTexture ? CreateTextureInput(anisoStrengthTexture, 0) : CreateConstantInput(1.0) // Anisotropy from red channel\r\n        ),\r\n        scene\r\n    );\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_anisotropy implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    private _anisoTexturesMap: Record<string, ProceduralTexture> = {};\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with the additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.anisotropy.isEnabled && !babylonMaterial.anisotropy.legacy) {\r\n                if (babylonMaterial.anisotropy.texture) {\r\n                    additionalTextures.push(babylonMaterial.anisotropy.texture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n            if (babylonMaterial.specularRoughnessAnisotropy > 0) {\r\n                const texId = GetAnisoTextureId(babylonMaterial);\r\n                if (this._anisoTexturesMap[texId]) {\r\n                    additionalTextures.push(this._anisoTexturesMap[texId]);\r\n                } else {\r\n                    const anisoTexture = await CreateMergedAnisotropyTexture(babylonMaterial);\r\n                    if (anisoTexture) {\r\n                        additionalTextures.push(anisoTexture);\r\n                        this._anisoTexturesMap[texId] = anisoTexture;\r\n                    }\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.anisotropy.isEnabled || babylonMaterial.anisotropy.legacy) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const anisotropyTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.anisotropy.texture);\r\n\r\n                const anisotropyInfo: IKHRMaterialsAnisotropy = {\r\n                    anisotropyStrength: babylonMaterial.anisotropy.intensity,\r\n                    anisotropyRotation: babylonMaterial.anisotropy.angle,\r\n                    anisotropyTexture: anisotropyTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (anisotropyInfo.anisotropyTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = anisotropyInfo;\r\n            } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                if (babylonMaterial.specularRoughnessAnisotropy > 0) {\r\n                    this._wasUsed = true;\r\n\r\n                    node.extensions = node.extensions || {};\r\n\r\n                    // Check if we can convert from OpenPBR anisotropy to glTF anisotropy\r\n                    // Conversion involves both specular roughness and anisotropic roughness changes so,\r\n                    // if there are textures for either, we can't reliably convert due to there potentially\r\n                    // being different mappings between the textures.\r\n                    let roughnessTexture: Nullable<BaseTexture> = babylonMaterial.specularRoughnessTexture;\r\n                    if (babylonMaterial._useRoughnessFromMetallicTextureGreen) {\r\n                        roughnessTexture = babylonMaterial.baseMetalnessTexture;\r\n                    }\r\n                    const mergedAnisoTexture = this._anisoTexturesMap[babylonMaterial.id];\r\n\r\n                    // If no textures are being used, we'll always output glTF-style anisotropy.\r\n                    // If using OpenPBR anisotropy, convert the constants. Otherwise, just export what we have.\r\n                    if (!roughnessTexture && !mergedAnisoTexture) {\r\n                        // Convert constants\r\n                        let newBaseRoughness = babylonMaterial.specularRoughness;\r\n                        let newAnisotropyStrength = babylonMaterial.specularRoughnessAnisotropy;\r\n                        if (!babylonMaterial._useGltfStyleAnisotropy) {\r\n                            const newParams = OpenpbrAnisotropyStrengthToGltf(babylonMaterial.specularRoughness, babylonMaterial.specularRoughnessAnisotropy);\r\n                            newBaseRoughness = newParams.newBaseRoughness;\r\n                            newAnisotropyStrength = newParams.newAnisotropyStrength;\r\n                        }\r\n                        if (node.pbrMetallicRoughness) {\r\n                            node.pbrMetallicRoughness.roughnessFactor = newBaseRoughness;\r\n                        }\r\n                        const anisotropyInfo: IKHRMaterialsAnisotropy = {\r\n                            anisotropyStrength: newAnisotropyStrength,\r\n                            anisotropyRotation: babylonMaterial.geometryTangentAngle + Math.PI * 0.5,\r\n                            anisotropyTexture: undefined,\r\n                        };\r\n                        node.extensions[NAME] = anisotropyInfo;\r\n                        return resolve(node);\r\n                    }\r\n\r\n                    const mergedAnisoTextureInfo = mergedAnisoTexture ? this._exporter._materialExporter.getTextureInfo(mergedAnisoTexture) : null;\r\n\r\n                    const anisotropyInfo: IKHRMaterialsAnisotropy = {\r\n                        anisotropyStrength: babylonMaterial.specularRoughnessAnisotropy,\r\n                        anisotropyRotation: babylonMaterial.geometryTangentAngle,\r\n                        anisotropyTexture: mergedAnisoTextureInfo ? mergedAnisoTextureInfo : undefined,\r\n                        extensions: {},\r\n                    };\r\n\r\n                    if (!babylonMaterial._useGltfStyleAnisotropy) {\r\n                        // Enable OpenPBR extension on this material.\r\n                        node.extensions![\"KHR_materials_openpbr\"] = {};\r\n                        this._exporter._glTF.extensionsUsed ||= [];\r\n                        if (this._exporter._glTF.extensionsUsed.indexOf(\"KHR_materials_openpbr\") === -1) {\r\n                            this._exporter._glTF.extensionsUsed.push(\"KHR_materials_openpbr\");\r\n                        }\r\n                    }\r\n\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n\r\n                    node.extensions[NAME] = anisotropyInfo;\r\n                }\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_anisotropy(exporter));\r\n"]}