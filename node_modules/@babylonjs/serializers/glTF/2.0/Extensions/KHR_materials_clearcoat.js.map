{"version":3,"file":"KHR_materials_clearcoat.js","sourceRoot":"","sources":["../../../../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IMaterial, IKHRMaterialsClearcoat } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\nimport type { InternalTexture } from \"core/Materials/Textures/internalTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { MergeTexturesAsync, CreateRGBAConfiguration, CreateTextureInput, CreateConstantInput } from \"core/Materials/Textures/textureMerger\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nconst NAME = \"KHR_materials_clearcoat\";\r\n\r\n/**\r\n * Generate a unique ID for the merged coat textures based on the internal texture data.\r\n * This is used for caching merged textures.\r\n * @param babylonMaterial Source OpenPBR material\r\n * @returns A unique ID string for the merged coat textures\r\n * @internal\r\n */\r\nfunction GetCoatTextureId(babylonMaterial: OpenPBRMaterial): string {\r\n    const coatTexture: Nullable<BaseTexture> = babylonMaterial.coatWeightTexture;\r\n    const coatId = coatTexture && coatTexture.getInternalTexture() ? coatTexture!.getInternalTexture()!.uniqueId : \"NoCoat\";\r\n    const coatRoughnessTexture: Nullable<BaseTexture> = babylonMaterial.coatRoughnessTexture;\r\n    const roughnessId = coatRoughnessTexture && coatRoughnessTexture.getInternalTexture() ? coatRoughnessTexture!.getInternalTexture()!.uniqueId : \"NoRoughness\";\r\n    return `${coatId}_${roughnessId}`;\r\n}\r\n\r\n/**\r\n * Using the coat weight and coat roughness textures, create a merged internal texture that can be used\r\n * for multiple textures (with potentially different transforms) on export.\r\n * @param babylonMaterial The source OpenPBR material\r\n * @returns A new, internal texture with the coat weight in the red channel and coat roughness in the green channel\r\n * @internal\r\n */\r\nasync function CreateMergedCoatInternalTextureAsync(babylonMaterial: OpenPBRMaterial): Promise<Nullable<InternalTexture>> {\r\n    const scene = babylonMaterial.getScene();\r\n    const coatTexture: Nullable<BaseTexture> = babylonMaterial.coatWeightTexture;\r\n    const coatRoughnessTexture: Nullable<BaseTexture> = babylonMaterial.coatRoughnessTexture;\r\n    // If we don't have any textures, we don't need to generate anything.\r\n    if (!(coatTexture || coatRoughnessTexture)) {\r\n        return null;\r\n    }\r\n\r\n    const texture = await MergeTexturesAsync(\r\n        \"CoatTexture\",\r\n        CreateRGBAConfiguration(\r\n            coatTexture ? CreateTextureInput(coatTexture, 0) : CreateConstantInput(1.0), // coat weight from red channel\r\n            // coat roughness goes in the green channel but may come from red or green channels in the source\r\n            coatRoughnessTexture ? CreateTextureInput(coatRoughnessTexture, babylonMaterial._useCoatRoughnessFromGreenChannel ? 1 : 0) : CreateConstantInput(1.0)\r\n        ),\r\n        scene\r\n    );\r\n\r\n    return texture.getInternalTexture();\r\n}\r\n\r\n/**\r\n * Creates a temporary texture based on the source texture.\r\n * @param internalTexture The source internal texture\r\n * @param sourceTexture The source of the new texture's name, and sampler info\r\n * @returns The new texture\r\n */\r\nfunction CreateTempTexture(internalTexture: InternalTexture, sourceTexture: BaseTexture): Texture {\r\n    const tempTexture = new Texture(sourceTexture.name, sourceTexture.getScene());\r\n    tempTexture._texture = internalTexture;\r\n    tempTexture.coordinatesIndex = sourceTexture.coordinatesIndex;\r\n    if (sourceTexture instanceof Texture) {\r\n        tempTexture.uOffset = sourceTexture.uOffset;\r\n        tempTexture.vOffset = sourceTexture.vOffset;\r\n        tempTexture.uScale = sourceTexture.uScale;\r\n        tempTexture.vScale = sourceTexture.vScale;\r\n        tempTexture.wAng = sourceTexture.wAng;\r\n    }\r\n    tempTexture.wrapU = sourceTexture.wrapU;\r\n    tempTexture.wrapV = sourceTexture.wrapV;\r\n    return tempTexture;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_clearcoat implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /**\r\n     * Cache that holds temporary merged textures created during export\r\n     */\r\n    private _mergedTexturesMap: Record<string, BaseTexture> = {};\r\n\r\n    /**\r\n     * Cache that holds internal textures of merged textures created during export\r\n     */\r\n    private _cachedInternalTexturesMap: Record<string, InternalTexture> = {};\r\n\r\n    public dispose() {\r\n        for (const key of Object.keys(this._mergedTexturesMap)) {\r\n            const texture = this._mergedTexturesMap[key];\r\n            texture.dispose();\r\n        }\r\n        this._mergedTexturesMap = {};\r\n        for (const key of Object.keys(this._cachedInternalTexturesMap)) {\r\n            const internalTexture = this._cachedInternalTexturesMap[key];\r\n            internalTexture.dispose();\r\n        }\r\n        this._cachedInternalTexturesMap = {};\r\n    }\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.clearCoat.isEnabled) {\r\n                if (babylonMaterial.clearCoat.texture) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.texture);\r\n                }\r\n                if (!babylonMaterial.clearCoat.useRoughnessFromMainTexture && babylonMaterial.clearCoat.textureRoughness) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.textureRoughness);\r\n                }\r\n                if (babylonMaterial.clearCoat.bumpTexture) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.bumpTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n            if (babylonMaterial.coatWeight > 0) {\r\n                // We will merge the coat_weight and coat_roughness textures, if needed.\r\n                // However, we want to retain the original texture's transforms and sampling info.\r\n                let coatNeedsMerge = false;\r\n                if (babylonMaterial.coatWeightTexture) {\r\n                    // If we don't have a coat_roughness texture or if the coat_weight and coat_roughness\r\n                    // textures are already merged, export them as-is.\r\n                    if (!babylonMaterial.coatRoughnessTexture) {\r\n                        additionalTextures.push(babylonMaterial.coatWeightTexture);\r\n                    } else if (\r\n                        babylonMaterial._useCoatRoughnessFromGreenChannel &&\r\n                        babylonMaterial.coatWeightTexture.getInternalTexture() === babylonMaterial.coatRoughnessTexture.getInternalTexture()\r\n                    ) {\r\n                        additionalTextures.push(babylonMaterial.coatWeightTexture);\r\n                        additionalTextures.push(babylonMaterial.coatRoughnessTexture);\r\n                    } else {\r\n                        coatNeedsMerge = true;\r\n                    }\r\n                } else if (babylonMaterial.coatRoughnessTexture) {\r\n                    if (babylonMaterial._useCoatRoughnessFromGreenChannel) {\r\n                        additionalTextures.push(babylonMaterial.coatRoughnessTexture);\r\n                    } else {\r\n                        coatNeedsMerge = true;\r\n                    }\r\n                }\r\n                if (coatNeedsMerge) {\r\n                    // Merge the two textures together but retain the transforms for each.\r\n                    // We do this by caching the internal texture that is created during the merge,\r\n                    // and then creating temporary textures that use that internal texture but\r\n                    // have the original texture's transforms/sampling info.\r\n                    const texId = GetCoatTextureId(babylonMaterial);\r\n                    if (!this._cachedInternalTexturesMap[texId]) {\r\n                        const internalTexture = await CreateMergedCoatInternalTextureAsync(babylonMaterial);\r\n                        if (internalTexture) {\r\n                            this._cachedInternalTexturesMap[texId] = internalTexture;\r\n                        }\r\n                    }\r\n                    if (this._cachedInternalTexturesMap[texId]) {\r\n                        if (babylonMaterial.coatWeightTexture) {\r\n                            this._mergedTexturesMap[babylonMaterial.coatWeightTexture.uniqueId] = CreateTempTexture(\r\n                                this._cachedInternalTexturesMap[texId],\r\n                                babylonMaterial.coatWeightTexture\r\n                            );\r\n                            additionalTextures.push(this._mergedTexturesMap[babylonMaterial.coatWeightTexture.uniqueId]);\r\n                        }\r\n                        if (babylonMaterial.coatRoughnessTexture) {\r\n                            this._mergedTexturesMap[babylonMaterial.coatRoughnessTexture.uniqueId] = CreateTempTexture(\r\n                                this._cachedInternalTexturesMap[texId],\r\n                                babylonMaterial.coatRoughnessTexture\r\n                            );\r\n                            additionalTextures.push(this._mergedTexturesMap[babylonMaterial.coatRoughnessTexture.uniqueId]);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (babylonMaterial.geometryCoatNormalTexture) {\r\n                    additionalTextures.push(babylonMaterial.geometryCoatNormalTexture);\r\n                }\r\n\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.clearCoat.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const clearCoatTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.texture);\r\n                let clearCoatTextureRoughnessInfo;\r\n                if (babylonMaterial.clearCoat.useRoughnessFromMainTexture) {\r\n                    clearCoatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.texture);\r\n                } else {\r\n                    clearCoatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.textureRoughness);\r\n                }\r\n\r\n                if (babylonMaterial.clearCoat.isTintEnabled) {\r\n                    Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);\r\n                }\r\n\r\n                if (babylonMaterial.clearCoat.remapF0OnInterfaceChange) {\r\n                    Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);\r\n                }\r\n\r\n                const clearCoatNormalTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.bumpTexture);\r\n\r\n                const clearCoatInfo: IKHRMaterialsClearcoat = {\r\n                    clearcoatFactor: babylonMaterial.clearCoat.intensity,\r\n                    clearcoatTexture: clearCoatTextureInfo ?? undefined,\r\n                    clearcoatRoughnessFactor: babylonMaterial.clearCoat.roughness,\r\n                    clearcoatRoughnessTexture: clearCoatTextureRoughnessInfo ?? undefined,\r\n                    clearcoatNormalTexture: clearCoatNormalTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (clearCoatInfo.clearcoatTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = clearCoatInfo;\r\n            } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                if (babylonMaterial.coatWeight == 0.0) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                let coatWeightTexture: Nullable<BaseTexture> = null;\r\n                let coatTextureInfo;\r\n                if (babylonMaterial.coatWeightTexture) {\r\n                    coatWeightTexture = this._mergedTexturesMap[babylonMaterial.coatWeightTexture.uniqueId];\r\n                    coatTextureInfo = this._exporter._materialExporter.getTextureInfo(coatWeightTexture);\r\n                }\r\n\r\n                let coatRoughnessTexture: Nullable<BaseTexture> = null;\r\n                let coatRoughnessTextureInfo;\r\n                if (babylonMaterial.coatRoughnessTexture) {\r\n                    coatRoughnessTexture = this._mergedTexturesMap[babylonMaterial.coatRoughnessTexture.uniqueId];\r\n                    coatRoughnessTextureInfo = this._exporter._materialExporter.getTextureInfo(coatRoughnessTexture);\r\n                }\r\n\r\n                if (babylonMaterial.coatColorTexture) {\r\n                    Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);\r\n                }\r\n\r\n                const clearCoatNormalTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.geometryCoatNormalTexture);\r\n\r\n                const clearCoatInfo: IKHRMaterialsClearcoat = {\r\n                    clearcoatFactor: babylonMaterial.coatWeight,\r\n                    clearcoatTexture: coatTextureInfo ?? undefined,\r\n                    clearcoatRoughnessFactor: babylonMaterial.coatRoughness,\r\n                    clearcoatRoughnessTexture: coatRoughnessTextureInfo ?? undefined,\r\n                    clearcoatNormalTexture: clearCoatNormalTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (clearCoatInfo.clearcoatTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = clearCoatInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_clearcoat(exporter));\r\n"]}