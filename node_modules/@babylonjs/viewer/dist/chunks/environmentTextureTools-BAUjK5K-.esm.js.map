{"version":3,"file":"environmentTextureTools-BAUjK5K-.esm.js","sources":["../../../../../dev/core/dist/Misc/environmentTextureTools.js"],"sourcesContent":["import { Tools } from \"./tools\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { ILog2 } from \"../Maths/math.scalar.functions\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\nimport { InternalTexture } from \"../Materials/Textures/internalTexture\";\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\nimport { Constants } from \"../Engines/constants\";\nimport { Scene } from \"../scene\";\nimport { PostProcess } from \"../PostProcesses/postProcess\";\nimport { Logger } from \"../Misc/logger\";\nimport { RGBDTextureTools } from \"./rgbdTextureTools\";\nimport { DumpDataAsync } from \"../Misc/dumpTools\";\nimport \"../Materials/Textures/baseTexture.polynomial\";\nconst DefaultEnvironmentTextureImageType = \"image/png\";\nconst CurrentVersion = 2;\n/**\n * Magic number identifying the env file.\n */\nconst MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\n/**\n * Gets the environment info from an env file.\n * @param data The array buffer containing the .env bytes.\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\n */\nexport function GetEnvInfo(data) {\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    let pos = 0;\n    for (let i = 0; i < MagicBytes.length; i++) {\n        if (dataView.getUint8(pos++) !== MagicBytes[i]) {\n            Logger.Error(\"Not a babylon environment map\");\n            return null;\n        }\n    }\n    // Read json manifest - collect characters up to null terminator\n    let manifestString = \"\";\n    let charCode = 0x00;\n    while ((charCode = dataView.getUint8(pos++))) {\n        manifestString += String.fromCharCode(charCode);\n    }\n    let manifest = JSON.parse(manifestString);\n    manifest = normalizeEnvInfo(manifest);\n    // Extend the header with the position of the payload.\n    manifest.binaryDataPosition = pos;\n    if (manifest.specular) {\n        // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\n        manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\n    }\n    return manifest;\n}\n/**\n * Normalizes any supported version of the environment file info to the latest version\n * @param info environment file info on any supported version\n * @returns environment file info in the latest supported version\n * @private\n */\nexport function normalizeEnvInfo(info) {\n    if (info.version > CurrentVersion) {\n        throw new Error(`Unsupported babylon environment map version \"${info.version}\". Latest supported version is \"${CurrentVersion}\".`);\n    }\n    if (info.version === 2) {\n        return info;\n    }\n    // Migrate a v1 info to v2\n    info = { ...info, version: 2, imageType: DefaultEnvironmentTextureImageType };\n    return info;\n}\n/**\n * Creates an environment texture from a loaded cube texture.\n * @param texture defines the cube texture to convert in env file\n * @param options options for the conversion process\n * @returns a promise containing the environment data if successful.\n */\nexport async function CreateEnvTextureAsync(texture, options = {}) {\n    const internalTexture = texture.getInternalTexture();\n    if (!internalTexture) {\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        return await Promise.reject(\"The cube texture is invalid.\");\n    }\n    const engine = internalTexture.getEngine();\n    if (texture.textureType !== Constants.TEXTURETYPE_HALF_FLOAT &&\n        texture.textureType !== Constants.TEXTURETYPE_FLOAT &&\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_BYTE &&\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_BYTE &&\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INTEGER &&\n        texture.textureType !== -1) {\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        return await Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\n    }\n    let textureType = Constants.TEXTURETYPE_FLOAT;\n    if (!engine.getCaps().textureFloatRender) {\n        textureType = Constants.TEXTURETYPE_HALF_FLOAT;\n        if (!engine.getCaps().textureHalfFloatRender) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return await Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\n        }\n    }\n    // sphericalPolynomial is lazy loaded so simply accessing it should trigger the computation.\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n    texture.sphericalPolynomial;\n    // Lets keep track of the polynomial promise so we can wait for it to be ready before generating the pixels.\n    const sphericalPolynomialPromise = texture.getInternalTexture()?._sphericalPolynomialPromise;\n    const cubeWidth = internalTexture.width;\n    const hostingScene = new Scene(engine);\n    const specularTextures = {};\n    const diffuseTextures = {};\n    // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\n    engine.flushFramebuffer();\n    const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;\n    // Read and collect all mipmaps data from the cube.\n    const mipmapsCount = ILog2(internalTexture.width);\n    for (let i = 0; i <= mipmapsCount; i++) {\n        const faceWidth = Math.pow(2, mipmapsCount - i);\n        // All faces of the cube.\n        for (let face = 0; face < 6; face++) {\n            // eslint-disable-next-line no-await-in-loop\n            specularTextures[i * 6 + face] = await _GetTextureEncodedDataAsync(hostingScene, texture, textureType, face, i, faceWidth, imageType, options.imageQuality);\n        }\n    }\n    // Read and collect all irradiance data from the cube.\n    const irradianceTexture = options.disableIrradianceTexture ? null : texture.irradianceTexture;\n    if (irradianceTexture) {\n        const faceWidth = irradianceTexture.getSize().width;\n        // All faces of the cube.\n        for (let face = 0; face < 6; face++) {\n            // eslint-disable-next-line no-await-in-loop\n            diffuseTextures[face] = await _GetTextureEncodedDataAsync(hostingScene, irradianceTexture, textureType, face, 0, faceWidth, imageType, options.imageQuality);\n        }\n    }\n    // We can delete the hosting scene keeping track of all the creation objects\n    hostingScene.dispose();\n    // Ensure completion of the polynomial creation promise.\n    if (sphericalPolynomialPromise) {\n        await sphericalPolynomialPromise;\n    }\n    // Creates the json header for the env texture\n    const info = {\n        version: CurrentVersion,\n        width: cubeWidth,\n        imageType,\n        irradiance: CreateEnvTextureIrradiance(texture),\n        specular: {\n            mipmaps: [],\n            lodGenerationScale: texture.lodGenerationScale,\n        },\n    };\n    // Sets the specular image data information\n    let position = 0;\n    for (let i = 0; i <= mipmapsCount; i++) {\n        for (let face = 0; face < 6; face++) {\n            const byteLength = specularTextures[i * 6 + face].byteLength;\n            info.specular.mipmaps.push({\n                length: byteLength,\n                position: position,\n            });\n            position += byteLength;\n        }\n    }\n    // Sets the irradiance image data information\n    if (irradianceTexture) {\n        info.irradiance = info.irradiance || {\n            x: [0, 0, 0],\n            xx: [0, 0, 0],\n            y: [0, 0, 0],\n            yy: [0, 0, 0],\n            z: [0, 0, 0],\n            zz: [0, 0, 0],\n            yz: [0, 0, 0],\n            zx: [0, 0, 0],\n            xy: [0, 0, 0],\n        };\n        info.irradiance.irradianceTexture = {\n            size: irradianceTexture.getSize().width,\n            faces: [],\n            dominantDirection: irradianceTexture._dominantDirection?.asArray(),\n        };\n        for (let face = 0; face < 6; face++) {\n            const byteLength = diffuseTextures[face].byteLength;\n            info.irradiance.irradianceTexture.faces.push({\n                length: byteLength,\n                position: position,\n            });\n            position += byteLength;\n        }\n    }\n    // Encode the JSON as an array buffer\n    const infoString = JSON.stringify(info);\n    const infoBuffer = new ArrayBuffer(infoString.length + 1);\n    const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\n    for (let i = 0, strLen = infoString.length; i < strLen; i++) {\n        infoView[i] = infoString.charCodeAt(i);\n    }\n    // Ends up with a null terminator for easier parsing\n    infoView[infoString.length] = 0x00;\n    // Computes the final required size and creates the storage\n    const totalSize = MagicBytes.length + position + infoBuffer.byteLength;\n    const finalBuffer = new ArrayBuffer(totalSize);\n    const finalBufferView = new Uint8Array(finalBuffer);\n    const dataView = new DataView(finalBuffer);\n    // Copy the magic bytes identifying the file in\n    let pos = 0;\n    for (let i = 0; i < MagicBytes.length; i++) {\n        dataView.setUint8(pos++, MagicBytes[i]);\n    }\n    // Add the json info\n    finalBufferView.set(new Uint8Array(infoBuffer), pos);\n    pos += infoBuffer.byteLength;\n    // Finally inserts the radiance texture data\n    for (let i = 0; i <= mipmapsCount; i++) {\n        for (let face = 0; face < 6; face++) {\n            const dataBuffer = specularTextures[i * 6 + face];\n            finalBufferView.set(new Uint8Array(dataBuffer), pos);\n            pos += dataBuffer.byteLength;\n        }\n    }\n    // Finally inserts the irradiance texture data\n    if (irradianceTexture) {\n        for (let face = 0; face < 6; face++) {\n            const dataBuffer = diffuseTextures[face];\n            finalBufferView.set(new Uint8Array(dataBuffer), pos);\n            pos += dataBuffer.byteLength;\n        }\n    }\n    // Voila\n    return finalBuffer;\n}\n/**\n * Get the texture encoded data from the current texture\n * @internal\n */\nasync function _GetTextureEncodedDataAsync(hostingScene, texture, textureType, face, i, size, imageType, imageQuality) {\n    let faceData = await texture.readPixels(face, i, undefined, false);\n    if (faceData && faceData.byteLength === faceData.length) {\n        const faceDataFloat = new Float32Array(faceData.byteLength * 4);\n        for (let i = 0; i < faceData.byteLength; i++) {\n            faceDataFloat[i] = faceData[i] / 255;\n            // Gamma to linear\n            faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);\n        }\n        faceData = faceDataFloat;\n    }\n    else if (faceData && texture.gammaSpace) {\n        const floatData = faceData;\n        for (let i = 0; i < floatData.length; i++) {\n            // Gamma to linear\n            floatData[i] = Math.pow(floatData[i], 2.2);\n        }\n    }\n    const engine = hostingScene.getEngine();\n    const tempTexture = engine.createRawTexture(faceData, size, size, Constants.TEXTUREFORMAT_RGBA, false, true, Constants.TEXTURE_NEAREST_SAMPLINGMODE, null, textureType);\n    await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);\n    const rgbdEncodedData = await engine._readTexturePixels(tempTexture, size, size);\n    const imageEncodedData = await DumpDataAsync(size, size, rgbdEncodedData, imageType, undefined, false, true, imageQuality);\n    tempTexture.dispose();\n    return imageEncodedData;\n}\n/**\n * Creates a JSON representation of the spherical data.\n * @param texture defines the texture containing the polynomials\n * @returns the JSON representation of the spherical info\n */\nfunction CreateEnvTextureIrradiance(texture) {\n    const polynmials = texture.sphericalPolynomial;\n    if (polynmials == null) {\n        return null;\n    }\n    return {\n        x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\n        y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\n        z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\n        xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\n        yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\n        zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\n        yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\n        zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\n        xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z],\n    };\n}\n/**\n * Creates the ArrayBufferViews used for initializing environment texture image data.\n * @param data the image data\n * @param info parameters that determine what views will be created for accessing the underlying buffer\n * @returns the views described by info providing access to the underlying buffer\n */\nexport function CreateRadianceImageDataArrayBufferViews(data, info) {\n    info = normalizeEnvInfo(info);\n    const specularInfo = info.specular;\n    // Double checks the enclosed info\n    let mipmapsCount = Math.log2(info.width);\n    mipmapsCount = Math.round(mipmapsCount) + 1;\n    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\n        throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\n    }\n    const imageData = new Array(mipmapsCount);\n    for (let i = 0; i < mipmapsCount; i++) {\n        imageData[i] = new Array(6);\n        for (let face = 0; face < 6; face++) {\n            const imageInfo = specularInfo.mipmaps[i * 6 + face];\n            imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + info.binaryDataPosition + imageInfo.position, imageInfo.length);\n        }\n    }\n    return imageData;\n}\n/**\n * Creates the ArrayBufferViews used for initializing environment texture image data.\n * @param data the image data\n * @param info parameters that determine what views will be created for accessing the underlying buffer\n * @returns the views described by info providing access to the underlying buffer\n */\nexport function CreateIrradianceImageDataArrayBufferViews(data, info) {\n    info = normalizeEnvInfo(info);\n    const imageData = new Array(6);\n    const irradianceTexture = info.irradiance?.irradianceTexture;\n    if (irradianceTexture) {\n        if (irradianceTexture.faces.length !== 6) {\n            throw new Error(`Incorrect irradiance texture faces number \"${irradianceTexture.faces.length}\"`);\n        }\n        for (let face = 0; face < 6; face++) {\n            const imageInfo = irradianceTexture.faces[face];\n            imageData[face] = new Uint8Array(data.buffer, data.byteOffset + info.binaryDataPosition + imageInfo.position, imageInfo.length);\n        }\n    }\n    return imageData;\n}\n/**\n * Uploads the texture info contained in the env file to the GPU.\n * @param texture defines the internal texture to upload to\n * @param data defines the data to load\n * @param info defines the texture info retrieved through the GetEnvInfo method\n * @returns a promise\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function UploadEnvLevelsAsync(texture, data, info) {\n    info = normalizeEnvInfo(info);\n    const specularInfo = info.specular;\n    if (!specularInfo) {\n        // Nothing else parsed so far\n        return Promise.resolve([]);\n    }\n    texture._lodGenerationScale = specularInfo.lodGenerationScale;\n    const promises = [];\n    const radianceImageData = CreateRadianceImageDataArrayBufferViews(data, info);\n    promises.push(UploadRadianceLevelsAsync(texture, radianceImageData, info.imageType));\n    const irradianceTexture = info.irradiance?.irradianceTexture;\n    if (irradianceTexture) {\n        const irradianceImageData = CreateIrradianceImageDataArrayBufferViews(data, info);\n        let dominantDirection = null;\n        if (info.irradiance?.irradianceTexture?.dominantDirection) {\n            dominantDirection = Vector3.FromArray(info.irradiance.irradianceTexture.dominantDirection);\n        }\n        promises.push(UploadIrradianceLevelsAsync(texture, irradianceImageData, irradianceTexture.size, info.imageType, dominantDirection));\n    }\n    return Promise.all(promises);\n}\nasync function _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {\n    return await new Promise((resolve, reject) => {\n        if (expandTexture) {\n            const tempTexture = engine.createTexture(null, true, true, null, Constants.TEXTURE_NEAREST_SAMPLINGMODE, null, (message) => {\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                reject(message);\n            }, image);\n            rgbdPostProcess?.onEffectCreatedObservable.addOnce((effect) => {\n                effect.executeWhenCompiled(() => {\n                    // Uncompress the data to a RTT\n                    rgbdPostProcess.externalTextureSamplerBinding = true;\n                    rgbdPostProcess.onApply = (effect) => {\n                        effect._bindTexture(\"textureSampler\", tempTexture);\n                        effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\n                    };\n                    if (!engine.scenes.length) {\n                        return;\n                    }\n                    engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i);\n                    // Cleanup\n                    engine.restoreDefaultFramebuffer();\n                    tempTexture.dispose();\n                    URL.revokeObjectURL(url);\n                    resolve();\n                });\n            });\n        }\n        else {\n            engine._uploadImageToTexture(texture, image, face, i);\n            // Upload the face to the non lod texture support\n            if (generateNonLODTextures) {\n                const lodTexture = lodTextures[i];\n                if (lodTexture) {\n                    engine._uploadImageToTexture(lodTexture._texture, image, face, 0);\n                }\n            }\n            resolve();\n        }\n    });\n}\n/**\n * Uploads the levels of image data to the GPU.\n * @param texture defines the internal texture to upload to\n * @param imageData defines the array buffer views of image data [mipmap][face]\n * @param imageType the mime type of the image data\n * @returns a promise\n */\nexport async function UploadRadianceLevelsAsync(texture, imageData, imageType = DefaultEnvironmentTextureImageType) {\n    const engine = texture.getEngine();\n    texture.format = Constants.TEXTUREFORMAT_RGBA;\n    texture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n    texture.generateMipMaps = true;\n    texture._cachedAnisotropicFilteringLevel = null;\n    engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, texture);\n    await _UploadLevelsAsync(texture, imageData, true, imageType);\n    // Flag internal texture as ready in case they are in use.\n    texture.isReady = true;\n}\n/**\n * Uploads the levels of image data to the GPU.\n * @param mainTexture defines the internal texture to upload to\n * @param imageData defines the array buffer views of image data [mipmap][face]\n * @param size defines the size of the texture faces\n * @param imageType the mime type of the image data\n * @param dominantDirection the dominant direction of light in the environment texture, if available\n * @returns a promise\n */\nexport async function UploadIrradianceLevelsAsync(mainTexture, imageData, size, imageType = DefaultEnvironmentTextureImageType, dominantDirection = null) {\n    // Gets everything ready.\n    const engine = mainTexture.getEngine();\n    const texture = new InternalTexture(engine, 5 /* InternalTextureSource.RenderTarget */);\n    const baseTexture = new BaseTexture(engine, texture);\n    mainTexture._irradianceTexture = baseTexture;\n    baseTexture._dominantDirection = dominantDirection;\n    texture.isCube = true;\n    texture.format = Constants.TEXTUREFORMAT_RGBA;\n    texture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n    texture.generateMipMaps = true;\n    texture._cachedAnisotropicFilteringLevel = null;\n    texture.generateMipMaps = true;\n    texture.width = size;\n    texture.height = size;\n    engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, texture);\n    await _UploadLevelsAsync(texture, [imageData], false, imageType);\n    engine.generateMipMapsForCubemap(texture);\n    // Flag internal texture as ready in case they are in use.\n    texture.isReady = true;\n}\n/**\n * Uploads the levels of image data to the GPU.\n * @param texture defines the internal texture to upload to\n * @param imageData defines the array buffer views of image data [mipmap][face]\n * @param canGenerateNonLODTextures defines whether or not to generate non lod textures\n * @param imageType the mime type of the image data\n * @returns a promise\n */\nasync function _UploadLevelsAsync(texture, imageData, canGenerateNonLODTextures, imageType = DefaultEnvironmentTextureImageType) {\n    if (!Tools.IsExponentOfTwo(texture.width)) {\n        throw new Error(\"Texture size must be a power of two\");\n    }\n    const mipmapsCount = ILog2(texture.width) + 1;\n    // Gets everything ready.\n    const engine = texture.getEngine();\n    let expandTexture = false;\n    let generateNonLODTextures = false;\n    let rgbdPostProcess = null;\n    let cubeRtt = null;\n    let lodTextures = null;\n    const caps = engine.getCaps();\n    if (!caps.textureLOD) {\n        expandTexture = false;\n        generateNonLODTextures = canGenerateNonLODTextures;\n    }\n    else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\n        expandTexture = false;\n    }\n    // If half float available we can uncompress the texture\n    else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n        expandTexture = true;\n        texture.type = Constants.TEXTURETYPE_HALF_FLOAT;\n    }\n    // If full float available we can uncompress the texture\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n        expandTexture = true;\n        texture.type = Constants.TEXTURETYPE_FLOAT;\n    }\n    // Expand the texture if possible\n    let shaderLanguage = 0 /* ShaderLanguage.GLSL */;\n    if (expandTexture) {\n        if (engine.isWebGPU) {\n            shaderLanguage = 1 /* ShaderLanguage.WGSL */;\n            await import(\"../ShadersWGSL/rgbdDecode.fragment\");\n        }\n        else {\n            await import(\"../Shaders/rgbdDecode.fragment\");\n        }\n        // Simply run through the decode PP\n        rgbdPostProcess = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, engine, false, undefined, texture.type, undefined, null, false, undefined, shaderLanguage);\n        texture._isRGBD = false;\n        texture.invertY = false;\n        cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\n            generateDepthBuffer: false,\n            generateMipMaps: true,\n            generateStencilBuffer: false,\n            samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\n            type: texture.type,\n            format: Constants.TEXTUREFORMAT_RGBA,\n        });\n    }\n    else {\n        texture._isRGBD = true;\n        texture.invertY = true;\n        // In case of missing support, applies the same patch than DDS files.\n        if (generateNonLODTextures) {\n            const mipSlices = 3;\n            lodTextures = {};\n            const scale = texture._lodGenerationScale;\n            const offset = texture._lodGenerationOffset;\n            for (let i = 0; i < mipSlices; i++) {\n                //compute LOD from even spacing in smoothness (matching shader calculation)\n                const smoothness = i / (mipSlices - 1);\n                const roughness = 1 - smoothness;\n                const minLODIndex = offset; // roughness = 0\n                const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\n                const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n                const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n                //compute LOD from even spacing in smoothness (matching shader calculation)\n                const glTextureFromLod = new InternalTexture(engine, 2 /* InternalTextureSource.Temp */);\n                glTextureFromLod.isCube = true;\n                glTextureFromLod.invertY = true;\n                glTextureFromLod.generateMipMaps = false;\n                engine.updateTextureSamplingMode(Constants.TEXTURE_LINEAR_LINEAR, glTextureFromLod);\n                // Wrap in a base texture for easy binding.\n                const lodTexture = new BaseTexture(null);\n                lodTexture._isCube = true;\n                lodTexture._texture = glTextureFromLod;\n                lodTextures[mipmapIndex] = lodTexture;\n                switch (i) {\n                    case 0:\n                        texture._lodTextureLow = lodTexture;\n                        break;\n                    case 1:\n                        texture._lodTextureMid = lodTexture;\n                        break;\n                    case 2:\n                        texture._lodTextureHigh = lodTexture;\n                        break;\n                }\n            }\n        }\n    }\n    const promises = [];\n    // All mipmaps up to provided number of images\n    for (let i = 0; i < imageData.length; i++) {\n        // All faces\n        for (let face = 0; face < 6; face++) {\n            // Constructs an image element from image data\n            const bytes = imageData[i][face];\n            const blob = new Blob([bytes], { type: imageType });\n            const url = URL.createObjectURL(blob);\n            let promise;\n            if (engine._features.forceBitmapOverHTMLImageElement) {\n                // eslint-disable-next-line github/no-then\n                promise = engine.createImageBitmap(blob, { premultiplyAlpha: \"none\" }).then(async (img) => {\n                    return await _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\n                });\n            }\n            else {\n                const image = new Image();\n                image.src = url;\n                // Enqueue promise to upload to the texture.\n                promise = new Promise((resolve, reject) => {\n                    image.onload = () => {\n                        _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture)\n                            // eslint-disable-next-line github/no-then\n                            .then(() => resolve())\n                            // eslint-disable-next-line github/no-then\n                            .catch((reason) => {\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                            reject(reason);\n                        });\n                    };\n                    image.onerror = (error) => {\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                        reject(error);\n                    };\n                });\n            }\n            promises.push(promise);\n        }\n    }\n    await Promise.all(promises);\n    // Fill remaining mipmaps with black textures.\n    if (imageData.length < mipmapsCount) {\n        let data;\n        const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\n        const dataLength = size * size * 4;\n        switch (texture.type) {\n            case Constants.TEXTURETYPE_UNSIGNED_BYTE: {\n                data = new Uint8Array(dataLength);\n                break;\n            }\n            case Constants.TEXTURETYPE_HALF_FLOAT: {\n                data = new Uint16Array(dataLength);\n                break;\n            }\n            case Constants.TEXTURETYPE_FLOAT: {\n                data = new Float32Array(dataLength);\n                break;\n            }\n        }\n        for (let i = imageData.length; i < mipmapsCount; i++) {\n            for (let face = 0; face < 6; face++) {\n                engine._uploadArrayBufferViewToTexture(cubeRtt?.texture || texture, data, face, i);\n            }\n        }\n    }\n    // Release temp RTT.\n    if (cubeRtt) {\n        const irradiance = texture._irradianceTexture;\n        texture._irradianceTexture = null;\n        engine._releaseTexture(texture);\n        cubeRtt._swapAndDie(texture);\n        texture._irradianceTexture = irradiance;\n    }\n    // Release temp Post Process.\n    if (rgbdPostProcess) {\n        rgbdPostProcess.dispose();\n    }\n    // Flag internal texture as ready in case they are in use.\n    if (generateNonLODTextures) {\n        if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\n            texture._lodTextureHigh._texture.isReady = true;\n        }\n        if (texture._lodTextureMid && texture._lodTextureMid._texture) {\n            texture._lodTextureMid._texture.isReady = true;\n        }\n        if (texture._lodTextureLow && texture._lodTextureLow._texture) {\n            texture._lodTextureLow._texture.isReady = true;\n        }\n    }\n}\n/**\n * Uploads spherical polynomials information to the texture.\n * @param texture defines the texture we are trying to upload the information to\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\n */\nexport function UploadEnvSpherical(texture, info) {\n    info = normalizeEnvInfo(info);\n    const irradianceInfo = info.irradiance;\n    if (!irradianceInfo) {\n        return;\n    }\n    const sp = new SphericalPolynomial();\n    Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\n    Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\n    Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\n    Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\n    Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\n    Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\n    Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\n    Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\n    Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\n    texture._sphericalPolynomial = sp;\n}\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function _UpdateRGBDAsync(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {\n    const proxy = internalTexture\n        .getEngine()\n        .createRawCubeTexture(null, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n    // eslint-disable-next-line github/no-then\n    const proxyPromise = UploadRadianceLevelsAsync(proxy, data).then(() => internalTexture);\n    internalTexture.onRebuildCallback = (_internalTexture) => {\n        return {\n            proxy: proxyPromise,\n            isReady: true,\n            isAsync: true,\n        };\n    };\n    internalTexture._source = 13 /* InternalTextureSource.CubeRawRGBD */;\n    internalTexture._bufferViewArrayArray = data;\n    internalTexture._lodGenerationScale = lodScale;\n    internalTexture._lodGenerationOffset = lodOffset;\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\n    // eslint-disable-next-line github/no-then\n    return UploadRadianceLevelsAsync(internalTexture, data).then(() => {\n        internalTexture.isReady = true;\n        return internalTexture;\n    });\n}\n/**\n * Sets of helpers addressing the serialization and deserialization of environment texture\n * stored in a BabylonJS env file.\n * Those files are usually stored as .env files.\n */\nexport const EnvironmentTextureTools = {\n    /**\n     * Gets the environment info from an env file.\n     * @param data The array buffer containing the .env bytes.\n     * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\n     */\n    GetEnvInfo,\n    /**\n     * Creates an environment texture from a loaded cube texture.\n     * @param texture defines the cube texture to convert in env file\n     * @param options options for the conversion process\n     * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\n     * @param options.imageQuality the image quality of encoded WebP images.\n     * @returns a promise containing the environment data if successful.\n     */\n    CreateEnvTextureAsync,\n    /**\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\n     * @param data the image data\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\n     * @returns the views described by info providing access to the underlying buffer\n     */\n    CreateRadianceImageDataArrayBufferViews,\n    /**\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\n     * @param data the image data\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\n     * @returns the views described by info providing access to the underlying buffer\n     */\n    CreateIrradianceImageDataArrayBufferViews,\n    /**\n     * Uploads the texture info contained in the env file to the GPU.\n     * @param texture defines the internal texture to upload to\n     * @param data defines the data to load\n     * @param info defines the texture info retrieved through the GetEnvInfo method\n     * @returns a promise\n     */\n    UploadEnvLevelsAsync,\n    /**\n     * Uploads the levels of image data to the GPU.\n     * @param texture defines the internal texture to upload to\n     * @param imageData defines the array buffer views of image data [mipmap][face]\n     * @param imageType the mime type of the image data\n     * @returns a promise\n     */\n    UploadRadianceLevelsAsync,\n    /**\n     * Uploads the levels of image data to the GPU.\n     * @param texture defines the internal texture to upload to\n     * @param imageData defines the array buffer views of image data [mipmap][face]\n     * @param imageType the mime type of the image data\n     * @param dominantDirection the dominant direction of light in the environment texture, if available\n     * @returns a promise\n     */\n    UploadIrradianceLevelsAsync,\n    /**\n     * Uploads spherical polynomials information to the texture.\n     * @param texture defines the texture we are trying to upload the information to\n     * @param info defines the environment texture info retrieved through the GetEnvInfo method\n     */\n    UploadEnvSpherical,\n};\n//# sourceMappingURL=environmentTextureTools.js.map"],"names":[],"mappings":"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"}