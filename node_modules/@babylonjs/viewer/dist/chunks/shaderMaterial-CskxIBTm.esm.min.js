import{aP as t,p as s,H as e,N as r,K as i,$ as o,W as n,l as a,X as h,aQ as c,Y as f,aR as u,aS as _,Z as l,S as x,T as p,Q as d,aT as m,e as y,aU as A,C as g,g as v}from"./index-1dDxZ_0d.esm.min.js";const T={effect:null,subMesh:null};class M extends t{constructor(t,e,r,i={},o=!0){super(t,e,o),this._textures={},this._internalTextures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new s,this._cachedWorldViewProjectionMatrix=new s,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=r,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...i}}get shaderPath(){return this._shaderPath}set shaderPath(t){this._shaderPath=t}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(t){-1===this._options.uniforms.indexOf(t)&&this._options.uniforms.push(t)}setTexture(t,s){return-1===this._options.samplers.indexOf(t)&&this._options.samplers.push(t),this._textures[t]=s,this}setInternalTexture(t,s){return-1===this._options.samplers.indexOf(t)&&this._options.samplers.push(t),this._internalTextures[t]=s,this}removeTexture(t){delete this._textures[t]}setTextureArray(t,s){return-1===this._options.samplers.indexOf(t)&&this._options.samplers.push(t),this._checkUniform(t),this._textureArrays[t]=s,this}setExternalTexture(t,s){return-1===this._options.externalTextures.indexOf(t)&&this._options.externalTextures.push(t),this._externalTextures[t]=s,this}setFloat(t,s){return this._checkUniform(t),this._floats[t]=s,this}setInt(t,s){return this._checkUniform(t),this._ints[t]=s,this}setUInt(t,s){return this._checkUniform(t),this._uints[t]=s,this}setFloats(t,s){return this._checkUniform(t),this._floatsArrays[t]=s,this}setColor3(t,s){return this._checkUniform(t),this._colors3[t]=s,this}setColor3Array(t,s){return this._checkUniform(t),this._colors3Arrays[t]=s.reduce(((t,s)=>(t.push(s.r,s.g,s.b),t)),[]),this}setColor4(t,s){return this._checkUniform(t),this._colors4[t]=s,this}setColor4Array(t,s){return this._checkUniform(t),this._colors4Arrays[t]=s.reduce(((t,s)=>(t.push(s.r,s.g,s.b,s.a),t)),[]),this}setVector2(t,s){return this._checkUniform(t),this._vectors2[t]=s,this}setVector3(t,s){return this._checkUniform(t),this._vectors3[t]=s,this}setVector4(t,s){return this._checkUniform(t),this._vectors4[t]=s,this}setQuaternion(t,s){return this._checkUniform(t),this._quaternions[t]=s,this}setQuaternionArray(t,s){return this._checkUniform(t),this._quaternionsArrays[t]=s.reduce(((t,s)=>(s.toArray(t,t.length),t)),[]),this}setMatrix(t,s){return this._checkUniform(t),this._matrices[t]=s,this}setMatrices(t,s){this._checkUniform(t);const e=new Float32Array(16*s.length);for(let t=0;t<s.length;t++){s[t].copyToArray(e,16*t)}return this._matrixArrays[t]=e,this}setMatrix3x3(t,s){return this._checkUniform(t),this._matrices3x3[t]=s,this}setMatrix2x2(t,s){return this._checkUniform(t),this._matrices2x2[t]=s,this}setArray2(t,s){return this._checkUniform(t),this._vectors2Arrays[t]=s,this}setArray3(t,s){return this._checkUniform(t),this._vectors3Arrays[t]=s,this}setArray4(t,s){return this._checkUniform(t),this._vectors4Arrays[t]=s,this}setUniformBuffer(t,s){return-1===this._options.uniformBuffers.indexOf(t)&&this._options.uniformBuffers.push(t),this._uniformBuffers[t]=s,this}setTextureSampler(t,s){return-1===this._options.samplerObjects.indexOf(t)&&this._options.samplerObjects.push(t),this._textureSamplers[t]=s,this}setStorageBuffer(t,s){return-1===this._options.storageBuffers.indexOf(t)&&this._options.storageBuffers.push(t),this._storageBuffers[t]=s,this}setDefine(t,s){const e=t.trimEnd()+" ",r=this.options.defines.findIndex((s=>s===t||s.startsWith(e)));return r>=0&&this.options.defines.splice(r,1),("boolean"!=typeof s||s)&&this.options.defines.push(e+s),this}isReadyForSubMesh(t,s,e){return this.isReady(t,e,s)}isReady(t,s,h){const c=h&&this._storeEffectOnSubMeshes;if(this.isFrozen){const t=c?h._drawWrapper:this._drawWrapper;if(t.effect&&t._wasPreviouslyReady&&t._wasPreviouslyUsingInstances===s)return!0}const f=this.getScene(),u=f.getEngine(),_=[],l=[];let x=null,p=this._shaderPath,d=this._options.uniforms,m=this._options.uniformBuffers,y=this._options.samplers;u.getCaps().multiview&&f.activeCamera&&f.activeCamera.outputRenderTarget&&f.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,_.push("#define MULTIVIEW"),-1!==d.indexOf("viewProjection")&&-1===d.indexOf("viewProjectionR")&&d.push("viewProjectionR"));for(let t=0;t<this._options.defines.length;t++){const s=0===this._options.defines[t].indexOf("#define")?this._options.defines[t]:`#define ${this._options.defines[t]}`;_.push(s)}for(let t=0;t<this._options.attributes.length;t++)l.push(this._options.attributes[t]);if(t&&t.isVerticesDataPresent(e.ColorKind)&&(-1===l.indexOf(e.ColorKind)&&l.push(e.ColorKind),_.push("#define VERTEXCOLOR")),s&&(_.push("#define INSTANCES"),r(l,this._materialHelperNeedsPreviousMatrices),t?.hasThinInstances&&(_.push("#define THIN_INSTANCES"),t&&t.isVerticesDataPresent(e.ColorInstanceKind)&&(l.push(e.ColorInstanceKind),_.push("#define INSTANCESCOLOR")))),t&&t.useBones&&t.computeBonesUsingShaders&&t.skeleton){l.push(e.MatricesIndicesKind),l.push(e.MatricesWeightsKind),t.numBoneInfluencers>4&&(l.push(e.MatricesIndicesExtraKind),l.push(e.MatricesWeightsExtraKind));const s=t.skeleton;_.push("#define NUM_BONE_INFLUENCERS "+t.numBoneInfluencers),x=new A,x.addCPUSkinningFallback(0,t),s.isUsingTextureForMatrices?(_.push("#define BONETEXTURE"),-1===d.indexOf("boneTextureWidth")&&d.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(_.push("#define BonesPerMesh "+(s.bones.length+1)),-1===d.indexOf("mBones")&&d.push("mBones"))}else _.push("#define NUM_BONE_INFLUENCERS 0");let g=0;const v=t?t.morphTargetManager:null;if(v){const s=-1!==_.indexOf("#define UV1"),e=-1!==_.indexOf("#define UV2"),r=-1!==_.indexOf("#define TANGENT"),o=-1!==_.indexOf("#define NORMAL"),n=-1!==_.indexOf("#define VERTEXCOLOR");g=i(v,_,l,t,!0,o,r,s,e,n),v.isUsingTextureForTargets&&(-1===d.indexOf("morphTargetTextureIndices")&&d.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),g>0&&(d=d.slice(),d.push("morphTargetInfluences"),d.push("morphTargetCount"),d.push("morphTargetTextureInfo"),d.push("morphTargetTextureIndices"))}else _.push("#define NUM_MORPH_INFLUENCERS 0");if(t){const e=t.bakedVertexAnimationManager;e&&e.isEnabled&&(_.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===d.indexOf("bakedVertexAnimationSettings")&&d.push("bakedVertexAnimationSettings"),-1===d.indexOf("bakedVertexAnimationTextureSizeInverted")&&d.push("bakedVertexAnimationTextureSizeInverted"),-1===d.indexOf("bakedVertexAnimationTime")&&d.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture"),s&&l.push("bakedVertexAnimationSettingsInstanced"))}for(const t in this._textures)if(!this._textures[t].isReady())return!1;for(const t in this._internalTextures)if(!this._internalTextures[t].isReady)return!1;t&&this.needAlphaTestingForMesh(t)&&_.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&(o(d),n(this,f,_)),f.fogEnabled&&t?.applyFog&&f.fogMode!==a.FOGMODE_NONE&&(_.push("#define FOG"),-1===d.indexOf("view")&&d.push("view"),-1===d.indexOf("vFogInfos")&&d.push("vFogInfos"),-1===d.indexOf("vFogColor")&&d.push("vFogColor")),this._useLogarithmicDepth&&(_.push("#define LOGARITHMICDEPTH"),-1===d.indexOf("logarithmicDepthConstant")&&d.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(d=d.slice(),m=m.slice(),y=y.slice(),p=this.customShaderNameResolve(this.name,d,m,y,_,l));const M=h?h.getRenderingMesh():t;if(M&&this.useVertexPulling){_.push("#define USE_VERTEX_PULLING");const t=M.geometry?.getIndexBuffer();t&&(_.push("#define VERTEX_PULLING_USE_INDEX_BUFFER"),t.is32Bits&&_.push("#define VERTEX_PULLING_INDEX_BUFFER_32BITS"))}const O=c?h._getDrawWrapper(void 0,!0):this._drawWrapper,E=O?.effect??null,b=O?.defines??null,S=_.join("\n");let w=E;return b!==S&&(w=u.createEffect(p,{attributes:l,uniformsNames:d,uniformBuffersNames:m,samplers:y,defines:S,fallbacks:x,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:g},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},u),c?h.setEffect(w,S,this._materialContext):O&&O.setEffect(w,S),this._onEffectCreatedObservable&&(T.effect=w,T.subMesh=h??t?.subMeshes[0]??null,this._onEffectCreatedObservable.notifyObservers(T))),O._wasPreviouslyUsingInstances=!!s,!!w?.isReady()&&(E!==w&&f.resetCachedMaterial(),O._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(t,s){const e=s??this.getEffect();if(!e)return;const r=this._options.uniforms;-1!==r.indexOf("world")&&e.setMatrix("world",t);const i=this.getScene();-1!==r.indexOf("worldView")&&(t.multiplyToRef(i.getViewMatrix(),this._cachedWorldViewMatrix),e.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==r.indexOf("worldViewProjection")&&(t.multiplyToRef(i.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),e.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==r.indexOf("view")&&e.setMatrix("view",i.getViewMatrix())}bindForSubMesh(t,s,e){this.bind(t,s,e._drawWrapperOverride?.effect,e)}bind(t,s,e,r){const i=r&&this._storeEffectOnSubMeshes,o=e??(i?r.effect:this.getEffect());if(!o)return;const n=this.getScene();this._activeEffect=o,this.bindOnlyWorldMatrix(t,e);const a=this._options.uniformBuffers;let x=!1;if(o&&a&&a.length>0&&n.getEngine().supportsUniformBuffers)for(let e=0;e<a.length;++e){switch(a[e]){case"Mesh":s&&(s.getMeshUniformBuffer().bindToEffect(o,"Mesh"),s.transferToEffect(t));break;case"Scene":h(o,n.getSceneUniformBuffer()),n.finalizeSceneUbo(),x=!0}}const p=s&&i?this._mustRebind(n,o,r,s.visibility):n.getCachedMaterial()!==this;if(o&&p){let t;for(t in x||-1===this._options.uniforms.indexOf("view")||o.setMatrix("view",n.getViewMatrix()),x||-1===this._options.uniforms.indexOf("projection")||o.setMatrix("projection",n.getProjectionMatrix()),x||-1===this._options.uniforms.indexOf("viewProjection")||(o.setMatrix("viewProjection",n.getTransformMatrix()),this._multiview&&o.setMatrix("viewProjectionR",n._transformMatrixR)),n.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&o.setVector3("cameraPosition",n.activeCamera.globalPosition),c(s,o),f(o,this,n),this._useLogarithmicDepth&&u(i?r.materialDefines:o.defines,o,n),s&&_(n,s,o),this._textures)o.setTexture(t,this._textures[t]);for(t in this._internalTextures)o._bindTexture(t,this._internalTextures[t]);for(t in this._textureArrays)o.setTextureArray(t,this._textureArrays[t]);for(t in this._ints)o.setInt(t,this._ints[t]);for(t in this._uints)o.setUInt(t,this._uints[t]);for(t in this._floats)o.setFloat(t,this._floats[t]);for(t in this._floatsArrays)o.setArray(t,this._floatsArrays[t]);for(t in this._colors3)o.setColor3(t,this._colors3[t]);for(t in this._colors3Arrays)o.setArray3(t,this._colors3Arrays[t]);for(t in this._colors4){const s=this._colors4[t];o.setFloat4(t,s.r,s.g,s.b,s.a)}for(t in this._colors4Arrays)o.setArray4(t,this._colors4Arrays[t]);for(t in this._vectors2)o.setVector2(t,this._vectors2[t]);for(t in this._vectors3)o.setVector3(t,this._vectors3[t]);for(t in this._vectors4)o.setVector4(t,this._vectors4[t]);for(t in this._quaternions)o.setQuaternion(t,this._quaternions[t]);for(t in this._matrices)o.setMatrix(t,this._matrices[t]);for(t in this._matrixArrays)o.setMatrices(t,this._matrixArrays[t]);for(t in this._matrices3x3)o.setMatrix3x3(t,this._matrices3x3[t]);for(t in this._matrices2x2)o.setMatrix2x2(t,this._matrices2x2[t]);for(t in this._vectors2Arrays)o.setArray2(t,this._vectors2Arrays[t]);for(t in this._vectors3Arrays)o.setArray3(t,this._vectors3Arrays[t]);for(t in this._vectors4Arrays)o.setArray4(t,this._vectors4Arrays[t]);for(t in this._quaternionsArrays)o.setArray4(t,this._quaternionsArrays[t]);for(t in this._uniformBuffers){const s=this._uniformBuffers[t].getBuffer();s&&o.bindUniformBuffer(s,t)}const e=n.getEngine(),a=e.setExternalTexture;if(a)for(t in this._externalTextures)a.call(e,t,this._externalTextures[t]);const h=e.setTextureSampler;if(h)for(t in this._textureSamplers)h.call(e,t,this._textureSamplers[t]);const l=e.setStorageBuffer;if(l)for(t in this._storageBuffers)l.call(e,t,this._storageBuffers[t])}if(o&&s&&(p||!this.isFrozen)){l(s,o),s.morphTargetManager&&s.morphTargetManager.isUsingTextureForTargets&&s.morphTargetManager._bind(o);const t=s.bakedVertexAnimationManager;if(t&&t.isEnabled){const t=i?r._drawWrapper:this._drawWrapper;s.bakedVertexAnimationManager?.bind(o,!!t._wasPreviouslyUsingInstances)}}this._afterBind(s,o,r)}getActiveTextures(){const t=super.getActiveTextures();for(const s in this._textures)t.push(this._textures[s]);for(const s in this._textureArrays){const e=this._textureArrays[s];for(let s=0;s<e.length;s++)t.push(e[s])}return t}hasTexture(t){if(super.hasTexture(t))return!0;for(const s in this._textures)if(this._textures[s]===t)return!0;const s=t.getInternalTexture();for(const t in this._internalTextures)if(this._internalTextures[t]===s)return!0;for(const s in this._textureArrays){const e=this._textureArrays[s];for(let s=0;s<e.length;s++)if(e[s]===t)return!0}return!1}clone(t){const s=x.Clone((()=>new M(t,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);s.name=t,s.id=t,"object"==typeof s._shaderPath&&(s._shaderPath={...s._shaderPath}),this._options={...this._options};const e=Object.keys(this._options);for(const t of e){const s=this._options[t];Array.isArray(s)&&(this._options[t]=s.slice(0))}this.stencil.copyTo(s.stencil);for(const t in this._textures)s.setTexture(t,this._textures[t]);for(const t in this._internalTextures)s.setInternalTexture(t,this._internalTextures[t]);for(const t in this._textureArrays)s.setTextureArray(t,this._textureArrays[t]);for(const t in this._externalTextures)s.setExternalTexture(t,this._externalTextures[t]);for(const t in this._ints)s.setInt(t,this._ints[t]);for(const t in this._uints)s.setUInt(t,this._uints[t]);for(const t in this._floats)s.setFloat(t,this._floats[t]);for(const t in this._floatsArrays)s.setFloats(t,this._floatsArrays[t]);for(const t in this._colors3)s.setColor3(t,this._colors3[t]);for(const t in this._colors3Arrays)s._colors3Arrays[t]=this._colors3Arrays[t];for(const t in this._colors4)s.setColor4(t,this._colors4[t]);for(const t in this._colors4Arrays)s._colors4Arrays[t]=this._colors4Arrays[t];for(const t in this._vectors2)s.setVector2(t,this._vectors2[t]);for(const t in this._vectors3)s.setVector3(t,this._vectors3[t]);for(const t in this._vectors4)s.setVector4(t,this._vectors4[t]);for(const t in this._quaternions)s.setQuaternion(t,this._quaternions[t]);for(const t in this._quaternionsArrays)s._quaternionsArrays[t]=this._quaternionsArrays[t];for(const t in this._matrices)s.setMatrix(t,this._matrices[t]);for(const t in this._matrixArrays)s._matrixArrays[t]=this._matrixArrays[t].slice();for(const t in this._matrices3x3)s.setMatrix3x3(t,this._matrices3x3[t]);for(const t in this._matrices2x2)s.setMatrix2x2(t,this._matrices2x2[t]);for(const t in this._vectors2Arrays)s.setArray2(t,this._vectors2Arrays[t]);for(const t in this._vectors3Arrays)s.setArray3(t,this._vectors3Arrays[t]);for(const t in this._vectors4Arrays)s.setArray4(t,this._vectors4Arrays[t]);for(const t in this._uniformBuffers)s.setUniformBuffer(t,this._uniformBuffers[t]);for(const t in this._textureSamplers)s.setTextureSampler(t,this._textureSamplers[t]);for(const t in this._storageBuffers)s.setStorageBuffer(t,this._storageBuffers[t]);return s}dispose(t,s,e){if(s){let t;for(t in this._textures)this._textures[t].dispose();for(t in this._internalTextures)this._internalTextures[t].dispose();for(t in this._textureArrays){const s=this._textureArrays[t];for(let t=0;t<s.length;t++)s[t].dispose()}}this._textures={},this._internalTextures={},super.dispose(t,s,e)}serialize(){const t=x.Serialize(this);let s;for(s in t.customType="BABYLON.ShaderMaterial",t.uniqueId=this.uniqueId,t.options=this._options,t.shaderPath=this._shaderPath,t.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,t.stencil=this.stencil.serialize(),t.textures={},this._textures)t.textures[s]=this._textures[s].serialize();for(s in t.textureArrays={},this._textureArrays){t.textureArrays[s]=[];const e=this._textureArrays[s];for(let r=0;r<e.length;r++)t.textureArrays[s].push(e[r].serialize())}for(s in t.ints={},this._ints)t.ints[s]=this._ints[s];for(s in t.uints={},this._uints)t.uints[s]=this._uints[s];for(s in t.floats={},this._floats)t.floats[s]=this._floats[s];for(s in t.floatsArrays={},this._floatsArrays)t.floatsArrays[s]=this._floatsArrays[s];for(s in t.colors3={},this._colors3){const e=this._colors3[s];t.colors3[s]=[e.r,e.g,e.b]}for(s in t.colors3Arrays={},this._colors3Arrays)t.colors3Arrays[s]=this._colors3Arrays[s];for(s in t.colors4={},this._colors4){const e=this._colors4[s];t.colors4[s]=[e.r,e.g,e.b,e.a]}for(s in t.colors4Arrays={},this._colors4Arrays)t.colors4Arrays[s]=this._colors4Arrays[s];for(s in t.vectors2={},this._vectors2){const e=this._vectors2[s];t.vectors2[s]=[e.x,e.y]}for(s in t.vectors3={},this._vectors3){const e=this._vectors3[s];t.vectors3[s]=[e.x,e.y,e.z]}for(s in t.vectors4={},this._vectors4){const e=this._vectors4[s];t.vectors4[s]=[e.x,e.y,e.z,e.w]}for(s in t.quaternions={},this._quaternions)t.quaternions[s]=this._quaternions[s].asArray();for(s in t.matrices={},this._matrices)t.matrices[s]=this._matrices[s].asArray();for(s in t.matrixArray={},this._matrixArrays)t.matrixArray[s]=this._matrixArrays[s];for(s in t.matrices3x3={},this._matrices3x3)t.matrices3x3[s]=this._matrices3x3[s];for(s in t.matrices2x2={},this._matrices2x2)t.matrices2x2[s]=this._matrices2x2[s];for(s in t.vectors2Arrays={},this._vectors2Arrays)t.vectors2Arrays[s]=this._vectors2Arrays[s];for(s in t.vectors3Arrays={},this._vectors3Arrays)t.vectors3Arrays[s]=this._vectors3Arrays[s];for(s in t.vectors4Arrays={},this._vectors4Arrays)t.vectors4Arrays[s]=this._vectors4Arrays[s];for(s in t.quaternionsArrays={},this._quaternionsArrays)t.quaternionsArrays[s]=this._quaternionsArrays[s];return t}static Parse(t,e,r){const i=x.Parse((()=>new M(t.name,e,t.shaderPath,t.options,t.storeEffectOnSubMeshes)),t,e,r);let o;for(o in t.stencil&&i.stencil.parse(t.stencil,e,r),t.textures)i.setTexture(o,p.Parse(t.textures[o],e,r));for(o in t.textureArrays){const s=t.textureArrays[o],n=[];for(let t=0;t<s.length;t++)n.push(p.Parse(s[t],e,r));i.setTextureArray(o,n)}for(o in t.ints)i.setInt(o,t.ints[o]);for(o in t.uints)i.setUInt(o,t.uints[o]);for(o in t.floats)i.setFloat(o,t.floats[o]);for(o in t.floatsArrays)i.setFloats(o,t.floatsArrays[o]);for(o in t.colors3){const s=t.colors3[o];i.setColor3(o,{r:s[0],g:s[1],b:s[2]})}for(o in t.colors3Arrays){const s=t.colors3Arrays[o].reduce(((t,s,e)=>(e%3==0?t.push([s]):t[t.length-1].push(s),t)),[]).map((t=>({r:t[0],g:t[1],b:t[2]})));i.setColor3Array(o,s)}for(o in t.colors4){const s=t.colors4[o];i.setColor4(o,{r:s[0],g:s[1],b:s[2],a:s[3]})}for(o in t.colors4Arrays){const s=t.colors4Arrays[o].reduce(((t,s,e)=>(e%4==0?t.push([s]):t[t.length-1].push(s),t)),[]).map((t=>({r:t[0],g:t[1],b:t[2],a:t[3]})));i.setColor4Array(o,s)}for(o in t.vectors2){const s=t.vectors2[o];i.setVector2(o,{x:s[0],y:s[1]})}for(o in t.vectors3){const s=t.vectors3[o];i.setVector3(o,{x:s[0],y:s[1],z:s[2]})}for(o in t.vectors4){const s=t.vectors4[o];i.setVector4(o,{x:s[0],y:s[1],z:s[2],w:s[3]})}for(o in t.quaternions)i.setQuaternion(o,d.FromArray(t.quaternions[o]));for(o in t.matrices)i.setMatrix(o,s.FromArray(t.matrices[o]));for(o in t.matrixArray)i._matrixArrays[o]=new Float32Array(t.matrixArray[o]);for(o in t.matrices3x3)i.setMatrix3x3(o,t.matrices3x3[o]);for(o in t.matrices2x2)i.setMatrix2x2(o,t.matrices2x2[o]);for(o in t.vectors2Arrays)i.setArray2(o,t.vectors2Arrays[o]);for(o in t.vectors3Arrays)i.setArray3(o,t.vectors3Arrays[o]);for(o in t.vectors4Arrays)i.setArray4(o,t.vectors4Arrays[o]);for(o in t.quaternionsArrays)i.setArray4(o,t.quaternionsArrays[o]);return i}static async ParseFromFileAsync(t,s,e,r=""){return await new Promise(((i,o)=>{const n=new m;n.addEventListener("readystatechange",(()=>{if(4==n.readyState)if(200==n.status){const s=JSON.parse(n.responseText),o=this.Parse(s,e||y.LastCreatedScene,r);t&&(o.name=t),i(o)}else o("Unable to load the ShaderMaterial")})),n.open("GET",s),n.send()}))}static async ParseFromSnippetAsync(t,s,e=""){return await new Promise(((r,i)=>{const o=new m;o.addEventListener("readystatechange",(()=>{if(4==o.readyState)if(200==o.status){const i=JSON.parse(JSON.parse(o.responseText).jsonPayload),n=JSON.parse(i.shaderMaterial),a=this.Parse(n,s||y.LastCreatedScene,e);a.snippetId=t,r(a)}else i("Unable to load the snippet "+t)})),o.open("GET",this.SnippetUrl+"/"+t.replace(/#/g,"/")),o.send()}))}}M.SnippetUrl=g.SnippetUrl,M.CreateFromSnippetAsync=M.ParseFromSnippetAsync,v("BABYLON.ShaderMaterial",M);export{M as ShaderMaterial};
//# sourceMappingURL=shaderMaterial-CskxIBTm.esm.min.js.map
