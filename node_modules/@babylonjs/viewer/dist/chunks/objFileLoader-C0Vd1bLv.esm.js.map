{"version":3,"file":"objFileLoader-C0Vd1bLv.esm.js","sources":["../../../../../dev/loaders/dist/OBJ/mtlFileLoader.js","../../../../../dev/loaders/dist/OBJ/solidParser.js","../../../../../dev/loaders/dist/OBJ/objFileLoader.js"],"sourcesContent":["import { Color3 } from \"core/Maths/math.color\";\nimport { Texture } from \"core/Materials/Textures/texture\";\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\n/**\n * Class reading and parsing the MTL file bundled with the obj file.\n */\nexport class MTLFileLoader {\n    constructor() {\n        /**\n         * All material loaded from the mtl will be set here\n         */\n        this.materials = [];\n    }\n    /**\n     * This function will read the mtl file and create each material described inside\n     * This function could be improve by adding :\n     * -some component missing (Ni, Tf...)\n     * -including the specific options available\n     *\n     * @param scene defines the scene the material will be created in\n     * @param data defines the mtl data to parse\n     * @param rootUrl defines the rooturl to use in order to load relative dependencies\n     * @param assetContainer defines the asset container to store the material in (can be null)\n     */\n    parseMTL(scene, data, rootUrl, assetContainer) {\n        if (data instanceof ArrayBuffer) {\n            return;\n        }\n        //Split the lines from the file\n        const lines = data.split(\"\\n\");\n        // whitespace char ie: [ \\t\\r\\n\\f]\n        const delimiterPattern = /\\s+/;\n        //Array with RGB colors\n        let color;\n        //New material\n        let material = null;\n        //Look at each line\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i].trim();\n            // Blank line or comment\n            if (line.length === 0 || line.charAt(0) === \"#\") {\n                continue;\n            }\n            //Get the first parameter (keyword)\n            const pos = line.indexOf(\" \");\n            let key = pos >= 0 ? line.substring(0, pos) : line;\n            key = key.toLowerCase();\n            //Get the data following the key\n            const value = pos >= 0 ? line.substring(pos + 1).trim() : \"\";\n            //This mtl keyword will create the new material\n            if (key === \"newmtl\") {\n                //Check if it is the first material.\n                // Materials specifications are described after this keyword.\n                if (material) {\n                    //Add the previous material in the material array.\n                    this.materials.push(material);\n                }\n                //Create a new material.\n                // value is the name of the material read in the mtl file\n                scene._blockEntityCollection = !!assetContainer;\n                material = new StandardMaterial(value, scene);\n                material._parentContainer = assetContainer;\n                scene._blockEntityCollection = false;\n            }\n            else if (key === \"kd\" && material) {\n                // Diffuse color (color under white light) using RGB values\n                //value  = \"r g b\"\n                color = value.split(delimiterPattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set tghe color into the material\n                material.diffuseColor = Color3.FromArray(color);\n            }\n            else if (key === \"ka\" && material) {\n                // Ambient color (color under shadow) using RGB values\n                //value = \"r g b\"\n                color = value.split(delimiterPattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set tghe color into the material\n                material.ambientColor = Color3.FromArray(color);\n            }\n            else if (key === \"ks\" && material) {\n                // Specular color (color when light is reflected from shiny surface) using RGB values\n                //value = \"r g b\"\n                color = value.split(delimiterPattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set the color into the material\n                material.specularColor = Color3.FromArray(color);\n            }\n            else if (key === \"ke\" && material) {\n                // Emissive color using RGB values\n                color = value.split(delimiterPattern, 3).map(parseFloat);\n                material.emissiveColor = Color3.FromArray(color);\n            }\n            else if (key === \"ns\" && material) {\n                //value = \"Integer\"\n                material.specularPower = parseFloat(value);\n            }\n            else if (key === \"d\" && material) {\n                //d is dissolve for current material. It mean alpha for BABYLON\n                material.alpha = parseFloat(value);\n                //Texture\n                //This part can be improved by adding the possible options of texture\n            }\n            else if (key === \"map_ka\" && material) {\n                // ambient texture map with a loaded image\n                //We must first get the folder of the image\n                material.ambientTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n            }\n            else if (key === \"map_kd\" && material) {\n                // Diffuse texture map with a loaded image\n                material.diffuseTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n            }\n            else if (key === \"map_ks\" && material) {\n                // Specular texture map with a loaded image\n                //We must first get the folder of the image\n                material.specularTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n            }\n            else if (key === \"map_ns\") {\n                //Specular\n                //Specular highlight component\n                //We must first get the folder of the image\n                //\n                //Not supported by BABYLON\n                //\n                //    continue;\n            }\n            else if (key === \"map_bump\" && material) {\n                //The bump texture\n                const values = value.split(delimiterPattern);\n                const bumpMultiplierIndex = values.indexOf(\"-bm\");\n                let bumpMultiplier = null;\n                if (bumpMultiplierIndex >= 0) {\n                    bumpMultiplier = values[bumpMultiplierIndex + 1];\n                    values.splice(bumpMultiplierIndex, 2); // remove\n                }\n                material.bumpTexture = MTLFileLoader._GetTexture(rootUrl, values.join(\" \"), scene);\n                if (material.bumpTexture && bumpMultiplier !== null) {\n                    material.bumpTexture.level = parseFloat(bumpMultiplier);\n                }\n            }\n            else if (key === \"map_d\" && material) {\n                // The dissolve of the material\n                material.opacityTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n                //Options for illumination\n            }\n            else if (key === \"illum\") {\n                //Illumination\n                if (value === \"0\") {\n                    //That mean Kd == Kd\n                }\n                else if (value === \"1\") {\n                    //Color on and Ambient on\n                }\n                else if (value === \"2\") {\n                    //Highlight on\n                }\n                else if (value === \"3\") {\n                    //Reflection on and Ray trace on\n                }\n                else if (value === \"4\") {\n                    //Transparency: Glass on, Reflection: Ray trace on\n                }\n                else if (value === \"5\") {\n                    //Reflection: Fresnel on and Ray trace on\n                }\n                else if (value === \"6\") {\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\n                }\n                else if (value === \"7\") {\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\n                }\n                else if (value === \"8\") {\n                    //Reflection on and Ray trace off\n                }\n                else if (value === \"9\") {\n                    //Transparency: Glass on, Reflection: Ray trace off\n                }\n                else if (value === \"10\") {\n                    //Casts shadows onto invisible surfaces\n                }\n            }\n            else {\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\n            }\n        }\n        //At the end of the file, add the last material\n        if (material) {\n            this.materials.push(material);\n        }\n    }\n    /**\n     * Gets the texture for the material.\n     *\n     * If the material is imported from input file,\n     * We sanitize the url to ensure it takes the texture from aside the material.\n     *\n     * @param rootUrl The root url to load from\n     * @param value The value stored in the mtl\n     * @param scene\n     * @returns The Texture\n     */\n    static _GetTexture(rootUrl, value, scene) {\n        if (!value) {\n            return null;\n        }\n        let url = rootUrl;\n        // Load from input file.\n        if (rootUrl === \"file:\") {\n            let lastDelimiter = value.lastIndexOf(\"\\\\\");\n            if (lastDelimiter === -1) {\n                lastDelimiter = value.lastIndexOf(\"/\");\n            }\n            if (lastDelimiter > -1) {\n                url += value.substring(lastDelimiter + 1);\n            }\n            else {\n                url += value;\n            }\n        }\n        // Not from input file.\n        else {\n            url += value;\n        }\n        return new Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);\n    }\n}\n/**\n * Invert Y-Axis of referenced textures on load\n */\nMTLFileLoader.INVERT_TEXTURE_Y = true;\n//# sourceMappingURL=mtlFileLoader.js.map","import { VertexBuffer } from \"core/Buffers/buffer\";\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\nimport { Color3, Color4 } from \"core/Maths/math.color\";\nimport { Vector2, Vector3 } from \"core/Maths/math.vector\";\nimport { Geometry } from \"core/Meshes/geometry\";\nimport { Mesh } from \"core/Meshes/mesh\";\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\nimport { Logger } from \"core/Misc/logger\";\n/**\n * Class used to load mesh data from OBJ content\n */\nexport class SolidParser {\n    /**\n     * Creates a new SolidParser\n     * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)\n     * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)\n     * @param loadingOptions defines the loading options to use\n     */\n    constructor(materialToUse, babylonMeshesArray, loadingOptions) {\n        this._positions = []; //values for the positions of vertices\n        this._normals = []; //Values for the normals\n        this._uvs = []; //Values for the textures\n        this._colors = [];\n        this._extColors = []; //Extension color\n        this._meshesFromObj = []; //[mesh] Contains all the obj meshes\n        this._indicesForBabylon = []; //The list of indices for VertexData\n        this._wrappedPositionForBabylon = []; //The list of position in vectors\n        this._wrappedUvsForBabylon = []; //Array with all value of uvs to match with the indices\n        this._wrappedColorsForBabylon = []; // Array with all color values to match with the indices\n        this._wrappedNormalsForBabylon = []; //Array with all value of normals to match with the indices\n        this._tuplePosNorm = []; //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\n        this._curPositionInIndices = 0;\n        this._hasMeshes = false; //Meshes are defined in the file\n        this._unwrappedPositionsForBabylon = []; //Value of positionForBabylon w/o Vector3() [x,y,z]\n        this._unwrappedColorsForBabylon = []; // Value of colorForBabylon w/o Color4() [r,g,b,a]\n        this._unwrappedNormalsForBabylon = []; //Value of normalsForBabylon w/o Vector3()  [x,y,z]\n        this._unwrappedUVForBabylon = []; //Value of uvsForBabylon w/o Vector3()      [x,y,z]\n        this._triangles = []; //Indices from new triangles coming from polygons\n        this._materialNameFromObj = \"\"; //The name of the current material\n        this._objMeshName = \"\"; //The name of the current obj mesh\n        this._increment = 1; //Id for meshes created by the multimaterial\n        this._isFirstMaterial = true;\n        this._grayColor = new Color4(0.5, 0.5, 0.5, 1);\n        this._hasLineData = false; //If this mesh has line segment(l) data\n        this._materialToUse = materialToUse;\n        this._babylonMeshesArray = babylonMeshesArray;\n        this._loadingOptions = loadingOptions;\n    }\n    /**\n     * Search for obj in the given array.\n     * This function is called to check if a couple of data already exists in an array.\n     *\n     * If found, returns the index of the founded tuple index. Returns -1 if not found\n     * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\n     * @param obj Array<number>\n     * @returns {boolean}\n     */\n    _isInArray(arr, obj) {\n        if (!arr[obj[0]]) {\n            arr[obj[0]] = { normals: [], idx: [] };\n        }\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\n        return idx === -1 ? -1 : arr[obj[0]].idx[idx];\n    }\n    _isInArrayUV(arr, obj) {\n        if (!arr[obj[0]]) {\n            arr[obj[0]] = { normals: [], idx: [], uv: [] };\n        }\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\n        if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {\n            return arr[obj[0]].idx[idx];\n        }\n        return -1;\n    }\n    /**\n     * This function set the data for each triangle.\n     * Data are position, normals and uvs\n     * If a tuple of (position, normal) is not set, add the data into the corresponding array\n     * If the tuple already exist, add only their indice\n     *\n     * @param data The vertex's data\n     * * indicesPositionFromObj: The index in positions array\n     * * indicesUvsFromObj: The index in uvs array\n     * * indicesNormalFromObj: The index in normals array\n     * * positionVectorFromOBJ: The value of position at index objIndice\n     * * textureVectorFromOBJ: The value of uvs\n     * * normalsVectorFromOBJ: The value of normals at index objNormale\n     * * positionColorsFromOBJ: The value of color at index objIndice\n     */\n    _setData(data) {\n        //Use default values if undefined\n        data.indiceUvsFromObj ??= -1;\n        data.indiceNormalFromObj ??= -1;\n        //Check if this tuple already exists in the list of tuples\n        let _index;\n        if (this._loadingOptions.optimizeWithUV) {\n            _index = this._isInArrayUV(this._tuplePosNorm, [data.indicePositionFromObj, data.indiceNormalFromObj, data.indiceUvsFromObj]);\n        }\n        else {\n            _index = this._isInArray(this._tuplePosNorm, [data.indicePositionFromObj, data.indiceNormalFromObj]);\n        }\n        //If it not exists\n        if (_index === -1) {\n            //Add an new indice.\n            //The array of indices is only an array with his length equal to the number of triangles - 1.\n            //We add vertices data in this order\n            this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);\n            //Push the position of vertice for Babylon\n            //Each element is a Vector3(x,y,z)\n            this._wrappedPositionForBabylon.push(data.positionVectorFromOBJ);\n            if (data.textureVectorFromOBJ !== undefined) {\n                //Push the uvs for Babylon\n                //Each element is a Vector2(u,v)\n                this._wrappedUvsForBabylon.push(data.textureVectorFromOBJ);\n            }\n            if (data.normalsVectorFromOBJ !== undefined) {\n                //Push the normals for Babylon\n                //Each element is a Vector3(x,y,z)\n                this._wrappedNormalsForBabylon.push(data.normalsVectorFromOBJ);\n            }\n            if (data.positionColorsFromOBJ !== undefined) {\n                //Push the colors for Babylon\n                //Each element is a BABYLON.Color4(r,g,b,a)\n                this._wrappedColorsForBabylon.push(data.positionColorsFromOBJ);\n            }\n            //Add the tuple in the comparison list\n            this._tuplePosNorm[data.indicePositionFromObj].normals.push(data.indiceNormalFromObj);\n            this._tuplePosNorm[data.indicePositionFromObj].idx.push(this._curPositionInIndices++);\n            if (this._loadingOptions.optimizeWithUV) {\n                this._tuplePosNorm[data.indicePositionFromObj].uv.push(data.indiceUvsFromObj);\n            }\n        }\n        else {\n            //The tuple already exists\n            //Add the index of the already existing tuple\n            //At this index we can get the value of position, normal, color and uvs of vertex\n            this._indicesForBabylon.push(_index);\n        }\n    }\n    /**\n     * Transform Vector() and BABYLON.Color() objects into numbers in an array\n     */\n    _unwrapData() {\n        try {\n            //Every array has the same length\n            for (let l = 0; l < this._wrappedPositionForBabylon.length; l++) {\n                //Push the x, y, z values of each element in the unwrapped array\n                this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[l].x * this._handednessSign, this._wrappedPositionForBabylon[l].y, this._wrappedPositionForBabylon[l].z);\n                if (this._wrappedNormalsForBabylon.length) {\n                    this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[l].x * this._handednessSign, this._wrappedNormalsForBabylon[l].y, this._wrappedNormalsForBabylon[l].z);\n                }\n                if (this._wrappedUvsForBabylon.length) {\n                    this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\n                }\n                if (this._unwrappedColorsForBabylon.length) {\n                    //Push the r, g, b, a values of each element in the unwrapped array\n                    this._unwrappedColorsForBabylon.push(this._wrappedColorsForBabylon[l].r, this._wrappedColorsForBabylon[l].g, this._wrappedColorsForBabylon[l].b, this._wrappedColorsForBabylon[l].a);\n                }\n            }\n            // Reset arrays for the next new meshes\n            this._wrappedPositionForBabylon.length = 0;\n            this._wrappedNormalsForBabylon.length = 0;\n            this._wrappedUvsForBabylon.length = 0;\n            this._wrappedColorsForBabylon.length = 0;\n            this._tuplePosNorm.length = 0;\n            this._curPositionInIndices = 0;\n        }\n        catch (e) {\n            throw new Error(\"Unable to unwrap data while parsing OBJ data.\");\n        }\n    }\n    /**\n     * Create triangles from polygons\n     * It is important to notice that a triangle is a polygon\n     * We get 5 patterns of face defined in OBJ File :\n     * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\n     * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\n     * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\n     * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\n     * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\n     * Each pattern is divided by the same method\n     * @param faces Array[String] The indices of elements\n     * @param v Integer The variable to increment\n     */\n    _getTriangles(faces, v) {\n        //Work for each element of the array\n        for (let faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {\n            //Add on the triangle variable the indexes to obtain triangles\n            this._pushTriangle(faces, faceIndex);\n        }\n        //Result obtained after 2 iterations:\n        //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\n        //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\n        //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\n        //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\n        //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\n    }\n    /**\n     * To get color between color and extension color\n     * @param index Integer The index of the element in the array\n     * @returns value of target color\n     */\n    _getColor(index) {\n        if (this._loadingOptions.importVertexColors) {\n            return this._extColors[index] ?? this._colors[index];\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 1\n     * In this pattern we get vertice positions\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern1(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        //For each element in the triangles array.\n        //This var could contains 1 to an infinity of triangles\n        for (let k = 0; k < this._triangles.length; k++) {\n            // Set position indice\n            const indicePositionFromObj = parseInt(this._triangles[k]) - 1;\n            this._setData({\n                indicePositionFromObj,\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\n            });\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 2\n     * In this pattern we get vertice positions and uvs\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern2(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"1/1\"\n            //Split the data for getting position and uv\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\"]\n            //Set position indice\n            const indicePositionFromObj = parseInt(point[0]) - 1;\n            //Set uv indice\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\n            this._setData({\n                indicePositionFromObj,\n                indiceUvsFromObj,\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\n                textureVectorFromOBJ: this._uvs[indiceUvsFromObj],\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\n            });\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 3\n     * In this pattern we get vertice positions, uvs and normals\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern3(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"1/1/1\"\n            //Split the data for getting position, uv, and normals\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\n            // Set position indice\n            const indicePositionFromObj = parseInt(point[0]) - 1;\n            // Set uv indice\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\n            // Set normal indice\n            const indiceNormalFromObj = parseInt(point[2]) - 1;\n            this._setData({\n                indicePositionFromObj,\n                indiceUvsFromObj,\n                indiceNormalFromObj,\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\n                textureVectorFromOBJ: this._uvs[indiceUvsFromObj],\n                normalsVectorFromOBJ: this._normals[indiceNormalFromObj],\n            });\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 4\n     * In this pattern we get vertice positions and normals\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern4(face, v) {\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"1//1\"\n            //Split the data for getting position and normals\n            const point = this._triangles[k].split(\"//\"); // [\"1\", \"1\"]\n            // We check indices, and normals\n            const indicePositionFromObj = parseInt(point[0]) - 1;\n            const indiceNormalFromObj = parseInt(point[1]) - 1;\n            this._setData({\n                indicePositionFromObj,\n                indiceNormalFromObj,\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\n                normalsVectorFromOBJ: this._normals[indiceNormalFromObj],\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\n            });\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /*\n     * Create triangles and push the data for each polygon for the pattern 3\n     * In this pattern we get vertice positions, uvs and normals\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern5(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"-1/-1/-1\"\n            //Split the data for getting position, uv, and normals\n            const point = this._triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\n            // Set position indice\n            const indicePositionFromObj = this._positions.length + parseInt(point[0]);\n            // Set uv indice\n            const indiceUvsFromObj = this._uvs.length + parseInt(point[1]);\n            // Set normal indice\n            const indiceNormalFromObj = this._normals.length + parseInt(point[2]);\n            this._setData({\n                indicePositionFromObj,\n                indiceUvsFromObj,\n                indiceNormalFromObj,\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\n                textureVectorFromOBJ: this._uvs[indiceUvsFromObj],\n                normalsVectorFromOBJ: this._normals[indiceNormalFromObj],\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\n            });\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    _addPreviousObjMesh() {\n        //Check if it is not the first mesh. Otherwise we don't have data.\n        if (this._meshesFromObj.length > 0) {\n            //Get the previous mesh for applying the data about the faces\n            //=> in obj file, faces definition append after the name of the mesh\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\n            //Set the data into Array for the mesh\n            this._unwrapData();\n            if (this._loadingOptions.useLegacyBehavior) {\n                // Reverse tab. Otherwise face are displayed in the wrong sens\n                this._indicesForBabylon.reverse();\n            }\n            //Set the information for the mesh\n            //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\n            this._handledMesh.indices = this._indicesForBabylon.slice();\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();\n            if (this._unwrappedNormalsForBabylon.length) {\n                this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();\n            }\n            if (this._unwrappedUVForBabylon.length) {\n                this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();\n            }\n            if (this._unwrappedColorsForBabylon.length) {\n                this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();\n            }\n            this._handledMesh.hasLines = this._hasLineData;\n            //Reset the array for the next mesh\n            this._indicesForBabylon.length = 0;\n            this._unwrappedPositionsForBabylon.length = 0;\n            this._unwrappedColorsForBabylon.length = 0;\n            this._unwrappedNormalsForBabylon.length = 0;\n            this._unwrappedUVForBabylon.length = 0;\n            this._hasLineData = false;\n        }\n    }\n    _optimizeNormals(mesh) {\n        const positions = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const normals = mesh.getVerticesData(VertexBuffer.NormalKind);\n        const mapVertices = {};\n        if (!positions || !normals) {\n            return;\n        }\n        for (let i = 0; i < positions.length / 3; i++) {\n            const x = positions[i * 3 + 0];\n            const y = positions[i * 3 + 1];\n            const z = positions[i * 3 + 2];\n            const key = x + \"_\" + y + \"_\" + z;\n            let lst = mapVertices[key];\n            if (!lst) {\n                lst = [];\n                mapVertices[key] = lst;\n            }\n            lst.push(i);\n        }\n        const normal = new Vector3();\n        for (const key in mapVertices) {\n            const lst = mapVertices[key];\n            if (lst.length < 2) {\n                continue;\n            }\n            const v0Idx = lst[0];\n            for (let i = 1; i < lst.length; ++i) {\n                const vIdx = lst[i];\n                normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];\n                normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];\n                normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];\n            }\n            normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);\n            normal.normalize();\n            for (let i = 0; i < lst.length; ++i) {\n                const vIdx = lst[i];\n                normals[vIdx * 3 + 0] = normal.x;\n                normals[vIdx * 3 + 1] = normal.y;\n                normals[vIdx * 3 + 2] = normal.z;\n            }\n        }\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n    }\n    static _IsLineElement(line) {\n        return line.startsWith(\"l\");\n    }\n    static _IsObjectElement(line) {\n        return line.startsWith(\"o\");\n    }\n    static _IsGroupElement(line) {\n        return line.startsWith(\"g\");\n    }\n    static _GetZbrushMRGB(line, notParse) {\n        if (!line.startsWith(\"mrgb\")) {\n            return null;\n        }\n        line = line.replace(\"mrgb\", \"\").trim();\n        // if include vertex color , not load mrgb anymore\n        if (notParse) {\n            return [];\n        }\n        const regex = /[a-z0-9]/g;\n        const regArray = line.match(regex);\n        if (!regArray || regArray.length % 8 !== 0) {\n            return [];\n        }\n        const array = [];\n        for (let regIndex = 0; regIndex < regArray.length / 8; regIndex++) {\n            //each item is MMRRGGBB, m is material index\n            // const m = regArray[regIndex * 8 + 0] + regArray[regIndex * 8 + 1];\n            const r = regArray[regIndex * 8 + 2] + regArray[regIndex * 8 + 3];\n            const g = regArray[regIndex * 8 + 4] + regArray[regIndex * 8 + 5];\n            const b = regArray[regIndex * 8 + 6] + regArray[regIndex * 8 + 7];\n            array.push(new Color4(parseInt(r, 16) / 255, parseInt(g, 16) / 255, parseInt(b, 16) / 255, 1));\n        }\n        return array;\n    }\n    /**\n     * Function used to parse an OBJ string\n     * @param meshesNames defines the list of meshes to load (all if not defined)\n     * @param data defines the OBJ string\n     * @param scene defines the hosting scene\n     * @param assetContainer defines the asset container to load data in\n     * @param onFileToLoadFound defines a callback that will be called if a MTL file is found\n     */\n    parse(meshesNames, data, scene, assetContainer, onFileToLoadFound) {\n        //Move Santitize here to forbid delete zbrush data\n        // Sanitize data\n        data = data.replace(/#MRGB/g, \"mrgb\");\n        data = data.replace(/#.*$/gm, \"\").trim();\n        if (this._loadingOptions.useLegacyBehavior) {\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\n            this._handednessSign = 1;\n        }\n        else if (scene.useRightHandedSystem) {\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex + 1], faces[faceIndex]);\n            this._handednessSign = 1;\n        }\n        else {\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\n            this._handednessSign = -1;\n        }\n        // Split the file into lines\n        // Preprocess line data\n        const linesOBJ = data.split(\"\\n\");\n        const lineLines = [];\n        let currentGroup = [];\n        lineLines.push(currentGroup);\n        for (let i = 0; i < linesOBJ.length; i++) {\n            const line = linesOBJ[i].trim().replace(/\\s\\s/g, \" \");\n            // Comment or newLine\n            if (line.length === 0 || line.charAt(0) === \"#\") {\n                continue;\n            }\n            if (SolidParser._IsGroupElement(line) || SolidParser._IsObjectElement(line)) {\n                currentGroup = [];\n                lineLines.push(currentGroup);\n            }\n            if (SolidParser._IsLineElement(line)) {\n                const lineValues = line.split(\" \");\n                // create line elements with two vertices only\n                for (let i = 1; i < lineValues.length - 1; i++) {\n                    currentGroup.push(`l ${lineValues[i]} ${lineValues[i + 1]}`);\n                }\n            }\n            else {\n                currentGroup.push(line);\n            }\n        }\n        const lines = lineLines.flat();\n        // Look at each line\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i].trim().replace(/\\s\\s/g, \" \");\n            let result;\n            // Comment or newLine\n            if (line.length === 0 || line.charAt(0) === \"#\") {\n                continue;\n            }\n            else if (SolidParser.VertexPattern.test(line)) {\n                //Get information about one position possible for the vertices\n                result = line.match(/[^ ]+/g); // match will return non-null due to passing regex pattern\n                // Value of result with line: \"v 1.0 2.0 3.0\"\n                // [\"v\", \"1.0\", \"2.0\", \"3.0\"]\n                // Create a Vector3 with the position x, y, z\n                this._positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n                if (this._loadingOptions.importVertexColors) {\n                    if (result.length >= 7) {\n                        const r = parseFloat(result[4]);\n                        const g = parseFloat(result[5]);\n                        const b = parseFloat(result[6]);\n                        this._colors.push(new Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === undefined ? 1 : parseFloat(result[7])));\n                    }\n                    else {\n                        // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).\n                        this._colors.push(this._grayColor);\n                    }\n                }\n            }\n            else if ((result = SolidParser.NormalPattern.exec(line)) !== null) {\n                //Create a Vector3 with the normals x, y, z\n                //Value of result\n                // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n                //Add the Vector in the list of normals\n                this._normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n            }\n            else if ((result = SolidParser.UVPattern.exec(line)) !== null) {\n                //Create a Vector2 with the normals u, v\n                //Value of result\n                // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\n                //Add the Vector in the list of uvs\n                this._uvs.push(new Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));\n                //Identify patterns of faces\n                //Face could be defined in different type of pattern\n            }\n            else if ((result = SolidParser.FacePattern3.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern3(result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern4.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern4(result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern5.exec(line)) !== null) {\n                //Value of result:\n                //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern5(result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern2.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern2(result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern1.exec(line)) !== null) {\n                //Value of result\n                //[\"f 1 2 3\", \"1 2 3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern1(result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\n                1);\n                // Define a mesh or an object\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\n            }\n            else if ((result = SolidParser.LinePattern1.exec(line)) !== null) {\n                //Value of result\n                //[\"l 1 2\"]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern1(result[1].trim().split(\" \"), // [\"1\", \"2\"]\n                0);\n                this._hasLineData = true;\n                // Define a mesh or an object\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\n            }\n            else if ((result = SolidParser.LinePattern2.exec(line)) !== null) {\n                //Value of result\n                //[\"l 1/1 2/2\"]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern2(result[1].trim().split(\" \"), // [\"1/1\", \"2/2\"]\n                0);\n                this._hasLineData = true;\n                // Define a mesh or an object\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\n            }\n            else if ((result = SolidParser._GetZbrushMRGB(line, !this._loadingOptions.importVertexColors))) {\n                for (const element of result) {\n                    this._extColors.push(element);\n                }\n            }\n            else if ((result = SolidParser.LinePattern3.exec(line)) !== null) {\n                //Value of result\n                //[\"l 1/1/1 2/2/2\"]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern3(result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\"]\n                0);\n                this._hasLineData = true;\n                // Define a mesh or an object\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\n            }\n            else if (SolidParser.GroupDescriptor.test(line) || SolidParser.ObjectDescriptor.test(line)) {\n                // Create a new mesh corresponding to the name of the group.\n                // Definition of the mesh\n                const objMesh = {\n                    name: line.substring(2).trim(), //Set the name of the current obj mesh\n                    indices: null,\n                    positions: null,\n                    normals: null,\n                    uvs: null,\n                    colors: null,\n                    materialName: this._materialNameFromObj,\n                    isObject: SolidParser.ObjectDescriptor.test(line),\n                };\n                this._addPreviousObjMesh();\n                //Push the last mesh created with only the name\n                this._meshesFromObj.push(objMesh);\n                //Set this variable to indicate that now meshesFromObj has objects defined inside\n                this._hasMeshes = true;\n                this._isFirstMaterial = true;\n                this._increment = 1;\n                //Keyword for applying a material\n            }\n            else if (SolidParser.UseMtlDescriptor.test(line)) {\n                //Get the name of the material\n                this._materialNameFromObj = line.substring(7).trim();\n                //If this new material is in the same mesh\n                if (!this._isFirstMaterial || !this._hasMeshes) {\n                    //Set the data for the previous mesh\n                    this._addPreviousObjMesh();\n                    //Create a new mesh\n                    const objMesh = \n                    //Set the name of the current obj mesh\n                    {\n                        name: (this._objMeshName || \"mesh\") + \"_mm\" + this._increment.toString(), //Set the name of the current obj mesh\n                        indices: null,\n                        positions: null,\n                        normals: null,\n                        uvs: null,\n                        colors: null,\n                        materialName: this._materialNameFromObj,\n                        isObject: false,\n                    };\n                    this._increment++;\n                    //If meshes are already defined\n                    this._meshesFromObj.push(objMesh);\n                    this._hasMeshes = true;\n                }\n                //Set the material name if the previous line define a mesh\n                if (this._hasMeshes && this._isFirstMaterial) {\n                    //Set the material name to the previous mesh (1 material per mesh)\n                    this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;\n                    this._isFirstMaterial = false;\n                }\n                // Keyword for loading the mtl file\n            }\n            else if (SolidParser.MtlLibGroupDescriptor.test(line)) {\n                // Get the name of mtl file\n                onFileToLoadFound(line.substring(7).trim());\n                // Apply smoothing\n            }\n            else if (SolidParser.SmoothDescriptor.test(line)) {\n                // smooth shading => apply smoothing\n                // Today I don't know it work with babylon and with obj.\n                // With the obj file  an integer is set\n            }\n            else {\n                //If there is another possibility\n                Logger.Log(\"Unhandled expression at line : \" + line);\n            }\n        }\n        // At the end of the file, add the last mesh into the meshesFromObj array\n        if (this._hasMeshes) {\n            // Set the data for the last mesh\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\n            if (this._loadingOptions.useLegacyBehavior) {\n                //Reverse indices for displaying faces in the good sense\n                this._indicesForBabylon.reverse();\n            }\n            //Get the good array\n            this._unwrapData();\n            //Set array\n            this._handledMesh.indices = this._indicesForBabylon;\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon;\n            if (this._unwrappedNormalsForBabylon.length) {\n                this._handledMesh.normals = this._unwrappedNormalsForBabylon;\n            }\n            if (this._unwrappedUVForBabylon.length) {\n                this._handledMesh.uvs = this._unwrappedUVForBabylon;\n            }\n            if (this._unwrappedColorsForBabylon.length) {\n                this._handledMesh.colors = this._unwrappedColorsForBabylon;\n            }\n            this._handledMesh.hasLines = this._hasLineData;\n        }\n        // If any o or g keyword not found, create a mesh with a random id\n        if (!this._hasMeshes) {\n            let newMaterial = null;\n            if (this._indicesForBabylon.length) {\n                if (this._loadingOptions.useLegacyBehavior) {\n                    // reverse tab of indices\n                    this._indicesForBabylon.reverse();\n                }\n                //Get positions normals uvs\n                this._unwrapData();\n            }\n            else {\n                // There is no indices in the file. We will have to switch to point cloud rendering\n                for (const pos of this._positions) {\n                    this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);\n                }\n                if (this._normals.length) {\n                    for (const normal of this._normals) {\n                        this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);\n                    }\n                }\n                if (this._uvs.length) {\n                    for (const uv of this._uvs) {\n                        this._unwrappedUVForBabylon.push(uv.x, uv.y);\n                    }\n                }\n                if (this._extColors.length) {\n                    for (const color of this._extColors) {\n                        this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\n                    }\n                }\n                else {\n                    if (this._colors.length) {\n                        for (const color of this._colors) {\n                            this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\n                        }\n                    }\n                }\n                if (!this._materialNameFromObj) {\n                    // Create a material with point cloud on\n                    newMaterial = new StandardMaterial(Geometry.RandomId(), scene);\n                    newMaterial.pointsCloud = true;\n                    this._materialNameFromObj = newMaterial.name;\n                    if (!this._normals.length) {\n                        newMaterial.disableLighting = true;\n                        newMaterial.emissiveColor = Color3.White();\n                    }\n                }\n            }\n            //Set data for one mesh\n            this._meshesFromObj.push({\n                name: Geometry.RandomId(),\n                indices: this._indicesForBabylon,\n                positions: this._unwrappedPositionsForBabylon,\n                colors: this._unwrappedColorsForBabylon,\n                normals: this._unwrappedNormalsForBabylon,\n                uvs: this._unwrappedUVForBabylon,\n                materialName: this._materialNameFromObj,\n                directMaterial: newMaterial,\n                isObject: true,\n                hasLines: this._hasLineData,\n            });\n        }\n        //Set data for each mesh\n        for (let j = 0; j < this._meshesFromObj.length; j++) {\n            //check meshesNames (stlFileLoader)\n            if (meshesNames && this._meshesFromObj[j].name) {\n                if (meshesNames instanceof Array) {\n                    if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {\n                        continue;\n                    }\n                }\n                else {\n                    if (this._meshesFromObj[j].name !== meshesNames) {\n                        continue;\n                    }\n                }\n            }\n            //Get the current mesh\n            //Set the data with VertexBuffer for each mesh\n            this._handledMesh = this._meshesFromObj[j];\n            //Create a Mesh with the name of the obj mesh\n            scene._blockEntityCollection = !!assetContainer;\n            const babylonMesh = new Mesh(this._meshesFromObj[j].name, scene);\n            babylonMesh._parentContainer = assetContainer;\n            scene._blockEntityCollection = false;\n            this._handledMesh._babylonMesh = babylonMesh;\n            // If this is a group mesh, it should have an object mesh as a parent. So look for the first object mesh that appears before it.\n            if (!this._handledMesh.isObject) {\n                for (let k = j - 1; k >= 0; --k) {\n                    if (this._meshesFromObj[k].isObject && this._meshesFromObj[k]._babylonMesh) {\n                        babylonMesh.parent = this._meshesFromObj[k]._babylonMesh;\n                        break;\n                    }\n                }\n            }\n            //Push the name of the material to an array\n            //This is indispensable for the importMesh function\n            this._materialToUse.push(this._meshesFromObj[j].materialName);\n            //If the mesh is a line mesh\n            if (this._handledMesh.hasLines) {\n                babylonMesh._internalMetadata ??= {};\n                babylonMesh._internalMetadata[\"_isLine\"] = true; //this is a line mesh\n            }\n            if (this._handledMesh.positions?.length === 0) {\n                //Push the mesh into an array\n                this._babylonMeshesArray.push(babylonMesh);\n                continue;\n            }\n            const vertexData = new VertexData(); //The container for the values\n            //Set the data for the babylonMesh\n            vertexData.indices = this._handledMesh.indices;\n            vertexData.positions = this._handledMesh.positions;\n            if (this._loadingOptions.computeNormals || !this._handledMesh.normals) {\n                // Compute normals if requested or if normals are not defined\n                const normals = new Array();\n                VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);\n                vertexData.normals = normals;\n            }\n            else {\n                vertexData.normals = this._handledMesh.normals;\n            }\n            if (this._handledMesh.uvs) {\n                vertexData.uvs = this._handledMesh.uvs;\n            }\n            if (this._handledMesh.colors) {\n                vertexData.colors = this._handledMesh.colors;\n            }\n            //Set the data from the VertexBuffer to the current Mesh\n            vertexData.applyToMesh(babylonMesh);\n            if (this._loadingOptions.invertY) {\n                babylonMesh.scaling.y *= -1;\n            }\n            if (this._loadingOptions.optimizeNormals) {\n                this._optimizeNormals(babylonMesh);\n            }\n            //Push the mesh into an array\n            this._babylonMeshesArray.push(babylonMesh);\n            if (this._handledMesh.directMaterial) {\n                babylonMesh.material = this._handledMesh.directMaterial;\n            }\n        }\n    }\n}\n// Descriptor\n/** Object descriptor */\nSolidParser.ObjectDescriptor = /^o/;\n/** Group descriptor */\nSolidParser.GroupDescriptor = /^g/;\n/** Material lib descriptor */\nSolidParser.MtlLibGroupDescriptor = /^mtllib /;\n/** Use a material descriptor */\nSolidParser.UseMtlDescriptor = /^usemtl /;\n/** Smooth descriptor */\nSolidParser.SmoothDescriptor = /^s /;\n// Patterns\n/** Pattern used to detect a vertex */\nSolidParser.VertexPattern = /^v(\\s+[\\d|.|+|\\-|e|E]+){3,7}/;\n/** Pattern used to detect a normal */\nSolidParser.NormalPattern = /^vn(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\n/** Pattern used to detect a UV set */\nSolidParser.UVPattern = /^vt(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\n/** Pattern used to detect a first kind of face (f vertex vertex vertex) */\nSolidParser.FacePattern1 = /^f\\s+(([\\d]{1,}[\\s]?){3,})+/;\n/** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */\nSolidParser.FacePattern2 = /^f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */\nSolidParser.FacePattern3 = /^f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/\nSolidParser.FacePattern4 = /^f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */\nSolidParser.FacePattern5 = /^f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a line(l vertex vertex) */\nSolidParser.LinePattern1 = /^l\\s+(([\\d]{1,}[\\s]?){2,})+/;\n/** Pattern used to detect a second kind of line (l vertex/uvs vertex/uvs) */\nSolidParser.LinePattern2 = /^l\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){2,})+)/;\n/** Pattern used to detect a third kind of line (l vertex/uvs/normal vertex/uvs/normal) */\nSolidParser.LinePattern3 = /^l\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){2,})+)/;\n//# sourceMappingURL=solidParser.js.map","import { Vector2 } from \"core/Maths/math.vector\";\nimport { Tools } from \"core/Misc/tools\";\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\nimport { AssetContainer } from \"core/assetContainer\";\nimport { OBJFileLoaderMetadata } from \"./objFileLoader.metadata\";\nimport { MTLFileLoader } from \"./mtlFileLoader\";\nimport { SolidParser } from \"./solidParser\";\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\n/**\n * OBJ file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class OBJFileLoader {\n    /**\n     * Invert Y-Axis of referenced textures on load\n     */\n    static get INVERT_TEXTURE_Y() {\n        return MTLFileLoader.INVERT_TEXTURE_Y;\n    }\n    static set INVERT_TEXTURE_Y(value) {\n        MTLFileLoader.INVERT_TEXTURE_Y = value;\n    }\n    /**\n     * Creates loader for .OBJ files\n     *\n     * @param loadingOptions options for loading and parsing OBJ/MTL files.\n     */\n    constructor(loadingOptions) {\n        /**\n         * Defines the name of the plugin.\n         */\n        this.name = OBJFileLoaderMetadata.name;\n        /**\n         * Defines the extension the plugin is able to load.\n         */\n        this.extensions = OBJFileLoaderMetadata.extensions;\n        this._assetContainer = null;\n        this._loadingOptions = { ...OBJFileLoader._DefaultLoadingOptions, ...(loadingOptions ?? {}) };\n    }\n    static get _DefaultLoadingOptions() {\n        return {\n            computeNormals: OBJFileLoader.COMPUTE_NORMALS,\n            optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,\n            importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\n            invertY: OBJFileLoader.INVERT_Y,\n            invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            UVScaling: OBJFileLoader.UV_SCALING,\n            materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\n            optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\n            skipMaterials: OBJFileLoader.SKIP_MATERIALS,\n            useLegacyBehavior: OBJFileLoader.USE_LEGACY_BEHAVIOR,\n        };\n    }\n    /**\n     * Calls synchronously the MTL file attached to this obj.\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\n     * Without this function materials are not displayed in the first frame (but displayed after).\n     * In consequence it is impossible to get material information in your HTML file\n     *\n     * @param url The URL of the MTL file\n     * @param rootUrl defines where to load data from\n     * @param onSuccess Callback function to be called when the MTL file is loaded\n     * @param onFailure\n     */\n    _loadMTL(url, rootUrl, onSuccess, onFailure) {\n        //The complete path to the mtl file\n        const pathOfFile = rootUrl + url;\n        // Loads through the babylon tools to allow fileInput search.\n        Tools.LoadFile(pathOfFile, onSuccess, undefined, undefined, false, (request, exception) => {\n            onFailure(pathOfFile, exception);\n        });\n    }\n    /** @internal */\n    createPlugin(options) {\n        return new OBJFileLoader(options[OBJFileLoaderMetadata.name]);\n    }\n    /**\n     * If the data string can be loaded directly.\n     * @returns if the data can be loaded directly\n     */\n    canDirectLoad() {\n        return false;\n    }\n    /**\n     * Imports one or more meshes from the loaded OBJ data and adds them to the scene\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    importMeshAsync(meshesNames, scene, data, rootUrl) {\n        //get the meshes from OBJ file\n        // eslint-disable-next-line github/no-then\n        return this._parseSolidAsync(meshesNames, scene, data, rootUrl).then((meshes) => {\n            return {\n                meshes: meshes,\n                particleSystems: [],\n                skeletons: [],\n                animationGroups: [],\n                transformNodes: [],\n                geometries: [],\n                lights: [],\n                spriteManagers: [],\n            };\n        });\n    }\n    /**\n     * Imports all objects from the loaded OBJ data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadAsync(scene, data, rootUrl) {\n        //Get the 3D model\n        // eslint-disable-next-line github/no-then\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\n            // return void\n        });\n    }\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @returns The loaded asset container\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    loadAssetContainerAsync(scene, data, rootUrl) {\n        const container = new AssetContainer(scene);\n        this._assetContainer = container;\n        return (this.importMeshAsync(null, scene, data, rootUrl)\n            // eslint-disable-next-line github/no-then\n            .then((result) => {\n            result.meshes.forEach((mesh) => container.meshes.push(mesh));\n            result.meshes.forEach((mesh) => {\n                const material = mesh.material;\n                if (material) {\n                    // Materials\n                    if (container.materials.indexOf(material) == -1) {\n                        container.materials.push(material);\n                        // Textures\n                        const textures = material.getActiveTextures();\n                        textures.forEach((t) => {\n                            if (container.textures.indexOf(t) == -1) {\n                                container.textures.push(t);\n                            }\n                        });\n                    }\n                }\n            });\n            this._assetContainer = null;\n            return container;\n        })\n            // eslint-disable-next-line github/no-then\n            .catch((ex) => {\n            this._assetContainer = null;\n            throw ex;\n        }));\n    }\n    /**\n     * Read the OBJ file and create an Array of meshes.\n     * Each mesh contains all information given by the OBJ and the MTL file.\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\n     * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene defines the scene where are displayed the data\n     * @param data defines the content of the obj file\n     * @param rootUrl defines the path to the folder\n     * @returns the list of loaded meshes\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _parseSolidAsync(meshesNames, scene, data, rootUrl) {\n        let fileToLoad = \"\"; //The name of the mtlFile to load\n        const materialsFromMTLFile = new MTLFileLoader();\n        const materialToUse = [];\n        const babylonMeshesArray = []; //The mesh for babylon\n        // Sanitize data\n        data = data.replace(/#.*$/gm, \"\").trim();\n        // Main function\n        const solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);\n        solidParser.parse(meshesNames, data, scene, this._assetContainer, (fileName) => {\n            fileToLoad = fileName;\n        });\n        // load the materials\n        const mtlPromises = [];\n        // Check if we have a file to load\n        if (fileToLoad !== \"\" && !this._loadingOptions.skipMaterials) {\n            //Load the file synchronously\n            mtlPromises.push(new Promise((resolve, reject) => {\n                this._loadMTL(fileToLoad, rootUrl, (dataLoaded) => {\n                    try {\n                        //Create materials thanks MTLLoader function\n                        materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, this._assetContainer);\n                        //Look at each material loaded in the mtl file\n                        for (let n = 0; n < materialsFromMTLFile.materials.length; n++) {\n                            //Three variables to get all meshes with the same material\n                            let startIndex = 0;\n                            const _indices = [];\n                            let _index;\n                            //The material from MTL file is used in the meshes loaded\n                            //Push the indice in an array\n                            //Check if the material is not used for another mesh\n                            while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\n                                _indices.push(_index);\n                                startIndex = _index + 1;\n                            }\n                            //If the material is not used dispose it\n                            if (_index === -1 && _indices.length === 0) {\n                                //If the material is not needed, remove it\n                                materialsFromMTLFile.materials[n].dispose();\n                            }\n                            else {\n                                for (let o = 0; o < _indices.length; o++) {\n                                    //Apply the material to the Mesh for each mesh with the material\n                                    const mesh = babylonMeshesArray[_indices[o]];\n                                    const material = materialsFromMTLFile.materials[n];\n                                    mesh.material = material;\n                                    if (!mesh.getTotalIndices()) {\n                                        // No indices, we need to turn on point cloud\n                                        material.pointsCloud = true;\n                                    }\n                                }\n                            }\n                        }\n                        resolve();\n                    }\n                    catch (e) {\n                        Tools.Warn(`Error processing MTL file: '${fileToLoad}'`);\n                        if (this._loadingOptions.materialLoadingFailsSilently) {\n                            resolve();\n                        }\n                        else {\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                            reject(e);\n                        }\n                    }\n                }, (pathOfFile, exception) => {\n                    Tools.Warn(`Error downloading MTL file: '${fileToLoad}'`);\n                    if (this._loadingOptions.materialLoadingFailsSilently) {\n                        resolve();\n                    }\n                    else {\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                        reject(exception);\n                    }\n                });\n            }));\n        }\n        //Return an array with all Mesh\n        // eslint-disable-next-line github/no-then\n        return Promise.all(mtlPromises).then(() => {\n            const isLine = (mesh) => Boolean(mesh._internalMetadata?.[\"_isLine\"] ?? false);\n            // Iterate over the mesh, determine if it is a line mesh, clone or modify the material to line rendering.\n            babylonMeshesArray.forEach((mesh) => {\n                if (isLine(mesh)) {\n                    let mat = mesh.material ?? new StandardMaterial(mesh.name + \"_line\", scene);\n                    // If another mesh is using this material and it is not a line then we need to clone it.\n                    const needClone = mat.getBindedMeshes().filter((e) => !isLine(e)).length > 0;\n                    if (needClone) {\n                        mat = mat.clone(mat.name + \"_line\") ?? mat;\n                    }\n                    mat.wireframe = true;\n                    mesh.material = mat;\n                    if (mesh._internalMetadata) {\n                        mesh._internalMetadata[\"_isLine\"] = undefined;\n                    }\n                }\n            });\n            return babylonMeshesArray;\n        });\n    }\n}\n/**\n * Defines if UVs are optimized by default during load.\n */\nOBJFileLoader.OPTIMIZE_WITH_UV = true;\n/**\n * Invert model on y-axis (does a model scaling inversion)\n */\nOBJFileLoader.INVERT_Y = false;\n/**\n * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\n */\nOBJFileLoader.IMPORT_VERTEX_COLORS = false;\n/**\n * Compute the normals for the model, even if normals are present in the file.\n */\nOBJFileLoader.COMPUTE_NORMALS = false;\n/**\n * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.\n * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.\n */\nOBJFileLoader.OPTIMIZE_NORMALS = false;\n/**\n * Defines custom scaling of UV coordinates of loaded meshes.\n */\nOBJFileLoader.UV_SCALING = new Vector2(1, 1);\n/**\n * Skip loading the materials even if defined in the OBJ file (materials are ignored).\n */\nOBJFileLoader.SKIP_MATERIALS = false;\n/**\n * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\n *\n * Defaults to true for backwards compatibility.\n */\nOBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY = true;\n/**\n * Loads assets without handedness conversions. This flag is for compatibility. Use it only if absolutely required. Defaults to false.\n */\nOBJFileLoader.USE_LEGACY_BEHAVIOR = false;\n//Add this loader into the register plugin\nRegisterSceneLoaderPlugin(new OBJFileLoader());\n//# sourceMappingURL=objFileLoader.js.map"],"names":[],"mappings":"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"}