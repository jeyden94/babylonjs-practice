import{q as t,bu as e,C as i,T as s,L as o,b as r,bw as n,_ as a,s as h,g as l,aV as _,bs as d,Q as f,bL as c,bK as u}from"./index-1dDxZ_0d.esm.min.js";import{R as T}from"./rawTexture-DNIIHHuO.esm.min.js";import{ArrayItem as m,GLTFLoader as p}from"./glTFLoader-wHGixHtC.esm.min.js";import"./bone-rpjVhoW9.esm.min.js";import"./skeleton-BuLyjIk1.esm.min.js";import"./assetContainer-Dam1dL5M.esm.min.js";import"./objectModelMapping-DtrR_R-D.esm.min.js";function g(e){const r=e.useDelayedTextureLoading;e.useDelayedTextureLoading=!1;const n=e._blockEntityCollection;e._blockEntityCollection=!1,e._ltcTextures={LTC1:T.CreateRGBATexture(null,64,64,e.getEngine(),!1,!1,i.TEXTURE_LINEAR_LINEAR,i.TEXTURETYPE_HALF_FLOAT,0,!1,!0),LTC2:T.CreateRGBATexture(null,64,64,e.getEngine(),!1,!1,i.TEXTURE_LINEAR_LINEAR,i.TEXTURETYPE_HALF_FLOAT,0,!1,!0)},e._blockEntityCollection=n,e._ltcTextures.LTC1.wrapU=s.CLAMP_ADDRESSMODE,e._ltcTextures.LTC1.wrapV=s.CLAMP_ADDRESSMODE,e._ltcTextures.LTC2.wrapU=s.CLAMP_ADDRESSMODE,e._ltcTextures.LTC2.wrapV=s.CLAMP_ADDRESSMODE,e.useDelayedTextureLoading=r,async function(){const e=new Uint16Array(16384),i=new Uint16Array(16384),s=await t.LoadFileAsync(t.GetAssetUrl("https://assets.babylonjs.com/core/areaLights/areaLightsLTC.bin")),o=new Uint16Array(s),r=o.length/8;for(let t=0;t<r;t++)e[4*t]=o[8*t],e[4*t+1]=o[8*t+1],e[4*t+2]=o[8*t+2],e[4*t+3]=o[8*t+3],i[4*t]=o[8*t+4],i[4*t+1]=o[8*t+5],i[4*t+2]=o[8*t+6],i[4*t+3]=o[8*t+7];return[e,i]}().then((t=>{if(e._ltcTextures){const i=e._ltcTextures?.LTC1;i.update(t[0]);const s=e._ltcTextures?.LTC2;s.update(t[1]),e.onDisposeObservable.addOnce((()=>{e._ltcTextures?.LTC1.dispose(),e._ltcTextures?.LTC2.dispose()}))}})).catch((t=>{o.Error(`Area Light fail to get LTC textures data. Error: ${t}`)}))}class L extends e{constructor(t,e,i){super(t,i),this.position=e,this._scene._ltcTextures||g(this._scene)}transferTexturesToEffect(t){return this._scene._ltcTextures&&(t.setTexture("areaLightsLTC1Sampler",this._scene._ltcTextures.LTC1),t.setTexture("areaLightsLTC2Sampler",this._scene._ltcTextures.LTC2)),this}prepareLightSpecificDefines(t,e){t["AREALIGHT"+e]=!0,t.AREALIGHTUSED=!0}_isReady(){return!!this._scene._ltcTextures&&(this._scene._ltcTextures.LTC1.isReady()&&this._scene._ltcTextures.LTC2.isReady())}}n.AddNodeConstructor("Light_Type_4",((t,e)=>()=>new y(t,r.Zero(),1,1,e)));class y extends L{get width(){return this._width.x}set width(t){this._width.x=t}get height(){return this._height.y}set height(t){this._height.y=t}constructor(t,e,i,s,o){super(t,e,o),this._width=new r(i,0,0),this._height=new r(0,s,0),this._pointTransformedPosition=r.Zero(),this._pointTransformedWidth=r.Zero(),this._pointTransformedHeight=r.Zero()}getClassName(){return"RectAreaLight"}getTypeID(){return e.LIGHTTYPEID_RECT_AREALIGHT}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightWidth",4),this._uniformBuffer.addUniform("vLightHeight",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}_computeTransformedInformation(){return!(!this.parent||!this.parent.getWorldMatrix)&&(r.TransformCoordinatesToRef(this.position,this.parent.getWorldMatrix(),this._pointTransformedPosition),r.TransformNormalToRef(this._width,this.parent.getWorldMatrix(),this._pointTransformedWidth),r.TransformNormalToRef(this._height,this.parent.getWorldMatrix(),this._pointTransformedHeight),!0)}transferToEffect(t,e){const i=this._scene.floatingOriginOffset;return this._computeTransformedInformation()?(this._uniformBuffer.updateFloat4("vLightData",this._pointTransformedPosition.x-i.x,this._pointTransformedPosition.y-i.y,this._pointTransformedPosition.z-i.z,0,e),this._uniformBuffer.updateFloat4("vLightWidth",this._pointTransformedWidth.x/2,this._pointTransformedWidth.y/2,this._pointTransformedWidth.z/2,0,e),this._uniformBuffer.updateFloat4("vLightHeight",this._pointTransformedHeight.x/2,this._pointTransformedHeight.y/2,this._pointTransformedHeight.z/2,0,e)):(this._uniformBuffer.updateFloat4("vLightData",this.position.x-i.x,this.position.y-i.y,this.position.z-i.z,0,e),this._uniformBuffer.updateFloat4("vLightWidth",this._width.x/2,this._width.y/2,this._width.z/2,0,e),this._uniformBuffer.updateFloat4("vLightHeight",this._height.x/2,this._height.y/2,this._height.z/2,0,e)),this}transferToNodeMaterialEffect(t,e){const i=this._scene.floatingOriginOffset;return this._computeTransformedInformation()?t.setFloat3(e,this._pointTransformedPosition.x-i.x,this._pointTransformedPosition.y-i.y,this._pointTransformedPosition.z-i.z):t.setFloat3(e,this.position.x-i.x,this.position.y-i.y,this.position.z-i.z),this}}a([h()],y.prototype,"width",null),a([h()],y.prototype,"height",null),l("BABYLON.RectAreaLight",y);const x="EXT_lights_area";class E{constructor(t){this.name=x,this._loader=t,this.enabled=this._loader.isExtensionUsed(x)}dispose(){this._loader=null,delete this._lights}onLoading(){const t=this._loader.gltf.extensions;if(t&&t[this.name]){const e=t[this.name];this._lights=e.lights,m.Assign(this._lights)}}loadNodeAsync(t,i,s){return p.LoadExtensionAsync(t,i,this.name,(async(o,n)=>(this._loader._allMaterialsDirtyRequired=!0,await this._loader.loadNodeAsync(t,i,(t=>{let i;const a=m.Get(o,this._lights,n.light),h=a.name||t.name;this._loader.babylonScene._blockEntityCollection=!!this._loader._assetContainer;const l=void 0!==a.size?a.size:1;switch(a.type){case"rect":{const t=void 0!==a.rect?.aspect?a.rect.aspect*l:l,e=l;i=new y(h,r.Zero(),t,e,this._loader.babylonScene);break}case"disk":{const t=Math.sqrt(l*l*.25*Math.PI);i=new y(h,r.Zero(),t,t,this._loader.babylonScene);break}default:throw this._loader.babylonScene._blockEntityCollection=!1,new Error(`${o}: Invalid area light type (${a.type})`)}i._parentContainer=this._loader._assetContainer,this._loader.babylonScene._blockEntityCollection=!1,a._babylonLight=i,i.falloffType=e.FALLOFF_GLTF,i.diffuse=a.color?_.FromArray(a.color):_.White(),i.intensity=null==a.intensity?1:a.intensity;const c=new d(`${h}_orientation`,this._loader.babylonScene);c.rotationQuaternion=f.RotationAxis(r.Up(),Math.PI),c.parent=t,i.parent=c,this._loader._babylonLights.push(i),p.AddPointerMetadata(i,o),s(t)})))))}}c(x),u(x,!0,(t=>new E(t)));export{E as EXT_lights_area};
//# sourceMappingURL=EXT_lights_area-CnOBNWyF.esm.min.js.map
