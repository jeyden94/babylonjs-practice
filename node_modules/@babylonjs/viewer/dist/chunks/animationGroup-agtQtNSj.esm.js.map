{"version":3,"file":"animationGroup-agtQtNSj.esm.js","sources":["../../../../../dev/core/dist/Animations/runtimeAnimation.js","../../../../../dev/core/dist/Animations/animatable.core.js","../../../../../dev/core/dist/Animations/animatable.js","../../../../../dev/core/dist/Animations/animationGroup.js"],"sourcesContent":["import { Matrix } from \"../Maths/math.vector\";\nimport { Animation, _StaticOffsetValueColor3, _StaticOffsetValueColor4, _StaticOffsetValueQuaternion, _StaticOffsetValueSize, _StaticOffsetValueVector2, _StaticOffsetValueVector3, } from \"./animation\";\n/**\n * Defines a runtime animation\n */\nexport class RuntimeAnimation {\n    /**\n     * Gets the current frame of the runtime animation\n     */\n    get currentFrame() {\n        return this._currentFrame;\n    }\n    /**\n     * Gets the weight of the runtime animation\n     */\n    get weight() {\n        return this._weight;\n    }\n    /**\n     * Gets the current value of the runtime animation\n     */\n    get currentValue() {\n        return this._currentValue;\n    }\n    /**\n     * Gets or sets the target path of the runtime animation\n     */\n    get targetPath() {\n        return this._targetPath;\n    }\n    /**\n     * Gets the actual target of the runtime animation\n     */\n    get target() {\n        return this._currentActiveTarget;\n    }\n    /**\n     * Gets the additive state of the runtime animation\n     */\n    get isAdditive() {\n        return this._host && this._host.isAdditive;\n    }\n    /**\n     * Create a new RuntimeAnimation object\n     * @param target defines the target of the animation\n     * @param animation defines the source animation object\n     * @param scene defines the hosting scene\n     * @param host defines the initiating Animatable\n     */\n    constructor(target, animation, scene, host) {\n        this._events = new Array();\n        /**\n         * The current frame of the runtime animation\n         */\n        this._currentFrame = 0;\n        /**\n         * The original value of the runtime animation\n         */\n        this._originalValue = new Array();\n        /**\n         * The original blend value of the runtime animation\n         */\n        this._originalBlendValue = null;\n        /**\n         * The offsets cache of the runtime animation\n         */\n        this._offsetsCache = {};\n        /**\n         * The high limits cache of the runtime animation\n         */\n        this._highLimitsCache = {};\n        /**\n         * Specifies if the runtime animation has been stopped\n         */\n        this._stopped = false;\n        /**\n         * The blending factor of the runtime animation\n         */\n        this._blendingFactor = 0;\n        /**\n         * The current value of the runtime animation\n         */\n        this._currentValue = null;\n        this._currentActiveTarget = null;\n        this._directTarget = null;\n        /**\n         * The target path of the runtime animation\n         */\n        this._targetPath = \"\";\n        /**\n         * The weight of the runtime animation\n         */\n        this._weight = 1.0;\n        /**\n         * The absolute frame offset of the runtime animation\n         */\n        this._absoluteFrameOffset = 0;\n        /**\n         * The previous elapsed time (since start of animation) of the runtime animation\n         */\n        this._previousElapsedTime = 0;\n        this._yoyoDirection = 1;\n        /**\n         * The previous absolute frame of the runtime animation (meaning, without taking into account the from/to values, only the elapsed time and the fps)\n         */\n        this._previousAbsoluteFrame = 0;\n        this._targetIsArray = false;\n        /** @internal */\n        this._coreRuntimeAnimation = null;\n        this._animation = animation;\n        this._target = target;\n        this._scene = scene;\n        this._host = host;\n        this._activeTargets = [];\n        animation._runtimeAnimations.push(this);\n        // State\n        this._animationState = {\n            key: 0,\n            repeatCount: 0,\n            loopMode: this._getCorrectLoopMode(),\n        };\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n            this._animationState.workValue = Matrix.Zero();\n        }\n        // Limits\n        this._keys = this._animation.getKeys();\n        this._minFrame = this._keys[0].frame;\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\n        // Add a start key at frame 0 if missing\n        if (this._minFrame !== 0) {\n            const newKey = { frame: 0, value: this._keys[0].value };\n            this._keys.splice(0, 0, newKey);\n        }\n        // Check data\n        if (this._target instanceof Array) {\n            let index = 0;\n            for (const target of this._target) {\n                this._preparePath(target, index);\n                this._getOriginalValues(index);\n                index++;\n            }\n            this._targetIsArray = true;\n        }\n        else {\n            this._preparePath(this._target);\n            this._getOriginalValues();\n            this._targetIsArray = false;\n            this._directTarget = this._activeTargets[0];\n        }\n        // Cloning events locally\n        const events = animation.getEvents();\n        if (events && events.length > 0) {\n            for (const e of events) {\n                this._events.push(e._clone());\n            }\n        }\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\n    }\n    _preparePath(target, targetIndex = 0) {\n        const targetPropertyPath = this._animation.targetPropertyPath;\n        if (targetPropertyPath.length > 1) {\n            let property = target;\n            for (let index = 0; index < targetPropertyPath.length - 1; index++) {\n                const name = targetPropertyPath[index];\n                property = property[name];\n                if (property === undefined) {\n                    throw new Error(`Invalid property (${name}) in property path (${targetPropertyPath.join(\".\")})`);\n                }\n            }\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\n            this._activeTargets[targetIndex] = property;\n        }\n        else {\n            this._targetPath = targetPropertyPath[0];\n            this._activeTargets[targetIndex] = target;\n        }\n        if (this._activeTargets[targetIndex][this._targetPath] === undefined) {\n            throw new Error(`Invalid property (${this._targetPath}) in property path (${targetPropertyPath.join(\".\")})`);\n        }\n    }\n    /**\n     * Gets the animation from the runtime animation\n     */\n    get animation() {\n        return this._animation;\n    }\n    /**\n     * Resets the runtime animation to the beginning\n     * @param restoreOriginal defines whether to restore the target property to the original value\n     */\n    reset(restoreOriginal = false) {\n        if (restoreOriginal) {\n            if (this._target instanceof Array) {\n                let index = 0;\n                for (const target of this._target) {\n                    if (this._originalValue[index] !== undefined) {\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\n                    }\n                    index++;\n                }\n            }\n            else {\n                if (this._originalValue[0] !== undefined) {\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\n                }\n            }\n        }\n        this._offsetsCache = {};\n        this._highLimitsCache = {};\n        this._currentFrame = 0;\n        this._blendingFactor = 0;\n        // Events\n        for (let index = 0; index < this._events.length; index++) {\n            this._events[index].isDone = false;\n        }\n    }\n    /**\n     * Specifies if the runtime animation is stopped\n     * @returns Boolean specifying if the runtime animation is stopped\n     */\n    isStopped() {\n        return this._stopped;\n    }\n    /**\n     * Disposes of the runtime animation\n     */\n    dispose() {\n        const index = this._animation.runtimeAnimations.indexOf(this);\n        if (index > -1) {\n            this._animation.runtimeAnimations.splice(index, 1);\n        }\n    }\n    /**\n     * Apply the interpolated value to the target\n     * @param currentValue defines the value computed by the animation\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\n     */\n    setValue(currentValue, weight) {\n        if (this._targetIsArray) {\n            for (let index = 0; index < this._target.length; index++) {\n                const target = this._target[index];\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\n            }\n            return;\n        }\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\n    }\n    _getOriginalValues(targetIndex = 0) {\n        let originalValue;\n        const target = this._activeTargets[targetIndex];\n        if (target.getLocalMatrix && this._targetPath === \"_matrix\") {\n            // For bones\n            originalValue = target.getLocalMatrix();\n        }\n        else {\n            originalValue = target[this._targetPath];\n        }\n        if (originalValue && originalValue.clone) {\n            this._originalValue[targetIndex] = originalValue.clone();\n        }\n        else {\n            this._originalValue[targetIndex] = originalValue;\n        }\n    }\n    _registerTargetForLateAnimationBinding(runtimeAnimation, originalValue) {\n        const target = runtimeAnimation.target;\n        this._scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\n        if (!target._lateAnimationHolders) {\n            target._lateAnimationHolders = {};\n        }\n        if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n            target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n                totalWeight: 0,\n                totalAdditiveWeight: 0,\n                animations: [],\n                additiveAnimations: [],\n                originalValue: originalValue,\n            };\n        }\n        if (runtimeAnimation.isAdditive) {\n            target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n        }\n        else {\n            target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n        }\n    }\n    _setValue(target, destination, currentValue, weight, targetIndex) {\n        // Set value\n        this._currentActiveTarget = destination;\n        this._weight = weight;\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\n            if (!this._originalBlendValue) {\n                const originalValue = destination[this._targetPath];\n                if (originalValue.clone) {\n                    this._originalBlendValue = originalValue.clone();\n                }\n                else {\n                    this._originalBlendValue = originalValue;\n                }\n            }\n            if (this._originalBlendValue.m) {\n                // Matrix\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\n                    if (this._currentValue) {\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n                    }\n                    else {\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n                    }\n                }\n                else {\n                    if (this._currentValue) {\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n                    }\n                    else {\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\n                    }\n                }\n            }\n            else {\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n            }\n            const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\n            this._blendingFactor += blendingSpeed;\n        }\n        else {\n            if (!this._currentValue) {\n                if (currentValue?.clone) {\n                    this._currentValue = currentValue.clone();\n                }\n                else {\n                    this._currentValue = currentValue;\n                }\n            }\n            else if (this._currentValue.copyFrom) {\n                this._currentValue.copyFrom(currentValue);\n            }\n            else {\n                this._currentValue = currentValue;\n            }\n        }\n        if (weight !== -1.0) {\n            this._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\n        }\n        else {\n            if (this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT) {\n                if (this._currentValue.addToRef) {\n                    this._currentValue.addToRef(this._originalValue[targetIndex], destination[this._targetPath]);\n                }\n                else {\n                    destination[this._targetPath] = this._originalValue[targetIndex] + this._currentValue;\n                }\n            }\n            else {\n                destination[this._targetPath] = this._currentValue;\n            }\n        }\n        if (target.markAsDirty) {\n            target.markAsDirty(this._animation.targetProperty);\n        }\n    }\n    /**\n     * Gets the loop pmode of the runtime animation\n     * @returns Loop Mode\n     */\n    _getCorrectLoopMode() {\n        if (this._target && this._target.animationPropertiesOverride) {\n            return this._target.animationPropertiesOverride.loopMode;\n        }\n        return this._animation.loopMode;\n    }\n    /**\n     * Move the current animation to a given frame\n     * @param frame defines the frame to move to\n     * @param weight defines the weight to apply to the animation (-1.0 by default)\n     */\n    goToFrame(frame, weight = -1) {\n        const keys = this._animation.getKeys();\n        if (frame < keys[0].frame) {\n            frame = keys[0].frame;\n        }\n        else if (frame > keys[keys.length - 1].frame) {\n            frame = keys[keys.length - 1].frame;\n        }\n        // Need to reset animation events\n        const events = this._events;\n        if (events.length) {\n            for (let index = 0; index < events.length; index++) {\n                if (!events[index].onlyOnce) {\n                    // reset events in the future\n                    events[index].isDone = events[index].frame < frame;\n                }\n            }\n        }\n        this._currentFrame = frame;\n        const currentValue = this._animation._interpolate(frame, this._animationState);\n        this.setValue(currentValue, weight);\n    }\n    /**\n     * @internal Internal use only\n     */\n    _prepareForSpeedRatioChange(newSpeedRatio) {\n        const newAbsoluteFrame = (this._previousElapsedTime * (this._animation.framePerSecond * newSpeedRatio)) / 1000.0;\n        this._absoluteFrameOffset = this._previousAbsoluteFrame - newAbsoluteFrame;\n    }\n    /**\n     * Execute the current animation\n     * @param elapsedTimeSinceAnimationStart defines the elapsed time (in milliseconds) since the animation was started\n     * @param from defines the lower frame of the animation range\n     * @param to defines the upper frame of the animation range\n     * @param loop defines if the current animation must loop\n     * @param speedRatio defines the current speed ratio\n     * @param weight defines the weight of the animation (default is -1 so no weight)\n     * @returns a boolean indicating if the animation is running\n     */\n    animate(elapsedTimeSinceAnimationStart, from, to, loop, speedRatio, weight = -1.0) {\n        const animation = this._animation;\n        const targetPropertyPath = animation.targetPropertyPath;\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\n            this._stopped = true;\n            return false;\n        }\n        let returnValue = true;\n        let currentFrame;\n        const events = this._events;\n        let frameRange = 0;\n        if (!this._coreRuntimeAnimation) {\n            // Check limits\n            if (from < this._minFrame || from > this._maxFrame) {\n                from = this._minFrame;\n            }\n            if (to < this._minFrame || to > this._maxFrame) {\n                to = this._maxFrame;\n            }\n            frameRange = to - from;\n            let offsetValue;\n            // Compute the frame according to the elapsed time and the fps of the animation (\"from\" and \"to\" are not factored in!)\n            let absoluteFrame = (elapsedTimeSinceAnimationStart * (animation.framePerSecond * speedRatio)) / 1000.0 + this._absoluteFrameOffset;\n            let highLimitValue = 0;\n            // Apply the yoyo function if required\n            let yoyoLoop = false;\n            const yoyoMode = loop && this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_YOYO;\n            if (yoyoMode) {\n                const position = (absoluteFrame - from) / frameRange;\n                // Apply the yoyo curve\n                const sin = Math.sin(position * Math.PI);\n                const yoyoPosition = Math.abs(sin);\n                // Map the yoyo position back to the range\n                absoluteFrame = yoyoPosition * frameRange + from;\n                const direction = sin >= 0 ? 1 : -1;\n                if (this._yoyoDirection !== direction) {\n                    yoyoLoop = true;\n                }\n                this._yoyoDirection = direction;\n            }\n            this._previousElapsedTime = elapsedTimeSinceAnimationStart;\n            this._previousAbsoluteFrame = absoluteFrame;\n            if (!loop && to >= from && ((absoluteFrame >= frameRange && speedRatio > 0) || (absoluteFrame <= 0 && speedRatio < 0))) {\n                // If we are out of range and not looping get back to caller\n                returnValue = false;\n                highLimitValue = animation.evaluate(to);\n            }\n            else if (!loop && from >= to && ((absoluteFrame <= frameRange && speedRatio < 0) || (absoluteFrame >= 0 && speedRatio > 0))) {\n                returnValue = false;\n                highLimitValue = animation.evaluate(from);\n            }\n            else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\n                const keyOffset = to.toString() + from.toString();\n                if (!this._offsetsCache[keyOffset]) {\n                    this._animationState.repeatCount = 0;\n                    this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE; // force a specific codepath in animation._interpolate()!\n                    const fromValue = animation._interpolate(from, this._animationState);\n                    const toValue = animation._interpolate(to, this._animationState);\n                    this._animationState.loopMode = this._getCorrectLoopMode();\n                    switch (animation.dataType) {\n                        // Float\n                        case Animation.ANIMATIONTYPE_FLOAT:\n                            this._offsetsCache[keyOffset] = toValue - fromValue;\n                            break;\n                        // Quaternion\n                        case Animation.ANIMATIONTYPE_QUATERNION:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Vector3\n                        case Animation.ANIMATIONTYPE_VECTOR3:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Vector2\n                        case Animation.ANIMATIONTYPE_VECTOR2:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Size\n                        case Animation.ANIMATIONTYPE_SIZE:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Color3\n                        case Animation.ANIMATIONTYPE_COLOR3:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        default:\n                            break;\n                    }\n                    this._highLimitsCache[keyOffset] = toValue;\n                }\n                highLimitValue = this._highLimitsCache[keyOffset];\n                offsetValue = this._offsetsCache[keyOffset];\n            }\n            if (offsetValue === undefined) {\n                switch (animation.dataType) {\n                    // Float\n                    case Animation.ANIMATIONTYPE_FLOAT:\n                        offsetValue = 0;\n                        break;\n                    // Quaternion\n                    case Animation.ANIMATIONTYPE_QUATERNION:\n                        offsetValue = _StaticOffsetValueQuaternion;\n                        break;\n                    // Vector3\n                    case Animation.ANIMATIONTYPE_VECTOR3:\n                        offsetValue = _StaticOffsetValueVector3;\n                        break;\n                    // Vector2\n                    case Animation.ANIMATIONTYPE_VECTOR2:\n                        offsetValue = _StaticOffsetValueVector2;\n                        break;\n                    // Size\n                    case Animation.ANIMATIONTYPE_SIZE:\n                        offsetValue = _StaticOffsetValueSize;\n                        break;\n                    // Color3\n                    case Animation.ANIMATIONTYPE_COLOR3:\n                        offsetValue = _StaticOffsetValueColor3;\n                        break;\n                    case Animation.ANIMATIONTYPE_COLOR4:\n                        offsetValue = _StaticOffsetValueColor4;\n                        break;\n                }\n            }\n            // Compute value\n            if (this._host && this._host.syncRoot) {\n                // If we must sync with an animatable, calculate the current frame based on the frame of the root animatable\n                const syncRoot = this._host.syncRoot;\n                const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\n                currentFrame = from + frameRange * hostNormalizedFrame;\n            }\n            else {\n                if ((absoluteFrame > 0 && from > to) || (absoluteFrame < 0 && from < to)) {\n                    currentFrame = returnValue && frameRange !== 0 ? to + (absoluteFrame % frameRange) : from;\n                }\n                else {\n                    currentFrame = returnValue && frameRange !== 0 ? from + (absoluteFrame % frameRange) : to;\n                }\n            }\n            // Reset event/state if looping\n            if ((!yoyoMode && ((speedRatio > 0 && this.currentFrame > currentFrame) || (speedRatio < 0 && this.currentFrame < currentFrame))) || (yoyoMode && yoyoLoop)) {\n                this._onLoop();\n                // Need to reset animation events\n                for (let index = 0; index < events.length; index++) {\n                    if (!events[index].onlyOnce) {\n                        // reset event, the animation is looping\n                        events[index].isDone = false;\n                    }\n                }\n                this._animationState.key = speedRatio > 0 ? 0 : animation.getKeys().length - 1;\n            }\n            this._currentFrame = currentFrame;\n            this._animationState.repeatCount = frameRange === 0 ? 0 : (absoluteFrame / frameRange) >> 0;\n            this._animationState.highLimitValue = highLimitValue;\n            this._animationState.offsetValue = offsetValue;\n        }\n        else {\n            frameRange = to - from;\n            currentFrame = this._coreRuntimeAnimation.currentFrame;\n            this._currentFrame = currentFrame;\n            this._animationState.repeatCount = this._coreRuntimeAnimation._animationState.repeatCount;\n            this._animationState.highLimitValue = this._coreRuntimeAnimation._animationState.highLimitValue;\n            this._animationState.offsetValue = this._coreRuntimeAnimation._animationState.offsetValue;\n        }\n        const currentValue = animation._interpolate(currentFrame, this._animationState);\n        // Set value\n        this.setValue(currentValue, weight);\n        // Check events\n        if (events.length) {\n            for (let index = 0; index < events.length; index++) {\n                // Make sure current frame has passed event frame and that event frame is within the current range\n                // Also, handle both forward and reverse animations\n                if ((frameRange >= 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\n                    (frameRange < 0 && currentFrame <= events[index].frame && events[index].frame <= from)) {\n                    const event = events[index];\n                    if (!event.isDone) {\n                        // If event should be done only once, remove it.\n                        if (event.onlyOnce) {\n                            events.splice(index, 1);\n                            index--;\n                        }\n                        event.isDone = true;\n                        event.action(currentFrame);\n                    } // Don't do anything if the event has already been done.\n                }\n            }\n        }\n        if (!returnValue) {\n            this._stopped = true;\n        }\n        return returnValue;\n    }\n}\n//# sourceMappingURL=runtimeAnimation.js.map","import { Observable } from \"core/Misc/observable\";\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\nimport { Animation } from \"./animation\";\nimport { PrecisionDate } from \"core/Misc/precisionDate\";\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\n/**\n * Class used to store an actual running animation\n */\nexport class Animatable {\n    /**\n     * Gets the root Animatable used to synchronize and normalize animations\n     */\n    get syncRoot() {\n        return this._syncRoot;\n    }\n    /**\n     * Gets the current frame of the first RuntimeAnimation\n     * Used to synchronize Animatables\n     */\n    get masterFrame() {\n        if (this._runtimeAnimations.length === 0) {\n            return 0;\n        }\n        return this._runtimeAnimations[0].currentFrame;\n    }\n    /**\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\n     */\n    get weight() {\n        return this._weight;\n    }\n    set weight(value) {\n        if (value === -1) {\n            // -1 is ok and means no weight\n            this._weight = -1;\n            return;\n        }\n        // Else weight must be in [0, 1] range\n        this._weight = Math.min(Math.max(value, 0), 1.0);\n    }\n    /**\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\n     */\n    get speedRatio() {\n        return this._speedRatio;\n    }\n    set speedRatio(value) {\n        for (let index = 0; index < this._runtimeAnimations.length; index++) {\n            const animation = this._runtimeAnimations[index];\n            animation._prepareForSpeedRatioChange(value);\n        }\n        this._speedRatio = value;\n        // Resync _manualJumpDelay in case goToFrame was called before speedRatio was set.\n        if (this._goToFrame !== null) {\n            this.goToFrame(this._goToFrame);\n        }\n    }\n    /**\n     * Gets the elapsed time since the animatable started in milliseconds\n     */\n    get elapsedTime() {\n        return this._localDelayOffset === null ? 0 : this._scene._animationTime - this._localDelayOffset;\n    }\n    /**\n     * Creates a new Animatable\n     * @param scene defines the hosting scene\n     * @param target defines the target object\n     * @param fromFrame defines the starting frame number (default is 0)\n     * @param toFrame defines the ending frame number (default is 100)\n     * @param loopAnimation defines if the animation must loop (default is false)\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\n     * @param animations defines a group of animation to add to the new Animatable\n     * @param onAnimationLoop defines a callback to call when animation loops\n     * @param isAdditive defines whether the animation should be evaluated additively\n     * @param playOrder defines the order in which this animatable should be processed in the list of active animatables (default: 0)\n     */\n    constructor(scene, \n    /** defines the target object */\n    target, \n    /** [0] defines the starting frame number (default is 0) */\n    fromFrame = 0, \n    /** [100] defines the ending frame number (default is 100) */\n    toFrame = 100, \n    /** [false] defines if the animation must loop (default is false)  */\n    loopAnimation = false, speedRatio = 1.0, \n    /** defines a callback to call when animation ends if it is not looping */\n    onAnimationEnd, animations, \n    /** defines a callback to call when animation loops */\n    onAnimationLoop, \n    /** [false] defines whether the animation should be evaluated additively */\n    isAdditive = false, \n    /** [0] defines the order in which this animatable should be processed in the list of active animatables (default: 0) */\n    playOrder = 0) {\n        this.target = target;\n        this.fromFrame = fromFrame;\n        this.toFrame = toFrame;\n        this.loopAnimation = loopAnimation;\n        this.onAnimationEnd = onAnimationEnd;\n        this.onAnimationLoop = onAnimationLoop;\n        this.isAdditive = isAdditive;\n        this.playOrder = playOrder;\n        this._localDelayOffset = null;\n        this._pausedDelay = null;\n        this._manualJumpDelay = null;\n        /** @hidden */\n        this._runtimeAnimations = new Array();\n        this._paused = false;\n        this._speedRatio = 1;\n        this._weight = -1.0;\n        this._previousWeight = -1.0;\n        this._syncRoot = null;\n        this._frameToSyncFromJump = null;\n        this._goToFrame = null;\n        /**\n         * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\n         * This will only apply for non looping animation (default is true)\n         */\n        this.disposeOnEnd = true;\n        /**\n         * Gets a boolean indicating if the animation has started\n         */\n        this.animationStarted = false;\n        /**\n         * Observer raised when the animation ends\n         */\n        this.onAnimationEndObservable = new Observable();\n        /**\n         * Observer raised when the animation loops\n         */\n        this.onAnimationLoopObservable = new Observable();\n        this._scene = scene;\n        if (animations) {\n            this.appendAnimations(target, animations);\n        }\n        this._speedRatio = speedRatio;\n        scene._activeAnimatables.push(this);\n    }\n    // Methods\n    /**\n     * Synchronize and normalize current Animatable with a source Animatable\n     * This is useful when using animation weights and when animations are not of the same length\n     * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\n     * @returns the current Animatable\n     */\n    syncWith(root) {\n        this._syncRoot = root;\n        if (root) {\n            // Make sure this animatable will animate after the root\n            const index = this._scene._activeAnimatables.indexOf(this);\n            if (index > -1) {\n                this._scene._activeAnimatables.splice(index, 1);\n                this._scene._activeAnimatables.push(this);\n            }\n        }\n        return this;\n    }\n    /**\n     * Gets the list of runtime animations\n     * @returns an array of RuntimeAnimation\n     */\n    getAnimations() {\n        return this._runtimeAnimations;\n    }\n    /**\n     * Adds more animations to the current animatable\n     * @param target defines the target of the animations\n     * @param animations defines the new animations to add\n     */\n    appendAnimations(target, animations) {\n        for (let index = 0; index < animations.length; index++) {\n            const animation = animations[index];\n            const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\n            newRuntimeAnimation._onLoop = () => {\n                this.onAnimationLoopObservable.notifyObservers(this);\n                if (this.onAnimationLoop) {\n                    this.onAnimationLoop();\n                }\n            };\n            this._runtimeAnimations.push(newRuntimeAnimation);\n        }\n    }\n    /**\n     * Gets the source animation for a specific property\n     * @param property defines the property to look for\n     * @returns null or the source animation for the given property\n     */\n    getAnimationByTargetProperty(property) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            if (runtimeAnimations[index].animation.targetProperty === property) {\n                return runtimeAnimations[index].animation;\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets the runtime animation for a specific property\n     * @param property defines the property to look for\n     * @returns null or the runtime animation for the given property\n     */\n    getRuntimeAnimationByTargetProperty(property) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            if (runtimeAnimations[index].animation.targetProperty === property) {\n                return runtimeAnimations[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Resets the animatable to its original state\n     */\n    reset() {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].reset(true);\n        }\n        this._localDelayOffset = null;\n        this._pausedDelay = null;\n    }\n    /**\n     * Allows the animatable to blend with current running animations\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     * @param blendingSpeed defines the blending speed to use\n     */\n    enableBlending(blendingSpeed) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].animation.enableBlending = true;\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\n        }\n    }\n    /**\n     * Disable animation blending\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     */\n    disableBlending() {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].animation.enableBlending = false;\n        }\n    }\n    /**\n     * Jump directly to a given frame\n     * @param frame defines the frame to jump to\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\n     */\n    goToFrame(frame, useWeight = false) {\n        const runtimeAnimations = this._runtimeAnimations;\n        if (runtimeAnimations[0]) {\n            const fps = runtimeAnimations[0].animation.framePerSecond;\n            this._frameToSyncFromJump = this._frameToSyncFromJump ?? runtimeAnimations[0].currentFrame;\n            const delay = this.speedRatio === 0 ? 0 : (((frame - this._frameToSyncFromJump) / fps) * 1000) / this.speedRatio;\n            this._manualJumpDelay = -delay;\n        }\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].goToFrame(frame, useWeight ? this._weight : -1);\n        }\n        this._goToFrame = frame;\n    }\n    /**\n     * Returns true if the animations for this animatable are paused\n     */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * Pause the animation\n     */\n    pause() {\n        if (this._paused) {\n            return;\n        }\n        this._paused = true;\n    }\n    /**\n     * Restart the animation\n     */\n    restart() {\n        this._paused = false;\n    }\n    _raiseOnAnimationEnd() {\n        if (this.onAnimationEnd) {\n            this.onAnimationEnd();\n        }\n        this.onAnimationEndObservable.notifyObservers(this);\n    }\n    /**\n     * Stop and delete the current animation\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\n     * @param targetMask a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n     * @param useGlobalSplice if true, the animatables will be removed by the caller of this function (false by default)\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\n     */\n    stop(animationName, targetMask, useGlobalSplice = false, skipOnAnimationEnd = false) {\n        if (animationName || targetMask) {\n            const idx = this._scene._activeAnimatables.indexOf(this);\n            if (idx > -1) {\n                const runtimeAnimations = this._runtimeAnimations;\n                for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\n                    const runtimeAnimation = runtimeAnimations[index];\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\n                        continue;\n                    }\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\n                        continue;\n                    }\n                    runtimeAnimation.dispose();\n                    runtimeAnimations.splice(index, 1);\n                }\n                if (runtimeAnimations.length == 0) {\n                    if (!useGlobalSplice) {\n                        this._scene._activeAnimatables.splice(idx, 1);\n                    }\n                    if (!skipOnAnimationEnd) {\n                        this._raiseOnAnimationEnd();\n                    }\n                }\n            }\n        }\n        else {\n            const index = this._scene._activeAnimatables.indexOf(this);\n            if (index > -1) {\n                if (!useGlobalSplice) {\n                    this._scene._activeAnimatables.splice(index, 1);\n                }\n                const runtimeAnimations = this._runtimeAnimations;\n                for (let index = 0; index < runtimeAnimations.length; index++) {\n                    runtimeAnimations[index].dispose();\n                }\n                this._runtimeAnimations.length = 0;\n                if (!skipOnAnimationEnd) {\n                    this._raiseOnAnimationEnd();\n                }\n            }\n        }\n    }\n    /**\n     * Wait asynchronously for the animation to end\n     * @returns a promise which will be fulfilled when the animation ends\n     */\n    async waitAsync() {\n        return await new Promise((resolve) => {\n            this.onAnimationEndObservable.add(() => {\n                resolve(this);\n            }, undefined, undefined, this, true);\n        });\n    }\n    /**\n     * @internal\n     */\n    _animate(delay) {\n        if (this._paused) {\n            this.animationStarted = false;\n            if (this._pausedDelay === null) {\n                this._pausedDelay = delay;\n            }\n            return true;\n        }\n        if (this._localDelayOffset === null) {\n            this._localDelayOffset = delay;\n            this._pausedDelay = null;\n        }\n        else if (this._pausedDelay !== null) {\n            this._localDelayOffset += delay - this._pausedDelay;\n            this._pausedDelay = null;\n        }\n        if (this._manualJumpDelay !== null) {\n            this._localDelayOffset += this.speedRatio < 0 ? -this._manualJumpDelay : this._manualJumpDelay;\n            this._manualJumpDelay = null;\n            this._frameToSyncFromJump = null;\n        }\n        this._goToFrame = null;\n        if (!Animatable.ProcessPausedAnimatables && this._weight === 0 && this._previousWeight === 0) {\n            // We consider that an animatable with a weight === 0 is \"actively\" paused\n            return true;\n        }\n        this._previousWeight = this._weight;\n        // Animating\n        let running = false;\n        const runtimeAnimations = this._runtimeAnimations;\n        let index;\n        for (index = 0; index < runtimeAnimations.length; index++) {\n            const animation = runtimeAnimations[index];\n            const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\n            running = running || isRunning;\n        }\n        this.animationStarted = running;\n        if (!running) {\n            if (this.disposeOnEnd) {\n                // Remove from active animatables\n                index = this._scene._activeAnimatables.indexOf(this);\n                this._scene._activeAnimatables.splice(index, 1);\n                // Dispose all runtime animations\n                for (index = 0; index < runtimeAnimations.length; index++) {\n                    runtimeAnimations[index].dispose();\n                }\n            }\n            this._raiseOnAnimationEnd();\n            if (this.disposeOnEnd) {\n                this.onAnimationEnd = null;\n                this.onAnimationLoop = null;\n                this.onAnimationLoopObservable.clear();\n                this.onAnimationEndObservable.clear();\n            }\n        }\n        return running;\n    }\n}\n/**\n * If true, the animatable will be processed even if it is considered actively paused (weight of 0 and previous weight of 0).\n * This can be used to force the full processing of paused animatables in the animation engine.\n * Default is false.\n */\nAnimatable.ProcessPausedAnimatables = false;\n/** @internal */\nfunction ProcessLateAnimationBindingsForMatrices(holder) {\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n        return holder.originalValue;\n    }\n    let normalizer = 1.0;\n    const finalPosition = TmpVectors.Vector3[0];\n    const finalScaling = TmpVectors.Vector3[1];\n    const finalQuaternion = TmpVectors.Quaternion[0];\n    let startIndex = 0;\n    const originalAnimation = holder.animations[0];\n    const originalValue = holder.originalValue;\n    let scale = 1;\n    let skipOverride = false;\n    if (holder.totalWeight < 1.0) {\n        // We need to mix the original value in\n        scale = 1.0 - holder.totalWeight;\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\n    }\n    else {\n        startIndex = 1;\n        // We need to normalize the weights\n        normalizer = holder.totalWeight;\n        scale = originalAnimation.weight / normalizer;\n        if (scale == 1) {\n            if (holder.totalAdditiveWeight) {\n                skipOverride = true;\n            }\n            else {\n                return originalAnimation.currentValue;\n            }\n        }\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\n    }\n    // Add up the override animations\n    if (!skipOverride) {\n        finalScaling.scaleInPlace(scale);\n        finalPosition.scaleInPlace(scale);\n        finalQuaternion.scaleInPlace(scale);\n        for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n            const runtimeAnimation = holder.animations[animIndex];\n            if (runtimeAnimation.weight === 0) {\n                continue;\n            }\n            scale = runtimeAnimation.weight / normalizer;\n            const currentPosition = TmpVectors.Vector3[2];\n            const currentScaling = TmpVectors.Vector3[3];\n            const currentQuaternion = TmpVectors.Quaternion[1];\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\n            currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\n        }\n        finalQuaternion.normalize();\n    }\n    // Add up the additive animations\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\n        if (runtimeAnimation.weight === 0) {\n            continue;\n        }\n        const currentPosition = TmpVectors.Vector3[2];\n        const currentScaling = TmpVectors.Vector3[3];\n        const currentQuaternion = TmpVectors.Quaternion[1];\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\n    }\n    const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\n    return workValue;\n}\n/** @internal */\nfunction ProcessLateAnimationBindingsForQuaternions(holder, refQuaternion) {\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n        return refQuaternion;\n    }\n    const originalAnimation = holder.animations[0];\n    const originalValue = holder.originalValue;\n    let cumulativeQuaternion = refQuaternion;\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\n        cumulativeQuaternion.copyFrom(originalValue);\n    }\n    else if (holder.animations.length === 1) {\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\n        if (holder.totalAdditiveWeight === 0) {\n            return cumulativeQuaternion;\n        }\n    }\n    else if (holder.animations.length > 1) {\n        // Add up the override animations\n        let normalizer = 1.0;\n        let quaternions;\n        let weights;\n        if (holder.totalWeight < 1.0) {\n            const scale = 1.0 - holder.totalWeight;\n            quaternions = [];\n            weights = [];\n            quaternions.push(originalValue);\n            weights.push(scale);\n        }\n        else {\n            if (holder.animations.length === 2) {\n                // Slerp as soon as we can\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\n                if (holder.totalAdditiveWeight === 0) {\n                    return refQuaternion;\n                }\n            }\n            quaternions = [];\n            weights = [];\n            normalizer = holder.totalWeight;\n        }\n        for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\n            const runtimeAnimation = holder.animations[animIndex];\n            quaternions.push(runtimeAnimation.currentValue);\n            weights.push(runtimeAnimation.weight / normalizer);\n        }\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\n        let cumulativeAmount = 0;\n        for (let index = 0; index < quaternions.length;) {\n            if (!index) {\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\n                cumulativeQuaternion = refQuaternion;\n                cumulativeAmount = weights[index] + weights[index + 1];\n                index += 2;\n                continue;\n            }\n            cumulativeAmount += weights[index];\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\n            index++;\n        }\n    }\n    // Add up the additive animations\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\n        if (runtimeAnimation.weight === 0) {\n            continue;\n        }\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\n    }\n    return cumulativeQuaternion;\n}\n/** @internal */\nfunction ProcessLateAnimationBindings(scene) {\n    if (!scene._registeredForLateAnimationBindings.length) {\n        return;\n    }\n    for (let index = 0; index < scene._registeredForLateAnimationBindings.length; index++) {\n        const target = scene._registeredForLateAnimationBindings.data[index];\n        for (const path in target._lateAnimationHolders) {\n            const holder = target._lateAnimationHolders[path];\n            const originalAnimation = holder.animations[0];\n            const originalValue = holder.originalValue;\n            if (originalValue === undefined || originalValue === null) {\n                continue;\n            }\n            const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\n            let finalValue = target[path];\n            if (matrixDecomposeMode) {\n                finalValue = ProcessLateAnimationBindingsForMatrices(holder);\n            }\n            else {\n                const quaternionMode = originalValue.w !== undefined;\n                if (quaternionMode) {\n                    finalValue = ProcessLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\n                }\n                else {\n                    let startIndex = 0;\n                    let normalizer = 1.0;\n                    const originalAnimationIsLoopRelativeFromCurrent = originalAnimation && originalAnimation._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;\n                    if (holder.totalWeight < 1.0) {\n                        // We need to mix the original value in\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\n                            finalValue = originalValue.clone ? originalValue.clone() : originalValue;\n                        }\n                        else if (originalAnimation && originalValue.scale) {\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\n                        }\n                        else if (originalAnimation) {\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\n                        }\n                        else if (originalValue.clone) {\n                            finalValue = originalValue.clone();\n                        }\n                        else {\n                            finalValue = originalValue;\n                        }\n                    }\n                    else if (originalAnimation) {\n                        // We need to normalize the weights\n                        normalizer = holder.totalWeight;\n                        const scale = originalAnimation.weight / normalizer;\n                        if (scale !== 1) {\n                            if (originalAnimation.currentValue.scale) {\n                                finalValue = originalAnimation.currentValue.scale(scale);\n                            }\n                            else {\n                                finalValue = originalAnimation.currentValue * scale;\n                            }\n                        }\n                        else {\n                            finalValue = originalAnimation.currentValue;\n                        }\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\n                            if (finalValue.addToRef) {\n                                finalValue.addToRef(originalValue, finalValue);\n                            }\n                            else {\n                                finalValue += originalValue;\n                            }\n                        }\n                        startIndex = 1;\n                    }\n                    // Add up the override animations\n                    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n                        const runtimeAnimation = holder.animations[animIndex];\n                        const scale = runtimeAnimation.weight / normalizer;\n                        if (!scale) {\n                            continue;\n                        }\n                        else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n                        }\n                        else {\n                            finalValue += runtimeAnimation.currentValue * scale;\n                        }\n                    }\n                    // Add up the additive animations\n                    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n                        const runtimeAnimation = holder.additiveAnimations[animIndex];\n                        const scale = runtimeAnimation.weight;\n                        if (!scale) {\n                            continue;\n                        }\n                        else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n                        }\n                        else {\n                            finalValue += runtimeAnimation.currentValue * scale;\n                        }\n                    }\n                }\n            }\n            target[path] = finalValue;\n        }\n        target._lateAnimationHolders = {};\n    }\n    scene._registeredForLateAnimationBindings.reset();\n}\n/** @internal */\nexport function RegisterTargetForLateAnimationBinding(scene, runtimeAnimation, originalValue) {\n    const target = runtimeAnimation.target;\n    scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\n    if (!target._lateAnimationHolders) {\n        target._lateAnimationHolders = {};\n    }\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n            totalWeight: 0,\n            totalAdditiveWeight: 0,\n            animations: [],\n            additiveAnimations: [],\n            originalValue: originalValue,\n        };\n    }\n    if (runtimeAnimation.isAdditive) {\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n    }\n    else {\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n    }\n}\n/**\n * Initialize all the inter dependecies between the animations and Scene and Bone\n * @param sceneClass defines the scene prototype to use\n * @param boneClass defines the bone prototype to use\n */\nexport function AddAnimationExtensions(sceneClass, boneClass) {\n    if (boneClass) {\n        boneClass.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired = false, skelDimensionsRatio = null) {\n            // all animation may be coming from a library skeleton, so may need to create animation\n            if (this.animations.length === 0) {\n                this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\n                this.animations[0].setKeys([]);\n            }\n            // get animation info / verify there is such a range from the source bone\n            const sourceRange = source.animations[0].getRange(rangeName);\n            if (!sourceRange) {\n                return false;\n            }\n            const from = sourceRange.from;\n            const to = sourceRange.to;\n            const sourceKeys = source.animations[0].getKeys();\n            // rescaling prep\n            const sourceBoneLength = source.length;\n            const sourceParent = source.getParent();\n            const parent = this.getParent();\n            const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\n            const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\n            const dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\n            const destKeys = this.animations[0].getKeys();\n            // loop vars declaration\n            let orig;\n            let origTranslation;\n            let mat;\n            for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\n                orig = sourceKeys[key];\n                if (orig.frame >= from && orig.frame <= to) {\n                    if (rescaleAsRequired) {\n                        mat = orig.value.clone();\n                        // scale based on parent ratio, when bone has parent\n                        if (parentScalingReqd) {\n                            origTranslation = mat.getTranslation();\n                            mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\n                            // scale based on skeleton dimension ratio when root bone, and value is passed\n                        }\n                        else if (dimensionsScalingReqd && skelDimensionsRatio) {\n                            origTranslation = mat.getTranslation();\n                            mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\n                            // use original when root bone, and no data for skelDimensionsRatio\n                        }\n                        else {\n                            mat = orig.value;\n                        }\n                    }\n                    else {\n                        mat = orig.value;\n                    }\n                    destKeys.push({ frame: orig.frame + frameOffset, value: mat });\n                }\n            }\n            this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\n            return true;\n        };\n    }\n    if (!sceneClass) {\n        return;\n    }\n    sceneClass.prototype._animate = function (customDeltaTime) {\n        if (!this.animationsEnabled) {\n            return;\n        }\n        // Getting time\n        const now = PrecisionDate.Now;\n        if (!this._animationTimeLast) {\n            if (this._pendingData.length > 0) {\n                return;\n            }\n            this._animationTimeLast = now;\n        }\n        this.deltaTime = customDeltaTime !== undefined ? customDeltaTime : this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\n        this._animationTimeLast = now;\n        const animatables = this._activeAnimatables;\n        if (animatables.length === 0) {\n            return;\n        }\n        this._animationTime += this.deltaTime;\n        const animationTime = this._animationTime;\n        for (let index = 0; index < animatables.length; index++) {\n            const animatable = animatables[index];\n            if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\n                index--; // Array was updated\n            }\n        }\n        // Late animation bindings\n        ProcessLateAnimationBindings(this);\n    };\n    sceneClass.prototype.sortActiveAnimatables = function () {\n        this._activeAnimatables.sort((a, b) => {\n            return a.playOrder - b.playOrder;\n        });\n    };\n    sceneClass.prototype.beginWeightedAnimation = function (target, from, to, weight = 1.0, loop, speedRatio = 1.0, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive = false) {\n        const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\n        returnedAnimatable.weight = weight;\n        return returnedAnimatable;\n    };\n    sceneClass.prototype.beginAnimation = function (target, from, to, loop, speedRatio = 1.0, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {\n        // get speed speedRatio, to and from, based on the sign and value(s)\n        if (speedRatio < 0) {\n            const tmp = from;\n            from = to;\n            to = tmp;\n            speedRatio = -speedRatio;\n        }\n        // if from > to switch speed ratio\n        if (from > to) {\n            speedRatio = -speedRatio;\n        }\n        if (stopCurrent) {\n            this.stopAnimation(target, undefined, targetMask);\n        }\n        if (!animatable) {\n            animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\n        }\n        const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\n        // Local animations\n        if (target.animations && shouldRunTargetAnimations) {\n            animatable.appendAnimations(target, target.animations);\n        }\n        // Children animations\n        if (target.getAnimatables) {\n            const animatables = target.getAnimatables();\n            for (let index = 0; index < animatables.length; index++) {\n                this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\n            }\n        }\n        animatable.reset();\n        return animatable;\n    };\n    sceneClass.prototype.beginHierarchyAnimation = function (target, directDescendantsOnly, from, to, loop, speedRatio = 1.0, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {\n        const children = target.getDescendants(directDescendantsOnly);\n        const result = [];\n        result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n        for (const child of children) {\n            result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n        }\n        return result;\n    };\n    sceneClass.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio = 1.0, onAnimationEnd, onAnimationLoop, isAdditive = false) {\n        // get speed speedRatio, to and from, based on the sign and value(s)\n        if (speedRatio < 0) {\n            const tmp = from;\n            from = to;\n            to = tmp;\n            speedRatio = -speedRatio;\n        }\n        // if from > to switch speed ratio\n        if (from > to) {\n            speedRatio = -speedRatio;\n        }\n        const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\n        return animatable;\n    };\n    sceneClass.prototype.beginDirectHierarchyAnimation = function (target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive = false) {\n        const children = target.getDescendants(directDescendantsOnly);\n        const result = [];\n        result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n        for (const child of children) {\n            result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n        }\n        return result;\n    };\n    sceneClass.prototype.getAnimatableByTarget = function (target) {\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\n            if (this._activeAnimatables[index].target === target) {\n                return this._activeAnimatables[index];\n            }\n        }\n        return null;\n    };\n    sceneClass.prototype.getAllAnimatablesByTarget = function (target) {\n        const result = [];\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\n            if (this._activeAnimatables[index].target === target) {\n                result.push(this._activeAnimatables[index]);\n            }\n        }\n        return result;\n    };\n    sceneClass.prototype.stopAnimation = function (target, animationName, targetMask) {\n        const animatables = this.getAllAnimatablesByTarget(target);\n        for (const animatable of animatables) {\n            animatable.stop(animationName, targetMask);\n        }\n    };\n    sceneClass.prototype.stopAllAnimations = function () {\n        if (this._activeAnimatables) {\n            for (let i = 0; i < this._activeAnimatables.length; i++) {\n                this._activeAnimatables[i].stop(undefined, undefined, true);\n            }\n            this._activeAnimatables.length = 0;\n        }\n        for (const group of this.animationGroups) {\n            group.stop();\n        }\n    };\n}\n//# sourceMappingURL=animatable.core.js.map","import { Bone } from \"../Bones/bone\";\nimport { AddAnimationExtensions } from \"./animatable.core\";\nimport { Scene } from \"core/scene\";\nexport * from \"./animatable.core\";\n// Connect everything!\nAddAnimationExtensions(Scene, Bone);\n//# sourceMappingURL=animatable.js.map","import { Animation } from \"./animation\";\nimport { Observable } from \"../Misc/observable\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Tags } from \"../Misc/tags\";\nimport \"./animatable\";\nimport { UniqueIdGenerator } from \"core/Misc/uniqueIdGenerator\";\n/**\n * This class defines the direct association between an animation and a target\n */\nexport class TargetedAnimation {\n    /**\n     * Returns the string \"TargetedAnimation\"\n     * @returns \"TargetedAnimation\"\n     */\n    getClassName() {\n        return \"TargetedAnimation\";\n    }\n    /**\n     * Creates a new targeted animation\n     * @param parent The animation group to which the animation belongs\n     */\n    constructor(parent) {\n        this.parent = parent;\n        /**\n         * Gets or sets the unique id of the targeted animation\n         */\n        this.uniqueId = UniqueIdGenerator.UniqueId;\n    }\n    /**\n     * Serialize the object\n     * @returns the JSON object representing the current entity\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.animation = this.animation.serialize();\n        serializationObject.targetId = this.target.id;\n        return serializationObject;\n    }\n}\n/**\n * Use this class to create coordinated animations on multiple targets\n */\nexport class AnimationGroup {\n    /**\n     * Gets or sets the mask associated with this animation group. This mask is used to filter which objects should be animated.\n     */\n    get mask() {\n        return this._mask;\n    }\n    set mask(value) {\n        if (this._mask === value) {\n            return;\n        }\n        this._mask = value;\n        this.syncWithMask(true);\n    }\n    /**\n     * Makes sure that the animations are either played or stopped according to the animation group mask.\n     * Note however that the call won't have any effect if the animation group has not been started yet.\n     * @param forceUpdate If true, forces to loop over the animatables even if no mask is defined (used internally, you shouldn't need to use it). Default: false.\n     */\n    syncWithMask(forceUpdate = false) {\n        if (!this.mask && !forceUpdate) {\n            this._numActiveAnimatables = this._targetedAnimations.length;\n            return;\n        }\n        this._numActiveAnimatables = 0;\n        for (let i = 0; i < this._animatables.length; ++i) {\n            const animatable = this._animatables[i];\n            if (!this.mask || this.mask.disabled || this.mask.retainsTarget(animatable.target.name)) {\n                this._numActiveAnimatables++;\n                if (animatable.paused) {\n                    animatable.restart();\n                }\n            }\n            else {\n                if (!animatable.paused) {\n                    animatable.pause();\n                }\n            }\n        }\n    }\n    /**\n     * Removes all animations for the targets not retained by the animation group mask.\n     * Use this function if you know you won't need those animations anymore and if you want to free memory.\n     */\n    removeUnmaskedAnimations() {\n        if (!this.mask || this.mask.disabled) {\n            return;\n        }\n        // Removes all animatables (in case the animation group has already been started)\n        for (let i = 0; i < this._animatables.length; ++i) {\n            const animatable = this._animatables[i];\n            if (!this.mask.retainsTarget(animatable.target.name)) {\n                animatable.stop();\n                this._animatables.splice(i, 1);\n                --i;\n            }\n        }\n        // Removes the targeted animations\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            if (!this.mask.retainsTarget(targetedAnimation.target.name)) {\n                this._targetedAnimations.splice(index, 1);\n                --index;\n            }\n        }\n    }\n    /**\n     * Gets or sets the first frame\n     */\n    get from() {\n        return this._from;\n    }\n    set from(value) {\n        if (this._from === value) {\n            return;\n        }\n        this._from = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.fromFrame = this._from;\n        }\n    }\n    /**\n     * Gets or sets the last frame\n     */\n    get to() {\n        return this._to;\n    }\n    set to(value) {\n        if (this._to === value) {\n            return;\n        }\n        this._to = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.toFrame = this._to;\n        }\n    }\n    /**\n     * Define if the animations are started\n     */\n    get isStarted() {\n        return this._isStarted;\n    }\n    /**\n     * Gets a value indicating that the current group is playing\n     */\n    get isPlaying() {\n        return this._isStarted && !this._isPaused;\n    }\n    /**\n     * Gets or sets the speed ratio to use for all animations\n     */\n    get speedRatio() {\n        return this._speedRatio;\n    }\n    /**\n     * Gets or sets the speed ratio to use for all animations\n     */\n    set speedRatio(value) {\n        if (this._speedRatio === value) {\n            return;\n        }\n        this._speedRatio = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.speedRatio = this._speedRatio;\n        }\n    }\n    /**\n     * Gets or sets if all animations should loop or not\n     */\n    get loopAnimation() {\n        return this._loopAnimation;\n    }\n    set loopAnimation(value) {\n        if (this._loopAnimation === value) {\n            return;\n        }\n        this._loopAnimation = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.loopAnimation = this._loopAnimation;\n        }\n    }\n    /**\n     * Gets or sets if all animations should be evaluated additively\n     */\n    get isAdditive() {\n        return this._isAdditive;\n    }\n    set isAdditive(value) {\n        if (this._isAdditive === value) {\n            return;\n        }\n        this._isAdditive = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.isAdditive = this._isAdditive;\n        }\n    }\n    /**\n     * Gets or sets the weight to apply to all animations of the group\n     */\n    get weight() {\n        return this._weight;\n    }\n    set weight(value) {\n        if (this._weight === value) {\n            return;\n        }\n        this._weight = value;\n        this.setWeightForAllAnimatables(this._weight);\n    }\n    /**\n     * Gets the targeted animations for this animation group\n     */\n    get targetedAnimations() {\n        return this._targetedAnimations;\n    }\n    /**\n     * returning the list of animatables controlled by this animation group.\n     */\n    get animatables() {\n        return this._animatables;\n    }\n    /**\n     * Gets the list of target animations\n     */\n    get children() {\n        return this._targetedAnimations;\n    }\n    /**\n     * Gets or sets the order of play of the animation group (default: 0)\n     */\n    get playOrder() {\n        return this._playOrder;\n    }\n    set playOrder(value) {\n        if (this._playOrder === value) {\n            return;\n        }\n        this._playOrder = value;\n        if (this._animatables.length > 0) {\n            for (let i = 0; i < this._animatables.length; i++) {\n                this._animatables[i].playOrder = this._playOrder;\n            }\n            this._scene.sortActiveAnimatables();\n        }\n    }\n    /**\n     * Allows the animations of the animation group to blend with current running animations\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.enableBlending)\n     */\n    get enableBlending() {\n        return this._enableBlending;\n    }\n    set enableBlending(value) {\n        if (this._enableBlending === value) {\n            return;\n        }\n        this._enableBlending = value;\n        if (value !== null) {\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\n                this._targetedAnimations[i].animation.enableBlending = value;\n            }\n        }\n    }\n    /**\n     * Gets or sets the animation blending speed\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.blendingSpeed)\n     */\n    get blendingSpeed() {\n        return this._blendingSpeed;\n    }\n    set blendingSpeed(value) {\n        if (this._blendingSpeed === value) {\n            return;\n        }\n        this._blendingSpeed = value;\n        if (value !== null) {\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\n                this._targetedAnimations[i].animation.blendingSpeed = value;\n            }\n        }\n    }\n    /**\n     * Gets the length (in seconds) of the animation group\n     * This function assumes that all animations are played at the same framePerSecond speed!\n     * Note: you can only call this method after you've added at least one targeted animation!\n     * @param from Starting frame range (default is AnimationGroup.from)\n     * @param to Ending frame range (default is AnimationGroup.to)\n     * @returns The length in seconds\n     */\n    getLength(from, to) {\n        from = from ?? this._from;\n        to = to ?? this._to;\n        const fps = this.targetedAnimations[0].animation.framePerSecond * this._speedRatio;\n        return (to - from) / fps;\n    }\n    /**\n     * Merge the array of animation groups into a new animation group\n     * @param animationGroups List of animation groups to merge\n     * @param disposeSource If true, animation groups will be disposed after being merged (default: true)\n     * @param normalize If true, animation groups will be normalized before being merged, so that all animations have the same \"from\" and \"to\" frame (default: false)\n     * @param weight Weight for the new animation group. If not provided, it will inherit the weight from the first animation group of the array\n     * @returns The new animation group or null if no animation groups were passed\n     */\n    static MergeAnimationGroups(animationGroups, disposeSource = true, normalize = false, weight) {\n        if (animationGroups.length === 0) {\n            return null;\n        }\n        weight = weight ?? animationGroups[0].weight;\n        let beginFrame = Number.MAX_VALUE;\n        let endFrame = -Number.MAX_VALUE;\n        if (normalize) {\n            for (const animationGroup of animationGroups) {\n                if (animationGroup.from < beginFrame) {\n                    beginFrame = animationGroup.from;\n                }\n                if (animationGroup.to > endFrame) {\n                    endFrame = animationGroup.to;\n                }\n            }\n        }\n        const mergedAnimationGroup = new AnimationGroup(animationGroups[0].name + \"_merged\", animationGroups[0]._scene, weight);\n        for (const animationGroup of animationGroups) {\n            if (normalize) {\n                animationGroup.normalize(beginFrame, endFrame);\n            }\n            for (const targetedAnimation of animationGroup.targetedAnimations) {\n                mergedAnimationGroup.addTargetedAnimation(targetedAnimation.animation, targetedAnimation.target);\n            }\n            if (disposeSource) {\n                animationGroup.dispose();\n            }\n        }\n        return mergedAnimationGroup;\n    }\n    /**\n     * Gets the scene the animation group belongs to\n     * @returns The scene the animation group belongs to\n     */\n    getScene() {\n        return this._scene;\n    }\n    /**\n     * Instantiates a new Animation Group.\n     * This helps managing several animations at once.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\n     * @param name Defines the name of the group\n     * @param scene Defines the scene the group belongs to\n     * @param weight Defines the weight to use for animations in the group (-1.0 by default, meaning \"no weight\")\n     * @param playOrder Defines the order of play of the animation group (default is 0)\n     */\n    constructor(\n    /** The name of the animation group */\n    name, scene = null, weight = -1, playOrder = 0) {\n        this.name = name;\n        this._targetedAnimations = new Array();\n        this._animatables = new Array();\n        this._from = Number.MAX_VALUE;\n        this._to = -Number.MAX_VALUE;\n        this._speedRatio = 1;\n        this._loopAnimation = false;\n        this._isAdditive = false;\n        this._weight = -1;\n        this._playOrder = 0;\n        this._enableBlending = null;\n        this._blendingSpeed = null;\n        this._numActiveAnimatables = 0;\n        this._shouldStart = true;\n        /** @internal */\n        this._parentContainer = null;\n        /**\n         * This observable will notify when one animation have ended\n         */\n        this.onAnimationEndObservable = new Observable();\n        /**\n         * Observer raised when one animation loops\n         */\n        this.onAnimationLoopObservable = new Observable();\n        /**\n         * Observer raised when all animations have looped\n         */\n        this.onAnimationGroupLoopObservable = new Observable();\n        /**\n         * This observable will notify when all animations have ended.\n         */\n        this.onAnimationGroupEndObservable = new Observable();\n        /**\n         * This observable will notify when all animations have paused.\n         */\n        this.onAnimationGroupPauseObservable = new Observable();\n        /**\n         * This observable will notify when all animations are playing.\n         */\n        this.onAnimationGroupPlayObservable = new Observable();\n        /**\n         * Gets or sets an object used to store user defined information for the node\n         */\n        this.metadata = null;\n        this._mask = null;\n        this._animationLoopFlags = [];\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._weight = weight;\n        this._playOrder = playOrder;\n        this.uniqueId = this._scene.getUniqueId();\n        this._scene.addAnimationGroup(this);\n    }\n    /**\n     * Add an animation (with its target) in the group\n     * @param animation defines the animation we want to add\n     * @param target defines the target of the animation\n     * @returns the TargetedAnimation object\n     */\n    addTargetedAnimation(animation, target) {\n        const targetedAnimation = new TargetedAnimation(this);\n        targetedAnimation.animation = animation;\n        targetedAnimation.target = target;\n        const keys = animation.getKeys();\n        if (this._from > keys[0].frame) {\n            this._from = keys[0].frame;\n        }\n        if (this._to < keys[keys.length - 1].frame) {\n            this._to = keys[keys.length - 1].frame;\n        }\n        if (this._enableBlending !== null) {\n            animation.enableBlending = this._enableBlending;\n        }\n        if (this._blendingSpeed !== null) {\n            animation.blendingSpeed = this._blendingSpeed;\n        }\n        this._targetedAnimations.push(targetedAnimation);\n        this._shouldStart = true;\n        return targetedAnimation;\n    }\n    /**\n     * Remove an animation from the group\n     * @param animation defines the animation we want to remove\n     */\n    removeTargetedAnimation(animation) {\n        for (let index = this._targetedAnimations.length - 1; index > -1; index--) {\n            const targetedAnimation = this._targetedAnimations[index];\n            if (targetedAnimation.animation === animation) {\n                this._targetedAnimations.splice(index, 1);\n            }\n        }\n    }\n    /**\n     * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\n     * It can add constant keys at begin or end\n     * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\n     * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\n     * @returns the animation group\n     */\n    normalize(beginFrame = null, endFrame = null) {\n        if (beginFrame == null) {\n            beginFrame = this._from;\n        }\n        if (endFrame == null) {\n            endFrame = this._to;\n        }\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            const keys = targetedAnimation.animation.getKeys();\n            const startKey = keys[0];\n            const endKey = keys[keys.length - 1];\n            if (startKey.frame > beginFrame) {\n                const newKey = {\n                    frame: beginFrame,\n                    value: startKey.value,\n                    inTangent: startKey.inTangent,\n                    outTangent: startKey.outTangent,\n                    interpolation: startKey.interpolation,\n                };\n                keys.splice(0, 0, newKey);\n            }\n            if (endKey.frame < endFrame) {\n                const newKey = {\n                    frame: endFrame,\n                    value: endKey.value,\n                    inTangent: endKey.inTangent,\n                    outTangent: endKey.outTangent,\n                    interpolation: endKey.interpolation,\n                };\n                keys.push(newKey);\n            }\n        }\n        this._from = beginFrame;\n        this._to = endFrame;\n        return this;\n    }\n    _processLoop(animatable, targetedAnimation, index) {\n        animatable.onAnimationLoop = () => {\n            this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\n            if (this._animationLoopFlags[index]) {\n                return;\n            }\n            this._animationLoopFlags[index] = true;\n            this._animationLoopCount++;\n            if (this._animationLoopCount === this._numActiveAnimatables) {\n                this.onAnimationGroupLoopObservable.notifyObservers(this);\n                this._animationLoopCount = 0;\n                this._animationLoopFlags.length = 0;\n            }\n        };\n    }\n    /**\n     * Start all animations on given targets\n     * @param loop defines if animations must loop\n     * @param speedRatio defines the ratio to apply to animation speed (1 by default)\n     * @param from defines the from key (optional)\n     * @param to defines the to key (optional)\n     * @param isAdditive defines the additive state for the resulting animatables (optional)\n     * @returns the current animation group\n     */\n    start(loop = false, speedRatio = 1, from, to, isAdditive) {\n        if (this._isStarted || this._targetedAnimations.length === 0) {\n            return this;\n        }\n        this._loopAnimation = loop;\n        this._shouldStart = false;\n        this._animationLoopCount = 0;\n        this._animationLoopFlags.length = 0;\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            const animatable = this._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== undefined ? from : this._from, to !== undefined ? to : this._to, loop, speedRatio, undefined, undefined, isAdditive !== undefined ? isAdditive : this._isAdditive);\n            animatable.weight = this._weight;\n            animatable.playOrder = this._playOrder;\n            animatable.onAnimationEnd = () => {\n                this.onAnimationEndObservable.notifyObservers(targetedAnimation);\n                this._checkAnimationGroupEnded(animatable);\n            };\n            this._processLoop(animatable, targetedAnimation, index);\n            this._animatables.push(animatable);\n        }\n        this.syncWithMask();\n        this._scene.sortActiveAnimatables();\n        this._speedRatio = speedRatio;\n        this._isStarted = true;\n        this._isPaused = false;\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Pause all animations\n     * @returns the animation group\n     */\n    pause() {\n        if (!this._isStarted) {\n            return this;\n        }\n        this._isPaused = true;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.pause();\n        }\n        this.onAnimationGroupPauseObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Play all animations to initial state\n     * This function will start() the animations if they were not started or will restart() them if they were paused\n     * @param loop defines if animations must loop\n     * @returns the animation group\n     */\n    play(loop) {\n        // only if there are animatable available\n        if (this.isStarted && this._animatables.length && !this._shouldStart) {\n            if (loop !== undefined) {\n                this.loopAnimation = loop;\n            }\n            this.restart();\n        }\n        else {\n            this.stop();\n            this.start(loop, this._speedRatio);\n        }\n        return this;\n    }\n    /**\n     * Reset all animations to initial state\n     * @returns the animation group\n     */\n    reset() {\n        if (!this._isStarted) {\n            this.play();\n            this.goToFrame(0);\n            this.stop(true);\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.reset();\n        }\n        return this;\n    }\n    /**\n     * Restart animations from after pausing it\n     * @returns the animation group\n     */\n    restart() {\n        if (!this._isStarted) {\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.restart();\n        }\n        this.syncWithMask();\n        this._isPaused = false;\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Stop all animations\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\n     * @returns the animation group\n     */\n    stop(skipOnAnimationEnd = false) {\n        if (!this._isStarted) {\n            return this;\n        }\n        const list = this._animatables.slice();\n        for (let index = 0; index < list.length; index++) {\n            list[index].stop(undefined, undefined, true, skipOnAnimationEnd);\n        }\n        // We will take care of removing all stopped animatables\n        let curIndex = 0;\n        for (let index = 0; index < this._scene._activeAnimatables.length; index++) {\n            const animatable = this._scene._activeAnimatables[index];\n            if (animatable._runtimeAnimations.length > 0) {\n                this._scene._activeAnimatables[curIndex++] = animatable;\n            }\n            else if (skipOnAnimationEnd) {\n                // We normally rely on the onAnimationEnd callback (assigned in the start function) to be notified when an animatable\n                // ends and should be removed from the active animatables array. However, if the animatable is stopped with the skipOnAnimationEnd\n                // flag set to true, then we need to explicitly remove it from the active animatables array.\n                this._checkAnimationGroupEnded(animatable, skipOnAnimationEnd);\n            }\n        }\n        this._scene._activeAnimatables.length = curIndex;\n        this._isStarted = false;\n        return this;\n    }\n    /**\n     * Set animation weight for all animatables\n     *\n     * @since 6.12.4\n     *  You can pass the weight to the AnimationGroup constructor, or use the weight property to set it after the group has been created,\n     *  making it easier to define the overall animation weight than calling setWeightForAllAnimatables() after the animation group has been started\n     * @param weight defines the weight to use\n     * @returns the animationGroup\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\n     */\n    setWeightForAllAnimatables(weight) {\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.weight = weight;\n        }\n        return this;\n    }\n    /**\n     * Synchronize and normalize all animatables with a source animatable\n     * @param root defines the root animatable to synchronize with (null to stop synchronizing)\n     * @returns the animationGroup\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\n     */\n    syncAllAnimationsWith(root) {\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.syncWith(root);\n        }\n        return this;\n    }\n    /**\n     * Goes to a specific frame in this animation group. Note that the animation group must be in playing or paused status\n     * @param frame the frame number to go to\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\n     * @returns the animationGroup\n     */\n    goToFrame(frame, useWeight = false) {\n        if (!this._isStarted) {\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.goToFrame(frame, useWeight);\n        }\n        return this;\n    }\n    /**\n     * Helper to get the current frame. This will return 0 if the AnimationGroup is not running, and it might return wrong results if multiple animations are running in different frames.\n     * @returns current animation frame.\n     */\n    getCurrentFrame() {\n        return this.animatables[0]?.masterFrame || 0;\n    }\n    /**\n     * Dispose all associated resources\n     */\n    dispose() {\n        if (this.isStarted) {\n            this.stop();\n        }\n        this._targetedAnimations.length = 0;\n        this._animatables.length = 0;\n        // Remove from scene\n        this._scene.removeAnimationGroup(this);\n        if (this._parentContainer) {\n            const index = this._parentContainer.animationGroups.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.animationGroups.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        this.onAnimationEndObservable.clear();\n        this.onAnimationGroupEndObservable.clear();\n        this.onAnimationGroupPauseObservable.clear();\n        this.onAnimationGroupPlayObservable.clear();\n        this.onAnimationLoopObservable.clear();\n        this.onAnimationGroupLoopObservable.clear();\n    }\n    _checkAnimationGroupEnded(animatable, skipOnAnimationEnd = false) {\n        // animatable should be taken out of the array\n        const idx = this._animatables.indexOf(animatable);\n        if (idx > -1) {\n            this._animatables.splice(idx, 1);\n        }\n        // all animatables were removed? animation group ended!\n        if (this._animatables.length === this._targetedAnimations.length - this._numActiveAnimatables) {\n            this._isStarted = false;\n            if (!skipOnAnimationEnd) {\n                this.onAnimationGroupEndObservable.notifyObservers(this);\n            }\n            this._animatables.length = 0;\n        }\n    }\n    /**\n     * Clone the current animation group and returns a copy\n     * @param newName defines the name of the new group\n     * @param targetConverter defines an optional function used to convert current animation targets to new ones\n     * @param cloneAnimations defines if the animations should be cloned or referenced\n     * @returns the new animation group\n     */\n    clone(newName, targetConverter, cloneAnimations = false) {\n        const newGroup = new AnimationGroup(newName || this.name, this._scene, this._weight, this._playOrder);\n        newGroup._from = this.from;\n        newGroup._to = this.to;\n        newGroup._speedRatio = this.speedRatio;\n        newGroup._loopAnimation = this.loopAnimation;\n        newGroup._isAdditive = this.isAdditive;\n        newGroup._enableBlending = this.enableBlending;\n        newGroup._blendingSpeed = this.blendingSpeed;\n        newGroup.metadata = this.metadata;\n        newGroup.mask = this.mask;\n        for (const targetAnimation of this._targetedAnimations) {\n            newGroup.addTargetedAnimation(cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation, targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);\n        }\n        return newGroup;\n    }\n    /**\n     * Serializes the animationGroup to an object\n     * @returns Serialized object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.from = this.from;\n        serializationObject.to = this.to;\n        serializationObject.speedRatio = this.speedRatio;\n        serializationObject.loopAnimation = this.loopAnimation;\n        serializationObject.isAdditive = this.isAdditive;\n        serializationObject.weight = this.weight;\n        serializationObject.playOrder = this.playOrder;\n        serializationObject.enableBlending = this.enableBlending;\n        serializationObject.blendingSpeed = this.blendingSpeed;\n        serializationObject.targetedAnimations = [];\n        for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\n            const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\n            serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\n        }\n        if (Tags && Tags.HasTags(this)) {\n            serializationObject.tags = Tags.GetTags(this);\n        }\n        // Metadata\n        if (this.metadata) {\n            serializationObject.metadata = this.metadata;\n        }\n        return serializationObject;\n    }\n    // Statics\n    /**\n     * Returns a new AnimationGroup object parsed from the source provided.\n     * @param parsedAnimationGroup defines the source\n     * @param scene defines the scene that will receive the animationGroup\n     * @param nodeMap a map of node.id to node in this scene, to accelerate node lookup\n     * @returns a new AnimationGroup\n     */\n    static Parse(parsedAnimationGroup, scene, nodeMap) {\n        const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene, parsedAnimationGroup.weight, parsedAnimationGroup.playOrder);\n        for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\n            const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\n            const animation = Animation.Parse(targetedAnimation.animation);\n            const id = targetedAnimation.targetId;\n            if (targetedAnimation.animation.property === \"influence\") {\n                // morph target animation\n                const morphTarget = scene.getMorphTargetById(id);\n                if (morphTarget) {\n                    animationGroup.addTargetedAnimation(animation, morphTarget);\n                }\n            }\n            else {\n                const targetNode = nodeMap ? nodeMap.get(id) : scene.getNodeById(id);\n                if (targetNode != null) {\n                    animationGroup.addTargetedAnimation(animation, targetNode);\n                }\n            }\n        }\n        if (Tags) {\n            Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);\n        }\n        if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\n            animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\n        }\n        if (parsedAnimationGroup.speedRatio !== undefined) {\n            animationGroup._speedRatio = parsedAnimationGroup.speedRatio;\n        }\n        if (parsedAnimationGroup.loopAnimation !== undefined) {\n            animationGroup._loopAnimation = parsedAnimationGroup.loopAnimation;\n        }\n        if (parsedAnimationGroup.isAdditive !== undefined) {\n            animationGroup._isAdditive = parsedAnimationGroup.isAdditive;\n        }\n        if (parsedAnimationGroup.weight !== undefined) {\n            animationGroup._weight = parsedAnimationGroup.weight;\n        }\n        if (parsedAnimationGroup.playOrder !== undefined) {\n            animationGroup._playOrder = parsedAnimationGroup.playOrder;\n        }\n        if (parsedAnimationGroup.enableBlending !== undefined) {\n            animationGroup._enableBlending = parsedAnimationGroup.enableBlending;\n        }\n        if (parsedAnimationGroup.blendingSpeed !== undefined) {\n            animationGroup._blendingSpeed = parsedAnimationGroup.blendingSpeed;\n        }\n        if (parsedAnimationGroup.metadata !== undefined) {\n            animationGroup.metadata = parsedAnimationGroup.metadata;\n        }\n        return animationGroup;\n    }\n    /** @internal */\n    static MakeAnimationAdditive(sourceAnimationGroup, referenceFrameOrOptions, range, cloneOriginal = false, clonedName) {\n        let options;\n        if (typeof referenceFrameOrOptions === \"object\") {\n            options = referenceFrameOrOptions;\n        }\n        else {\n            options = {\n                referenceFrame: referenceFrameOrOptions,\n                range: range,\n                cloneOriginalAnimationGroup: cloneOriginal,\n                clonedAnimationName: clonedName,\n            };\n        }\n        let animationGroup = sourceAnimationGroup;\n        if (options.cloneOriginalAnimationGroup) {\n            animationGroup = sourceAnimationGroup.clone(options.clonedAnimationGroupName || animationGroup.name);\n        }\n        const targetedAnimations = animationGroup.targetedAnimations;\n        for (let index = 0; index < targetedAnimations.length; index++) {\n            const targetedAnimation = targetedAnimations[index];\n            targetedAnimation.animation = Animation.MakeAnimationAdditive(targetedAnimation.animation, options);\n        }\n        animationGroup.isAdditive = true;\n        if (options.clipKeys) {\n            // We need to recalculate the from/to frames for the animation group because some keys may have been removed\n            let from = Number.MAX_VALUE;\n            let to = -Number.MAX_VALUE;\n            const targetedAnimations = animationGroup.targetedAnimations;\n            for (let index = 0; index < targetedAnimations.length; index++) {\n                const targetedAnimation = targetedAnimations[index];\n                const animation = targetedAnimation.animation;\n                const keys = animation.getKeys();\n                if (from > keys[0].frame) {\n                    from = keys[0].frame;\n                }\n                if (to < keys[keys.length - 1].frame) {\n                    to = keys[keys.length - 1].frame;\n                }\n            }\n            animationGroup._from = from;\n            animationGroup._to = to;\n        }\n        return animationGroup;\n    }\n    /**\n     * Creates a new animation, keeping only the keys that are inside a given key range\n     * @param sourceAnimationGroup defines the animation group on which to operate\n     * @param fromKey defines the lower bound of the range\n     * @param toKey defines the upper bound of the range\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @returns a new animation group stripped from all the keys outside the given range\n     */\n    static ClipKeys(sourceAnimationGroup, fromKey, toKey, name, dontCloneAnimations) {\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\n        return AnimationGroup.ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations);\n    }\n    /**\n     * Updates an existing animation, keeping only the keys that are inside a given key range\n     * @param animationGroup defines the animation group on which to operate\n     * @param fromKey defines the lower bound of the range\n     * @param toKey defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @returns the animationGroup stripped from all the keys outside the given range\n     */\n    static ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations) {\n        return AnimationGroup.ClipInPlace(animationGroup, fromKey, toKey, dontCloneAnimations, false);\n    }\n    /**\n     * Creates a new animation, keeping only the frames that are inside a given frame range\n     * @param sourceAnimationGroup defines the animation group on which to operate\n     * @param fromFrame defines the lower bound of the range\n     * @param toFrame defines the upper bound of the range\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\n     * @returns a new animation group stripped from all the frames outside the given range\n     */\n    static ClipFrames(sourceAnimationGroup, fromFrame, toFrame, name, dontCloneAnimations) {\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\n        return AnimationGroup.ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations);\n    }\n    /**\n     * Updates an existing animation, keeping only the frames that are inside a given frame range\n     * @param animationGroup defines the animation group on which to operate\n     * @param fromFrame defines the lower bound of the range\n     * @param toFrame defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\n     * @returns the animationGroup stripped from all the frames outside the given range\n     */\n    static ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations) {\n        return AnimationGroup.ClipInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations, true);\n    }\n    /**\n     * Updates an existing animation, keeping only the keys that are inside a given key or frame range\n     * @param animationGroup defines the animation group on which to operate\n     * @param start defines the lower bound of the range\n     * @param end defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @param useFrame defines if the range is defined by frame numbers or key indices (default is false which means use key indices)\n     * @returns the animationGroup stripped from all the keys outside the given range\n     */\n    static ClipInPlace(animationGroup, start, end, dontCloneAnimations, useFrame = false) {\n        let from = Number.MAX_VALUE;\n        let to = -Number.MAX_VALUE;\n        const targetedAnimations = animationGroup.targetedAnimations;\n        for (let index = 0; index < targetedAnimations.length; index++) {\n            const targetedAnimation = targetedAnimations[index];\n            const animation = dontCloneAnimations ? targetedAnimation.animation : targetedAnimation.animation.clone();\n            if (useFrame) {\n                // Make sure we have keys corresponding to the bounds of the frame range\n                animation.createKeyForFrame(start);\n                animation.createKeyForFrame(end);\n            }\n            const keys = animation.getKeys();\n            const newKeys = [];\n            let startFrame = Number.MAX_VALUE;\n            for (let k = 0; k < keys.length; k++) {\n                const key = keys[k];\n                if ((!useFrame && k >= start && k <= end) || (useFrame && key.frame >= start && key.frame <= end)) {\n                    const newKey = {\n                        frame: key.frame,\n                        value: key.value.clone ? key.value.clone() : key.value,\n                        inTangent: key.inTangent,\n                        outTangent: key.outTangent,\n                        interpolation: key.interpolation,\n                        lockedTangent: key.lockedTangent,\n                    };\n                    if (startFrame === Number.MAX_VALUE) {\n                        startFrame = newKey.frame;\n                    }\n                    newKey.frame -= startFrame;\n                    newKeys.push(newKey);\n                }\n            }\n            if (newKeys.length === 0) {\n                targetedAnimations.splice(index, 1);\n                index--;\n                continue;\n            }\n            if (from > newKeys[0].frame) {\n                from = newKeys[0].frame;\n            }\n            if (to < newKeys[newKeys.length - 1].frame) {\n                to = newKeys[newKeys.length - 1].frame;\n            }\n            animation.setKeys(newKeys, true);\n            targetedAnimation.animation = animation; // in case the animation has been cloned\n        }\n        animationGroup._from = from;\n        animationGroup._to = to;\n        return animationGroup;\n    }\n    /**\n     * Returns the string \"AnimationGroup\"\n     * @returns \"AnimationGroup\"\n     */\n    getClassName() {\n        return \"AnimationGroup\";\n    }\n    /**\n     * Creates a detailed string about the object\n     * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\n     * @returns a string representing the object\n     */\n    toString(fullDetails) {\n        let ret = \"Name: \" + this.name;\n        ret += \", type: \" + this.getClassName();\n        if (fullDetails) {\n            ret += \", from: \" + this._from;\n            ret += \", to: \" + this._to;\n            ret += \", isStarted: \" + this._isStarted;\n            ret += \", speedRatio: \" + this._speedRatio;\n            ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\n            ret += \", animatables length: \" + this._animatables;\n        }\n        return ret;\n    }\n}\n//# sourceMappingURL=animationGroup.js.map"],"names":[],"mappings":"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"}