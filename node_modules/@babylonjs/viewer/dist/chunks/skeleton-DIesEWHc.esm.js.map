{"version":3,"file":"skeleton-DIesEWHc.esm.js","sources":["../../../../../dev/core/dist/Bones/skeleton.js"],"sourcesContent":["import { Bone } from \"./bone\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\nimport { Animation } from \"../Animations/animation\";\nimport { AnimationRange } from \"../Animations/animationRange\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Constants } from \"../Engines/constants\";\nimport { Logger } from \"../Misc/logger\";\nimport { DeepCopier } from \"../Misc/deepCopier\";\n/**\n * Class used to handle skinning animations\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n */\nexport class Skeleton {\n    /**\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\n     * Please note that this option is not available if the hardware does not support it\n     */\n    get useTextureToStoreBoneMatrices() {\n        return this._useTextureToStoreBoneMatrices;\n    }\n    set useTextureToStoreBoneMatrices(value) {\n        this._useTextureToStoreBoneMatrices = value;\n        this._markAsDirty();\n    }\n    /**\n     * Gets or sets the animation properties override\n     */\n    get animationPropertiesOverride() {\n        if (!this._animationPropertiesOverride) {\n            return this._scene.animationPropertiesOverride;\n        }\n        return this._animationPropertiesOverride;\n    }\n    set animationPropertiesOverride(value) {\n        this._animationPropertiesOverride = value;\n    }\n    /**\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\n     */\n    get isUsingTextureForMatrices() {\n        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\n    }\n    /**\n     * Gets the unique ID of this skeleton\n     */\n    get uniqueId() {\n        return this._uniqueId;\n    }\n    /**\n     * Creates a new skeleton\n     * @param name defines the skeleton name\n     * @param id defines the skeleton Id\n     * @param scene defines the hosting scene\n     */\n    constructor(\n    /** defines the skeleton name */\n    name, \n    /** defines the skeleton Id */\n    id, scene) {\n        this.name = name;\n        this.id = id;\n        /**\n         * Defines the list of child bones\n         */\n        this.bones = [];\n        /**\n         * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\n         */\n        this.needInitialSkinMatrix = false;\n        this._isDirty = true;\n        this._meshesWithPoseMatrix = new Array();\n        this._identity = Matrix.Identity();\n        this._currentRenderId = -1;\n        this._ranges = {};\n        this._absoluteTransformIsDirty = true;\n        this._canUseTextureForBones = false;\n        this._uniqueId = 0;\n        /** @internal */\n        this._numBonesWithLinkedTransformNode = 0;\n        /** @internal */\n        this._hasWaitingData = null;\n        /** @internal */\n        this._parentContainer = null;\n        /**\n         * Specifies if the skeleton should be serialized\n         */\n        this.doNotSerialize = false;\n        this._useTextureToStoreBoneMatrices = true;\n        this._animationPropertiesOverride = null;\n        // Events\n        /**\n         * An observable triggered before computing the skeleton's matrices\n         */\n        this.onBeforeComputeObservable = new Observable();\n        /**\n         * Gets or sets an object used to store user defined information for the skeleton\n         */\n        this.metadata = null;\n        this.bones = [];\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._uniqueId = this._scene.getUniqueId();\n        this._scene.addSkeleton(this);\n        //make sure it will recalculate the matrix next time prepare is called.\n        this._isDirty = true;\n        const engineCaps = this._scene.getEngine().getCaps();\n        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"Skeleton\";\n    }\n    /**\n     * Returns an array containing the root bones\n     * @returns an array containing the root bones\n     */\n    getChildren() {\n        return this.bones.filter((b) => !b.getParent());\n    }\n    // Members\n    /**\n     * Gets the list of transform matrices to send to shaders (one matrix per bone)\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n     * @returns a Float32Array containing matrices data\n     */\n    getTransformMatrices(mesh) {\n        if (this.needInitialSkinMatrix) {\n            if (!mesh) {\n                throw new Error(\"getTransformMatrices: When using the needInitialSkinMatrix flag, a mesh must be provided\");\n            }\n            if (!mesh._bonesTransformMatrices) {\n                this.prepare(true);\n            }\n            return mesh._bonesTransformMatrices;\n        }\n        if (!this._transformMatrices || this._isDirty) {\n            this.prepare(!this._transformMatrices);\n        }\n        return this._transformMatrices;\n    }\n    /**\n     * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n     * @returns a raw texture containing the data\n     */\n    getTransformMatrixTexture(mesh) {\n        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\n            return mesh._transformMatrixTexture;\n        }\n        return this._transformMatrixTexture;\n    }\n    /**\n     * Gets the current hosting scene\n     * @returns a scene object\n     */\n    getScene() {\n        return this._scene;\n    }\n    // Methods\n    /**\n     * Gets a string representing the current skeleton data\n     * @param fullDetails defines a boolean indicating if we want a verbose version\n     * @returns a string representing the current skeleton data\n     */\n    toString(fullDetails) {\n        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\n        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\n        if (fullDetails) {\n            ret += \", Ranges: {\";\n            let first = true;\n            for (const name in this._ranges) {\n                if (first) {\n                    ret += \", \";\n                    first = false;\n                }\n                ret += name;\n            }\n            ret += \"}\";\n        }\n        return ret;\n    }\n    /**\n     * Get bone's index searching by name\n     * @param name defines bone's name to search for\n     * @returns the indice of the bone. Returns -1 if not found\n     */\n    getBoneIndexByName(name) {\n        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\n            if (this.bones[boneIndex].name === name) {\n                return boneIndex;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Create a new animation range\n     * @param name defines the name of the range\n     * @param from defines the start key\n     * @param to defines the end key\n     */\n    createAnimationRange(name, from, to) {\n        // check name not already in use\n        if (!this._ranges[name]) {\n            this._ranges[name] = new AnimationRange(name, from, to);\n            for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n                if (this.bones[i].animations[0]) {\n                    this.bones[i].animations[0].createRange(name, from, to);\n                }\n            }\n        }\n    }\n    /**\n     * Delete a specific animation range\n     * @param name defines the name of the range\n     * @param deleteFrames defines if frames must be removed as well\n     */\n    deleteAnimationRange(name, deleteFrames = true) {\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n            if (this.bones[i].animations[0]) {\n                this.bones[i].animations[0].deleteRange(name, deleteFrames);\n            }\n        }\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n    }\n    /**\n     * Gets a specific animation range\n     * @param name defines the name of the range to look for\n     * @returns the requested animation range or null if not found\n     */\n    getAnimationRange(name) {\n        return this._ranges[name] || null;\n    }\n    /**\n     * Gets the list of all animation ranges defined on this skeleton\n     * @returns an array\n     */\n    getAnimationRanges() {\n        const animationRanges = [];\n        let name;\n        for (name in this._ranges) {\n            animationRanges.push(this._ranges[name]);\n        }\n        return animationRanges;\n    }\n    /**\n     * Copy animation range from a source skeleton.\n     * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\n     * @param source defines the source skeleton\n     * @param name defines the name of the range to copy\n     * @param rescaleAsRequired defines if rescaling must be applied if required\n     * @returns true if operation was successful\n     */\n    copyAnimationRange(source, name, rescaleAsRequired = false) {\n        if (this._ranges[name] || !source.getAnimationRange(name)) {\n            return false;\n        }\n        let ret = true;\n        const frameOffset = this._getHighestAnimationFrame() + 1;\n        // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\n        const boneDict = {};\n        const sourceBones = source.bones;\n        let nBones;\n        let i;\n        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\n            boneDict[sourceBones[i].name] = sourceBones[i];\n        }\n        if (this.bones.length !== sourceBones.length) {\n            Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\n            ret = false;\n        }\n        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\n        for (i = 0, nBones = this.bones.length; i < nBones; i++) {\n            const boneName = this.bones[i].name;\n            const sourceBone = boneDict[boneName];\n            if (sourceBone) {\n                ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\n            }\n            else {\n                Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\n                ret = false;\n            }\n        }\n        // do not call createAnimationRange(), since it also is done to bones, which was already done\n        const range = source.getAnimationRange(name);\n        if (range) {\n            this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\n        }\n        return ret;\n    }\n    /**\n     * Forces the skeleton to go to rest pose\n     */\n    returnToRest() {\n        for (const bone of this.bones) {\n            if (bone._index !== -1) {\n                bone.returnToRest();\n            }\n        }\n    }\n    _getHighestAnimationFrame() {\n        let ret = 0;\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n            if (this.bones[i].animations[0]) {\n                const highest = this.bones[i].animations[0].getHighestFrame();\n                if (ret < highest) {\n                    ret = highest;\n                }\n            }\n        }\n        return ret;\n    }\n    /**\n     * Begin a specific animation range\n     * @param name defines the name of the range to start\n     * @param loop defines if looping must be turned on (false by default)\n     * @param speedRatio defines the speed ratio to apply (1 by default)\n     * @param onAnimationEnd defines a callback which will be called when animation will end\n     * @returns a new animatable\n     */\n    beginAnimation(name, loop, speedRatio, onAnimationEnd) {\n        const range = this.getAnimationRange(name);\n        if (!range) {\n            return null;\n        }\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n    }\n    /**\n     * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\n     * @param skeleton defines the Skeleton containing the animation range to convert\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\n     * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\n     * @returns the original skeleton\n     */\n    static MakeAnimationAdditive(skeleton, referenceFrame = 0, range) {\n        const rangeValue = skeleton.getAnimationRange(range);\n        // We can't make a range additive if it doesn't exist\n        if (!rangeValue) {\n            return null;\n        }\n        // Find any current scene-level animatable belonging to the target that matches the range\n        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\n        let rangeAnimatable = null;\n        for (let index = 0; index < sceneAnimatables.length; index++) {\n            const sceneAnimatable = sceneAnimatables[index];\n            if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {\n                rangeAnimatable = sceneAnimatable;\n                break;\n            }\n        }\n        // Convert the animations belonging to the skeleton to additive keyframes\n        const animatables = skeleton.getAnimatables();\n        for (let index = 0; index < animatables.length; index++) {\n            const animatable = animatables[index];\n            const animations = animatable.animations;\n            if (!animations) {\n                continue;\n            }\n            for (let animIndex = 0; animIndex < animations.length; animIndex++) {\n                Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\n            }\n        }\n        // Mark the scene-level animatable as additive\n        if (rangeAnimatable) {\n            rangeAnimatable.isAdditive = true;\n        }\n        return skeleton;\n    }\n    /** @internal */\n    _markAsDirty() {\n        this._isDirty = true;\n        this._absoluteTransformIsDirty = true;\n    }\n    /**\n     * @internal\n     */\n    _registerMeshWithPoseMatrix(mesh) {\n        this._meshesWithPoseMatrix.push(mesh);\n    }\n    /**\n     * @internal\n     */\n    _unregisterMeshWithPoseMatrix(mesh) {\n        const index = this._meshesWithPoseMatrix.indexOf(mesh);\n        if (index > -1) {\n            this._meshesWithPoseMatrix.splice(index, 1);\n        }\n    }\n    _computeTransformMatrices(targetMatrix, initialSkinMatrix) {\n        this.onBeforeComputeObservable.notifyObservers(this);\n        for (let index = 0; index < this.bones.length; index++) {\n            const bone = this.bones[index];\n            bone._childUpdateId++;\n            const parentBone = bone.getParent();\n            if (parentBone) {\n                bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());\n            }\n            else {\n                if (initialSkinMatrix) {\n                    bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());\n                }\n                else {\n                    bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());\n                }\n            }\n            if (bone._index !== -1) {\n                const mappedIndex = bone._index === null ? index : bone._index;\n                bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);\n            }\n        }\n        this._identity.copyToArray(targetMatrix, this.bones.length * 16);\n    }\n    /**\n     * Build all resources required to render a skeleton\n     * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)\n     */\n    prepare(dontCheckFrameId = false) {\n        if (!dontCheckFrameId) {\n            const currentRenderId = this.getScene().getRenderId();\n            if (this._currentRenderId === currentRenderId) {\n                return;\n            }\n            this._currentRenderId = currentRenderId;\n        }\n        // Update the local matrix of bones with linked transform nodes.\n        if (this._numBonesWithLinkedTransformNode > 0) {\n            for (const bone of this.bones) {\n                if (bone._linkedTransformNode) {\n                    const node = bone._linkedTransformNode;\n                    bone.position = node.position;\n                    if (node.rotationQuaternion) {\n                        bone.rotationQuaternion = node.rotationQuaternion;\n                    }\n                    else {\n                        bone.rotation = node.rotation;\n                    }\n                    bone.scaling = node.scaling;\n                }\n            }\n        }\n        if (this.needInitialSkinMatrix) {\n            for (const mesh of this._meshesWithPoseMatrix) {\n                const poseMatrix = mesh.getPoseMatrix();\n                let needsUpdate = this._isDirty;\n                if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\n                    mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                    needsUpdate = true;\n                }\n                if (!needsUpdate) {\n                    continue;\n                }\n                if (this._synchronizedWithMesh !== mesh) {\n                    this._synchronizedWithMesh = mesh;\n                    // Prepare bones\n                    for (const bone of this.bones) {\n                        if (!bone.getParent()) {\n                            const matrix = bone.getBindMatrix();\n                            matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\n                            bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);\n                        }\n                    }\n                    if (this.isUsingTextureForMatrices) {\n                        const textureWidth = (this.bones.length + 1) * 4;\n                        if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\n                            if (mesh._transformMatrixTexture) {\n                                mesh._transformMatrixTexture.dispose();\n                            }\n                            mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);\n                        }\n                    }\n                }\n                this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\n                if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\n                    mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\n                }\n            }\n        }\n        else {\n            if (!this._isDirty) {\n                return;\n            }\n            if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\n                this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                if (this.isUsingTextureForMatrices) {\n                    if (this._transformMatrixTexture) {\n                        this._transformMatrixTexture.dispose();\n                    }\n                    this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);\n                }\n            }\n            this._computeTransformMatrices(this._transformMatrices, null);\n            if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\n                this._transformMatrixTexture.update(this._transformMatrices);\n            }\n        }\n        this._isDirty = false;\n    }\n    /**\n     * Gets the list of animatables currently running for this skeleton\n     * @returns an array of animatables\n     */\n    getAnimatables() {\n        if (!this._animatables || this._animatables.length !== this.bones.length) {\n            this._animatables = [];\n            for (let index = 0; index < this.bones.length; index++) {\n                this._animatables.push(this.bones[index]);\n            }\n        }\n        return this._animatables;\n    }\n    /**\n     * Clone the current skeleton\n     * @param name defines the name of the new skeleton\n     * @param id defines the id of the new skeleton\n     * @returns the new skeleton\n     */\n    clone(name, id) {\n        const result = new Skeleton(name, id || name, this._scene);\n        result.needInitialSkinMatrix = this.needInitialSkinMatrix;\n        result.metadata = this.metadata;\n        for (let index = 0; index < this.bones.length; index++) {\n            const source = this.bones[index];\n            let parentBone = null;\n            const parent = source.getParent();\n            if (parent) {\n                const parentIndex = this.bones.indexOf(parent);\n                parentBone = result.bones[parentIndex];\n            }\n            const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());\n            bone._index = source._index;\n            if (source._linkedTransformNode) {\n                bone.linkTransformNode(source._linkedTransformNode);\n            }\n            DeepCopier.DeepCopy(source.animations, bone.animations);\n        }\n        if (this._ranges) {\n            result._ranges = {};\n            for (const rangeName in this._ranges) {\n                const range = this._ranges[rangeName];\n                if (range) {\n                    result._ranges[rangeName] = range.clone();\n                }\n            }\n        }\n        this._isDirty = true;\n        result.prepare(true);\n        return result;\n    }\n    /**\n     * Enable animation blending for this skeleton\n     * @param blendingSpeed defines the blending speed to apply\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     */\n    enableBlending(blendingSpeed = 0.01) {\n        for (const bone of this.bones) {\n            for (const animation of bone.animations) {\n                animation.enableBlending = true;\n                animation.blendingSpeed = blendingSpeed;\n            }\n        }\n    }\n    /**\n     * Releases all resources associated with the current skeleton\n     */\n    dispose() {\n        this._meshesWithPoseMatrix.length = 0;\n        this.metadata = null;\n        // Animations\n        this.getScene().stopAnimation(this);\n        // Remove from scene\n        this.getScene().removeSkeleton(this);\n        if (this._parentContainer) {\n            const index = this._parentContainer.skeletons.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.skeletons.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n            this._transformMatrixTexture = null;\n        }\n    }\n    /**\n     * Serialize the skeleton in a JSON object\n     * @returns a JSON object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.id = this.id;\n        if (this.dimensionsAtRest) {\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\n        }\n        serializationObject.bones = [];\n        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\n        if (this.metadata) {\n            serializationObject.metadata = this.metadata;\n        }\n        for (let index = 0; index < this.bones.length; index++) {\n            const bone = this.bones[index];\n            const parent = bone.getParent();\n            const serializedBone = {\n                parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\n                index: bone.getIndex(),\n                name: bone.name,\n                id: bone.id,\n                matrix: bone.getBindMatrix().asArray(),\n                rest: bone.getRestMatrix().asArray(),\n                linkedTransformNodeId: bone.getTransformNode()?.id,\n            };\n            serializationObject.bones.push(serializedBone);\n            if (bone.length) {\n                serializedBone.length = bone.length;\n            }\n            if (bone.metadata) {\n                serializedBone.metadata = bone.metadata;\n            }\n            if (bone.animations && bone.animations.length > 0) {\n                serializedBone.animation = bone.animations[0].serialize();\n            }\n            serializationObject.ranges = [];\n            for (const name in this._ranges) {\n                const source = this._ranges[name];\n                if (!source) {\n                    continue;\n                }\n                const range = {};\n                range.name = name;\n                range.from = source.from;\n                range.to = source.to;\n                serializationObject.ranges.push(range);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * Creates a new skeleton from serialized data\n     * @param parsedSkeleton defines the serialized data\n     * @param scene defines the hosting scene\n     * @returns a new skeleton\n     */\n    static Parse(parsedSkeleton, scene) {\n        const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\n        if (parsedSkeleton.dimensionsAtRest) {\n            skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\n        }\n        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\n        if (parsedSkeleton.metadata) {\n            skeleton.metadata = parsedSkeleton.metadata;\n        }\n        let index;\n        for (index = 0; index < parsedSkeleton.bones.length; index++) {\n            const parsedBone = parsedSkeleton.bones[index];\n            const parsedBoneIndex = parsedSkeleton.bones[index].index;\n            let parentBone = null;\n            if (parsedBone.parentBoneIndex > -1) {\n                parentBone = skeleton.bones[parsedBone.parentBoneIndex];\n            }\n            const rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\n            const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\n            if (parsedBone.id !== undefined && parsedBone.id !== null) {\n                bone.id = parsedBone.id;\n            }\n            if (parsedBone.length) {\n                bone.length = parsedBone.length;\n            }\n            if (parsedBone.metadata) {\n                bone.metadata = parsedBone.metadata;\n            }\n            if (parsedBone.animation) {\n                bone.animations.push(Animation.Parse(parsedBone.animation));\n            }\n            if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\n                skeleton._hasWaitingData = true;\n                bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\n            }\n        }\n        // placed after bones, so createAnimationRange can cascade down\n        if (parsedSkeleton.ranges) {\n            for (index = 0; index < parsedSkeleton.ranges.length; index++) {\n                const data = parsedSkeleton.ranges[index];\n                skeleton.createAnimationRange(data.name, data.from, data.to);\n            }\n        }\n        return skeleton;\n    }\n    /**\n     * Compute all node absolute matrices\n     * @param forceUpdate defines if computation must be done even if cache is up to date\n     */\n    computeAbsoluteMatrices(forceUpdate = false) {\n        if (this._absoluteTransformIsDirty || forceUpdate) {\n            this.bones[0].computeAbsoluteMatrices();\n            this._absoluteTransformIsDirty = false;\n        }\n    }\n    /**\n     * Compute all node absolute matrices\n     * @param forceUpdate defines if computation must be done even if cache is up to date\n     * @deprecated Please use computeAbsoluteMatrices instead\n     */\n    computeAbsoluteTransforms(forceUpdate = false) {\n        this.computeAbsoluteMatrices(forceUpdate);\n    }\n    /**\n     * Gets the root pose matrix\n     * @returns a matrix\n     */\n    getPoseMatrix() {\n        let poseMatrix = null;\n        if (this._meshesWithPoseMatrix.length > 0) {\n            poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\n        }\n        return poseMatrix;\n    }\n    /**\n     * Sorts bones per internal index\n     */\n    sortBones() {\n        const bones = [];\n        const visited = new Array(this.bones.length);\n        for (let index = 0; index < this.bones.length; index++) {\n            this._sortBones(index, bones, visited);\n        }\n        this.bones = bones;\n    }\n    _sortBones(index, bones, visited) {\n        if (visited[index]) {\n            return;\n        }\n        visited[index] = true;\n        const bone = this.bones[index];\n        if (!bone) {\n            return;\n        }\n        if (bone._index === undefined) {\n            bone._index = index;\n        }\n        const parentBone = bone.getParent();\n        if (parentBone) {\n            this._sortBones(this.bones.indexOf(parentBone), bones, visited);\n        }\n        bones.push(bone);\n    }\n    /**\n     * Set the current local matrix as the restPose for all bones in the skeleton.\n     */\n    setCurrentPoseAsRest() {\n        for (const b of this.bones) {\n            b.setCurrentPoseAsRest();\n        }\n    }\n}\n//# sourceMappingURL=skeleton.js.map"],"names":[],"mappings":"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"}