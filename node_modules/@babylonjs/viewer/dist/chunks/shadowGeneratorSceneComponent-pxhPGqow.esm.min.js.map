{"version":3,"file":"shadowGeneratorSceneComponent-pxhPGqow.esm.min.js","sources":["../../../../../dev/core/dist/Lights/Shadows/shadowGeneratorSceneComponent.js"],"sourcesContent":["import { ShadowGenerator } from \"./shadowGenerator\";\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator\";\nimport { SceneComponentConstants } from \"../../sceneComponent\";\nimport { AddParser } from \"core/Loading/Plugins/babylonFileParser.function\";\n// Adds the parser to the scene parsers.\nAddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData, scene) => {\n    // Shadows\n    if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\n        for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\n            const parsedShadowGenerator = parsedData.shadowGenerators[index];\n            if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\n                CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\n            }\n            else {\n                ShadowGenerator.Parse(parsedShadowGenerator, scene);\n            }\n            // SG would be available on their associated lights\n        }\n    }\n});\n/**\n * Defines the shadow generator component responsible to manage any shadow generators\n * in a given scene.\n */\nexport class ShadowGeneratorSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_SHADOWGENERATOR;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing To Do Here.\n    }\n    /**\n     * Serializes the component data to the specified json object\n     * @param serializationObject The object to serialize to\n     */\n    serialize(serializationObject) {\n        // Shadows\n        serializationObject.shadowGenerators = [];\n        const lights = this.scene.lights;\n        for (const light of lights) {\n            if (light.doNotSerialize) {\n                continue;\n            }\n            const shadowGenerators = light.getShadowGenerators();\n            if (shadowGenerators) {\n                const iterator = shadowGenerators.values();\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                    const shadowGenerator = key.value;\n                    if (shadowGenerator.doNotSerialize) {\n                        continue;\n                    }\n                    serializationObject.shadowGenerators.push(shadowGenerator.serialize());\n                }\n            }\n        }\n    }\n    /**\n     * Adds all the elements from the container to the scene\n     * @param container the container holding the elements\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    addFromContainer(container) {\n        // Nothing To Do Here. (directly attached to a light)\n    }\n    /**\n     * Removes all the elements in the container from the scene\n     * @param container contains the elements to remove\n     * @param dispose if the removed element should be disposed (default: false)\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    removeFromContainer(container, dispose) {\n        // Nothing To Do Here. (directly attached to a light)\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    dispose() {\n        // Nothing To Do Here.\n    }\n    _gatherRenderTargets(renderTargets) {\n        // Shadows\n        const scene = this.scene;\n        if (this.scene.shadowsEnabled) {\n            for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\n                const light = scene.lights[lightIndex];\n                const shadowGenerators = light.getShadowGenerators();\n                if (light.isEnabled() && light.shadowEnabled && shadowGenerators) {\n                    const iterator = shadowGenerators.values();\n                    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                        const shadowGenerator = key.value;\n                        const shadowMap = shadowGenerator.getShadowMap();\n                        if (scene.textures.indexOf(shadowMap) !== -1) {\n                            renderTargets.push(shadowMap);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nShadowGenerator._SceneComponentInitialization = (scene) => {\n    let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\n    if (!component) {\n        component = new ShadowGeneratorSceneComponent(scene);\n        scene._addComponent(component);\n    }\n};\n//# sourceMappingURL=shadowGeneratorSceneComponent.js.map"],"names":["ShadowGeneratorSceneComponent","constructor","scene","this","name","SceneComponentConstants","NAME_SHADOWGENERATOR","register","_gatherRenderTargetsStage","registerStep","STEP_GATHERRENDERTARGETS_SHADOWGENERATOR","_gatherRenderTargets","rebuild","serialize","serializationObject","shadowGenerators","lights","light","doNotSerialize","getShadowGenerators","iterator","values","key","next","done","shadowGenerator","value","push","addFromContainer","container","removeFromContainer","dispose","renderTargets","shadowsEnabled","lightIndex","length","isEnabled","shadowEnabled","shadowMap","getShadowMap","textures","indexOf","ShadowGenerator","_SceneComponentInitialization","component","_getComponent","_addComponent"],"mappings":"wDAwBO,MAAMA,EAKT,WAAAC,CAAYC,GAIRC,KAAKC,KAAOC,EAAwBC,qBACpCH,KAAKD,MAAQA,CACrB,CAII,QAAAK,GACIJ,KAAKD,MAAMM,0BAA0BC,aAAaJ,EAAwBK,yCAA0CP,KAAMA,KAAKQ,qBACvI,CAKI,OAAAC,GAEJ,CAKI,SAAAC,CAAUC,GAENA,EAAoBC,iBAAmB,GACvC,MAAMC,EAASb,KAAKD,MAAMc,OAC1B,IAAK,MAAMC,KAASD,EAAQ,CACxB,GAAIC,EAAMC,eACN,SAEJ,MAAMH,EAAmBE,EAAME,sBAC/B,GAAIJ,EAAkB,CAClB,MAAMK,EAAWL,EAAiBM,SAClC,IAAK,IAAIC,EAAMF,EAASG,QAAqB,IAAbD,EAAIE,KAAeF,EAAMF,EAASG,OAAQ,CACtE,MAAME,EAAkBH,EAAII,MACxBD,EAAgBP,gBAGpBJ,EAAoBC,iBAAiBY,KAAKF,EAAgBZ,YAC9E,CACA,CACA,CACA,CAMI,gBAAAe,CAAiBC,GAErB,CAOI,mBAAAC,CAAoBD,EAAWE,GAEnC,CAKI,OAAAA,GAEJ,CACI,oBAAApB,CAAqBqB,GAEjB,MAAM9B,EAAQC,KAAKD,MACnB,GAAIC,KAAKD,MAAM+B,eACX,IAAK,IAAIC,EAAa,EAAGA,EAAahC,EAAMc,OAAOmB,OAAQD,IAAc,CACrE,MAAMjB,EAAQf,EAAMc,OAAOkB,GACrBnB,EAAmBE,EAAME,sBAC/B,GAAIF,EAAMmB,aAAenB,EAAMoB,eAAiBtB,EAAkB,CAC9D,MAAMK,EAAWL,EAAiBM,SAClC,IAAK,IAAIC,EAAMF,EAASG,QAAqB,IAAbD,EAAIE,KAAeF,EAAMF,EAASG,OAAQ,CACtE,MACMe,EADkBhB,EAAII,MACMa,gBACQ,IAAtCrC,EAAMsC,SAASC,QAAQH,IACvBN,EAAcL,KAAKW,EAE/C,CACA,CACA,CAEA,EAEAI,EAAgBC,8BAAiCzC,IAC7C,IAAI0C,EAAY1C,EAAM2C,cAAcxC,EAAwBC,sBACvDsC,IACDA,EAAY,IAAI5C,EAA8BE,GAC9CA,EAAM4C,cAAcF"}